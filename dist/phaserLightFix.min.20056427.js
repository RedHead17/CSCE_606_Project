// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  var error;
  for (var i = 0; i < entry.length; i++) {
    try {
      newRequire(entry[i]);
    } catch (e) {
      // Save first error but execute all entries
      if (!error) {
        error = e;
      }
    }
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  parcelRequire = newRequire;

  if (error) {
    // throw error from earlier, _after updating parcelRequire_
    throw error;
  }

  return newRequire;
})({"C:/Users/maryj/AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/process/browser.js":[function(require,module,exports) {

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};
},{}],"src/site/phaserLightFix.min.js":[function(require,module,exports) {
var define;
var process = require("process");
var global = arguments[3];
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

!function (root, factory) {
  "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) && "object" == (typeof module === "undefined" ? "undefined" : _typeof(module)) ? module.exports = factory() : "function" == typeof define && define.amd ? define("Phaser", [], factory) : "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) ? exports.Phaser = factory() : root.Phaser = factory();
}(this, function () {
  return installedModules = {}, __webpack_require__.m = modules = [function (module, exports) {
    function extend(ctor, definition, isClassDescriptor, extend) {
      for (var k in definition) {
        if (definition.hasOwnProperty(k)) {
          var def = function (definition, def, isClassDescriptor) {
            return def = isClassDescriptor ? definition[def] : Object.getOwnPropertyDescriptor(definition, def), !(!(def = !isClassDescriptor && def.value && "object" == _typeof(def.value) ? def.value : def) || !function (def) {
              return def.get && "function" == typeof def.get || def.set && "function" == typeof def.set;
            }(def)) && (void 0 === def.enumerable && (def.enumerable = !0), void 0 === def.configurable && (def.configurable = !0), def);
          }(definition, k, isClassDescriptor);

          if (!1 !== def) {
            if (obj = (extend || ctor).prototype, prop = k, (prop = Object.getOwnPropertyDescriptor(obj, prop)) && !1 === (prop = prop.value && "object" == _typeof(prop.value) ? prop.value : prop).configurable) {
              if (Class.ignoreFinals) continue;
              throw new Error("cannot override final property '" + k + "', set Class.ignoreFinals = true to skip");
            }

            Object.defineProperty(ctor.prototype, k, def);
          } else ctor.prototype[k] = definition[k];
        }
      }

      var obj, prop;
    }

    function mixin(myClass, mixins) {
      if (mixins) {
        Array.isArray(mixins) || (mixins = [mixins]);

        for (var i = 0; i < mixins.length; i++) {
          extend(myClass, mixins[i].prototype || mixins[i]);
        }
      }
    }

    function Class(definition) {
      var Extends, base, initialize;

      if ((definition = definition || {}).initialize) {
        if ("function" != typeof definition.initialize) throw new Error("initialize must be a function");
        initialize = definition.initialize, delete definition.initialize;
      } else initialize = definition.Extends ? (base = definition.Extends, function () {
        base.apply(this, arguments);
      }) : function () {};

      definition.Extends ? (initialize.prototype = Object.create(definition.Extends.prototype), initialize.prototype.constructor = initialize, Extends = definition.Extends, delete definition.Extends) : initialize.prototype.constructor = initialize;
      var mixins = null;
      return definition.Mixins && (mixins = definition.Mixins, delete definition.Mixins), mixin(initialize, mixins), extend(initialize, definition, !0, Extends), initialize;
    }

    Class.extend = extend, Class.mixin = mixin, Class.ignoreFinals = !1, module.exports = Class;
  }, function (module, exports) {
    module.exports = function () {};
  }, function (module, exports) {
    module.exports = function (source, key, defaultValue) {
      var t = _typeof(source);

      return source && "number" != t && "string" != t && source.hasOwnProperty(key) && void 0 !== source[key] ? source[key] : defaultValue;
    };
  }, function (module, exports, __webpack_require__) {
    var Class = __webpack_require__(0),
        FuzzyEqual = __webpack_require__(124),
        Vector2 = new Class({
      initialize: function initialize(x, y) {
        this.x = 0, this.y = 0, "object" == _typeof(x) ? (this.x = x.x || 0, this.y = x.y || 0) : (void 0 === y && (y = x), this.x = x || 0, this.y = y || 0);
      },
      clone: function clone() {
        return new Vector2(this.x, this.y);
      },
      copy: function copy(src) {
        return this.x = src.x || 0, this.y = src.y || 0, this;
      },
      setFromObject: function setFromObject(obj) {
        return this.x = obj.x || 0, this.y = obj.y || 0, this;
      },
      set: function set(x, y) {
        return void 0 === y && (y = x), this.x = x, this.y = y, this;
      },
      setTo: function setTo(x, y) {
        return this.set(x, y);
      },
      setToPolar: function setToPolar(azimuth, radius) {
        return null == radius && (radius = 1), this.x = Math.cos(azimuth) * radius, this.y = Math.sin(azimuth) * radius, this;
      },
      equals: function equals(v) {
        return this.x === v.x && this.y === v.y;
      },
      fuzzyEquals: function fuzzyEquals(v, epsilon) {
        return FuzzyEqual(this.x, v.x, epsilon) && FuzzyEqual(this.y, v.y, epsilon);
      },
      angle: function angle() {
        var angle = Math.atan2(this.y, this.x);
        return angle < 0 && (angle += 2 * Math.PI), angle;
      },
      setAngle: function setAngle(angle) {
        return this.setToPolar(angle, this.length());
      },
      add: function add(src) {
        return this.x += src.x, this.y += src.y, this;
      },
      subtract: function subtract(src) {
        return this.x -= src.x, this.y -= src.y, this;
      },
      multiply: function multiply(src) {
        return this.x *= src.x, this.y *= src.y, this;
      },
      scale: function scale(value) {
        return isFinite(value) ? (this.x *= value, this.y *= value) : (this.x = 0, this.y = 0), this;
      },
      divide: function divide(src) {
        return this.x /= src.x, this.y /= src.y, this;
      },
      negate: function negate() {
        return this.x = -this.x, this.y = -this.y, this;
      },
      distance: function distance(dy) {
        var dx = dy.x - this.x,
            dy = dy.y - this.y;
        return Math.sqrt(dx * dx + dy * dy);
      },
      distanceSq: function distanceSq(dy) {
        var dx = dy.x - this.x,
            dy = dy.y - this.y;
        return dx * dx + dy * dy;
      },
      length: function length() {
        var x = this.x,
            y = this.y;
        return Math.sqrt(x * x + y * y);
      },
      setLength: function setLength(length) {
        return this.normalize().scale(length);
      },
      lengthSq: function lengthSq() {
        var x = this.x,
            y = this.y;
        return x * x + y * y;
      },
      normalize: function normalize() {
        var x = this.x,
            y = this.y,
            len = x * x + y * y;
        return 0 < len && (len = 1 / Math.sqrt(len), this.x = x * len, this.y = y * len), this;
      },
      normalizeRightHand: function normalizeRightHand() {
        var x = this.x;
        return this.x = -1 * this.y, this.y = x, this;
      },
      normalizeLeftHand: function normalizeLeftHand() {
        var x = this.x;
        return this.x = this.y, this.y = -1 * x, this;
      },
      dot: function dot(src) {
        return this.x * src.x + this.y * src.y;
      },
      cross: function cross(src) {
        return this.x * src.y - this.y * src.x;
      },
      lerp: function lerp(src, t) {
        var ax = this.x,
            ay = this.y;
        return this.x = ax + (t = void 0 === t ? 0 : t) * (src.x - ax), this.y = ay + t * (src.y - ay), this;
      },
      transformMat3: function transformMat3(m) {
        var x = this.x,
            y = this.y,
            m = m.val;
        return this.x = m[0] * x + m[3] * y + m[6], this.y = m[1] * x + m[4] * y + m[7], this;
      },
      transformMat4: function transformMat4(m) {
        var x = this.x,
            y = this.y,
            m = m.val;
        return this.x = m[0] * x + m[4] * y + m[12], this.y = m[1] * x + m[5] * y + m[13], this;
      },
      reset: function reset() {
        return this.x = 0, this.y = 0, this;
      },
      limit: function limit(max) {
        var len = this.length();
        return len && max < len && this.scale(max / len), this;
      },
      reflect: function reflect(normal) {
        return normal = normal.clone().normalize(), this.subtract(normal.scale(2 * this.dot(normal)));
      },
      mirror: function mirror(axis) {
        return this.reflect(axis).negate();
      },
      rotate: function rotate(sin) {
        var cos = Math.cos(sin),
            sin = Math.sin(sin);
        return this.set(cos * this.x - sin * this.y, sin * this.x + cos * this.y);
      }
    });

    Vector2.ZERO = new Vector2(), Vector2.RIGHT = new Vector2(1, 0), Vector2.LEFT = new Vector2(-1, 0), Vector2.UP = new Vector2(0, -1), Vector2.DOWN = new Vector2(0, 1), Vector2.ONE = new Vector2(1, 1), module.exports = Vector2;
  }, function (module, exports, __webpack_require__) {
    var Point = __webpack_require__(0),
        GEOM_CONST = __webpack_require__(56),
        Point = new Point({
      initialize: function initialize(x, y) {
        void 0 === x && (x = 0), void 0 === y && (y = x), this.type = GEOM_CONST.POINT, this.x = x, this.y = y;
      },
      setTo: function setTo(x, y) {
        return void 0 === x && (x = 0), void 0 === y && (y = x), this.x = x, this.y = y, this;
      }
    });

    module.exports = Point;
  }, function (module, exports, __webpack_require__) {
    var Class = __webpack_require__(0),
        PluginCache = __webpack_require__(24),
        SceneEvents = __webpack_require__(20),
        GameObjectFactory = new Class({
      initialize: function initialize(scene) {
        this.scene = scene, this.systems = scene.sys, this.events = scene.sys.events, this.displayList, this.updateList, this.events.once(SceneEvents.BOOT, this.boot, this), this.events.on(SceneEvents.START, this.start, this);
      },
      boot: function boot() {
        this.displayList = this.systems.displayList, this.updateList = this.systems.updateList, this.events.once(SceneEvents.DESTROY, this.destroy, this);
      },
      start: function start() {
        this.events.once(SceneEvents.SHUTDOWN, this.shutdown, this);
      },
      existing: function existing(child) {
        return (child.renderCanvas || child.renderWebGL) && this.displayList.add(child), child.preUpdate && this.updateList.add(child), child;
      },
      shutdown: function shutdown() {
        this.events.off(SceneEvents.SHUTDOWN, this.shutdown, this);
      },
      destroy: function destroy() {
        this.shutdown(), this.events.off(SceneEvents.START, this.start, this), this.scene = null, this.systems = null, this.events = null, this.displayList = null, this.updateList = null;
      }
    });

    GameObjectFactory.register = function (factoryType, factoryFunction) {
      GameObjectFactory.prototype.hasOwnProperty(factoryType) || (GameObjectFactory.prototype[factoryType] = factoryFunction);
    }, GameObjectFactory.remove = function (factoryType) {
      GameObjectFactory.prototype.hasOwnProperty(factoryType) && delete GameObjectFactory.prototype[factoryType];
    }, PluginCache.register("GameObjectFactory", GameObjectFactory, "add"), module.exports = GameObjectFactory;
  }, function (module, exports) {
    module.exports = function (source, key, defaultValue) {
      if (source && "number" != typeof source) {
        if (source.hasOwnProperty(key)) return source[key];
        if (-1 === key.indexOf(".")) return defaultValue;

        for (var keys = key.split("."), parent = source, value = defaultValue, i = 0; i < keys.length; i++) {
          if (!parent.hasOwnProperty(keys[i])) {
            value = defaultValue;
            break;
          }

          value = parent[keys[i]], parent = parent[keys[i]];
        }

        return value;
      }

      return defaultValue;
    };
  }, function (module, exports) {
    module.exports = function (obj) {
      if ("object" != _typeof(obj) || obj.nodeType || obj === obj.window) return !1;

      try {
        if (obj.constructor && !{}.hasOwnProperty.call(obj.constructor.prototype, "isPrototypeOf")) return !1;
      } catch (e) {
        return !1;
      }

      return !0;
    };
  }, function (module, exports) {
    var types = {};
    module.exports = {
      install: function install(loader) {
        for (var key in types) {
          loader[key] = types[key];
        }
      },
      register: function register(key, factoryFunction) {
        types[key] = factoryFunction;
      },
      destroy: function destroy() {
        types = {};
      }
    };
  }, function (module, exports, __webpack_require__) {
    "use strict";

    var has = Object.prototype.hasOwnProperty,
        prefix = "~";

    function Events() {}

    function EE(fn, context, once) {
      this.fn = fn, this.context = context, this.once = once || !1;
    }

    function addListener(emitter, evt, fn, context, listener) {
      if ("function" != typeof fn) throw new TypeError("The listener must be a function");
      listener = new EE(fn, context || emitter, listener), evt = prefix ? prefix + evt : evt;
      return emitter._events[evt] ? emitter._events[evt].fn ? emitter._events[evt] = [emitter._events[evt], listener] : emitter._events[evt].push(listener) : (emitter._events[evt] = listener, emitter._eventsCount++), emitter;
    }

    function clearEvent(emitter, evt) {
      0 == --emitter._eventsCount ? emitter._events = new Events() : delete emitter._events[evt];
    }

    function EventEmitter() {
      this._events = new Events(), this._eventsCount = 0;
    }

    Object.create && (Events.prototype = Object.create(null), new Events().__proto__ || (prefix = !1)), EventEmitter.prototype.eventNames = function () {
      var events,
          name,
          names = [];
      if (0 === this._eventsCount) return names;

      for (name in events = this._events) {
        has.call(events, name) && names.push(prefix ? name.slice(1) : name);
      }

      return Object.getOwnPropertySymbols ? names.concat(Object.getOwnPropertySymbols(events)) : names;
    }, EventEmitter.prototype.listeners = function (evt) {
      var evt = prefix ? prefix + evt : evt,
          handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];

      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }

      return ee;
    }, EventEmitter.prototype.listenerCount = function (listeners) {
      listeners = prefix ? prefix + listeners : listeners, listeners = this._events[listeners];
      return listeners ? listeners.fn ? 1 : listeners.length : 0;
    }, EventEmitter.prototype.emit = function (event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return !1;
      var args,
          listeners = this._events[evt],
          len = arguments.length;

      if (listeners.fn) {
        switch (listeners.once && this.removeListener(event, listeners.fn, void 0, !0), len) {
          case 1:
            return listeners.fn.call(listeners.context), !0;

          case 2:
            return listeners.fn.call(listeners.context, a1), !0;

          case 3:
            return listeners.fn.call(listeners.context, a1, a2), !0;

          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), !0;

          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), !0;

          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), !0;
        }

        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }

        listeners.fn.apply(listeners.context, args);
      } else for (var j, length = listeners.length, i = 0; i < length; i++) {
        switch (listeners[i].once && this.removeListener(event, listeners[i].fn, void 0, !0), len) {
          case 1:
            listeners[i].fn.call(listeners[i].context);
            break;

          case 2:
            listeners[i].fn.call(listeners[i].context, a1);
            break;

          case 3:
            listeners[i].fn.call(listeners[i].context, a1, a2);
            break;

          case 4:
            listeners[i].fn.call(listeners[i].context, a1, a2, a3);
            break;

          default:
            if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
              args[j - 1] = arguments[j];
            }
            listeners[i].fn.apply(listeners[i].context, args);
        }
      }

      return !0;
    }, EventEmitter.prototype.on = function (event, fn, context) {
      return addListener(this, event, fn, context, !1);
    }, EventEmitter.prototype.once = function (event, fn, context) {
      return addListener(this, event, fn, context, !0);
    }, EventEmitter.prototype.removeListener = function (evt, fn, context, once) {
      evt = prefix ? prefix + evt : evt;
      if (!this._events[evt]) return this;
      if (!fn) return clearEvent(this, evt), this;
      var listeners = this._events[evt];
      if (listeners.fn) listeners.fn !== fn || once && !listeners.once || context && listeners.context !== context || clearEvent(this, evt);else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) && events.push(listeners[i]);
        }

        events.length ? this._events[evt] = 1 === events.length ? events[0] : events : clearEvent(this, evt);
      }
      return this;
    }, EventEmitter.prototype.removeAllListeners = function (evt) {
      return evt ? (evt = prefix ? prefix + evt : evt, this._events[evt] && clearEvent(this, evt)) : (this._events = new Events(), this._eventsCount = 0), this;
    }, EventEmitter.prototype.off = EventEmitter.prototype.removeListener, EventEmitter.prototype.addListener = EventEmitter.prototype.on, EventEmitter.prefixed = prefix, module.exports = EventEmitter.EventEmitter = EventEmitter;
  }, function (module, exports, __webpack_require__) {
    var Rectangle = __webpack_require__(0),
        Contains = __webpack_require__(57),
        GetPoint = __webpack_require__(171),
        GetPoints = __webpack_require__(306),
        GEOM_CONST = __webpack_require__(56),
        Line = __webpack_require__(47),
        Random = __webpack_require__(174),
        Rectangle = new Rectangle({
      initialize: function initialize(x, y, width, height) {
        void 0 === x && (x = 0), void 0 === y && (y = 0), void 0 === width && (width = 0), void 0 === height && (height = 0), this.type = GEOM_CONST.RECTANGLE, this.x = x, this.y = y, this.width = width, this.height = height;
      },
      contains: function contains(x, y) {
        return Contains(this, x, y);
      },
      getPoint: function getPoint(position, output) {
        return GetPoint(this, position, output);
      },
      getPoints: function getPoints(quantity, stepRate, output) {
        return GetPoints(this, quantity, stepRate, output);
      },
      getRandomPoint: function getRandomPoint(point) {
        return Random(this, point);
      },
      setTo: function setTo(x, y, width, height) {
        return this.x = x, this.y = y, this.width = width, this.height = height, this;
      },
      setEmpty: function setEmpty() {
        return this.setTo(0, 0, 0, 0);
      },
      setPosition: function setPosition(x, y) {
        return void 0 === y && (y = x), this.x = x, this.y = y, this;
      },
      setSize: function setSize(width, height) {
        return void 0 === height && (height = width), this.width = width, this.height = height, this;
      },
      isEmpty: function isEmpty() {
        return this.width <= 0 || this.height <= 0;
      },
      getLineA: function getLineA(line) {
        return (line = void 0 === line ? new Line() : line).setTo(this.x, this.y, this.right, this.y), line;
      },
      getLineB: function getLineB(line) {
        return (line = void 0 === line ? new Line() : line).setTo(this.right, this.y, this.right, this.bottom), line;
      },
      getLineC: function getLineC(line) {
        return (line = void 0 === line ? new Line() : line).setTo(this.right, this.bottom, this.x, this.bottom), line;
      },
      getLineD: function getLineD(line) {
        return (line = void 0 === line ? new Line() : line).setTo(this.x, this.bottom, this.x, this.y), line;
      },
      left: {
        get: function get() {
          return this.x;
        },
        set: function set(value) {
          value >= this.right ? this.width = 0 : this.width = this.right - value, this.x = value;
        }
      },
      right: {
        get: function get() {
          return this.x + this.width;
        },
        set: function set(value) {
          value <= this.x ? this.width = 0 : this.width = value - this.x;
        }
      },
      top: {
        get: function get() {
          return this.y;
        },
        set: function set(value) {
          value >= this.bottom ? this.height = 0 : this.height = this.bottom - value, this.y = value;
        }
      },
      bottom: {
        get: function get() {
          return this.y + this.height;
        },
        set: function set(value) {
          value <= this.y ? this.height = 0 : this.height = value - this.y;
        }
      },
      centerX: {
        get: function get() {
          return this.x + this.width / 2;
        },
        set: function set(value) {
          this.x = value - this.width / 2;
        }
      },
      centerY: {
        get: function get() {
          return this.y + this.height / 2;
        },
        set: function set(value) {
          this.y = value - this.height / 2;
        }
      }
    });

    module.exports = Rectangle;
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      Alpha: __webpack_require__(607),
      AlphaSingle: __webpack_require__(303),
      BlendMode: __webpack_require__(304),
      ComputedSize: __webpack_require__(608),
      Crop: __webpack_require__(609),
      Depth: __webpack_require__(305),
      Flip: __webpack_require__(610),
      GetBounds: __webpack_require__(611),
      Mask: __webpack_require__(309),
      Origin: __webpack_require__(632),
      PathFollower: __webpack_require__(633),
      Pipeline: __webpack_require__(167),
      ScrollFactor: __webpack_require__(312),
      Size: __webpack_require__(634),
      Texture: __webpack_require__(635),
      TextureCrop: __webpack_require__(636),
      Tint: __webpack_require__(637),
      ToJSON: __webpack_require__(176),
      Transform: __webpack_require__(313),
      TransformMatrix: __webpack_require__(25),
      Visible: __webpack_require__(314)
    };
  }, function (module, exports) {
    module.exports = {
      getTintFromFloats: function getTintFromFloats(r, g, b, a) {
        return ((255 & (255 * a | 0)) << 24 | (255 & (255 * r | 0)) << 16 | (255 & (255 * g | 0)) << 8 | 255 & (255 * b | 0)) >>> 0;
      },
      getTintAppendFloatAlpha: function getTintAppendFloatAlpha(rgb, a) {
        return ((255 & (255 * a | 0)) << 24 | rgb) >>> 0;
      },
      getTintAppendFloatAlphaAndSwap: function getTintAppendFloatAlphaAndSwap(rgb, a) {
        return ((255 & (255 * a | 0)) << 24 | (255 & (0 | rgb)) << 16 | (255 & (rgb >> 8 | 0)) << 8 | 255 & (rgb >> 16 | 0)) >>> 0;
      },
      getFloatsFromUintRGB: function getFloatsFromUintRGB(rgb) {
        return [(255 & (rgb >> 16 | 0)) / 255, (255 & (rgb >> 8 | 0)) / 255, (255 & (0 | rgb)) / 255];
      },
      checkShaderMax: function checkShaderMax(gl, maxTextures) {
        maxTextures && -1 !== maxTextures || (maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS));

        for (var shader = gl.createShader(gl.FRAGMENT_SHADER), fragTemplate = ["precision mediump float;", "void main(void){", "float test = 0.1;", "%forloop%", "gl_FragColor = vec4(0.0);", "}"].join("\n");;) {
          var fragmentSrc = fragTemplate.replace(/%forloop%/gi, function (maxIfs) {
            for (var src = "", i = 0; i < maxIfs; ++i) {
              0 < i && (src += "\nelse "), i < maxIfs - 1 && (src += "if(test == " + i + ".0){}");
            }

            return src;
          }(maxTextures));
          if (gl.shaderSource(shader, fragmentSrc), gl.compileShader(shader), gl.getShaderParameter(shader, gl.COMPILE_STATUS)) break;
          maxTextures = maxTextures / 2 | 0;
        }

        return maxTextures;
      },
      parseFragmentShaderMaxTextures: function parseFragmentShaderMaxTextures(fragmentShaderSource, maxTextures) {
        if (!fragmentShaderSource) return "";

        for (var src = "", i = 0; i < maxTextures; i++) {
          0 < i && (src += "\n\telse "), i < maxTextures - 1 && (src += "if (outTexId < " + i + ".5)"), src += "\n\t{", src += "\n\t\ttexture = texture2D(uMainSampler[" + i + "], outTexCoord);", src += "\n\t}";
        }

        return (fragmentShaderSource = fragmentShaderSource.replace(/%count%/gi, maxTextures.toString())).replace(/%forloop%/gi, src);
      }
    };
  }, function (module, exports, __webpack_require__) {
    var MATH = __webpack_require__(193),
        GetValue = __webpack_require__(6);

    module.exports = function (value, key, defaultValue) {
      value = GetValue(value, key, null);
      if (null === value) return defaultValue;
      if (Array.isArray(value)) return MATH.RND.pick(value);

      if ("object" == _typeof(value)) {
        if (value.hasOwnProperty("randInt")) return MATH.RND.integerInRange(value.randInt[0], value.randInt[1]);
        if (value.hasOwnProperty("randFloat")) return MATH.RND.realInRange(value.randFloat[0], value.randFloat[1]);
      } else if ("function" == typeof value) return value(key);

      return value;
    };
  }, function (module, exports) {
    var MATH_CONST = {
      PI2: 2 * Math.PI,
      TAU: .5 * Math.PI,
      EPSILON: 1e-6,
      DEG_TO_RAD: Math.PI / 180,
      RAD_TO_DEG: 180 / Math.PI,
      RND: null,
      MIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER || -9007199254740991,
      MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991
    };
    module.exports = MATH_CONST;
  }, function (module, exports, __webpack_require__) {
    var Class = __webpack_require__(0),
        ComponentsToJSON = __webpack_require__(176),
        DataManager = __webpack_require__(101),
        EventEmitter = __webpack_require__(9),
        Events = __webpack_require__(75),
        SceneEvents = __webpack_require__(20),
        GameObject = new Class({
      Extends: EventEmitter,
      initialize: function initialize(scene, type) {
        EventEmitter.call(this), this.scene = scene, this.displayList = null, this.type = type, this.state = 0, this.parentContainer = null, this.name = "", this.active = !0, this.tabIndex = -1, this.data = null, this.renderFlags = 15, this.cameraFilter = 0, this.input = null, this.body = null, this.ignoreDestroy = !1, this.on(Events.ADDED_TO_SCENE, this.addedToScene, this), this.on(Events.REMOVED_FROM_SCENE, this.removedFromScene, this), scene.sys.queueDepthSort();
      },
      setActive: function setActive(value) {
        return this.active = value, this;
      },
      setName: function setName(value) {
        return this.name = value, this;
      },
      setState: function setState(value) {
        return this.state = value, this;
      },
      setDataEnabled: function setDataEnabled() {
        return this.data || (this.data = new DataManager(this)), this;
      },
      setData: function setData(key, value) {
        return this.data || (this.data = new DataManager(this)), this.data.set(key, value), this;
      },
      incData: function incData(key, value) {
        return this.data || (this.data = new DataManager(this)), this.data.inc(key, value), this;
      },
      toggleData: function toggleData(key) {
        return this.data || (this.data = new DataManager(this)), this.data.toggle(key), this;
      },
      getData: function getData(key) {
        return this.data || (this.data = new DataManager(this)), this.data.get(key);
      },
      setInteractive: function setInteractive(hitArea, hitAreaCallback, dropZone) {
        return this.scene.sys.input.enable(this, hitArea, hitAreaCallback, dropZone), this;
      },
      disableInteractive: function disableInteractive() {
        return this.input && (this.input.enabled = !1), this;
      },
      removeInteractive: function removeInteractive() {
        return this.scene.sys.input.clear(this), this.input = void 0, this;
      },
      addedToScene: function addedToScene() {},
      removedFromScene: function removedFromScene() {},
      update: function update() {},
      toJSON: function toJSON() {
        return ComponentsToJSON(this);
      },
      willRender: function willRender(camera) {
        return !(GameObject.RENDER_MASK !== this.renderFlags || 0 !== this.cameraFilter && this.cameraFilter & camera.id);
      },
      getIndexList: function getIndexList() {
        for (var child = this, parent = this.parentContainer, indexes = []; parent && (indexes.unshift(parent.getIndex(child)), (child = parent).parentContainer);) {
          parent = parent.parentContainer;
        }

        return this.displayList ? indexes.unshift(this.displayList.getIndex(child)) : indexes.unshift(this.scene.sys.displayList.getIndex(child)), indexes;
      },
      addToDisplayList: function addToDisplayList(displayList) {
        return void 0 === displayList && (displayList = this.scene.sys.displayList), this.displayList && this.displayList !== displayList && this.removeFromDisplayList(), displayList.exists(this) || ((this.displayList = displayList).add(this, !0), displayList.queueDepthSort(), this.emit(Events.ADDED_TO_SCENE, this, this.scene), displayList.events.emit(SceneEvents.ADDED_TO_SCENE, this, this.scene)), this;
      },
      addToUpdateList: function addToUpdateList() {
        return this.scene && this.preUpdate && this.scene.sys.updateList.add(this), this;
      },
      removeFromDisplayList: function removeFromDisplayList() {
        var displayList = this.displayList || this.scene.sys.displayList;
        return displayList.exists(this) && (displayList.remove(this, !0), displayList.queueDepthSort(), this.displayList = null, this.emit(Events.REMOVED_FROM_SCENE, this, this.scene), displayList.events.emit(SceneEvents.REMOVED_FROM_SCENE, this, this.scene)), this;
      },
      removeFromUpdateList: function removeFromUpdateList() {
        return this.scene && this.preUpdate && this.scene.sys.updateList.remove(this), this;
      },
      destroy: function destroy(fromScene) {
        this.scene && !this.ignoreDestroy && (void 0 === fromScene && (fromScene = !1), this.preDestroy && this.preDestroy.call(this), this.emit(Events.DESTROY, this, fromScene), this.removeAllListeners(), this.postPipelines && this.resetPostPipeline(!0), this.removeFromDisplayList(), this.removeFromUpdateList(), this.input && (this.scene.sys.input.clear(this), this.input = void 0), this.data && (this.data.destroy(), this.data = void 0), this.body && (this.body.destroy(), this.body = void 0), this.active = !1, this.visible = !1, this.scene = void 0, this.parentContainer = void 0);
      }
    });

    GameObject.RENDER_MASK = 15, module.exports = GameObject;
  }, function (module, exports, __webpack_require__) {
    var Class = __webpack_require__(0),
        PluginCache = __webpack_require__(24),
        SceneEvents = __webpack_require__(20),
        GameObjectCreator = new Class({
      initialize: function initialize(scene) {
        this.scene = scene, this.systems = scene.sys, this.events = scene.sys.events, this.displayList, this.updateList, this.events.once(SceneEvents.BOOT, this.boot, this), this.events.on(SceneEvents.START, this.start, this);
      },
      boot: function boot() {
        this.displayList = this.systems.displayList, this.updateList = this.systems.updateList, this.events.once(SceneEvents.DESTROY, this.destroy, this);
      },
      start: function start() {
        this.events.once(SceneEvents.SHUTDOWN, this.shutdown, this);
      },
      shutdown: function shutdown() {
        this.events.off(SceneEvents.SHUTDOWN, this.shutdown, this);
      },
      destroy: function destroy() {
        this.shutdown(), this.events.off(SceneEvents.START, this.start, this), this.scene = null, this.systems = null, this.events = null, this.displayList = null, this.updateList = null;
      }
    });

    GameObjectCreator.register = function (factoryType, factoryFunction) {
      GameObjectCreator.prototype.hasOwnProperty(factoryType) || (GameObjectCreator.prototype[factoryType] = factoryFunction);
    }, GameObjectCreator.remove = function (factoryType) {
      GameObjectCreator.prototype.hasOwnProperty(factoryType) && delete GameObjectCreator.prototype[factoryType];
    }, PluginCache.register("GameObjectCreator", GameObjectCreator, "make"), module.exports = GameObjectCreator;
  }, function (module, exports, __webpack_require__) {
    function Extend() {
      var options,
          name,
          copy,
          copyIsArray,
          clone,
          target = arguments[0] || {},
          i = 1,
          length = arguments.length,
          deep = !1;

      for ("boolean" == typeof target && (deep = target, target = arguments[1] || {}, i = 2), length === i && (target = this, --i); i < length; i++) {
        if (null != (options = arguments[i])) for (name in options) {
          clone = target[name], target !== (copy = options[name]) && (deep && copy && (IsPlainObject(copy) || (copyIsArray = Array.isArray(copy))) ? (clone = copyIsArray ? (copyIsArray = !1, clone && Array.isArray(clone) ? clone : []) : clone && IsPlainObject(clone) ? clone : {}, target[name] = Extend(deep, clone, copy)) : void 0 !== copy && (target[name] = copy));
        }
      }

      return target;
    }

    var IsPlainObject = __webpack_require__(7);

    module.exports = Extend;
  }, function (module, exports) {
    module.exports = function (value, min, max) {
      return Math.max(min, Math.min(max, value));
    };
  }, function (module, exports, TransformMatrix) {
    var TransformMatrix = TransformMatrix(25),
        tempMatrix1 = new TransformMatrix(),
        tempMatrix2 = new TransformMatrix(),
        tempMatrix3 = new TransformMatrix(),
        result = {
      camera: tempMatrix1,
      sprite: tempMatrix2,
      calc: tempMatrix3
    };

    module.exports = function (src, camera, parentMatrix) {
      var camMatrix = tempMatrix1,
          spriteMatrix = tempMatrix2,
          calcMatrix = tempMatrix3;
      return spriteMatrix.applyITRS(src.x, src.y, src.rotation, src.scaleX, src.scaleY), camMatrix.copyFrom(camera.matrix), parentMatrix ? (camMatrix.multiplyWithOffset(parentMatrix, -camera.scrollX * src.scrollFactorX, -camera.scrollY * src.scrollFactorY), spriteMatrix.e = src.x, spriteMatrix.f = src.y) : (spriteMatrix.e -= camera.scrollX * src.scrollFactorX, spriteMatrix.f -= camera.scrollY * src.scrollFactorY), camMatrix.multiply(spriteMatrix, calcMatrix), result;
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      ADDED_TO_SCENE: __webpack_require__(656),
      BOOT: __webpack_require__(657),
      CREATE: __webpack_require__(658),
      DESTROY: __webpack_require__(659),
      PAUSE: __webpack_require__(660),
      POST_UPDATE: __webpack_require__(661),
      PRE_RENDER: __webpack_require__(662),
      PRE_UPDATE: __webpack_require__(663),
      READY: __webpack_require__(664),
      REMOVED_FROM_SCENE: __webpack_require__(665),
      RENDER: __webpack_require__(666),
      RESUME: __webpack_require__(667),
      SHUTDOWN: __webpack_require__(668),
      SLEEP: __webpack_require__(669),
      START: __webpack_require__(670),
      TRANSITION_COMPLETE: __webpack_require__(671),
      TRANSITION_INIT: __webpack_require__(672),
      TRANSITION_OUT: __webpack_require__(673),
      TRANSITION_START: __webpack_require__(674),
      TRANSITION_WAKE: __webpack_require__(675),
      UPDATE: __webpack_require__(676),
      WAKE: __webpack_require__(677)
    };
  }, function (module, exports) {
    module.exports = {
      LOADER_IDLE: 0,
      LOADER_LOADING: 1,
      LOADER_PROCESSING: 2,
      LOADER_COMPLETE: 3,
      LOADER_SHUTDOWN: 4,
      LOADER_DESTROYED: 5,
      FILE_PENDING: 10,
      FILE_LOADING: 11,
      FILE_LOADED: 12,
      FILE_FAILED: 13,
      FILE_PROCESSING: 14,
      FILE_ERRORED: 16,
      FILE_COMPLETE: 17,
      FILE_DESTROYED: 18,
      FILE_POPULATED: 19
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      BLUR: __webpack_require__(612),
      BOOT: __webpack_require__(613),
      CONTEXT_LOST: __webpack_require__(614),
      CONTEXT_RESTORED: __webpack_require__(615),
      DESTROY: __webpack_require__(616),
      FOCUS: __webpack_require__(617),
      HIDDEN: __webpack_require__(618),
      PAUSE: __webpack_require__(619),
      POST_RENDER: __webpack_require__(620),
      POST_STEP: __webpack_require__(621),
      PRE_RENDER: __webpack_require__(622),
      PRE_STEP: __webpack_require__(623),
      READY: __webpack_require__(624),
      RESUME: __webpack_require__(625),
      STEP: __webpack_require__(626),
      VISIBLE: __webpack_require__(627)
    };
  }, function (module, exports, __webpack_require__) {
    var File = __webpack_require__(0),
        CONST = __webpack_require__(21),
        Events = __webpack_require__(95),
        GetFastValue = __webpack_require__(2),
        GetURL = __webpack_require__(155),
        MergeXHRSettings = __webpack_require__(240),
        XHRLoader = __webpack_require__(517),
        XHRSettings = __webpack_require__(156),
        File = new File({
      initialize: function initialize(loader, fileConfig) {
        this.loader = loader, this.cache = GetFastValue(fileConfig, "cache", !1), this.type = GetFastValue(fileConfig, "type", !1), this.key = GetFastValue(fileConfig, "key", !1);
        var loadKey = this.key;
        if (loader.prefix && "" !== loader.prefix && (this.key = loader.prefix + loadKey), !this.type || !this.key) throw new Error("Invalid Loader." + this.type + " key");
        var url = GetFastValue(fileConfig, "url");
        void 0 === url ? url = loader.path + loadKey + "." + GetFastValue(fileConfig, "extension", "") : "string" != typeof url || url.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/) || (url = loader.path + url), this.url = url, this.src = "", this.xhrSettings = XHRSettings(GetFastValue(fileConfig, "responseType", void 0)), GetFastValue(fileConfig, "xhrSettings", !1) && (this.xhrSettings = MergeXHRSettings(this.xhrSettings, GetFastValue(fileConfig, "xhrSettings", {}))), this.xhrLoader = null, this.state = "function" == typeof this.url ? CONST.FILE_POPULATED : CONST.FILE_PENDING, this.bytesTotal = 0, this.bytesLoaded = -1, this.percentComplete = -1, this.crossOrigin = void 0, this.data = void 0, this.config = GetFastValue(fileConfig, "config", {}), this.multiFile, this.linkFile;
      },
      setLink: function setLink(fileB) {
        (this.linkFile = fileB).linkFile = this;
      },
      resetXHR: function resetXHR() {
        this.xhrLoader && (this.xhrLoader.onload = void 0, this.xhrLoader.onerror = void 0, this.xhrLoader.onprogress = void 0);
      },
      load: function load() {
        this.state === CONST.FILE_POPULATED ? this.loader.nextFile(this, !0) : (this.state = CONST.FILE_LOADING, this.src = GetURL(this, this.loader.baseURL), 0 === this.src.indexOf("data:") ? console.warn("Local data URIs are not supported: " + this.key) : this.xhrLoader = XHRLoader(this, this.loader.xhr));
      },
      onLoad: function onLoad(xhr, event) {
        var success = xhr.responseURL && (0 === xhr.responseURL.indexOf("file://") || 0 === xhr.responseURL.indexOf("capacitor://")) && 0 === event.target.status,
            success = !(event.target && 200 !== event.target.status) || success;
        4 === xhr.readyState && 400 <= xhr.status && xhr.status <= 599 && (success = !1), this.state = CONST.FILE_LOADED, this.resetXHR(), this.loader.nextFile(this, success);
      },
      onError: function onError() {
        this.resetXHR(), this.loader.nextFile(this, !1);
      },
      onProgress: function onProgress(event) {
        event.lengthComputable && (this.bytesLoaded = event.loaded, this.bytesTotal = event.total, this.percentComplete = Math.min(this.bytesLoaded / this.bytesTotal, 1), this.loader.emit(Events.FILE_PROGRESS, this, this.percentComplete));
      },
      onProcess: function onProcess() {
        this.state = CONST.FILE_PROCESSING, this.onProcessComplete();
      },
      onProcessComplete: function onProcessComplete() {
        this.state = CONST.FILE_COMPLETE, this.multiFile && this.multiFile.onFileComplete(this), this.loader.fileProcessComplete(this);
      },
      onProcessError: function onProcessError() {
        this.state = CONST.FILE_ERRORED, this.multiFile && this.multiFile.onFileFailed(this), this.loader.fileProcessComplete(this);
      },
      hasCacheConflict: function hasCacheConflict() {
        return this.cache && this.cache.exists(this.key);
      },
      addToCache: function addToCache() {
        this.cache && this.cache.add(this.key, this.data), this.pendingDestroy();
      },
      pendingDestroy: function pendingDestroy(data) {
        void 0 === data && (data = this.data);
        var key = this.key,
            type = this.type;
        this.loader.emit(Events.FILE_COMPLETE, key, type, data), this.loader.emit(Events.FILE_KEY_COMPLETE + type + "-" + key, key, type, data), this.loader.flagForRemoval(this);
      },
      destroy: function destroy() {
        this.loader = null, this.cache = null, this.xhrSettings = null, this.multiFile = null, this.linkFile = null, this.data = null;
      }
    });

    File.createObjectURL = function (image, blob, defaultType) {
      var reader;
      "function" == typeof URL ? image.src = URL.createObjectURL(blob) : ((reader = new FileReader()).onload = function () {
        image.removeAttribute("crossOrigin"), image.src = "data:" + (blob.type || defaultType) + ";base64," + reader.result.split(",")[1];
      }, reader.onerror = image.onerror, reader.readAsDataURL(blob));
    }, File.revokeObjectURL = function (image) {
      "function" == typeof URL && URL.revokeObjectURL(image.src);
    }, module.exports = File;
  }, function (module, exports) {
    var corePlugins = {},
        customPlugins = {},
        PluginCache = {
      register: function register(key, plugin, mapping, custom) {
        corePlugins[key] = {
          plugin: plugin,
          mapping: mapping,
          custom: custom = void 0 === custom ? !1 : custom
        };
      },
      registerCustom: function registerCustom(key, plugin, mapping, data) {
        customPlugins[key] = {
          plugin: plugin,
          mapping: mapping,
          data: data
        };
      },
      hasCore: function hasCore(key) {
        return corePlugins.hasOwnProperty(key);
      },
      hasCustom: function hasCustom(key) {
        return customPlugins.hasOwnProperty(key);
      },
      getCore: function getCore(key) {
        return corePlugins[key];
      },
      getCustom: function getCustom(key) {
        return customPlugins[key];
      },
      getCustomClass: function getCustomClass(key) {
        return customPlugins.hasOwnProperty(key) ? customPlugins[key].plugin : null;
      },
      remove: function remove(key) {
        corePlugins.hasOwnProperty(key) && delete corePlugins[key];
      },
      removeCustom: function removeCustom(key) {
        customPlugins.hasOwnProperty(key) && delete customPlugins[key];
      },
      destroyCorePlugins: function destroyCorePlugins() {
        for (var key in corePlugins) {
          corePlugins.hasOwnProperty(key) && delete corePlugins[key];
        }
      },
      destroyCustomPlugins: function destroyCustomPlugins() {
        for (var key in customPlugins) {
          customPlugins.hasOwnProperty(key) && delete customPlugins[key];
        }
      }
    };
    module.exports = PluginCache;
  }, function (module, exports, __webpack_require__) {
    var TransformMatrix = __webpack_require__(0),
        MATH_CONST = __webpack_require__(14),
        Vector2 = __webpack_require__(3),
        TransformMatrix = new TransformMatrix({
      initialize: function initialize(a, b, c, d, tx, ty) {
        void 0 === a && (a = 1), void 0 === b && (b = 0), void 0 === c && (c = 0), void 0 === d && (d = 1), void 0 === tx && (tx = 0), void 0 === ty && (ty = 0), this.matrix = new Float32Array([a, b, c, d, tx, ty, 0, 0, 1]), this.decomposedMatrix = {
          translateX: 0,
          translateY: 0,
          scaleX: 1,
          scaleY: 1,
          rotation: 0
        };
      },
      a: {
        get: function get() {
          return this.matrix[0];
        },
        set: function set(value) {
          this.matrix[0] = value;
        }
      },
      b: {
        get: function get() {
          return this.matrix[1];
        },
        set: function set(value) {
          this.matrix[1] = value;
        }
      },
      c: {
        get: function get() {
          return this.matrix[2];
        },
        set: function set(value) {
          this.matrix[2] = value;
        }
      },
      d: {
        get: function get() {
          return this.matrix[3];
        },
        set: function set(value) {
          this.matrix[3] = value;
        }
      },
      e: {
        get: function get() {
          return this.matrix[4];
        },
        set: function set(value) {
          this.matrix[4] = value;
        }
      },
      f: {
        get: function get() {
          return this.matrix[5];
        },
        set: function set(value) {
          this.matrix[5] = value;
        }
      },
      tx: {
        get: function get() {
          return this.matrix[4];
        },
        set: function set(value) {
          this.matrix[4] = value;
        }
      },
      ty: {
        get: function get() {
          return this.matrix[5];
        },
        set: function set(value) {
          this.matrix[5] = value;
        }
      },
      rotation: {
        get: function get() {
          return Math.acos(this.a / this.scaleX) * (Math.atan(-this.c / this.a) < 0 ? -1 : 1);
        }
      },
      rotationNormalized: {
        get: function get() {
          var d = this.matrix,
              a = d[0],
              b = d[1],
              c = d[2],
              d = d[3];
          return a || b ? 0 < b ? Math.acos(a / this.scaleX) : -Math.acos(a / this.scaleX) : c || d ? MATH_CONST.TAU - (0 < d ? Math.acos(-c / this.scaleY) : -Math.acos(c / this.scaleY)) : 0;
        }
      },
      scaleX: {
        get: function get() {
          return Math.sqrt(this.a * this.a + this.b * this.b);
        }
      },
      scaleY: {
        get: function get() {
          return Math.sqrt(this.c * this.c + this.d * this.d);
        }
      },
      loadIdentity: function loadIdentity() {
        var matrix = this.matrix;
        return matrix[0] = 1, matrix[1] = 0, matrix[2] = 0, matrix[3] = 1, matrix[4] = 0, matrix[5] = 0, this;
      },
      translate: function translate(x, y) {
        var matrix = this.matrix;
        return matrix[4] = matrix[0] * x + matrix[2] * y + matrix[4], matrix[5] = matrix[1] * x + matrix[3] * y + matrix[5], this;
      },
      scale: function scale(x, y) {
        var matrix = this.matrix;
        return matrix[0] *= x, matrix[1] *= x, matrix[2] *= y, matrix[3] *= y, this;
      },
      rotate: function rotate(d) {
        var sin = Math.sin(d),
            cos = Math.cos(d),
            matrix = this.matrix,
            a = matrix[0],
            b = matrix[1],
            c = matrix[2],
            d = matrix[3];
        return matrix[0] = a * cos + c * sin, matrix[1] = b * cos + d * sin, matrix[2] = a * -sin + c * cos, matrix[3] = b * -sin + d * cos, this;
      },
      multiply: function multiply(sourceD, destinationMatrix) {
        var sourceE = this.matrix,
            sourceF = sourceD.matrix,
            localA = sourceE[0],
            localB = sourceE[1],
            localC = sourceE[2],
            localD = sourceE[3],
            localE = sourceE[4],
            localF = sourceE[5],
            sourceA = sourceF[0],
            sourceB = sourceF[1],
            sourceC = sourceF[2],
            sourceD = sourceF[3],
            sourceE = sourceF[4],
            sourceF = sourceF[5],
            destinationMatrix = void 0 === destinationMatrix ? this : destinationMatrix;
        return destinationMatrix.a = sourceA * localA + sourceB * localC, destinationMatrix.b = sourceA * localB + sourceB * localD, destinationMatrix.c = sourceC * localA + sourceD * localC, destinationMatrix.d = sourceC * localB + sourceD * localD, destinationMatrix.e = sourceE * localA + sourceF * localC + localE, destinationMatrix.f = sourceE * localB + sourceF * localD + localF, destinationMatrix;
      },
      multiplyWithOffset: function multiplyWithOffset(c1, d1, tx1) {
        var matrix = this.matrix,
            ty1 = c1.matrix,
            a0 = matrix[0],
            b0 = matrix[1],
            c0 = matrix[2],
            d0 = matrix[3],
            pse = d1 * a0 + tx1 * c0 + matrix[4],
            psf = d1 * b0 + tx1 * d0 + matrix[5],
            a1 = ty1[0],
            b1 = ty1[1],
            c1 = ty1[2],
            d1 = ty1[3],
            tx1 = ty1[4],
            ty1 = ty1[5];
        return matrix[0] = a1 * a0 + b1 * c0, matrix[1] = a1 * b0 + b1 * d0, matrix[2] = c1 * a0 + d1 * c0, matrix[3] = c1 * b0 + d1 * d0, matrix[4] = tx1 * a0 + ty1 * c0 + pse, matrix[5] = tx1 * b0 + ty1 * d0 + psf, this;
      },
      transform: function transform(a, b, c, d, tx, ty) {
        var matrix = this.matrix,
            a0 = matrix[0],
            b0 = matrix[1],
            c0 = matrix[2],
            d0 = matrix[3],
            tx0 = matrix[4],
            ty0 = matrix[5];
        return matrix[0] = a * a0 + b * c0, matrix[1] = a * b0 + b * d0, matrix[2] = c * a0 + d * c0, matrix[3] = c * b0 + d * d0, matrix[4] = tx * a0 + ty * c0 + tx0, matrix[5] = tx * b0 + ty * d0 + ty0, this;
      },
      transformPoint: function transformPoint(x, y, point) {
        var ty = this.matrix,
            a = ty[0],
            b = ty[1],
            c = ty[2],
            d = ty[3],
            tx = ty[4],
            ty = ty[5];
        return (point = void 0 === point ? {
          x: 0,
          y: 0
        } : point).x = x * a + y * c + tx, point.y = x * b + y * d + ty, point;
      },
      invert: function invert() {
        var matrix = this.matrix,
            a = matrix[0],
            b = matrix[1],
            c = matrix[2],
            d = matrix[3],
            tx = matrix[4],
            ty = matrix[5],
            n = a * d - b * c;
        return matrix[0] = d / n, matrix[1] = -b / n, matrix[2] = -c / n, matrix[3] = a / n, matrix[4] = (c * ty - d * tx) / n, matrix[5] = -(a * ty - b * tx) / n, this;
      },
      copyFrom: function copyFrom(src) {
        var matrix = this.matrix;
        return matrix[0] = src.a, matrix[1] = src.b, matrix[2] = src.c, matrix[3] = src.d, matrix[4] = src.e, matrix[5] = src.f, this;
      },
      copyFromArray: function copyFromArray(src) {
        var matrix = this.matrix;
        return matrix[0] = src[0], matrix[1] = src[1], matrix[2] = src[2], matrix[3] = src[3], matrix[4] = src[4], matrix[5] = src[5], this;
      },
      copyToContext: function copyToContext(ctx) {
        var matrix = this.matrix;
        return ctx.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]), ctx;
      },
      setToContext: function setToContext(ctx) {
        var matrix = this.matrix;
        return ctx.setTransform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]), ctx;
      },
      copyToArray: function copyToArray(out) {
        var matrix = this.matrix;
        return void 0 === out ? out = [matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]] : (out[0] = matrix[0], out[1] = matrix[1], out[2] = matrix[2], out[3] = matrix[3], out[4] = matrix[4], out[5] = matrix[5]), out;
      },
      setTransform: function setTransform(a, b, c, d, tx, ty) {
        var matrix = this.matrix;
        return matrix[0] = a, matrix[1] = b, matrix[2] = c, matrix[3] = d, matrix[4] = tx, matrix[5] = ty, this;
      },
      decomposeMatrix: function decomposeMatrix() {
        var s,
            decomposedMatrix = this.decomposedMatrix,
            matrix = this.matrix,
            a = matrix[0],
            b = matrix[1],
            c = matrix[2],
            d = matrix[3],
            determ = a * d - b * c;
        return decomposedMatrix.translateX = matrix[4], decomposedMatrix.translateY = matrix[5], a || b ? (s = Math.sqrt(a * a + b * b), decomposedMatrix.rotation = 0 < b ? Math.acos(a / s) : -Math.acos(a / s), decomposedMatrix.scaleX = s, decomposedMatrix.scaleY = determ / s) : c || d ? (s = Math.sqrt(c * c + d * d), decomposedMatrix.rotation = .5 * Math.PI - (0 < d ? Math.acos(-c / s) : -Math.acos(c / s)), decomposedMatrix.scaleX = determ / s, decomposedMatrix.scaleY = s) : (decomposedMatrix.rotation = 0, decomposedMatrix.scaleX = 0, decomposedMatrix.scaleY = 0), decomposedMatrix;
      },
      applyITRS: function applyITRS(x, y, radianCos, scaleX, scaleY) {
        var matrix = this.matrix,
            radianSin = Math.sin(radianCos),
            radianCos = Math.cos(radianCos);
        return matrix[4] = x, matrix[5] = y, matrix[0] = radianCos * scaleX, matrix[1] = radianSin * scaleX, matrix[2] = -radianSin * scaleY, matrix[3] = radianCos * scaleY, this;
      },
      applyInverse: function applyInverse(x, y, output) {
        void 0 === output && (output = new Vector2());
        var id = this.matrix,
            a = id[0],
            b = id[1],
            c = id[2],
            d = id[3],
            tx = id[4],
            ty = id[5],
            id = 1 / (a * d + c * -b);
        return output.x = d * id * x + -c * id * y + (ty * c - tx * d) * id, output.y = a * id * y + -b * id * x + (-ty * a + tx * b) * id, output;
      },
      getX: function getX(x, y) {
        return x * this.a + y * this.c + this.e;
      },
      getY: function getY(x, y) {
        return x * this.b + y * this.d + this.f;
      },
      getXRound: function getXRound(x, v, round) {
        v = this.getX(x, v);
        return v = round ? Math.round(v) : v;
      },
      getYRound: function getYRound(x, v, round) {
        v = this.getY(x, v);
        return v = round ? Math.round(v) : v;
      },
      getCSSMatrix: function getCSSMatrix() {
        var m = this.matrix;
        return "matrix(" + m[0] + "," + m[1] + "," + m[2] + "," + m[3] + "," + m[4] + "," + m[5] + ")";
      },
      destroy: function destroy() {
        this.matrix = null, this.decomposedMatrix = null;
      }
    });

    module.exports = TransformMatrix;
  }, function (module, exports, __webpack_require__) {
    var GetFastValue = __webpack_require__(2);

    module.exports = function (tileX, tileY, width, height, filteringOptions, layer) {
      void 0 === tileX && (tileX = 0), void 0 === tileY && (tileY = 0), void 0 === width && (width = layer.width), void 0 === height && (height = layer.height);
      var isNotEmpty = GetFastValue(filteringOptions = filteringOptions || {}, "isNotEmpty", !1),
          isColliding = GetFastValue(filteringOptions, "isColliding", !1),
          hasInterestingFace = GetFastValue(filteringOptions, "hasInterestingFace", !1);
      tileX < 0 && (width += tileX, tileX = 0), tileY < 0 && (height += tileY, tileY = 0), tileX + width > layer.width && (width = Math.max(layer.width - tileX, 0)), tileY + height > layer.height && (height = Math.max(layer.height - tileY, 0));

      for (var results = [], ty = tileY; ty < tileY + height; ty++) {
        for (var tx = tileX; tx < tileX + width; tx++) {
          var tile = layer.data[ty][tx];
          null !== tile && (isNotEmpty && -1 === tile.index || isColliding && !tile.collides || hasInterestingFace && !tile.hasInterestingFace || results.push(tile));
        }
      }

      return results;
    };
  }, function (module, exports) {
    module.exports = function (items, key, value, step, index, direction) {
      var i;
      void 0 === step && (step = 0), void 0 === index && (index = 0);
      var t = 0,
          end = items.length;
      if (1 === (direction = void 0 === direction ? 1 : direction)) for (i = index; i < end; i++) {
        items[i][key] = value + t * step, t++;
      } else for (i = index; 0 <= i; i--) {
        items[i][key] = value + t * step, t++;
      }
      return items;
    };
  }, function (module, exports, __webpack_require__) {
    var BlendModes = __webpack_require__(35),
        GetAdvancedValue = __webpack_require__(13);

    module.exports = function (scene, gameObject, config) {
      gameObject.x = GetAdvancedValue(config, "x", 0), gameObject.y = GetAdvancedValue(config, "y", 0), gameObject.depth = GetAdvancedValue(config, "depth", 0), gameObject.flipX = GetAdvancedValue(config, "flipX", !1), gameObject.flipY = GetAdvancedValue(config, "flipY", !1);
      var ox = GetAdvancedValue(config, "scale", null);
      "number" == typeof ox ? gameObject.setScale(ox) : null !== ox && (gameObject.scaleX = GetAdvancedValue(ox, "x", 1), gameObject.scaleY = GetAdvancedValue(ox, "y", 1));
      var oy = GetAdvancedValue(config, "scrollFactor", null);
      "number" == typeof oy ? gameObject.setScrollFactor(oy) : null !== oy && (gameObject.scrollFactorX = GetAdvancedValue(oy, "x", 1), gameObject.scrollFactorY = GetAdvancedValue(oy, "y", 1)), gameObject.rotation = GetAdvancedValue(config, "rotation", 0);
      ox = GetAdvancedValue(config, "angle", null);
      null !== ox && (gameObject.angle = ox), gameObject.alpha = GetAdvancedValue(config, "alpha", 1);
      var oy = GetAdvancedValue(config, "origin", null);
      return "number" == typeof oy ? gameObject.setOrigin(oy) : null !== oy && (ox = GetAdvancedValue(oy, "x", .5), oy = GetAdvancedValue(oy, "y", .5), gameObject.setOrigin(ox, oy)), gameObject.blendMode = GetAdvancedValue(config, "blendMode", BlendModes.NORMAL), gameObject.visible = GetAdvancedValue(config, "visible", !0), GetAdvancedValue(config, "add", !0) && scene.sys.displayList.add(gameObject), gameObject.preUpdate && scene.sys.updateList.add(gameObject), gameObject;
    };
  }, function (module, exports) {
    module.exports = {
      ORTHOGONAL: 0,
      ISOMETRIC: 1,
      STAGGERED: 2,
      HEXAGONAL: 3
    };
  }, function (module, exports, __webpack_require__) {
    var GetCalcMatrix = __webpack_require__(19);

    module.exports = function (renderer, ctx, src, camera, calcMatrix) {
      var alpha = camera.alpha * src.alpha;
      if (alpha <= 0) return !1;
      calcMatrix = GetCalcMatrix(src, camera, calcMatrix).calc;
      return ctx.globalCompositeOperation = renderer.blendModes[src.blendMode], ctx.globalAlpha = alpha, ctx.save(), calcMatrix.setToContext(ctx), ctx.imageSmoothingEnabled = !(!renderer.antialias || src.frame && src.frame.source.scaleMode), !0;
    };
  }, function (module, exports, __webpack_require__) {
    var first,
        CONST = __webpack_require__(33),
        Smoothing = __webpack_require__(192),
        pool = [],
        _disableContextSmoothing = !1;

    function create(canvas, width, height, canvasType, selfParent) {
      void 0 === width && (width = 1), void 0 === height && (height = 1), void 0 === canvasType && (canvasType = CONST.CANVAS), void 0 === selfParent && (selfParent = !1);
      var container = first(canvasType),
          canvas = (null === container ? (container = {
        parent: canvas,
        canvas: document.createElement("canvas"),
        type: canvasType
      }, canvasType === CONST.CANVAS && pool.push(container)) : container.parent = canvas, container.canvas);
      return selfParent && (container.parent = canvas), canvas.width = width, canvas.height = height, _disableContextSmoothing && canvasType === CONST.CANVAS && Smoothing.disable(canvas.getContext("2d")), canvas;
    }

    function total() {
      var c = 0;
      return pool.forEach(function (container) {
        container.parent && c++;
      }), c;
    }

    module.exports = {
      create2D: function create2D(parent, width, height) {
        return create(parent, width, height, CONST.CANVAS);
      },
      create: create,
      createWebGL: function createWebGL(parent, width, height) {
        return create(parent, width, height, CONST.WEBGL);
      },
      disableSmoothing: function disableSmoothing() {
        _disableContextSmoothing = !0;
      },
      enableSmoothing: function enableSmoothing() {
        _disableContextSmoothing = !1;
      },
      first: first = function first(canvasType) {
        if ((canvasType = void 0 === canvasType ? CONST.CANVAS : canvasType) === CONST.WEBGL) return null;

        for (var i = 0; i < pool.length; i++) {
          var container = pool[i];
          if (!container.parent && container.type === canvasType) return container;
        }

        return null;
      },
      free: function free() {
        return pool.length - total();
      },
      pool: pool,
      remove: function remove(parent) {
        var isCanvas = parent instanceof HTMLCanvasElement;
        pool.forEach(function (container) {
          (isCanvas && container.canvas === parent || !isCanvas && container.parent === parent) && (container.parent = null, container.canvas.width = 1, container.canvas.height = 1);
        });
      },
      total: total
    };
  }, function (module, exports) {
    var Common = {};
    module.exports = Common, function () {
      Common._nextId = 0, Common._seed = 0, Common._nowStartTime = +new Date(), Common.extend = function (obj, deep) {
        for (var argsStart, deepClone = "boolean" == typeof deep ? (argsStart = 2, deep) : (argsStart = 1, !0), i = argsStart; i < arguments.length; i++) {
          var source = arguments[i];
          if (source) for (var prop in source) {
            !deepClone || !source[prop] || source[prop].constructor !== Object || obj[prop] && obj[prop].constructor !== Object ? obj[prop] = source[prop] : (obj[prop] = obj[prop] || {}, Common.extend(obj[prop], deepClone, source[prop]));
          }
        }

        return obj;
      }, Common.clone = function (obj, deep) {
        return Common.extend({}, deep, obj);
      }, Common.keys = function (obj) {
        if (Object.keys) return Object.keys(obj);
        var key,
            keys = [];

        for (key in obj) {
          keys.push(key);
        }

        return keys;
      }, Common.values = function (obj) {
        var key,
            values = [];

        if (Object.keys) {
          for (var keys = Object.keys(obj), i = 0; i < keys.length; i++) {
            values.push(obj[keys[i]]);
          }

          return values;
        }

        for (key in obj) {
          values.push(obj[key]);
        }

        return values;
      }, Common.get = function (obj, path, begin, end) {
        path = path.split(".").slice(begin, end);

        for (var i = 0; i < path.length; i += 1) {
          obj = obj[path[i]];
        }

        return obj;
      }, Common.set = function (obj, path, val, begin, parts) {
        parts = path.split(".").slice(begin, parts);
        return Common.get(obj, path, 0, -1)[parts[parts.length - 1]] = val;
      }, Common.shuffle = function (array) {
        for (var i = array.length - 1; 0 < i; i--) {
          var j = Math.floor(Common.random() * (i + 1)),
              temp = array[i];
          array[i] = array[j], array[j] = temp;
        }

        return array;
      }, Common.choose = function (choices) {
        return choices[Math.floor(Common.random() * choices.length)];
      }, Common.isElement = function (obj) {
        return "undefined" != typeof HTMLElement ? obj instanceof HTMLElement : !!(obj && obj.nodeType && obj.nodeName);
      }, Common.isArray = function (obj) {
        return "[object Array]" === Object.prototype.toString.call(obj);
      }, Common.isFunction = function (obj) {
        return "function" == typeof obj;
      }, Common.isPlainObject = function (obj) {
        return "object" == _typeof(obj) && obj.constructor === Object;
      }, Common.isString = function (obj) {
        return "[object String]" === Object.prototype.toString.call(obj);
      }, Common.clamp = function (value, min, max) {
        return value < min ? min : max < value ? max : value;
      }, Common.sign = function (value) {
        return value < 0 ? -1 : 1;
      }, Common.now = function () {
        if ("undefined" != typeof window && window.performance) {
          if (window.performance.now) return window.performance.now();
          if (window.performance.webkitNow) return window.performance.webkitNow();
        }

        return new Date() - Common._nowStartTime;
      }, Common.random = function (min, max) {
        return max = void 0 !== max ? max : 1, (min = void 0 !== min ? min : 0) + _seededRandom() * (max - min);
      };

      var _seededRandom = function _seededRandom() {
        return Common._seed = (9301 * Common._seed + 49297) % 233280, Common._seed / 233280;
      };

      Common.colorToNumber = function (colorString) {
        return 3 == (colorString = colorString.replace("#", "")).length && (colorString = colorString.charAt(0) + colorString.charAt(0) + colorString.charAt(1) + colorString.charAt(1) + colorString.charAt(2) + colorString.charAt(2)), parseInt(colorString, 16);
      }, Common.logLevel = 1, Common.log = function () {
        console && 0 < Common.logLevel && Common.logLevel <= 3 && console.log.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments)));
      }, Common.info = function () {
        console && 0 < Common.logLevel && Common.logLevel <= 2 && console.info.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments)));
      }, Common.warn = function () {
        console && 0 < Common.logLevel && Common.logLevel <= 3 && console.warn.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments)));
      }, Common.nextId = function () {
        return Common._nextId++;
      }, Common.indexOf = function (haystack, needle) {
        if (haystack.indexOf) return haystack.indexOf(needle);

        for (var i = 0; i < haystack.length; i++) {
          if (haystack[i] === needle) return i;
        }

        return -1;
      }, Common.map = function (list, func) {
        if (list.map) return list.map(func);

        for (var mapped = [], i = 0; i < list.length; i += 1) {
          mapped.push(func(list[i]));
        }

        return mapped;
      }, Common.topologicalSort = function (graph) {
        var node,
            result = [],
            visited = [],
            temp = [];

        for (node in graph) {
          visited[node] || temp[node] || Common._topologicalSort(node, visited, temp, graph, result);
        }

        return result;
      }, Common._topologicalSort = function (node, visited, temp, graph, result) {
        var neighbors = graph[node] || [];
        temp[node] = !0;

        for (var i = 0; i < neighbors.length; i += 1) {
          var neighbor = neighbors[i];
          temp[neighbor] || visited[neighbor] || Common._topologicalSort(neighbor, visited, temp, graph, result);
        }

        temp[node] = !1, visited[node] = !0, result.push(node);
      }, Common.chain = function () {
        for (var funcs = [], i = 0; i < arguments.length; i += 1) {
          var func = arguments[i];
          func._chained ? funcs.push.apply(funcs, func._chained) : funcs.push(func);
        }

        function chain() {
          for (var lastResult, args = new Array(arguments.length), i = 0, l = arguments.length; i < l; i++) {
            args[i] = arguments[i];
          }

          for (i = 0; i < funcs.length; i += 1) {
            var result = funcs[i].apply(lastResult, args);
            void 0 !== result && (lastResult = result);
          }

          return lastResult;
        }

        return chain._chained = funcs, chain;
      }, Common.chainPathBefore = function (base, path, func) {
        return Common.set(base, path, Common.chain(func, Common.get(base, path)));
      }, Common.chainPathAfter = function (base, path, func) {
        return Common.set(base, path, Common.chain(Common.get(base, path), func));
      };
    }();
  }, function (module, exports, CONST) {
    CONST = {
      VERSION: "3.55.2",
      BlendModes: CONST(35),
      ScaleModes: CONST(168),
      AUTO: 0,
      CANVAS: 1,
      WEBGL: 2,
      HEADLESS: 3,
      FOREVER: -1,
      NONE: 4,
      UP: 5,
      DOWN: 6,
      LEFT: 7,
      RIGHT: 8
    };
    module.exports = CONST;
  }, function (module, exports, __webpack_require__) {
    var Class = __webpack_require__(0),
        Shape = __webpack_require__(11),
        GameObject = __webpack_require__(15),
        Line = __webpack_require__(47),
        Shape = new Class({
      Extends: GameObject,
      Mixins: [Shape.AlphaSingle, Shape.BlendMode, Shape.Depth, Shape.GetBounds, Shape.Mask, Shape.Origin, Shape.Pipeline, Shape.ScrollFactor, Shape.Transform, Shape.Visible],
      initialize: function initialize(scene, type, data) {
        GameObject.call(this, scene, type = void 0 === type ? "Shape" : type), this.geom = data, this.pathData = [], this.pathIndexes = [], this.fillColor = 16777215, this.fillAlpha = 1, this.strokeColor = 16777215, this.strokeAlpha = 1, this.lineWidth = 1, this.isFilled = !1, this.isStroked = !1, this.closePath = !0, this._tempLine = new Line(), this.width = 0, this.height = 0, this.initPipeline();
      },
      setFillStyle: function setFillStyle(color, alpha) {
        return void 0 === alpha && (alpha = 1), void 0 === color ? this.isFilled = !1 : (this.fillColor = color, this.fillAlpha = alpha, this.isFilled = !0), this;
      },
      setStrokeStyle: function setStrokeStyle(lineWidth, color, alpha) {
        return void 0 === alpha && (alpha = 1), void 0 === lineWidth ? this.isStroked = !1 : (this.lineWidth = lineWidth, this.strokeColor = color, this.strokeAlpha = alpha, this.isStroked = !0), this;
      },
      setClosePath: function setClosePath(value) {
        return this.closePath = value, this;
      },
      setSize: function setSize(width, height) {
        return this.width = width, this.height = height, this;
      },
      setDisplaySize: function setDisplaySize(width, height) {
        return this.displayWidth = width, this.displayHeight = height, this;
      },
      preDestroy: function preDestroy() {
        this.geom = null, this._tempLine = null, this.pathData = [], this.pathIndexes = [];
      },
      displayWidth: {
        get: function get() {
          return this.scaleX * this.width;
        },
        set: function set(value) {
          this.scaleX = value / this.width;
        }
      },
      displayHeight: {
        get: function get() {
          return this.scaleY * this.height;
        },
        set: function set(value) {
          this.scaleY = value / this.height;
        }
      }
    });

    module.exports = Shape;
  }, function (module, exports) {
    module.exports = {
      SKIP_CHECK: -1,
      NORMAL: 0,
      ADD: 1,
      MULTIPLY: 2,
      SCREEN: 3,
      OVERLAY: 4,
      DARKEN: 5,
      LIGHTEN: 6,
      COLOR_DODGE: 7,
      COLOR_BURN: 8,
      HARD_LIGHT: 9,
      SOFT_LIGHT: 10,
      DIFFERENCE: 11,
      EXCLUSION: 12,
      HUE: 13,
      SATURATION: 14,
      COLOR: 15,
      LUMINOSITY: 16,
      ERASE: 17,
      SOURCE_IN: 18,
      SOURCE_OUT: 19,
      SOURCE_ATOP: 20,
      DESTINATION_OVER: 21,
      DESTINATION_IN: 22,
      DESTINATION_OUT: 23,
      DESTINATION_ATOP: 24,
      LIGHTER: 25,
      COPY: 26,
      XOR: 27
    };
  }, function (module, exports, __webpack_require__) {
    var CONST = __webpack_require__(14);

    module.exports = function (degrees) {
      return degrees * CONST.DEG_TO_RAD;
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      DESTROY: __webpack_require__(743),
      FADE_IN_COMPLETE: __webpack_require__(744),
      FADE_IN_START: __webpack_require__(745),
      FADE_OUT_COMPLETE: __webpack_require__(746),
      FADE_OUT_START: __webpack_require__(747),
      FLASH_COMPLETE: __webpack_require__(748),
      FLASH_START: __webpack_require__(749),
      FOLLOW_UPDATE: __webpack_require__(750),
      PAN_COMPLETE: __webpack_require__(751),
      PAN_START: __webpack_require__(752),
      POST_RENDER: __webpack_require__(753),
      PRE_RENDER: __webpack_require__(754),
      ROTATE_COMPLETE: __webpack_require__(755),
      ROTATE_START: __webpack_require__(756),
      SHAKE_COMPLETE: __webpack_require__(757),
      SHAKE_START: __webpack_require__(758),
      ZOOM_COMPLETE: __webpack_require__(759),
      ZOOM_START: __webpack_require__(760)
    };
  }, function (module, exports, __webpack_require__) {
    var Class = __webpack_require__(0),
        GetColor = __webpack_require__(103),
        GetColor32 = __webpack_require__(328),
        HSVToRGB = __webpack_require__(188),
        RGBToHSV = __webpack_require__(329),
        Color = new Class({
      initialize: function initialize(red, green, blue, alpha) {
        void 0 === red && (red = 0), void 0 === green && (green = 0), void 0 === blue && (blue = 0), void 0 === alpha && (alpha = 255), this.r = 0, this.g = 0, this.b = 0, this.a = 255, this._h = 0, this._s = 0, this._v = 0, this._locked = !1, this.gl = [0, 0, 0, 1], this._color = 0, this._color32 = 0, this._rgba = "", this.setTo(red, green, blue, alpha);
      },
      transparent: function transparent() {
        return this._locked = !0, this.red = 0, this.green = 0, this.blue = 0, this.alpha = 0, this._locked = !1, this.update(!0);
      },
      setTo: function setTo(red, green, blue, alpha, updateHSV) {
        return void 0 === alpha && (alpha = 255), void 0 === updateHSV && (updateHSV = !0), this._locked = !0, this.red = red, this.green = green, this.blue = blue, this.alpha = alpha, this._locked = !1, this.update(updateHSV);
      },
      setGLTo: function setGLTo(red, green, blue, alpha) {
        return void 0 === alpha && (alpha = 1), this._locked = !0, this.redGL = red, this.greenGL = green, this.blueGL = blue, this.alphaGL = alpha, this._locked = !1, this.update(!0);
      },
      setFromRGB: function setFromRGB(color) {
        return this._locked = !0, this.red = color.r, this.green = color.g, this.blue = color.b, color.hasOwnProperty("a") && (this.alpha = color.a), this._locked = !1, this.update(!0);
      },
      setFromHSV: function setFromHSV(h, s, v) {
        return HSVToRGB(h, s, v, this);
      },
      update: function update(updateHSV) {
        if (void 0 === updateHSV && (updateHSV = !1), this._locked) return this;
        var r = this.r,
            g = this.g,
            b = this.b,
            a = this.a;
        return this._color = GetColor(r, g, b), this._color32 = GetColor32(r, g, b, a), this._rgba = "rgba(" + r + "," + g + "," + b + "," + a / 255 + ")", updateHSV && RGBToHSV(r, g, b, this), this;
      },
      updateHSV: function updateHSV() {
        var r = this.r,
            g = this.g,
            b = this.b;
        return RGBToHSV(r, g, b, this), this;
      },
      clone: function clone() {
        return new Color(this.r, this.g, this.b, this.a);
      },
      gray: function gray(shade) {
        return this.setTo(shade, shade, shade);
      },
      random: function random(b, max) {
        void 0 === b && (b = 0), void 0 === max && (max = 255);
        var r = Math.floor(b + Math.random() * (max - b)),
            g = Math.floor(b + Math.random() * (max - b)),
            b = Math.floor(b + Math.random() * (max - b));
        return this.setTo(r, g, b);
      },
      randomGray: function randomGray(s, max) {
        void 0 === s && (s = 0), void 0 === max && (max = 255);
        s = Math.floor(s + Math.random() * (max - s));
        return this.setTo(s, s, s);
      },
      saturate: function saturate(amount) {
        return this.s += amount / 100, this;
      },
      desaturate: function desaturate(amount) {
        return this.s -= amount / 100, this;
      },
      lighten: function lighten(amount) {
        return this.v += amount / 100, this;
      },
      darken: function darken(amount) {
        return this.v -= amount / 100, this;
      },
      brighten: function brighten(amount) {
        var r = this.r,
            g = this.g,
            b = this.b,
            r = Math.max(0, Math.min(255, r - Math.round(-amount / 100 * 255))),
            g = Math.max(0, Math.min(255, g - Math.round(-amount / 100 * 255))),
            b = Math.max(0, Math.min(255, b - Math.round(-amount / 100 * 255)));
        return this.setTo(r, g, b);
      },
      color: {
        get: function get() {
          return this._color;
        }
      },
      color32: {
        get: function get() {
          return this._color32;
        }
      },
      rgba: {
        get: function get() {
          return this._rgba;
        }
      },
      redGL: {
        get: function get() {
          return this.gl[0];
        },
        set: function set(value) {
          this.gl[0] = Math.min(Math.abs(value), 1), this.r = Math.floor(255 * this.gl[0]), this.update(!0);
        }
      },
      greenGL: {
        get: function get() {
          return this.gl[1];
        },
        set: function set(value) {
          this.gl[1] = Math.min(Math.abs(value), 1), this.g = Math.floor(255 * this.gl[1]), this.update(!0);
        }
      },
      blueGL: {
        get: function get() {
          return this.gl[2];
        },
        set: function set(value) {
          this.gl[2] = Math.min(Math.abs(value), 1), this.b = Math.floor(255 * this.gl[2]), this.update(!0);
        }
      },
      alphaGL: {
        get: function get() {
          return this.gl[3];
        },
        set: function set(value) {
          this.gl[3] = Math.min(Math.abs(value), 1), this.a = Math.floor(255 * this.gl[3]), this.update();
        }
      },
      red: {
        get: function get() {
          return this.r;
        },
        set: function set(value) {
          value = Math.floor(Math.abs(value)), this.r = Math.min(value, 255), this.gl[0] = value / 255, this.update(!0);
        }
      },
      green: {
        get: function get() {
          return this.g;
        },
        set: function set(value) {
          value = Math.floor(Math.abs(value)), this.g = Math.min(value, 255), this.gl[1] = value / 255, this.update(!0);
        }
      },
      blue: {
        get: function get() {
          return this.b;
        },
        set: function set(value) {
          value = Math.floor(Math.abs(value)), this.b = Math.min(value, 255), this.gl[2] = value / 255, this.update(!0);
        }
      },
      alpha: {
        get: function get() {
          return this.a;
        },
        set: function set(value) {
          value = Math.floor(Math.abs(value)), this.a = Math.min(value, 255), this.gl[3] = value / 255, this.update();
        }
      },
      h: {
        get: function get() {
          return this._h;
        },
        set: function set(value) {
          this._h = value, HSVToRGB(value, this._s, this._v, this);
        }
      },
      s: {
        get: function get() {
          return this._s;
        },
        set: function set(value) {
          this._s = value, HSVToRGB(this._h, value, this._v, this);
        }
      },
      v: {
        get: function get() {
          return this._v;
        },
        set: function set(value) {
          this._v = value, HSVToRGB(this._h, this._s, value, this);
        }
      }
    });

    module.exports = Color;
  }, function (module, exports, __webpack_require__) {
    var Vector3 = new (__webpack_require__(0))({
      initialize: function initialize(x, y, z) {
        this.x = 0, this.y = 0, this.z = 0, "object" == _typeof(x) ? (this.x = x.x || 0, this.y = x.y || 0, this.z = x.z || 0) : (this.x = x || 0, this.y = y || 0, this.z = z || 0);
      },
      up: function up() {
        return this.x = 0, this.y = 1, this.z = 0, this;
      },
      min: function min(v) {
        return this.x = Math.min(this.x, v.x), this.y = Math.min(this.y, v.y), this.z = Math.min(this.z, v.z), this;
      },
      max: function max(v) {
        return this.x = Math.max(this.x, v.x), this.y = Math.max(this.y, v.y), this.z = Math.max(this.z, v.z), this;
      },
      clone: function clone() {
        return new Vector3(this.x, this.y, this.z);
      },
      addVectors: function addVectors(a, b) {
        return this.x = a.x + b.x, this.y = a.y + b.y, this.z = a.z + b.z, this;
      },
      crossVectors: function crossVectors(by, bz) {
        var ax = by.x,
            ay = by.y,
            az = by.z,
            bx = bz.x,
            by = bz.y,
            bz = bz.z;
        return this.x = ay * bz - az * by, this.y = az * bx - ax * bz, this.z = ax * by - ay * bx, this;
      },
      equals: function equals(v) {
        return this.x === v.x && this.y === v.y && this.z === v.z;
      },
      copy: function copy(src) {
        return this.x = src.x, this.y = src.y, this.z = src.z || 0, this;
      },
      set: function set(x, y, z) {
        return "object" == _typeof(x) ? (this.x = x.x || 0, this.y = x.y || 0, this.z = x.z || 0) : (this.x = x || 0, this.y = y || 0, this.z = z || 0), this;
      },
      setFromMatrixPosition: function setFromMatrixPosition(m) {
        return this.fromArray(m.val, 12);
      },
      setFromMatrixColumn: function setFromMatrixColumn(mat4, index) {
        return this.fromArray(mat4.val, 4 * index);
      },
      fromArray: function fromArray(array, offset) {
        return this.x = array[offset = void 0 === offset ? 0 : offset], this.y = array[offset + 1], this.z = array[offset + 2], this;
      },
      add: function add(v) {
        return this.x += v.x, this.y += v.y, this.z += v.z || 0, this;
      },
      addScalar: function addScalar(s) {
        return this.x += s, this.y += s, this.z += s, this;
      },
      addScale: function addScale(v, scale) {
        return this.x += v.x * scale, this.y += v.y * scale, this.z += v.z * scale || 0, this;
      },
      subtract: function subtract(v) {
        return this.x -= v.x, this.y -= v.y, this.z -= v.z || 0, this;
      },
      multiply: function multiply(v) {
        return this.x *= v.x, this.y *= v.y, this.z *= v.z || 1, this;
      },
      scale: function scale(_scale) {
        return isFinite(_scale) ? (this.x *= _scale, this.y *= _scale, this.z *= _scale) : (this.x = 0, this.y = 0, this.z = 0), this;
      },
      divide: function divide(v) {
        return this.x /= v.x, this.y /= v.y, this.z /= v.z || 1, this;
      },
      negate: function negate() {
        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
      },
      distance: function distance(dz) {
        var dx = dz.x - this.x,
            dy = dz.y - this.y,
            dz = dz.z - this.z || 0;
        return Math.sqrt(dx * dx + dy * dy + dz * dz);
      },
      distanceSq: function distanceSq(dz) {
        var dx = dz.x - this.x,
            dy = dz.y - this.y,
            dz = dz.z - this.z || 0;
        return dx * dx + dy * dy + dz * dz;
      },
      length: function length() {
        var x = this.x,
            y = this.y,
            z = this.z;
        return Math.sqrt(x * x + y * y + z * z);
      },
      lengthSq: function lengthSq() {
        var x = this.x,
            y = this.y,
            z = this.z;
        return x * x + y * y + z * z;
      },
      normalize: function normalize() {
        var x = this.x,
            y = this.y,
            z = this.z,
            len = x * x + y * y + z * z;
        return 0 < len && (len = 1 / Math.sqrt(len), this.x = x * len, this.y = y * len, this.z = z * len), this;
      },
      dot: function dot(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z;
      },
      cross: function cross(bz) {
        var ax = this.x,
            ay = this.y,
            az = this.z,
            bx = bz.x,
            by = bz.y,
            bz = bz.z;
        return this.x = ay * bz - az * by, this.y = az * bx - ax * bz, this.z = ax * by - ay * bx, this;
      },
      lerp: function lerp(v, t) {
        var ax = this.x,
            ay = this.y,
            az = this.z;
        return this.x = ax + (t = void 0 === t ? 0 : t) * (v.x - ax), this.y = ay + t * (v.y - ay), this.z = az + t * (v.z - az), this;
      },
      applyMatrix3: function applyMatrix3(m) {
        var x = this.x,
            y = this.y,
            z = this.z,
            m = m.val;
        return this.x = m[0] * x + m[3] * y + m[6] * z, this.y = m[1] * x + m[4] * y + m[7] * z, this.z = m[2] * x + m[5] * y + m[8] * z, this;
      },
      applyMatrix4: function applyMatrix4(w) {
        var x = this.x,
            y = this.y,
            z = this.z,
            m = w.val,
            w = 1 / (m[3] * x + m[7] * y + m[11] * z + m[15]);
        return this.x = (m[0] * x + m[4] * y + m[8] * z + m[12]) * w, this.y = (m[1] * x + m[5] * y + m[9] * z + m[13]) * w, this.z = (m[2] * x + m[6] * y + m[10] * z + m[14]) * w, this;
      },
      transformMat3: function transformMat3(m) {
        var x = this.x,
            y = this.y,
            z = this.z,
            m = m.val;
        return this.x = x * m[0] + y * m[3] + z * m[6], this.y = x * m[1] + y * m[4] + z * m[7], this.z = x * m[2] + y * m[5] + z * m[8], this;
      },
      transformMat4: function transformMat4(m) {
        var x = this.x,
            y = this.y,
            z = this.z,
            m = m.val;
        return this.x = m[0] * x + m[4] * y + m[8] * z + m[12], this.y = m[1] * x + m[5] * y + m[9] * z + m[13], this.z = m[2] * x + m[6] * y + m[10] * z + m[14], this;
      },
      transformCoordinates: function transformCoordinates(tz) {
        var x = this.x,
            y = this.y,
            z = this.z,
            tw = tz.val,
            tx = x * tw[0] + y * tw[4] + z * tw[8] + tw[12],
            ty = x * tw[1] + y * tw[5] + z * tw[9] + tw[13],
            tz = x * tw[2] + y * tw[6] + z * tw[10] + tw[14],
            tw = x * tw[3] + y * tw[7] + z * tw[11] + tw[15];
        return this.x = tx / tw, this.y = ty / tw, this.z = tz / tw, this;
      },
      transformQuat: function transformQuat(iz) {
        var x = this.x,
            y = this.y,
            iw = this.z,
            qx = iz.x,
            qy = iz.y,
            qz = iz.z,
            qw = iz.w,
            ix = qw * x + qy * iw - qz * y,
            iy = qw * y + qz * x - qx * iw,
            iz = qw * iw + qx * y - qy * x,
            iw = -qx * x - qy * y - qz * iw;
        return this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy, this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz, this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx, this;
      },
      project: function project(a32) {
        var x = this.x,
            y = this.y,
            z = this.z,
            lw = a32.val,
            a00 = lw[0],
            a01 = lw[1],
            a02 = lw[2],
            a03 = lw[3],
            a10 = lw[4],
            a11 = lw[5],
            a12 = lw[6],
            a13 = lw[7],
            a20 = lw[8],
            a21 = lw[9],
            a22 = lw[10],
            a23 = lw[11],
            a30 = lw[12],
            a31 = lw[13],
            a32 = lw[14],
            lw = 1 / (x * a03 + y * a13 + z * a23 + lw[15]);
        return this.x = (x * a00 + y * a10 + z * a20 + a30) * lw, this.y = (x * a01 + y * a11 + z * a21 + a31) * lw, this.z = (x * a02 + y * a12 + z * a22 + a32) * lw, this;
      },
      projectViewMatrix: function projectViewMatrix(viewMatrix, projectionMatrix) {
        return this.applyMatrix4(viewMatrix).applyMatrix4(projectionMatrix);
      },
      unprojectViewMatrix: function unprojectViewMatrix(projectionMatrix, worldMatrix) {
        return this.applyMatrix4(projectionMatrix).applyMatrix4(worldMatrix);
      },
      unproject: function unproject(x, invProjectionView) {
        var y = x.x,
            z = x.y,
            viewWidth = x.z,
            viewHeight = x.w,
            x = this.x - y,
            y = viewHeight - this.y - 1 - z,
            z = this.z;
        return this.x = 2 * x / viewWidth - 1, this.y = 2 * y / viewHeight - 1, this.z = 2 * z - 1, this.project(invProjectionView);
      },
      reset: function reset() {
        return this.x = 0, this.y = 0, this.z = 0, this;
      }
    });
    Vector3.ZERO = new Vector3(), Vector3.RIGHT = new Vector3(1, 0, 0), Vector3.LEFT = new Vector3(-1, 0, 0), Vector3.UP = new Vector3(0, -1, 0), Vector3.DOWN = new Vector3(0, 1, 0), Vector3.FORWARD = new Vector3(0, 0, 1), Vector3.BACK = new Vector3(0, 0, -1), Vector3.ONE = new Vector3(1, 1, 1), module.exports = Vector3;
  }, function (module, exports) {
    module.exports = {
      CSV: 0,
      TILED_JSON: 1,
      ARRAY_2D: 2,
      WELTMEISTER: 3
    };
  }, function (module, exports, __webpack_require__) {
    var Body = {};
    module.exports = Body;

    var Vertices = __webpack_require__(64),
        Vector = __webpack_require__(83),
        Sleeping = __webpack_require__(165),
        Common = __webpack_require__(32),
        Bounds = __webpack_require__(84),
        Axes = __webpack_require__(271);

    !function () {
      Body._inertiaScale = 4, Body._nextCollidingGroupId = 1, Body._nextNonCollidingGroupId = -1, Body._nextCategory = 1, Body.create = function (options) {
        var body = {
          id: Common.nextId(),
          type: "body",
          label: "Body",
          parts: [],
          plugin: {},
          angle: 0,
          vertices: null,
          position: {
            x: 0,
            y: 0
          },
          force: {
            x: 0,
            y: 0
          },
          torque: 0,
          positionImpulse: {
            x: 0,
            y: 0
          },
          previousPositionImpulse: {
            x: 0,
            y: 0
          },
          constraintImpulse: {
            x: 0,
            y: 0,
            angle: 0
          },
          totalContacts: 0,
          speed: 0,
          angularSpeed: 0,
          velocity: {
            x: 0,
            y: 0
          },
          angularVelocity: 0,
          isSensor: !1,
          isStatic: !1,
          isSleeping: !1,
          motion: 0,
          sleepThreshold: 60,
          density: .001,
          restitution: 0,
          friction: .1,
          frictionStatic: .5,
          frictionAir: .01,
          collisionFilter: {
            category: 1,
            mask: 4294967295,
            group: 0
          },
          slop: .05,
          timeScale: 1,
          events: null,
          bounds: null,
          chamfer: null,
          circleRadius: 0,
          positionPrev: null,
          anglePrev: 0,
          parent: null,
          axes: null,
          area: 0,
          mass: 0,
          inverseMass: 0,
          inertia: 0,
          inverseInertia: 0,
          _original: null,
          render: {
            visible: !0,
            opacity: 1,
            sprite: {
              xOffset: 0,
              yOffset: 0
            },
            fillColor: null,
            fillOpacity: null,
            lineColor: null,
            lineOpacity: null,
            lineThickness: null
          },
          gameObject: null,
          scale: {
            x: 1,
            y: 1
          },
          centerOfMass: {
            x: 0,
            y: 0
          },
          centerOffset: {
            x: 0,
            y: 0
          },
          gravityScale: {
            x: 1,
            y: 1
          },
          ignoreGravity: !1,
          ignorePointer: !1,
          onCollideCallback: null,
          onCollideEndCallback: null,
          onCollideActiveCallback: null,
          onCollideWith: {}
        };
        !options.hasOwnProperty("position") && options.hasOwnProperty("vertices") ? options.position = Vertices.centre(options.vertices) : options.hasOwnProperty("vertices") || (body.vertices = Vertices.fromPath("L 0 0 L 40 0 L 40 40 L 0 40"));
        body = Common.extend(body, options);
        return _initProperties(body, options), body.setOnCollideWith = function (body, callback) {
          return callback ? this.onCollideWith[body.id] = callback : delete this.onCollideWith[body.id], this;
        }, body;
      }, Body.nextGroup = function (isNonColliding) {
        return isNonColliding ? Body._nextNonCollidingGroupId-- : Body._nextCollidingGroupId++;
      }, Body.nextCategory = function () {
        return Body._nextCategory = Body._nextCategory << 1, Body._nextCategory;
      };

      var _initProperties = function _initProperties(body, bodyHeight) {
        bodyHeight = bodyHeight || {}, Body.set(body, {
          bounds: body.bounds || Bounds.create(body.vertices),
          positionPrev: body.positionPrev || Vector.clone(body.position),
          anglePrev: body.anglePrev || body.angle,
          vertices: body.vertices,
          parts: body.parts || [body],
          isStatic: body.isStatic,
          isSleeping: body.isSleeping,
          parent: body.parent || body
        });
        var centerOfMass,
            centerOffset,
            bodyWidth,
            bounds = body.bounds;
        Vertices.rotate(body.vertices, body.angle, body.position), Axes.rotate(body.axes, body.angle), Bounds.update(bounds, body.vertices, body.velocity), Body.set(body, {
          axes: bodyHeight.axes || body.axes,
          area: bodyHeight.area || body.area,
          mass: bodyHeight.mass || body.mass,
          inertia: bodyHeight.inertia || body.inertia
        }), 1 === body.parts.length && (centerOfMass = body.centerOfMass, centerOffset = body.centerOffset, bodyWidth = bounds.max.x - bounds.min.x, bodyHeight = bounds.max.y - bounds.min.y, centerOfMass.x = -(bounds.min.x - body.position.x) / bodyWidth, centerOfMass.y = -(bounds.min.y - body.position.y) / bodyHeight, centerOffset.x = bodyWidth * centerOfMass.x, centerOffset.y = bodyHeight * centerOfMass.y);
      };

      Body.set = function (body, settings, value) {
        for (var property in "string" == typeof settings && (property = settings, (settings = {})[property] = value), settings) {
          if (Object.prototype.hasOwnProperty.call(settings, property)) switch (value = settings[property], property) {
            case "isStatic":
              Body.setStatic(body, value);
              break;

            case "isSleeping":
              Sleeping.set(body, value);
              break;

            case "mass":
              Body.setMass(body, value);
              break;

            case "density":
              Body.setDensity(body, value);
              break;

            case "inertia":
              Body.setInertia(body, value);
              break;

            case "vertices":
              Body.setVertices(body, value);
              break;

            case "position":
              Body.setPosition(body, value);
              break;

            case "angle":
              Body.setAngle(body, value);
              break;

            case "velocity":
              Body.setVelocity(body, value);
              break;

            case "angularVelocity":
              Body.setAngularVelocity(body, value);
              break;

            case "parts":
              Body.setParts(body, value);
              break;

            case "centre":
              Body.setCentre(body, value);
              break;

            default:
              body[property] = value;
          }
        }
      }, Body.setStatic = function (body, isStatic) {
        for (var i = 0; i < body.parts.length; i++) {
          var part = body.parts[i];
          (part.isStatic = isStatic) ? (part._original = {
            restitution: part.restitution,
            friction: part.friction,
            mass: part.mass,
            inertia: part.inertia,
            density: part.density,
            inverseMass: part.inverseMass,
            inverseInertia: part.inverseInertia
          }, part.restitution = 0, part.friction = 1, part.mass = part.inertia = part.density = 1 / 0, part.inverseMass = part.inverseInertia = 0, part.positionPrev.x = part.position.x, part.positionPrev.y = part.position.y, part.anglePrev = part.angle, part.angularVelocity = 0, part.speed = 0, part.angularSpeed = 0, part.motion = 0) : part._original && (part.restitution = part._original.restitution, part.friction = part._original.friction, part.mass = part._original.mass, part.inertia = part._original.inertia, part.density = part._original.density, part.inverseMass = part._original.inverseMass, part.inverseInertia = part._original.inverseInertia, part._original = null);
        }
      }, Body.setMass = function (body, mass) {
        var moment = body.inertia / (body.mass / 6);
        body.inertia = mass / 6 * moment, body.inverseInertia = 1 / body.inertia, body.mass = mass, body.inverseMass = 1 / body.mass, body.density = body.mass / body.area;
      }, Body.setDensity = function (body, density) {
        Body.setMass(body, density * body.area), body.density = density;
      }, Body.setInertia = function (body, inertia) {
        body.inertia = inertia, body.inverseInertia = 1 / body.inertia;
      }, Body.setVertices = function (body, centre) {
        centre[0].body === body ? body.vertices = centre : body.vertices = Vertices.create(centre, body), body.axes = Axes.fromVertices(body.vertices), body.area = Vertices.area(body.vertices), Body.setMass(body, body.density * body.area);
        centre = Vertices.centre(body.vertices);
        Vertices.translate(body.vertices, centre, -1), Body.setInertia(body, Body._inertiaScale * Vertices.inertia(body.vertices, body.mass)), Vertices.translate(body.vertices, body.position), Bounds.update(body.bounds, body.vertices, body.velocity);
      }, Body.setParts = function (body, parts, bounds) {
        for (parts = parts.slice(0), body.parts.length = 0, body.parts.push(body), body.parent = body, i = 0; i < parts.length; i++) {
          var part = parts[i];
          part !== body && (part.parent = body).parts.push(part);
        }

        if (1 !== body.parts.length) {
          if (bounds = void 0 === bounds || bounds) {
            for (var vertices = [], i = 0; i < parts.length; i++) {
              vertices = vertices.concat(parts[i].vertices);
            }

            Vertices.clockwiseSort(vertices);
            var centerOfMass = Vertices.hull(vertices),
                centerOffset = Vertices.centre(centerOfMass);
            Body.setVertices(body, centerOfMass), Vertices.translate(body.vertices, centerOffset);
          }

          var total = Body._totalProperties(body),
              cx = total.centre.x,
              cy = total.centre.y,
              bounds = body.bounds,
              centerOfMass = body.centerOfMass,
              centerOffset = body.centerOffset;

          Bounds.update(bounds, body.vertices, body.velocity), centerOfMass.x = -(bounds.min.x - cx) / (bounds.max.x - bounds.min.x), centerOfMass.y = -(bounds.min.y - cy) / (bounds.max.y - bounds.min.y), centerOffset.x = cx, centerOffset.y = cy, body.area = total.area, (body.parent = body).position.x = cx, body.position.y = cy, body.positionPrev.x = cx, body.positionPrev.y = cy, Body.setMass(body, total.mass), Body.setInertia(body, total.inertia), Body.setPosition(body, total.centre);
        }
      }, Body.setCentre = function (body, centre, relative) {
        relative ? (body.positionPrev.x += centre.x, body.positionPrev.y += centre.y, body.position.x += centre.x, body.position.y += centre.y) : (body.positionPrev.x = centre.x - (body.position.x - body.positionPrev.x), body.positionPrev.y = centre.y - (body.position.y - body.positionPrev.y), body.position.x = centre.x, body.position.y = centre.y);
      }, Body.setPosition = function (body, position) {
        var delta = Vector.sub(position, body.position);
        body.positionPrev.x += delta.x, body.positionPrev.y += delta.y;

        for (var i = 0; i < body.parts.length; i++) {
          var part = body.parts[i];
          part.position.x += delta.x, part.position.y += delta.y, Vertices.translate(part.vertices, delta), Bounds.update(part.bounds, part.vertices, body.velocity);
        }
      }, Body.setAngle = function (body, angle) {
        var delta = angle - body.angle;
        body.anglePrev += delta;

        for (var i = 0; i < body.parts.length; i++) {
          var part = body.parts[i];
          part.angle += delta, Vertices.rotate(part.vertices, delta, body.position), Axes.rotate(part.axes, delta), Bounds.update(part.bounds, part.vertices, body.velocity), 0 < i && Vector.rotateAbout(part.position, delta, body.position, part.position);
        }
      }, Body.setVelocity = function (body, velocity) {
        body.positionPrev.x = body.position.x - velocity.x, body.positionPrev.y = body.position.y - velocity.y, body.velocity.x = velocity.x, body.velocity.y = velocity.y, body.speed = Vector.magnitude(body.velocity);
      }, Body.setAngularVelocity = function (body, velocity) {
        body.anglePrev = body.angle - velocity, body.angularVelocity = velocity, body.angularSpeed = Math.abs(body.angularVelocity);
      }, Body.translate = function (body, translation) {
        Body.setPosition(body, Vector.add(body.position, translation));
      }, Body.rotate = function (body, rotation, point) {
        var cos, sin, dx, dy;
        point && (cos = Math.cos(rotation), sin = Math.sin(rotation), dx = body.position.x - point.x, dy = body.position.y - point.y, Body.setPosition(body, {
          x: point.x + (dx * cos - dy * sin),
          y: point.y + (dx * sin + dy * cos)
        })), Body.setAngle(body, body.angle + rotation);
      }, Body.scale = function (body, scaleX, scaleY, point) {
        var totalArea = 0,
            totalInertia = 0;
        point = point || body.position;

        for (var i = 0; i < body.parts.length; i++) {
          var part = body.parts[i];
          part.scale.x = scaleX, part.scale.y = scaleY, Vertices.scale(part.vertices, scaleX, scaleY, point), part.axes = Axes.fromVertices(part.vertices), part.area = Vertices.area(part.vertices), Body.setMass(part, body.density * part.area), Vertices.translate(part.vertices, {
            x: -part.position.x,
            y: -part.position.y
          }), Body.setInertia(part, Body._inertiaScale * Vertices.inertia(part.vertices, part.mass)), Vertices.translate(part.vertices, {
            x: part.position.x,
            y: part.position.y
          }), 0 < i && (totalArea += part.area, totalInertia += part.inertia), part.position.x = point.x + (part.position.x - point.x) * scaleX, part.position.y = point.y + (part.position.y - point.y) * scaleY, Bounds.update(part.bounds, part.vertices, body.velocity);
        }

        1 < body.parts.length && (body.area = totalArea, body.isStatic || (Body.setMass(body, body.density * totalArea), Body.setInertia(body, totalInertia))), body.circleRadius && (scaleX === scaleY ? body.circleRadius *= scaleX : body.circleRadius = null);
      }, Body.update = function (body, velocityPrevX, velocityPrevY, correction) {
        var deltaTimeSquared = Math.pow(velocityPrevX * velocityPrevY * body.timeScale, 2),
            frictionAir = 1 - body.frictionAir * velocityPrevY * body.timeScale,
            velocityPrevX = body.position.x - body.positionPrev.x,
            velocityPrevY = body.position.y - body.positionPrev.y;
        body.velocity.x = velocityPrevX * frictionAir * correction + body.force.x / body.mass * deltaTimeSquared, body.velocity.y = velocityPrevY * frictionAir * correction + body.force.y / body.mass * deltaTimeSquared, body.positionPrev.x = body.position.x, body.positionPrev.y = body.position.y, body.position.x += body.velocity.x, body.position.y += body.velocity.y, body.angularVelocity = (body.angle - body.anglePrev) * frictionAir * correction + body.torque / body.inertia * deltaTimeSquared, body.anglePrev = body.angle, body.angle += body.angularVelocity, body.speed = Vector.magnitude(body.velocity), body.angularSpeed = Math.abs(body.angularVelocity);

        for (var i = 0; i < body.parts.length; i++) {
          var part = body.parts[i];
          Vertices.translate(part.vertices, body.velocity), 0 < i && (part.position.x += body.velocity.x, part.position.y += body.velocity.y), 0 !== body.angularVelocity && (Vertices.rotate(part.vertices, body.angularVelocity, body.position), Axes.rotate(part.axes, body.angularVelocity), 0 < i && Vector.rotateAbout(part.position, body.angularVelocity, body.position, part.position)), Bounds.update(part.bounds, part.vertices, body.velocity);
        }
      }, Body.applyForce = function (body, offset_y, force) {
        body.force.x += force.x, body.force.y += force.y;
        var offset_x = offset_y.x - body.position.x,
            offset_y = offset_y.y - body.position.y;
        body.torque += offset_x * force.y - offset_y * force.x;
      }, Body._totalProperties = function (body) {
        for (var properties = {
          mass: 0,
          area: 0,
          inertia: 0,
          centre: {
            x: 0,
            y: 0
          }
        }, i = 1 === body.parts.length ? 0 : 1; i < body.parts.length; i++) {
          var part = body.parts[i],
              mass = part.mass !== 1 / 0 ? part.mass : 1;
          properties.mass += mass, properties.area += part.area, properties.inertia += part.inertia, properties.centre = Vector.add(properties.centre, Vector.mult(part.position, mass));
        }

        return properties.centre = Vector.div(properties.centre, properties.mass), properties;
      };
    }();
  }, function (module, exports) {
    module.exports = function (gameObject) {
      return gameObject.y + gameObject.height - gameObject.height * gameObject.originY;
    };
  }, function (module, exports) {
    module.exports = function (gameObject) {
      return gameObject.x - gameObject.width * gameObject.originX;
    };
  }, function (module, exports) {
    module.exports = function (gameObject) {
      return gameObject.x + gameObject.width - gameObject.width * gameObject.originX;
    };
  }, function (module, exports) {
    module.exports = function (gameObject) {
      return gameObject.y - gameObject.height * gameObject.originY;
    };
  }, function (module, exports) {
    module.exports = function (items, key, value, step, index, direction) {
      var i;
      void 0 === step && (step = 0), void 0 === index && (index = 0);
      var t = 0,
          end = items.length;
      if (1 === (direction = void 0 === direction ? 1 : direction)) for (i = index; i < end; i++) {
        items[i][key] += value + t * step, t++;
      } else for (i = index; 0 <= i; i--) {
        items[i][key] += value + t * step, t++;
      }
      return items;
    };
  }, function (module, exports, __webpack_require__) {
    var Line = __webpack_require__(0),
        GetPoint = __webpack_require__(307),
        GetPoints = __webpack_require__(172),
        GEOM_CONST = __webpack_require__(56),
        Random = __webpack_require__(173),
        Vector2 = __webpack_require__(3),
        Line = new Line({
      initialize: function initialize(x1, y1, x2, y2) {
        void 0 === x1 && (x1 = 0), void 0 === y1 && (y1 = 0), void 0 === x2 && (x2 = 0), void 0 === y2 && (y2 = 0), this.type = GEOM_CONST.LINE, this.x1 = x1, this.y1 = y1, this.x2 = x2, this.y2 = y2;
      },
      getPoint: function getPoint(position, output) {
        return GetPoint(this, position, output);
      },
      getPoints: function getPoints(quantity, stepRate, output) {
        return GetPoints(this, quantity, stepRate, output);
      },
      getRandomPoint: function getRandomPoint(point) {
        return Random(this, point);
      },
      setTo: function setTo(x1, y1, x2, y2) {
        return void 0 === y1 && (y1 = 0), void 0 === x2 && (x2 = 0), void 0 === y2 && (y2 = 0), this.x1 = x1 = void 0 === x1 ? 0 : x1, this.y1 = y1, this.x2 = x2, this.y2 = y2, this;
      },
      getPointA: function getPointA(vec2) {
        return (vec2 = void 0 === vec2 ? new Vector2() : vec2).set(this.x1, this.y1), vec2;
      },
      getPointB: function getPointB(vec2) {
        return (vec2 = void 0 === vec2 ? new Vector2() : vec2).set(this.x2, this.y2), vec2;
      },
      left: {
        get: function get() {
          return Math.min(this.x1, this.x2);
        },
        set: function set(value) {
          this.x1 <= this.x2 ? this.x1 = value : this.x2 = value;
        }
      },
      right: {
        get: function get() {
          return Math.max(this.x1, this.x2);
        },
        set: function set(value) {
          this.x1 > this.x2 ? this.x1 = value : this.x2 = value;
        }
      },
      top: {
        get: function get() {
          return Math.min(this.y1, this.y2);
        },
        set: function set(value) {
          this.y1 <= this.y2 ? this.y1 = value : this.y2 = value;
        }
      },
      bottom: {
        get: function get() {
          return Math.max(this.y1, this.y2);
        },
        set: function set(value) {
          this.y1 > this.y2 ? this.y1 = value : this.y2 = value;
        }
      }
    });

    module.exports = Line;
  }, function (module, exports) {
    module.exports = function (ctx, fillAlpha, fillColor, altAlpha) {
      fillColor = fillColor || fillAlpha.fillColor, fillAlpha = altAlpha || fillAlpha.fillAlpha;
      ctx.fillStyle = "rgba(" + ((16711680 & fillColor) >>> 16) + "," + ((65280 & fillColor) >>> 8) + "," + (255 & fillColor) + "," + fillAlpha + ")";
    };
  }, function (module, exports, MultiFile) {
    MultiFile = new (MultiFile(0))({
      initialize: function initialize(loader, type, key, files) {
        var finalFiles = [];
        files.forEach(function (file) {
          file && finalFiles.push(file);
        }), this.loader = loader, this.type = type, this.key = key, this.multiKeyIndex = loader.multiKeyIndex++, this.files = finalFiles, this.complete = !1, this.pending = finalFiles.length, this.failed = 0, this.config = {}, this.baseURL = loader.baseURL, this.path = loader.path, this.prefix = loader.prefix;

        for (var i = 0; i < finalFiles.length; i++) {
          finalFiles[i].multiFile = this;
        }
      },
      isReadyToProcess: function isReadyToProcess() {
        return 0 === this.pending && 0 === this.failed && !this.complete;
      },
      addToMultiFile: function addToMultiFile(file) {
        return this.files.push(file), (file.multiFile = this).pending++, this.complete = !1, this;
      },
      onFileComplete: function onFileComplete(file) {
        -1 !== this.files.indexOf(file) && this.pending--;
      },
      onFileFailed: function onFileFailed(file) {
        -1 !== this.files.indexOf(file) && this.failed++;
      }
    });
    module.exports = MultiFile;
  }, function (module, exports) {
    module.exports = function (x1, y1, dx, dy) {
      dx = x1 - dx, dy = y1 - dy;
      return Math.sqrt(dx * dx + dy * dy);
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      BOOT: __webpack_require__(922),
      DESTROY: __webpack_require__(923),
      DRAG_END: __webpack_require__(924),
      DRAG_ENTER: __webpack_require__(925),
      DRAG: __webpack_require__(926),
      DRAG_LEAVE: __webpack_require__(927),
      DRAG_OVER: __webpack_require__(928),
      DRAG_START: __webpack_require__(929),
      DROP: __webpack_require__(930),
      GAME_OUT: __webpack_require__(931),
      GAME_OVER: __webpack_require__(932),
      GAMEOBJECT_DOWN: __webpack_require__(933),
      GAMEOBJECT_DRAG_END: __webpack_require__(934),
      GAMEOBJECT_DRAG_ENTER: __webpack_require__(935),
      GAMEOBJECT_DRAG: __webpack_require__(936),
      GAMEOBJECT_DRAG_LEAVE: __webpack_require__(937),
      GAMEOBJECT_DRAG_OVER: __webpack_require__(938),
      GAMEOBJECT_DRAG_START: __webpack_require__(939),
      GAMEOBJECT_DROP: __webpack_require__(940),
      GAMEOBJECT_MOVE: __webpack_require__(941),
      GAMEOBJECT_OUT: __webpack_require__(942),
      GAMEOBJECT_OVER: __webpack_require__(943),
      GAMEOBJECT_POINTER_DOWN: __webpack_require__(944),
      GAMEOBJECT_POINTER_MOVE: __webpack_require__(945),
      GAMEOBJECT_POINTER_OUT: __webpack_require__(946),
      GAMEOBJECT_POINTER_OVER: __webpack_require__(947),
      GAMEOBJECT_POINTER_UP: __webpack_require__(948),
      GAMEOBJECT_POINTER_WHEEL: __webpack_require__(949),
      GAMEOBJECT_UP: __webpack_require__(950),
      GAMEOBJECT_WHEEL: __webpack_require__(951),
      MANAGER_BOOT: __webpack_require__(952),
      MANAGER_PROCESS: __webpack_require__(953),
      MANAGER_UPDATE: __webpack_require__(954),
      POINTER_DOWN: __webpack_require__(955),
      POINTER_DOWN_OUTSIDE: __webpack_require__(956),
      POINTER_MOVE: __webpack_require__(957),
      POINTER_OUT: __webpack_require__(958),
      POINTER_OVER: __webpack_require__(959),
      POINTER_UP: __webpack_require__(960),
      POINTER_UP_OUTSIDE: __webpack_require__(961),
      POINTER_WHEEL: __webpack_require__(962),
      POINTERLOCK_CHANGE: __webpack_require__(963),
      PRE_UPDATE: __webpack_require__(964),
      SHUTDOWN: __webpack_require__(965),
      START: __webpack_require__(966),
      UPDATE: __webpack_require__(967)
    };
  }, function (module, exports) {
    module.exports = function (gameObject, value) {
      return gameObject.y = value + gameObject.height * gameObject.originY, gameObject;
    };
  }, function (module, exports) {
    module.exports = function (gameObject, value) {
      return gameObject.x = value + gameObject.width * gameObject.originX, gameObject;
    };
  }, function (module, exports) {
    module.exports = function (gameObject, value) {
      return gameObject.x = value - gameObject.width + gameObject.width * gameObject.originX, gameObject;
    };
  }, function (module, exports) {
    module.exports = function (gameObject, value) {
      return gameObject.y = value - gameObject.height + gameObject.height * gameObject.originY, gameObject;
    };
  }, function (module, exports) {
    module.exports = {
      CIRCLE: 0,
      ELLIPSE: 1,
      LINE: 2,
      POINT: 3,
      POLYGON: 4,
      RECTANGLE: 5,
      TRIANGLE: 6
    };
  }, function (module, exports) {
    module.exports = function (rect, x, y) {
      return !(rect.width <= 0 || rect.height <= 0) && rect.x <= x && rect.x + rect.width >= x && rect.y <= y && rect.y + rect.height >= y;
    };
  }, function (module, exports, __webpack_require__) {
    var WebGLPipeline = __webpack_require__(0),
        DeepCopy = __webpack_require__(175),
        EventEmitter = __webpack_require__(9),
        Events = __webpack_require__(374),
        GetFastValue = __webpack_require__(2),
        Matrix4 = __webpack_require__(69),
        RendererEvents = __webpack_require__(91),
        RenderTarget = __webpack_require__(141),
        Utils = __webpack_require__(12),
        WebGLShader = __webpack_require__(375),
        WebGLPipeline = new WebGLPipeline({
      Extends: EventEmitter,
      initialize: function initialize(config) {
        EventEmitter.call(this);
        var game = config.game,
            renderer = game.renderer,
            gl = renderer.gl;
        this.name = GetFastValue(config, "name", "WebGLPipeline"), this.game = game, this.renderer = renderer, this.manager, this.gl = gl, this.view = game.canvas, this.width = 0, this.height = 0, this.vertexCount = 0, this.vertexCapacity = 0, this.vertexData, this.vertexBuffer, this.topology = GetFastValue(config, "topology", gl.TRIANGLES), this.bytes, this.vertexViewF32, this.vertexViewU32, this.active = !0, this.currentUnit = 0, this.forceZero = GetFastValue(config, "forceZero", !1), this.hasBooted = !1, this.isPostFX = !1, this.renderTargets = [], this.currentRenderTarget, this.shaders = [], this.currentShader, this.projectionMatrix, this.projectionWidth = 0, this.projectionHeight = 0, this.config = config, this.glReset = !1;
      },
      boot: function boot() {
        var gl = this.gl,
            configVerts = this.config,
            renderer = this.renderer;
        this.isPostFX || (this.projectionMatrix = new Matrix4().identity());
        var renderTargets = this.renderTargets,
            targets = GetFastValue(configVerts, "renderTarget", !1),
            width = renderer.width,
            height = renderer.height;
        if ("number" == typeof (targets = "boolean" == typeof targets && targets ? 1 : targets)) for (i = 0; i < targets; i++) {
          renderTargets.push(new RenderTarget(renderer, width, height, 1, 0, !0));
        } else if (Array.isArray(targets)) for (i = 0; i < targets.length; i++) {
          var scale = GetFastValue(targets[i], "scale", 1),
              minFilter = GetFastValue(targets[i], "minFilter", 0),
              autoClear = GetFastValue(targets[i], "autoClear", 1);
          renderTargets.push(new RenderTarget(renderer, width, height, scale, minFilter, autoClear));
        }
        renderTargets.length && (this.currentRenderTarget = renderTargets[0]), this.setShadersFromConfig(configVerts);

        for (var shaders = this.shaders, vertexSize = 0, i = 0; i < shaders.length; i++) {
          shaders[i].vertexSize > vertexSize && (vertexSize = shaders[i].vertexSize);
        }

        var data = GetFastValue(configVerts, "batchSize", renderer.config.batchSize);
        this.vertexCapacity = 6 * data;
        data = new ArrayBuffer(this.vertexCapacity * vertexSize);
        this.vertexData = data, this.bytes = new Uint8Array(data), this.vertexViewF32 = new Float32Array(data), this.vertexViewU32 = new Uint32Array(data);
        configVerts = GetFastValue(configVerts, "vertices", null);

        for (configVerts ? (this.vertexViewF32.set(configVerts), this.vertexBuffer = renderer.createVertexBuffer(data, gl.STATIC_DRAW)) : this.vertexBuffer = renderer.createVertexBuffer(data.byteLength, gl.DYNAMIC_DRAW), this.setVertexBuffer(), i = shaders.length - 1; 0 <= i; i--) {
          shaders[i].rebind();
        }

        this.hasBooted = !0, renderer.on(RendererEvents.RESIZE, this.resize, this), renderer.on(RendererEvents.PRE_RENDER, this.onPreRender, this), renderer.on(RendererEvents.RENDER, this.onRender, this), renderer.on(RendererEvents.POST_RENDER, this.onPostRender, this), this.emit(Events.BOOT, this), this.onBoot();
      },
      onBoot: function onBoot() {},
      onResize: function onResize() {},
      setShader: function setShader(shader, setAttributes) {
        var wasBound = this.renderer;
        return shader === this.currentShader && wasBound.currentProgram === this.currentShader.program || (this.flush(), wasBound.resetTextures(), wasBound = this.setVertexBuffer(), shader.bind(setAttributes = wasBound && !setAttributes ? !0 : setAttributes, !1), this.currentShader = shader), this;
      },
      getShaderByName: function getShaderByName(name) {
        for (var shaders = this.shaders, i = 0; i < shaders.length; i++) {
          if (shaders[i].name === name) return shaders[i];
        }
      },
      setShadersFromConfig: function setShadersFromConfig(config) {
        var shaders = this.shaders,
            renderer = this.renderer;

        for (i = 0; i < shaders.length; i++) {
          shaders[i].destroy();
        }

        var defaultVertShader = GetFastValue(config, "vertShader", null),
            defaultFragShader = Utils.parseFragmentShaderMaxTextures(GetFastValue(config, "fragShader", null), renderer.maxTextures),
            defaultAttribs = GetFastValue(config, "attributes", null),
            configShaders = GetFastValue(config, "shaders", []),
            len = configShaders.length;
        if (0 === len) defaultVertShader && defaultFragShader && (this.shaders = [new WebGLShader(this, "default", defaultVertShader, defaultFragShader, DeepCopy(defaultAttribs))]);else {
          for (var newShaders = [], i = 0; i < len; i++) {
            var attributes = configShaders[i],
                name = GetFastValue(attributes, "name", "default"),
                vertShader = GetFastValue(attributes, "vertShader", defaultVertShader),
                fragShader = Utils.parseFragmentShaderMaxTextures(GetFastValue(attributes, "fragShader", defaultFragShader), renderer.maxTextures),
                attributes = GetFastValue(attributes, "attributes", defaultAttribs);
            vertShader && fragShader && newShaders.push(new WebGLShader(this, name, vertShader, fragShader, DeepCopy(attributes)));
          }

          this.shaders = newShaders;
        }
        return 0 === this.shaders.length ? console.warn("Pipeline: " + this.name + " - Invalid shader config") : this.currentShader = this.shaders[0], this;
      },
      setGameObject: function setGameObject(gameObject, frame) {
        return void 0 === frame && (frame = gameObject.frame), this.currentUnit = this.renderer.setTextureSource(frame.source), this.currentUnit;
      },
      shouldFlush: function shouldFlush(amount) {
        return this.vertexCount + (amount = void 0 === amount ? 0 : amount) > this.vertexCapacity;
      },
      resize: function resize(width, height) {
        width === this.width && height === this.height || this.flush(), this.width = width, this.height = height;

        for (var targets = this.renderTargets, i = 0; i < targets.length; i++) {
          targets[i].resize(width, height);
        }

        return this.setProjectionMatrix(width, height), this.emit(Events.RESIZE, width, height, this), this.onResize(width, height), this;
      },
      setProjectionMatrix: function setProjectionMatrix(width, height) {
        var projectionMatrix = this.projectionMatrix;
        if (!projectionMatrix) return this;
        this.projectionWidth = width, this.projectionHeight = height, projectionMatrix.ortho(0, width, height, 0, -1e3, 1e3);

        for (var shaders = this.shaders, name = "uProjectionMatrix", i = 0; i < shaders.length; i++) {
          var shader = shaders[i];
          shader.hasUniform(name) && (shader.resetUniform(name), shader.setMatrix4fv(name, !1, projectionMatrix.val, shader));
        }

        return this;
      },
      updateProjectionMatrix: function updateProjectionMatrix() {
        var globalWidth, globalHeight;
        this.projectionMatrix && (globalWidth = this.renderer.projectionWidth, globalHeight = this.renderer.projectionHeight, this.projectionWidth === globalWidth && this.projectionHeight === globalHeight || this.setProjectionMatrix(globalWidth, globalHeight));
      },
      bind: function bind(currentShader) {
        if (void 0 === currentShader && (currentShader = this.currentShader), this.glReset) return this.rebind(currentShader);
        var wasBound = this.setVertexBuffer();
        return currentShader.bind(wasBound), this.currentShader = currentShader, this.emit(Events.BIND, this, currentShader), this.onActive(currentShader), this;
      },
      rebind: function rebind(currentShader) {
        this.setVertexBuffer();

        for (var shaders = this.shaders, i = shaders.length - 1; 0 <= i; i--) {
          var shader = shaders[i].rebind();
          currentShader && shader !== currentShader || (this.currentShader = shader);
        }

        return this.emit(Events.REBIND, this.currentShader), this.onActive(this.currentShader), this.onRebind(), this.glReset = !1, this;
      },
      setVertexBuffer: function setVertexBuffer() {
        var gl = this.gl,
            buffer = this.vertexBuffer;
        return gl.getParameter(gl.ARRAY_BUFFER_BINDING) !== buffer && (gl.bindBuffer(gl.ARRAY_BUFFER, buffer), !0);
      },
      preBatch: function preBatch(gameObject) {
        return this.currentRenderTarget && this.currentRenderTarget.bind(), this.onPreBatch(gameObject), this;
      },
      postBatch: function postBatch(gameObject) {
        return this.onDraw(this.currentRenderTarget), this.onPostBatch(gameObject), this;
      },
      onDraw: function onDraw() {},
      unbind: function unbind() {
        this.currentRenderTarget && this.currentRenderTarget.unbind();
      },
      flush: function flush(isPostFlush) {
        var gl, vertexCount, vertexSize;
        return void 0 === isPostFlush && (isPostFlush = !1), 0 < this.vertexCount && (this.emit(Events.BEFORE_FLUSH, this, isPostFlush), this.onBeforeFlush(isPostFlush), gl = this.gl, vertexCount = this.vertexCount, vertexSize = this.currentShader.vertexSize, this.active && (this.setVertexBuffer(), vertexCount === this.vertexCapacity ? gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.DYNAMIC_DRAW) : gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.bytes.subarray(0, vertexCount * vertexSize)), gl.drawArrays(this.topology, 0, vertexCount)), this.vertexCount = 0, this.emit(Events.AFTER_FLUSH, this, isPostFlush), this.onAfterFlush(isPostFlush)), this;
      },
      onActive: function onActive() {},
      onBind: function onBind() {},
      onRebind: function onRebind() {},
      onBatch: function onBatch() {},
      onPreBatch: function onPreBatch() {},
      onPostBatch: function onPostBatch() {},
      onPreRender: function onPreRender() {},
      onRender: function onRender() {},
      onPostRender: function onPostRender() {},
      onBeforeFlush: function onBeforeFlush() {},
      onAfterFlush: function onAfterFlush() {},
      batchVert: function batchVert(x, y, u, v, unit, tintEffect, tint) {
        var vertexViewF32 = this.vertexViewF32,
            vertexViewU32 = this.vertexViewU32,
            vertexOffset = this.vertexCount * this.currentShader.vertexComponentCount - 1;
        vertexViewF32[++vertexOffset] = x, vertexViewF32[++vertexOffset] = y, vertexViewF32[++vertexOffset] = u, vertexViewF32[++vertexOffset] = v, vertexViewF32[++vertexOffset] = unit, vertexViewF32[++vertexOffset] = tintEffect, vertexViewU32[++vertexOffset] = tint, this.vertexCount++;
      },
      batchQuad: function batchQuad(gameObject, x0, y0, x1, y1, x2, y2, x3, y3, u0, v0, u1, v1, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, unit) {
        void 0 === unit && (unit = this.currentUnit);
        var hasFlushed = !1;
        return this.shouldFlush(6) && (this.flush(), hasFlushed = !0, unit = this.setTexture2D(texture)), this.batchVert(x0, y0, u0, v0, unit, tintEffect, tintTL), this.batchVert(x1, y1, u0, v1, unit, tintEffect, tintBL), this.batchVert(x2, y2, u1, v1, unit, tintEffect, tintBR), this.batchVert(x0, y0, u0, v0, unit, tintEffect, tintTL), this.batchVert(x2, y2, u1, v1, unit, tintEffect, tintBR), this.batchVert(x3, y3, u1, v0, unit, tintEffect, tintTR), this.onBatch(gameObject), hasFlushed;
      },
      batchTri: function batchTri(gameObject, x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, tintTL, tintTR, tintBL, tintEffect, texture, unit) {
        void 0 === unit && (unit = this.currentUnit);
        var hasFlushed = !1;
        return this.shouldFlush(3) && (this.flush(), hasFlushed = !0, unit = this.setTexture2D(texture)), this.batchVert(x0, y0, u0, v0, unit, tintEffect, tintTL), this.batchVert(x1, y1, u0, v1, unit, tintEffect, tintTR), this.batchVert(x2, y2, u1, v1, unit, tintEffect, tintBL), this.onBatch(gameObject), hasFlushed;
      },
      drawFillRect: function drawFillRect(x, y, unit, tint, v0, v1, texture, flipUV) {
        void 0 === texture && (texture = this.renderer.whiteTexture.glTexture), void 0 === flipUV && (flipUV = !0), x = Math.floor(x), y = Math.floor(y);
        var xw = Math.floor(x + unit),
            yh = Math.floor(y + tint),
            unit = this.setTexture2D(texture),
            tint = Utils.getTintAppendFloatAlphaAndSwap(v0, v1),
            v0 = 0,
            v1 = 1;
        flipUV && (v0 = 1, v1 = 0), this.batchQuad(null, x, y, x, yh, xw, yh, xw, y, 0, v0, 1, v1, tint, tint, tint, tint, 0, texture, unit);
      },
      setTexture2D: function setTexture2D(texture) {
        return void 0 === texture && (texture = this.renderer.whiteTexture.glTexture), this.currentUnit = this.renderer.setTexture2D(texture), this.currentUnit;
      },
      bindTexture: function bindTexture(texture, unit) {
        var gl = this.gl;
        return gl.activeTexture(gl.TEXTURE0 + (unit = void 0 === unit ? 0 : unit)), gl.bindTexture(gl.TEXTURE_2D, texture), this;
      },
      bindRenderTarget: function bindRenderTarget(target, unit) {
        return this.bindTexture(target.texture, unit);
      },
      setTime: function setTime(uniform) {
        return this.set1f(uniform, this.game.loop.getDuration()), this;
      },
      set1f: function set1f(name, x, shader) {
        return (shader = void 0 === shader ? this.currentShader : shader).set1f(name, x), this;
      },
      set2f: function set2f(name, x, y, shader) {
        return (shader = void 0 === shader ? this.currentShader : shader).set2f(name, x, y), this;
      },
      set3f: function set3f(name, x, y, z, shader) {
        return (shader = void 0 === shader ? this.currentShader : shader).set3f(name, x, y, z), this;
      },
      set4f: function set4f(name, x, y, z, w, shader) {
        return (shader = void 0 === shader ? this.currentShader : shader).set4f(name, x, y, z, w), this;
      },
      set1fv: function set1fv(name, arr, shader) {
        return (shader = void 0 === shader ? this.currentShader : shader).set1fv(name, arr), this;
      },
      set2fv: function set2fv(name, arr, shader) {
        return (shader = void 0 === shader ? this.currentShader : shader).set2fv(name, arr), this;
      },
      set3fv: function set3fv(name, arr, shader) {
        return (shader = void 0 === shader ? this.currentShader : shader).set3fv(name, arr), this;
      },
      set4fv: function set4fv(name, arr, shader) {
        return (shader = void 0 === shader ? this.currentShader : shader).set4fv(name, arr), this;
      },
      set1iv: function set1iv(name, arr, shader) {
        return (shader = void 0 === shader ? this.currentShader : shader).set1iv(name, arr), this;
      },
      set2iv: function set2iv(name, arr, shader) {
        return (shader = void 0 === shader ? this.currentShader : shader).set2iv(name, arr), this;
      },
      set3iv: function set3iv(name, arr, shader) {
        return (shader = void 0 === shader ? this.currentShader : shader).set3iv(name, arr), this;
      },
      set4iv: function set4iv(name, arr, shader) {
        return (shader = void 0 === shader ? this.currentShader : shader).set4iv(name, arr), this;
      },
      set1i: function set1i(name, x, shader) {
        return (shader = void 0 === shader ? this.currentShader : shader).set1i(name, x), this;
      },
      set2i: function set2i(name, x, y, shader) {
        return (shader = void 0 === shader ? this.currentShader : shader).set2i(name, x, y), this;
      },
      set3i: function set3i(name, x, y, z, shader) {
        return (shader = void 0 === shader ? this.currentShader : shader).set3i(name, x, y, z), this;
      },
      set4i: function set4i(name, x, y, z, w, shader) {
        return (shader = void 0 === shader ? this.currentShader : shader).set4i(name, x, y, z, w), this;
      },
      setMatrix2fv: function setMatrix2fv(name, transpose, matrix, shader) {
        return (shader = void 0 === shader ? this.currentShader : shader).setMatrix2fv(name, transpose, matrix), this;
      },
      setMatrix3fv: function setMatrix3fv(name, transpose, matrix, shader) {
        return (shader = void 0 === shader ? this.currentShader : shader).setMatrix3fv(name, transpose, matrix), this;
      },
      setMatrix4fv: function setMatrix4fv(name, transpose, matrix, shader) {
        return (shader = void 0 === shader ? this.currentShader : shader).setMatrix4fv(name, transpose, matrix), this;
      },
      destroy: function destroy() {
        this.emit(Events.DESTROY, this);

        for (var shaders = this.shaders, i = 0; i < shaders.length; i++) {
          shaders[i].destroy();
        }

        var targets = this.renderTargets;

        for (i = 0; i < targets.length; i++) {
          targets[i].destroy();
        }

        this.gl.deleteBuffer(this.vertexBuffer);
        var renderer = this.renderer;
        return renderer.off(RendererEvents.RESIZE, this.resize, this), renderer.off(RendererEvents.PRE_RENDER, this.onPreRender, this), renderer.off(RendererEvents.RENDER, this.onRender, this), renderer.off(RendererEvents.POST_RENDER, this.onPostRender, this), this.removeAllListeners(), this.game = null, this.renderer = null, this.manager = null, this.gl = null, this.view = null, this.shaders = null, this.renderTargets = null, this.bytes = null, this.vertexViewF32 = null, this.vertexViewU32 = null, this.vertexData = null, this.vertexBuffer = null, this.currentShader = null, this.currentRenderTarget = null, this;
      }
    });

    module.exports = WebGLPipeline;
  }, function (module, exports, __webpack_require__) {
    "use strict";

    function earcut(data, holeIndices, dim) {
      dim = dim || 2;
      var maxX,
          maxY,
          x,
          y,
          invSize,
          hasHoles = holeIndices && holeIndices.length,
          outerLen = hasHoles ? holeIndices[0] * dim : data.length,
          outerNode = linkedList(data, 0, outerLen, dim, !0),
          triangles = [];
      if (!outerNode || outerNode.next === outerNode.prev) return triangles;

      if (hasHoles && (outerNode = function (data, holeIndices, outerNode, dim) {
        var i,
            len,
            start,
            list,
            queue = [];

        for (i = 0, len = holeIndices.length; i < len; i++) {
          start = holeIndices[i] * dim, list = i < len - 1 ? holeIndices[i + 1] * dim : data.length, (list = linkedList(data, start, list, dim, !1)) === list.next && (list.steiner = !0), queue.push(function (start) {
            var p = start,
                leftmost = start;

            for (; (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) && (leftmost = p), p = p.next, p !== start;) {
              ;
            }

            return leftmost;
          }(list));
        }

        for (queue.sort(compareX), i = 0; i < queue.length; i++) {
          !function (b, outerNode) {
            (outerNode = function (hole, outerNode) {
              var m,
                  p = outerNode,
                  hx = hole.x,
                  hy = hole.y,
                  qx = -1 / 0;

              do {
                if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
                  var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);

                  if (x <= hx && qx < x) {
                    if ((qx = x) === hx) {
                      if (hy === p.y) return p;
                      if (hy === p.next.y) return p.next;
                    }

                    m = p.x < p.next.x ? p : p.next;
                  }
                }
              } while ((p = p.next, p !== outerNode));

              if (!m) return null;
              if (hx === qx) return m;
              var tan,
                  stop = m,
                  mx = m.x,
                  my = m.y,
                  tanMin = 1 / 0;
              p = m;

              for (; hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y) && (tan = Math.abs(hy - p.y) / (hx - p.x), locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && function (m, p) {
                return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
              }(m, p))) && (m = p, tanMin = tan)), p = p.next, p !== stop;) {
                ;
              }

              return m;
            }(b, outerNode)) && (b = splitPolygon(outerNode, b), filterPoints(outerNode, outerNode.next), filterPoints(b, b.next));
          }(queue[i], outerNode), outerNode = filterPoints(outerNode, outerNode.next);
        }

        return outerNode;
      }(data, holeIndices, outerNode, dim)), data.length > 80 * dim) {
        for (var minX = maxX = data[0], minY = maxY = data[1], i = dim; i < outerLen; i += dim) {
          (x = data[i]) < minX && (minX = x), (y = data[i + 1]) < minY && (minY = y), maxX < x && (maxX = x), maxY < y && (maxY = y);
        }

        invSize = 0 !== (invSize = Math.max(maxX - minX, maxY - minY)) ? 1 / invSize : 0;
      }

      return earcutLinked(outerNode, triangles, dim, minX, minY, invSize), triangles;
    }

    function linkedList(data, start, end, dim, clockwise) {
      var i, last;
      if (clockwise === 0 < signedArea(data, start, end, dim)) for (i = start; i < end; i += dim) {
        last = insertNode(i, data[i], data[i + 1], last);
      } else for (i = end - dim; start <= i; i -= dim) {
        last = insertNode(i, data[i], data[i + 1], last);
      }
      return last && equals(last, last.next) && (removeNode(last), last = last.next), last;
    }

    function filterPoints(start, end) {
      if (!start) return start;
      end = end || start;
      var again,
          p = start;

      do {
        if (again = !1, p.steiner || !equals(p, p.next) && 0 !== area(p.prev, p, p.next)) p = p.next;else {
          if (removeNode(p), (p = end = p.prev) === p.next) break;
          again = !0;
        }
      } while (again || p !== end);

      return end;
    }

    function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
      if (ear) {
        !pass && invSize && function (start, minX, minY, invSize) {
          var p = start;

          for (; null === p.z && (p.z = zOrder(p.x, p.y, minX, minY, invSize)), p.prevZ = p.prev, p.nextZ = p.next, p = p.next, p !== start;) {
            ;
          }

          p.prevZ.nextZ = null, p.prevZ = null, function (list) {
            var i,
                p,
                q,
                e,
                tail,
                numMerges,
                pSize,
                qSize,
                inSize = 1;

            do {
              for (p = list, tail = list = null, numMerges = 0; p;) {
                for (numMerges++, q = p, i = pSize = 0; i < inSize && (pSize++, q = q.nextZ); i++) {
                  ;
                }

                for (qSize = inSize; 0 < pSize || 0 < qSize && q;) {
                  0 !== pSize && (0 === qSize || !q || p.z <= q.z) ? (p = (e = p).nextZ, pSize--) : (q = (e = q).nextZ, qSize--), tail ? tail.nextZ = e : list = e, e.prevZ = tail, tail = e;
                }

                p = q;
              }
            } while ((tail.nextZ = null, inSize *= 2, 1 < numMerges));
          }(p);
        }(ear, minX, minY, invSize);

        for (var prev, next, stop = ear; ear.prev !== ear.next;) {
          if (prev = ear.prev, next = ear.next, invSize ? function (ear, minX, minY, invSize) {
            var a = ear.prev,
                b = ear,
                c = ear.next;
            if (0 <= area(a, b, c)) return !1;
            var minTX = (a.x < b.x ? a.x < c.x ? a : c : b.x < c.x ? b : c).x,
                minTY = (a.y < b.y ? a.y < c.y ? a : c : b.y < c.y ? b : c).y,
                maxTX = (a.x > b.x ? a.x > c.x ? a : c : b.x > c.x ? b : c).x,
                maxTY = (a.y > b.y ? a.y > c.y ? a : c : b.y > c.y ? b : c).y,
                minZ = zOrder(minTX, minTY, minX, minY, invSize),
                maxZ = zOrder(maxTX, maxTY, minX, minY, invSize),
                p = ear.prevZ,
                n = ear.nextZ;

            for (; p && p.z >= minZ && n && n.z <= maxZ;) {
              if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && 0 <= area(p.prev, p, p.next)) return !1;
              if (p = p.prevZ, n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && 0 <= area(n.prev, n, n.next)) return !1;
              n = n.nextZ;
            }

            for (; p && p.z >= minZ;) {
              if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && 0 <= area(p.prev, p, p.next)) return !1;
              p = p.prevZ;
            }

            for (; n && n.z <= maxZ;) {
              if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && 0 <= area(n.prev, n, n.next)) return !1;
              n = n.nextZ;
            }

            return !0;
          }(ear, minX, minY, invSize) : function (ear) {
            var a = ear.prev,
                b = ear,
                c = ear.next;
            if (0 <= area(a, b, c)) return !1;
            var p = ear.next.next;

            for (; p !== ear.prev;) {
              if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && 0 <= area(p.prev, p, p.next)) return !1;
              p = p.next;
            }

            return !0;
          }(ear)) triangles.push(prev.i / dim), triangles.push(ear.i / dim), triangles.push(next.i / dim), removeNode(ear), ear = next.next, stop = next.next;else if ((ear = next) === stop) {
            pass ? 1 === pass ? earcutLinked(ear = function (start, triangles, dim) {
              var p = start;

              do {
                var a = p.prev,
                    b = p.next.next;
              } while ((!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a) && (triangles.push(a.i / dim), triangles.push(p.i / dim), triangles.push(b.i / dim), removeNode(p), removeNode(p.next), p = start = b), p = p.next, p !== start));

              return filterPoints(p);
            }(filterPoints(ear), triangles, dim), triangles, dim, minX, minY, invSize, 2) : 2 === pass && function (start, triangles, dim, minX, minY, invSize) {
              var a = start;

              do {
                for (var b = a.next.next; b !== a.prev;) {
                  if (a.i !== b.i && function (a, b) {
                    return a.next.i !== b.i && a.prev.i !== b.i && !function (a, b) {
                      var p = a;

                      do {
                        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return !0;
                      } while ((p = p.next, p !== a));

                      return !1;
                    }(a, b) && (locallyInside(a, b) && locallyInside(b, a) && function (a, b) {
                      var p = a,
                          inside = !1,
                          px = (a.x + b.x) / 2,
                          py = (a.y + b.y) / 2;

                      for (; p.y > py != p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x && (inside = !inside), p = p.next, p !== a;) {
                        ;
                      }

                      return inside;
                    }(a, b) && (area(a.prev, a, b.prev) || area(a, b.prev, b)) || equals(a, b) && 0 < area(a.prev, a, a.next) && 0 < area(b.prev, b, b.next));
                  }(a, b)) {
                    var c = splitPolygon(a, b);
                    return a = filterPoints(a, a.next), c = filterPoints(c, c.next), earcutLinked(a, triangles, dim, minX, minY, invSize), earcutLinked(c, triangles, dim, minX, minY, invSize);
                  }

                  b = b.next;
                }
              } while ((a = a.next, a !== start));
            }(ear, triangles, dim, minX, minY, invSize) : earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
            break;
          }
        }
      }
    }

    function compareX(a, b) {
      return a.x - b.x;
    }

    function zOrder(x, y, minX, minY, invSize) {
      return (x = 1431655765 & ((x = 858993459 & ((x = 252645135 & ((x = 16711935 & ((x = 32767 * (x - minX) * invSize) | x << 8)) | x << 4)) | x << 2)) | x << 1)) | (y = 1431655765 & ((y = 858993459 & ((y = 252645135 & ((y = 16711935 & ((y = 32767 * (y - minY) * invSize) | y << 8)) | y << 4)) | y << 2)) | y << 1)) << 1;
    }

    function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
      return 0 <= (cx - px) * (ay - py) - (ax - px) * (cy - py) && 0 <= (ax - px) * (by - py) - (bx - px) * (ay - py) && 0 <= (bx - px) * (cy - py) - (cx - px) * (by - py);
    }

    function area(p, q, r) {
      return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
    }

    function equals(p1, p2) {
      return p1.x === p2.x && p1.y === p2.y;
    }

    function intersects(p1, q1, p2, q2) {
      var o1 = sign(area(p1, q1, p2)),
          o2 = sign(area(p1, q1, q2)),
          o3 = sign(area(p2, q2, p1)),
          o4 = sign(area(p2, q2, q1));
      return o1 !== o2 && o3 !== o4 || 0 === o1 && onSegment(p1, p2, q1) || 0 === o2 && onSegment(p1, q2, q1) || 0 === o3 && onSegment(p2, p1, q2) || !(0 !== o4 || !onSegment(p2, q1, q2));
    }

    function onSegment(p, q, r) {
      return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
    }

    function sign(num) {
      return 0 < num ? 1 : num < 0 ? -1 : 0;
    }

    function locallyInside(a, b) {
      return area(a.prev, a, a.next) < 0 ? 0 <= area(a, b, a.next) && 0 <= area(a, a.prev, b) : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
    }

    function splitPolygon(a, b) {
      var a2 = new Node(a.i, a.x, a.y),
          b2 = new Node(b.i, b.x, b.y),
          an = a.next,
          bp = b.prev;
      return (a.next = b).prev = a, (a2.next = an).prev = a2, (b2.next = a2).prev = b2, (bp.next = b2).prev = bp, b2;
    }

    function insertNode(i, x, p, last) {
      p = new Node(i, x, p);
      return last ? (p.next = last.next, (p.prev = last).next.prev = p, last.next = p) : (p.prev = p).next = p, p;
    }

    function removeNode(p) {
      p.next.prev = p.prev, p.prev.next = p.next, p.prevZ && (p.prevZ.nextZ = p.nextZ), p.nextZ && (p.nextZ.prevZ = p.prevZ);
    }

    function Node(i, x, y) {
      this.i = i, this.x = x, this.y = y, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1;
    }

    function signedArea(data, start, end, dim) {
      for (var sum = 0, i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]), j = i;
      }

      return sum;
    }

    earcut.deviation = function (data, holeIndices, dim, triangles) {
      var hasHoles = holeIndices && holeIndices.length,
          outerLen = hasHoles ? holeIndices[0] * dim : data.length,
          polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
      if (hasHoles) for (var i = 0, len = holeIndices.length; i < len; i++) {
        var start = holeIndices[i] * dim,
            end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        polygonArea -= Math.abs(signedArea(data, start, end, dim));
      }

      for (var trianglesArea = 0, i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim,
            b = triangles[i + 1] * dim,
            c = triangles[i + 2] * dim;
        trianglesArea += Math.abs((data[a] - data[c]) * (data[1 + b] - data[1 + a]) - (data[a] - data[b]) * (data[1 + c] - data[1 + a]));
      }

      return 0 === polygonArea && 0 === trianglesArea ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
    }, earcut.flatten = function (data) {
      for (var dim = data[0][0].length, result = {
        vertices: [],
        holes: [],
        dimensions: dim
      }, holeIndex = 0, i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
          for (var d = 0; d < dim; d++) {
            result.vertices.push(data[i][j][d]);
          }
        }

        0 < i && (holeIndex += data[i - 1].length, result.holes.push(holeIndex));
      }

      return result;
    }, module.exports = earcut;
  }, function (module, exports) {
    module.exports = function (ctx, src, strokeColor, strokeAlpha) {
      strokeColor = strokeColor || src.strokeColor, strokeAlpha = strokeAlpha || src.strokeAlpha;
      ctx.strokeStyle = "rgba(" + ((16711680 & strokeColor) >>> 16) + "," + ((65280 & strokeColor) >>> 8) + "," + (255 & strokeColor) + "," + strokeAlpha + ")", ctx.lineWidth = src.lineWidth;
    };
  }, function (module, exports, __webpack_require__) {
    var Class = __webpack_require__(0),
        CONST = __webpack_require__(21),
        File = __webpack_require__(23),
        FileTypesManager = __webpack_require__(8),
        GetFastValue = __webpack_require__(2),
        GetValue = __webpack_require__(6),
        IsPlainObject = __webpack_require__(7),
        JSONFile = new Class({
      Extends: File,
      initialize: function initialize(loader, key, url, fileConfig, dataKey) {
        var config,
            extension = "json";
        IsPlainObject(key) && (key = GetFastValue(config = key, "key"), url = GetFastValue(config, "url"), fileConfig = GetFastValue(config, "xhrSettings"), extension = GetFastValue(config, "extension", extension), dataKey = GetFastValue(config, "dataKey", dataKey));
        fileConfig = {
          type: "json",
          cache: loader.cacheManager.json,
          extension: extension,
          responseType: "text",
          key: key,
          url: url,
          xhrSettings: fileConfig,
          config: dataKey
        };
        File.call(this, loader, fileConfig), IsPlainObject(url) && (this.data = dataKey ? GetValue(url, dataKey) : url, this.state = CONST.FILE_POPULATED);
      },
      onProcess: function onProcess() {
        if (this.state !== CONST.FILE_POPULATED) {
          this.state = CONST.FILE_PROCESSING;

          try {
            var json = JSON.parse(this.xhrLoader.responseText);
          } catch (e) {
            throw console.warn("Invalid JSON: " + this.key), this.onProcessError(), e;
          }

          var key = this.config;
          this.data = "string" == typeof key ? GetValue(json, key, json) : json;
        }

        this.onProcessComplete();
      }
    });

    FileTypesManager.register("json", function (key, url, dataKey, xhrSettings) {
      if (Array.isArray(key)) for (var i = 0; i < key.length; i++) {
        this.addFile(new JSONFile(this, key[i]));
      } else this.addFile(new JSONFile(this, key, url, xhrSettings, dataKey));
      return this;
    }), module.exports = JSONFile;
  }, function (module, exports) {
    module.exports = {
      DYNAMIC_BODY: 0,
      STATIC_BODY: 1,
      GROUP: 2,
      TILEMAPLAYER: 3,
      FACING_NONE: 10,
      FACING_UP: 11,
      FACING_DOWN: 12,
      FACING_LEFT: 13,
      FACING_RIGHT: 14
    };
  }, function (module, exports, __webpack_require__) {
    var GetTileAt = __webpack_require__(158),
        GetTilesWithin = __webpack_require__(26);

    module.exports = function (tileX, tileY, width, height, layer) {
      for (var above, below, left, right, tiles = GetTilesWithin(tileX, tileY, width, height, null, layer), i = 0; i < tiles.length; i++) {
        var tile = tiles[i];
        tile && (tile.collides ? (above = GetTileAt(tile.x, tile.y - 1, !0, layer), below = GetTileAt(tile.x, tile.y + 1, !0, layer), left = GetTileAt(tile.x - 1, tile.y, !0, layer), right = GetTileAt(tile.x + 1, tile.y, !0, layer), tile.faceTop = !above || !above.collides, tile.faceBottom = !below || !below.collides, tile.faceLeft = !left || !left.collides, tile.faceRight = !right || !right.collides) : tile.resetFaces());
      }
    };
  }, function (module, exports, __webpack_require__) {
    var Vertices = {};
    module.exports = Vertices;

    var Vector = __webpack_require__(83),
        Common = __webpack_require__(32);

    Vertices.create = function (points, body) {
      for (var vertices = [], i = 0; i < points.length; i++) {
        var vertex = points[i],
            vertex = {
          x: vertex.x,
          y: vertex.y,
          index: i,
          body: body,
          isInternal: !1,
          contact: null,
          offset: null
        };
        vertex.contact = {
          vertex: vertex,
          normalImpulse: 0,
          tangentImpulse: 0
        }, vertices.push(vertex);
      }

      return vertices;
    }, Vertices.fromPath = function (path, body) {
      var points = [];
      return path.replace(/L?\s*([-\d.e]+)[\s,]*([-\d.e]+)*/gi, function (match, x, y) {
        points.push({
          x: parseFloat(x),
          y: parseFloat(y)
        });
      }), Vertices.create(points, body);
    }, Vertices.centre = function (vertices) {
      for (var temp, j, area = Vertices.area(vertices, !0), centre = {
        x: 0,
        y: 0
      }, i = 0; i < vertices.length; i++) {
        j = (i + 1) % vertices.length, temp = Vector.cross(vertices[i], vertices[j]), temp = Vector.mult(Vector.add(vertices[i], vertices[j]), temp), centre = Vector.add(centre, temp);
      }

      return Vector.div(centre, 6 * area);
    }, Vertices.mean = function (vertices) {
      for (var average = {
        x: 0,
        y: 0
      }, i = 0; i < vertices.length; i++) {
        average.x += vertices[i].x, average.y += vertices[i].y;
      }

      return Vector.div(average, vertices.length);
    }, Vertices.area = function (vertices, signed) {
      for (var area = 0, j = vertices.length - 1, i = 0; i < vertices.length; i++) {
        area += (vertices[j].x - vertices[i].x) * (vertices[j].y + vertices[i].y), j = i;
      }

      return signed ? area / 2 : Math.abs(area) / 2;
    }, Vertices.inertia = function (vertices, mass) {
      for (var cross, j, numerator = 0, denominator = 0, v = vertices, n = 0; n < v.length; n++) {
        j = (n + 1) % v.length, numerator += (cross = Math.abs(Vector.cross(v[j], v[n]))) * (Vector.dot(v[j], v[j]) + Vector.dot(v[j], v[n]) + Vector.dot(v[n], v[n])), denominator += cross;
      }

      return mass / 6 * (numerator / denominator);
    }, Vertices.translate = function (vertices, vector, scalar) {
      var i;
      if (scalar) for (i = 0; i < vertices.length; i++) {
        vertices[i].x += vector.x * scalar, vertices[i].y += vector.y * scalar;
      } else for (i = 0; i < vertices.length; i++) {
        vertices[i].x += vector.x, vertices[i].y += vector.y;
      }
      return vertices;
    }, Vertices.rotate = function (vertices, angle, point) {
      if (0 !== angle) {
        for (var cos = Math.cos(angle), sin = Math.sin(angle), i = 0; i < vertices.length; i++) {
          var vertice = vertices[i],
              dx = vertice.x - point.x,
              dy = vertice.y - point.y;
          vertice.x = point.x + (dx * cos - dy * sin), vertice.y = point.y + (dx * sin + dy * cos);
        }

        return vertices;
      }
    }, Vertices.contains = function (vertices, point) {
      for (var i = 0; i < vertices.length; i++) {
        var vertice = vertices[i],
            nextVertice = vertices[(i + 1) % vertices.length];
        if (0 < (point.x - vertice.x) * (nextVertice.y - vertice.y) + (point.y - vertice.y) * (vertice.x - nextVertice.x)) return !1;
      }

      return !0;
    }, Vertices.scale = function (vertices, scaleX, scaleY, point) {
      if (1 === scaleX && 1 === scaleY) return vertices;
      var delta;
      point = point || Vertices.centre(vertices);

      for (var i = 0; i < vertices.length; i++) {
        delta = vertices[i], delta = Vector.sub(delta, point), vertices[i].x = point.x + delta.x * scaleX, vertices[i].y = point.y + delta.y * scaleY;
      }

      return vertices;
    }, Vertices.chamfer = function (vertices, radius, quality, qualityMin, qualityMax) {
      radius = "number" == typeof radius ? [radius] : radius || [8], quality = void 0 !== quality ? quality : -1, qualityMin = qualityMin || 2, qualityMax = qualityMax || 14;

      for (var newVertices = [], i = 0; i < vertices.length; i++) {
        var diagonalRadius = vertices[0 <= i - 1 ? i - 1 : vertices.length - 1],
            vertex = vertices[i],
            midNormal = vertices[(i + 1) % vertices.length],
            currentRadius = radius[i < radius.length ? i : radius.length - 1];

        if (0 !== currentRadius) {
          var prevNormal = Vector.normalise({
            x: vertex.y - diagonalRadius.y,
            y: diagonalRadius.x - vertex.x
          }),
              nextNormal = Vector.normalise({
            x: midNormal.y - vertex.y,
            y: vertex.x - midNormal.x
          }),
              diagonalRadius = Math.sqrt(2 * Math.pow(currentRadius, 2)),
              radiusVector = Vector.mult(Common.clone(prevNormal), currentRadius),
              midNormal = Vector.normalise(Vector.mult(Vector.add(prevNormal, nextNormal), .5)),
              scaledVertex = Vector.sub(vertex, Vector.mult(midNormal, diagonalRadius)),
              precision = quality;
          -1 === quality && (precision = 1.75 * Math.pow(currentRadius, .32)), (precision = Common.clamp(precision, qualityMin, qualityMax)) % 2 == 1 && (precision += 1);

          for (var theta = Math.acos(Vector.dot(prevNormal, nextNormal)) / precision, j = 0; j < precision; j++) {
            newVertices.push(Vector.add(Vector.rotate(radiusVector, theta * j), scaledVertex));
          }
        } else newVertices.push(vertex);
      }

      return newVertices;
    }, Vertices.clockwiseSort = function (vertices) {
      var centre = Vertices.mean(vertices);
      return vertices.sort(function (vertexA, vertexB) {
        return Vector.angle(centre, vertexA) - Vector.angle(centre, vertexB);
      }), vertices;
    }, Vertices.isConvex = function (vertices) {
      var i,
          j,
          k,
          z,
          flag = 0,
          n = vertices.length;
      if (n < 3) return null;

      for (i = 0; i < n; i++) {
        if (z = (vertices[j = (i + 1) % n].x - vertices[i].x) * (vertices[k = (i + 2) % n].y - vertices[j].y), (z -= (vertices[j].y - vertices[i].y) * (vertices[k].x - vertices[j].x)) < 0 ? flag |= 1 : 0 < z && (flag |= 2), 3 === flag) return !1;
      }

      return 0 !== flag || null;
    }, Vertices.hull = function (vertices) {
      var vertex,
          i,
          upper = [],
          lower = [];

      for ((vertices = vertices.slice(0)).sort(function (vertexA, vertexB) {
        var dx = vertexA.x - vertexB.x;
        return 0 != dx ? dx : vertexA.y - vertexB.y;
      }), i = 0; i < vertices.length; i += 1) {
        for (vertex = vertices[i]; 2 <= lower.length && Vector.cross3(lower[lower.length - 2], lower[lower.length - 1], vertex) <= 0;) {
          lower.pop();
        }

        lower.push(vertex);
      }

      for (i = vertices.length - 1; 0 <= i; --i) {
        for (vertex = vertices[i]; 2 <= upper.length && Vector.cross3(upper[upper.length - 2], upper[upper.length - 1], vertex) <= 0;) {
          upper.pop();
        }

        upper.push(vertex);
      }

      return upper.pop(), lower.pop(), upper.concat(lower);
    };
  }, function (module, exports, __webpack_require__) {
    var Circle = __webpack_require__(0),
        Contains = __webpack_require__(66),
        GetPoint = __webpack_require__(300),
        GetPoints = __webpack_require__(301),
        GEOM_CONST = __webpack_require__(56),
        Random = __webpack_require__(170),
        Circle = new Circle({
      initialize: function initialize(x, y, radius) {
        void 0 === x && (x = 0), void 0 === y && (y = 0), void 0 === radius && (radius = 0), this.type = GEOM_CONST.CIRCLE, this.x = x, this.y = y, this._radius = radius, this._diameter = 2 * radius;
      },
      contains: function contains(x, y) {
        return Contains(this, x, y);
      },
      getPoint: function getPoint(position, point) {
        return GetPoint(this, position, point);
      },
      getPoints: function getPoints(quantity, stepRate, output) {
        return GetPoints(this, quantity, stepRate, output);
      },
      getRandomPoint: function getRandomPoint(point) {
        return Random(this, point);
      },
      setTo: function setTo(x, y, radius) {
        return this.x = x, this.y = y, this._radius = radius, this._diameter = 2 * radius, this;
      },
      setEmpty: function setEmpty() {
        return this._radius = 0, this._diameter = 0, this;
      },
      setPosition: function setPosition(x, y) {
        return void 0 === y && (y = x), this.x = x, this.y = y, this;
      },
      isEmpty: function isEmpty() {
        return this._radius <= 0;
      },
      radius: {
        get: function get() {
          return this._radius;
        },
        set: function set(value) {
          this._radius = value, this._diameter = 2 * value;
        }
      },
      diameter: {
        get: function get() {
          return this._diameter;
        },
        set: function set(value) {
          this._diameter = value, this._radius = .5 * value;
        }
      },
      left: {
        get: function get() {
          return this.x - this._radius;
        },
        set: function set(value) {
          this.x = value + this._radius;
        }
      },
      right: {
        get: function get() {
          return this.x + this._radius;
        },
        set: function set(value) {
          this.x = value - this._radius;
        }
      },
      top: {
        get: function get() {
          return this.y - this._radius;
        },
        set: function set(value) {
          this.y = value + this._radius;
        }
      },
      bottom: {
        get: function get() {
          return this.y + this._radius;
        },
        set: function set(value) {
          this.y = value - this._radius;
        }
      }
    });

    module.exports = Circle;
  }, function (module, exports) {
    module.exports = function (circle, x, y) {
      return 0 < circle.radius && x >= circle.left && x <= circle.right && y >= circle.top && y <= circle.bottom && (circle.x - x) * (circle.x - x) + (circle.y - y) * (circle.y - y) <= circle.radius * circle.radius;
    };
  }, function (module, exports) {
    module.exports = function (line) {
      return Math.sqrt((line.x2 - line.x1) * (line.x2 - line.x1) + (line.y2 - line.y1) * (line.y2 - line.y1));
    };
  }, function (module, exports) {
    module.exports = function (value, min, range) {
      range -= min;
      return min + ((value - min) % range + range) % range;
    };
  }, function (module, exports, Vector3) {
    var Class = Vector3(0),
        Vector3 = Vector3(39),
        Matrix4 = new Class({
      initialize: function initialize(m) {
        this.val = new Float32Array(16), m ? this.copy(m) : this.identity();
      },
      clone: function clone() {
        return new Matrix4(this);
      },
      set: function set(src) {
        return this.copy(src);
      },
      setValues: function setValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
        var out = this.val;
        return out[0] = m00, out[1] = m01, out[2] = m02, out[3] = m03, out[4] = m10, out[5] = m11, out[6] = m12, out[7] = m13, out[8] = m20, out[9] = m21, out[10] = m22, out[11] = m23, out[12] = m30, out[13] = m31, out[14] = m32, out[15] = m33, this;
      },
      copy: function copy(a) {
        a = a.val;
        return this.setValues(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
      },
      fromArray: function fromArray(a) {
        return this.setValues(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
      },
      zero: function zero() {
        return this.setValues(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      },
      transform: function transform(position, sz, sy) {
        var rm = _tempMat1.fromQuat(sy).val,
            sx = sz.x,
            sy = sz.y,
            sz = sz.z;

        return this.setValues(rm[0] * sx, rm[1] * sx, rm[2] * sx, 0, rm[4] * sy, rm[5] * sy, rm[6] * sy, 0, rm[8] * sz, rm[9] * sz, rm[10] * sz, 0, position.x, position.y, position.z, 1);
      },
      xyz: function xyz(x, y, z) {
        this.identity();
        var out = this.val;
        return out[12] = x, out[13] = y, out[14] = z, this;
      },
      scaling: function scaling(x, y, z) {
        this.zero();
        var out = this.val;
        return out[0] = x, out[5] = y, out[10] = z, out[15] = 1, this;
      },
      identity: function identity() {
        return this.setValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      },
      transpose: function transpose() {
        var a = this.val,
            a01 = a[1],
            a02 = a[2],
            a03 = a[3],
            a12 = a[6],
            a13 = a[7],
            a23 = a[11];
        return a[1] = a[4], a[2] = a[8], a[3] = a[12], a[4] = a01, a[6] = a[9], a[7] = a[13], a[8] = a02, a[9] = a12, a[11] = a[14], a[12] = a03, a[13] = a13, a[14] = a23, this;
      },
      getInverse: function getInverse(m) {
        return this.copy(m), this.invert();
      },
      invert: function invert() {
        var det = this.val,
            a00 = det[0],
            a01 = det[1],
            a02 = det[2],
            a03 = det[3],
            a10 = det[4],
            a11 = det[5],
            a12 = det[6],
            a13 = det[7],
            a20 = det[8],
            a21 = det[9],
            a22 = det[10],
            a23 = det[11],
            a30 = det[12],
            a31 = det[13],
            a32 = det[14],
            a33 = det[15],
            b00 = a00 * a11 - a01 * a10,
            b01 = a00 * a12 - a02 * a10,
            b02 = a00 * a13 - a03 * a10,
            b03 = a01 * a12 - a02 * a11,
            b04 = a01 * a13 - a03 * a11,
            b05 = a02 * a13 - a03 * a12,
            b06 = a20 * a31 - a21 * a30,
            b07 = a20 * a32 - a22 * a30,
            b08 = a20 * a33 - a23 * a30,
            b09 = a21 * a32 - a22 * a31,
            b10 = a21 * a33 - a23 * a31,
            b11 = a22 * a33 - a23 * a32,
            det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
        return det ? this.setValues((a11 * b11 - a12 * b10 + a13 * b09) * (det = 1 / det), (a02 * b10 - a01 * b11 - a03 * b09) * det, (a31 * b05 - a32 * b04 + a33 * b03) * det, (a22 * b04 - a21 * b05 - a23 * b03) * det, (a12 * b08 - a10 * b11 - a13 * b07) * det, (a00 * b11 - a02 * b08 + a03 * b07) * det, (a32 * b02 - a30 * b05 - a33 * b01) * det, (a20 * b05 - a22 * b02 + a23 * b01) * det, (a10 * b10 - a11 * b08 + a13 * b06) * det, (a01 * b08 - a00 * b10 - a03 * b06) * det, (a30 * b04 - a31 * b02 + a33 * b00) * det, (a21 * b02 - a20 * b04 - a23 * b00) * det, (a11 * b07 - a10 * b09 - a12 * b06) * det, (a00 * b09 - a01 * b07 + a02 * b06) * det, (a31 * b01 - a30 * b03 - a32 * b00) * det, (a20 * b03 - a21 * b01 + a22 * b00) * det) : this;
      },
      adjoint: function adjoint() {
        var a33 = this.val,
            a00 = a33[0],
            a01 = a33[1],
            a02 = a33[2],
            a03 = a33[3],
            a10 = a33[4],
            a11 = a33[5],
            a12 = a33[6],
            a13 = a33[7],
            a20 = a33[8],
            a21 = a33[9],
            a22 = a33[10],
            a23 = a33[11],
            a30 = a33[12],
            a31 = a33[13],
            a32 = a33[14],
            a33 = a33[15];
        return this.setValues(a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22), -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22)), a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12), -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12)), -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22)), a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22), -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12)), a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12), a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21), -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21)), a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11), -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11)), -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21)), a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21), -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11)), a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
      },
      determinant: function determinant() {
        var a33 = this.val,
            a00 = a33[0],
            a01 = a33[1],
            a02 = a33[2],
            a03 = a33[3],
            a10 = a33[4],
            a11 = a33[5],
            a12 = a33[6],
            a13 = a33[7],
            a20 = a33[8],
            a21 = a33[9],
            a22 = a33[10],
            a23 = a33[11],
            a30 = a33[12],
            a31 = a33[13],
            a32 = a33[14],
            a33 = a33[15];
        return (a00 * a11 - a01 * a10) * (a22 * a33 - a23 * a32) - (a00 * a12 - a02 * a10) * (a21 * a33 - a23 * a31) + (a00 * a13 - a03 * a10) * (a21 * a32 - a22 * a31) + (a01 * a12 - a02 * a11) * (a20 * a33 - a23 * a30) - (a01 * a13 - a03 * a11) * (a20 * a32 - a22 * a30) + (a02 * a13 - a03 * a12) * (a20 * a31 - a21 * a30);
      },
      multiply: function multiply(b3) {
        var a = this.val,
            a00 = a[0],
            a01 = a[1],
            a02 = a[2],
            a03 = a[3],
            a10 = a[4],
            a11 = a[5],
            a12 = a[6],
            a13 = a[7],
            a20 = a[8],
            a21 = a[9],
            a22 = a[10],
            a23 = a[11],
            a30 = a[12],
            a31 = a[13],
            a32 = a[14],
            a33 = a[15],
            b = b3.val,
            b0 = b[0],
            b1 = b[1],
            b2 = b[2],
            b3 = b[3];
        return a[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, a[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, a[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, a[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, b0 = b[4], b1 = b[5], b2 = b[6], b3 = b[7], a[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, a[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, a[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, a[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, b0 = b[8], b1 = b[9], b2 = b[10], b3 = b[11], a[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, a[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, a[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, a[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, b0 = b[12], b1 = b[13], b2 = b[14], b3 = b[15], a[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, a[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, a[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, a[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, this;
      },
      multiplyLocal: function multiplyLocal(b) {
        var a = this.val,
            b = b.val;
        return this.setValues(a[0] * b[0] + a[1] * b[4] + a[2] * b[8] + a[3] * b[12], a[0] * b[1] + a[1] * b[5] + a[2] * b[9] + a[3] * b[13], a[0] * b[2] + a[1] * b[6] + a[2] * b[10] + a[3] * b[14], a[0] * b[3] + a[1] * b[7] + a[2] * b[11] + a[3] * b[15], a[4] * b[0] + a[5] * b[4] + a[6] * b[8] + a[7] * b[12], a[4] * b[1] + a[5] * b[5] + a[6] * b[9] + a[7] * b[13], a[4] * b[2] + a[5] * b[6] + a[6] * b[10] + a[7] * b[14], a[4] * b[3] + a[5] * b[7] + a[6] * b[11] + a[7] * b[15], a[8] * b[0] + a[9] * b[4] + a[10] * b[8] + a[11] * b[12], a[8] * b[1] + a[9] * b[5] + a[10] * b[9] + a[11] * b[13], a[8] * b[2] + a[9] * b[6] + a[10] * b[10] + a[11] * b[14], a[8] * b[3] + a[9] * b[7] + a[10] * b[11] + a[11] * b[15], a[12] * b[0] + a[13] * b[4] + a[14] * b[8] + a[15] * b[12], a[12] * b[1] + a[13] * b[5] + a[14] * b[9] + a[15] * b[13], a[12] * b[2] + a[13] * b[6] + a[14] * b[10] + a[15] * b[14], a[12] * b[3] + a[13] * b[7] + a[14] * b[11] + a[15] * b[15]);
      },
      premultiply: function premultiply(m) {
        return this.multiplyMatrices(m, this);
      },
      multiplyMatrices: function multiplyMatrices(b41, b42) {
        var b43 = b41.val,
            b44 = b42.val,
            a11 = b43[0],
            a12 = b43[4],
            a13 = b43[8],
            a14 = b43[12],
            a21 = b43[1],
            a22 = b43[5],
            a23 = b43[9],
            a24 = b43[13],
            a31 = b43[2],
            a32 = b43[6],
            a33 = b43[10],
            a34 = b43[14],
            a41 = b43[3],
            a42 = b43[7],
            a43 = b43[11],
            a44 = b43[15],
            b11 = b44[0],
            b12 = b44[4],
            b13 = b44[8],
            b14 = b44[12],
            b21 = b44[1],
            b22 = b44[5],
            b23 = b44[9],
            b24 = b44[13],
            b31 = b44[2],
            b32 = b44[6],
            b33 = b44[10],
            b34 = b44[14],
            b41 = b44[3],
            b42 = b44[7],
            b43 = b44[11],
            b44 = b44[15];
        return this.setValues(a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41, a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41, a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41, a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41, a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42, a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42, a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42, a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42, a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43, a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43, a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43, a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43, a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44, a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44, a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44, a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44);
      },
      translate: function translate(v) {
        return this.translateXYZ(v.x, v.y, v.z);
      },
      translateXYZ: function translateXYZ(x, y, z) {
        var a = this.val;
        return a[12] = a[0] * x + a[4] * y + a[8] * z + a[12], a[13] = a[1] * x + a[5] * y + a[9] * z + a[13], a[14] = a[2] * x + a[6] * y + a[10] * z + a[14], a[15] = a[3] * x + a[7] * y + a[11] * z + a[15], this;
      },
      scale: function scale(v) {
        return this.scaleXYZ(v.x, v.y, v.z);
      },
      scaleXYZ: function scaleXYZ(x, y, z) {
        var a = this.val;
        return a[0] = a[0] * x, a[1] = a[1] * x, a[2] = a[2] * x, a[3] = a[3] * x, a[4] = a[4] * y, a[5] = a[5] * y, a[6] = a[6] * y, a[7] = a[7] * y, a[8] = a[8] * z, a[9] = a[9] * z, a[10] = a[10] * z, a[11] = a[11] * z, this;
      },
      makeRotationAxis: function makeRotationAxis(ty, tx) {
        var c = Math.cos(tx),
            s = Math.sin(tx),
            t = 1 - c,
            x = ty.x,
            y = ty.y,
            z = ty.z,
            tx = t * x,
            ty = t * y;
        return this.setValues(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
      },
      rotate: function rotate(b12, b10) {
        var b20 = this.val,
            x = b10.x,
            y = b10.y,
            z = b10.z,
            b11 = Math.sqrt(x * x + y * y + z * z);
        if (Math.abs(b11) < 1e-6) return this;
        x *= b11 = 1 / b11, y *= b11, z *= b11;
        var b21 = Math.sin(b12),
            b22 = Math.cos(b12),
            t = 1 - b22,
            a00 = b20[0],
            a01 = b20[1],
            a02 = b20[2],
            a03 = b20[3],
            a10 = b20[4],
            a11 = b20[5],
            a12 = b20[6],
            a13 = b20[7],
            a20 = b20[8],
            a21 = b20[9],
            a22 = b20[10],
            a23 = b20[11],
            a30 = b20[12],
            a31 = b20[13],
            a32 = b20[14],
            a33 = b20[15],
            b00 = x * x * t + b22,
            b01 = y * x * t + z * b21,
            b02 = z * x * t - y * b21,
            b10 = x * y * t - z * b21,
            b11 = y * y * t + b22,
            b12 = z * y * t + x * b21,
            b20 = x * z * t + y * b21,
            b21 = y * z * t - x * b21,
            b22 = z * z * t + b22;
        return this.setValues(a00 * b00 + a10 * b01 + a20 * b02, a01 * b00 + a11 * b01 + a21 * b02, a02 * b00 + a12 * b01 + a22 * b02, a03 * b00 + a13 * b01 + a23 * b02, a00 * b10 + a10 * b11 + a20 * b12, a01 * b10 + a11 * b11 + a21 * b12, a02 * b10 + a12 * b11 + a22 * b12, a03 * b10 + a13 * b11 + a23 * b12, a00 * b20 + a10 * b21 + a20 * b22, a01 * b20 + a11 * b21 + a21 * b22, a02 * b20 + a12 * b21 + a22 * b22, a03 * b20 + a13 * b21 + a23 * b22, a30, a31, a32, a33);
      },
      rotateX: function rotateX(a23) {
        var a = this.val,
            s = Math.sin(a23),
            c = Math.cos(a23),
            a10 = a[4],
            a11 = a[5],
            a12 = a[6],
            a13 = a[7],
            a20 = a[8],
            a21 = a[9],
            a22 = a[10],
            a23 = a[11];
        return a[4] = a10 * c + a20 * s, a[5] = a11 * c + a21 * s, a[6] = a12 * c + a22 * s, a[7] = a13 * c + a23 * s, a[8] = a20 * c - a10 * s, a[9] = a21 * c - a11 * s, a[10] = a22 * c - a12 * s, a[11] = a23 * c - a13 * s, this;
      },
      rotateY: function rotateY(a23) {
        var a = this.val,
            s = Math.sin(a23),
            c = Math.cos(a23),
            a00 = a[0],
            a01 = a[1],
            a02 = a[2],
            a03 = a[3],
            a20 = a[8],
            a21 = a[9],
            a22 = a[10],
            a23 = a[11];
        return a[0] = a00 * c - a20 * s, a[1] = a01 * c - a21 * s, a[2] = a02 * c - a22 * s, a[3] = a03 * c - a23 * s, a[8] = a00 * s + a20 * c, a[9] = a01 * s + a21 * c, a[10] = a02 * s + a22 * c, a[11] = a03 * s + a23 * c, this;
      },
      rotateZ: function rotateZ(a13) {
        var a = this.val,
            s = Math.sin(a13),
            c = Math.cos(a13),
            a00 = a[0],
            a01 = a[1],
            a02 = a[2],
            a03 = a[3],
            a10 = a[4],
            a11 = a[5],
            a12 = a[6],
            a13 = a[7];
        return a[0] = a00 * c + a10 * s, a[1] = a01 * c + a11 * s, a[2] = a02 * c + a12 * s, a[3] = a03 * c + a13 * s, a[4] = a10 * c - a00 * s, a[5] = a11 * c - a01 * s, a[6] = a12 * c - a02 * s, a[7] = a13 * c - a03 * s, this;
      },
      fromRotationTranslation: function fromRotationTranslation(xz, v) {
        var yy = xz.x,
            yz = xz.y,
            zz = xz.z,
            w = xz.w,
            wx = yy + yy,
            wy = yz + yz,
            wz = zz + zz,
            xx = yy * wx,
            xy = yy * wy,
            xz = yy * wz,
            yy = yz * wy,
            yz = yz * wz,
            zz = zz * wz,
            wx = w * wx,
            wy = w * wy,
            wz = w * wz;
        return this.setValues(1 - (yy + zz), xy + wz, xz - wy, 0, xy - wz, 1 - (xx + zz), yz + wx, 0, xz + wy, yz - wx, 1 - (xx + yy), 0, v.x, v.y, v.z, 1);
      },
      fromQuat: function fromQuat(xz) {
        var yy = xz.x,
            yz = xz.y,
            zz = xz.z,
            w = xz.w,
            wx = yy + yy,
            wy = yz + yz,
            wz = zz + zz,
            xx = yy * wx,
            xy = yy * wy,
            xz = yy * wz,
            yy = yz * wy,
            yz = yz * wz,
            zz = zz * wz,
            wx = w * wx,
            wy = w * wy,
            wz = w * wz;
        return this.setValues(1 - (yy + zz), xy + wz, xz - wy, 0, xy - wz, 1 - (xx + zz), yz + wx, 0, xz + wy, yz - wx, 1 - (xx + yy), 0, 0, 0, 0, 1);
      },
      frustum: function frustum(left, right, bottom, top, near, far) {
        var rl = 1 / (right - left),
            tb = 1 / (top - bottom),
            nf = 1 / (near - far);
        return this.setValues(2 * near * rl, 0, 0, 0, 0, 2 * near * tb, 0, 0, (right + left) * rl, (top + bottom) * tb, (far + near) * nf, -1, 0, 0, far * near * 2 * nf, 0);
      },
      perspective: function perspective(nf, aspect, near, far) {
        var f = 1 / Math.tan(nf / 2),
            nf = 1 / (near - far);
        return this.setValues(f / aspect, 0, 0, 0, 0, f, 0, 0, 0, 0, (far + near) * nf, -1, 0, 0, 2 * far * near * nf, 0);
      },
      perspectiveLH: function perspectiveLH(width, height, near, far) {
        return this.setValues(2 * near / width, 0, 0, 0, 0, 2 * near / height, 0, 0, 0, 0, -far / (near - far), 1, 0, 0, near * far / (near - far), 0);
      },
      ortho: function ortho(left, right, bottom, top, near, far) {
        var lr = 0 === (lr = left - right) ? lr : 1 / lr,
            bt = 0 === (bt = bottom - top) ? bt : 1 / bt,
            nf = 0 === (nf = near - far) ? nf : 1 / nf;
        return this.setValues(-2 * lr, 0, 0, 0, 0, -2 * bt, 0, 0, 0, 0, 2 * nf, 0, (left + right) * lr, (top + bottom) * bt, (far + near) * nf, 1);
      },
      lookAtRH: function lookAtRH(eye, target, up) {
        var m = this.val;
        return _z.subVectors(eye, target), 0 === _z.getLengthSquared() && (_z.z = 1), _z.normalize(), _x.crossVectors(up, _z), 0 === _x.getLengthSquared() && (1 === Math.abs(up.z) ? _z.x += 1e-4 : _z.z += 1e-4, _z.normalize(), _x.crossVectors(up, _z)), _x.normalize(), _y.crossVectors(_z, _x), m[0] = _x.x, m[1] = _x.y, m[2] = _x.z, m[4] = _y.x, m[5] = _y.y, m[6] = _y.z, m[8] = _z.x, m[9] = _z.y, m[10] = _z.z, this;
      },
      lookAt: function lookAt(z1, len, z2) {
        var eyex = z1.x,
            eyey = z1.y,
            eyez = z1.z,
            y1 = z2.x,
            y2 = z2.y,
            y0 = z2.z,
            x0 = len.x,
            x1 = len.y,
            x2 = len.z;
        if (Math.abs(eyex - x0) < 1e-6 && Math.abs(eyey - x1) < 1e-6 && Math.abs(eyez - x2) < 1e-6) return this.identity();
        var z0 = eyex - x0,
            z1 = eyey - x1,
            z2 = eyez - x2,
            len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2),
            x0 = y2 * (z2 *= len) - y0 * (z1 *= len),
            x1 = y0 * (z0 *= len) - y1 * z2,
            x2 = y1 * z1 - y2 * z0;
        (len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2)) ? (x0 *= len = 1 / len, x1 *= len, x2 *= len) : x2 = x1 = x0 = 0;
        y0 = z1 * x2 - z2 * x1, y1 = z2 * x0 - z0 * x2, y2 = z0 * x1 - z1 * x0;
        return (len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2)) ? (y0 *= len = 1 / len, y1 *= len, y2 *= len) : y2 = y1 = y0 = 0, this.setValues(x0, y0, z0, 0, x1, y1, z1, 0, x2, y2, z2, 0, -(x0 * eyex + x1 * eyey + x2 * eyez), -(y0 * eyex + y1 * eyey + y2 * eyez), -(z0 * eyex + z1 * eyey + z2 * eyez), 1);
      },
      yawPitchRoll: function yawPitchRoll(yaw, pitch, c) {
        this.zero(), _tempMat1.zero(), _tempMat2.zero();
        var m0 = this.val,
            m1 = _tempMat1.val,
            m2 = _tempMat2.val,
            s = Math.sin(c),
            c = Math.cos(c);
        return m0[10] = 1, m0[15] = 1, m0[0] = c, m0[1] = s, m0[4] = -s, m0[5] = c, s = Math.sin(pitch), c = Math.cos(pitch), m1[0] = 1, m1[15] = 1, m1[5] = c, m1[10] = c, m1[9] = -s, m1[6] = s, s = Math.sin(yaw), c = Math.cos(yaw), m2[5] = 1, m2[15] = 1, m2[0] = c, m2[2] = -s, m2[8] = s, m2[10] = c, this.multiplyLocal(_tempMat1), this.multiplyLocal(_tempMat2), this;
      },
      setWorldMatrix: function setWorldMatrix(rotation, position, scale, viewMatrix, projectionMatrix) {
        return this.yawPitchRoll(rotation.y, rotation.x, rotation.z), _tempMat1.scaling(scale.x, scale.y, scale.z), _tempMat2.xyz(position.x, position.y, position.z), this.multiplyLocal(_tempMat1), this.multiplyLocal(_tempMat2), viewMatrix && this.multiplyLocal(viewMatrix), projectionMatrix && this.multiplyLocal(projectionMatrix), this;
      },
      multiplyToMat4: function multiplyToMat4(b31, out) {
        var b32 = this.val,
            b33 = b31.val,
            a00 = b32[0],
            a01 = b32[1],
            a02 = b32[2],
            a03 = b32[3],
            a10 = b32[4],
            a11 = b32[5],
            a12 = b32[6],
            a13 = b32[7],
            a20 = b32[8],
            a21 = b32[9],
            a22 = b32[10],
            a23 = b32[11],
            a30 = b32[12],
            a31 = b32[13],
            a32 = b32[14],
            a33 = b32[15],
            b00 = b33[0],
            b01 = b33[1],
            b02 = b33[2],
            b03 = b33[3],
            b10 = b33[4],
            b11 = b33[5],
            b12 = b33[6],
            b13 = b33[7],
            b20 = b33[8],
            b21 = b33[9],
            b22 = b33[10],
            b23 = b33[11],
            b30 = b33[12],
            b31 = b33[13],
            b32 = b33[14],
            b33 = b33[15];
        return out.setValues(b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30, b01 * a01 + b01 * a11 + b02 * a21 + b03 * a31, b02 * a02 + b01 * a12 + b02 * a22 + b03 * a32, b03 * a03 + b01 * a13 + b02 * a23 + b03 * a33, b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30, b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31, b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32, b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33, b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30, b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31, b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32, b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33, b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30, b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31, b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32, b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33);
      },
      fromRotationXYTranslation: function fromRotationXYTranslation(c21, c02, translateFirst) {
        var x = c02.x,
            y = c02.y,
            z = c02.z,
            sx = Math.sin(c21.x),
            cx = Math.cos(c21.x),
            sy = Math.sin(c21.y),
            cy = Math.cos(c21.y),
            a30 = x,
            a31 = y,
            a32 = z,
            c22 = -sx,
            c01 = 0 - c22 * sy,
            c02 = 0 - cx * sy,
            c21 = c22 * cy,
            c22 = cx * cy;
        return translateFirst || (a30 = cy * x + sy * z, a31 = c01 * x + cx * y + c21 * z, a32 = c02 * x + sx * y + c22 * z), this.setValues(cy, c01, c02, 0, 0, cx, sx, 0, sy, c21, c22, 0, a30, a31, a32, 1);
      },
      getMaxScaleOnAxis: function getMaxScaleOnAxis() {
        var scaleZSq = this.val,
            scaleXSq = scaleZSq[0] * scaleZSq[0] + scaleZSq[1] * scaleZSq[1] + scaleZSq[2] * scaleZSq[2],
            scaleYSq = scaleZSq[4] * scaleZSq[4] + scaleZSq[5] * scaleZSq[5] + scaleZSq[6] * scaleZSq[6],
            scaleZSq = scaleZSq[8] * scaleZSq[8] + scaleZSq[9] * scaleZSq[9] + scaleZSq[10] * scaleZSq[10];
        return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
      }
    }),
        _tempMat1 = new Matrix4(),
        _tempMat2 = new Matrix4(),
        _x = new Vector3(),
        _y = new Vector3(),
        _z = new Vector3();

    module.exports = Matrix4;
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      COMPLETE: __webpack_require__(987),
      DECODED: __webpack_require__(988),
      DECODED_ALL: __webpack_require__(989),
      DESTROY: __webpack_require__(990),
      DETUNE: __webpack_require__(991),
      GLOBAL_DETUNE: __webpack_require__(992),
      GLOBAL_MUTE: __webpack_require__(993),
      GLOBAL_RATE: __webpack_require__(994),
      GLOBAL_VOLUME: __webpack_require__(995),
      LOOP: __webpack_require__(996),
      LOOPED: __webpack_require__(997),
      MUTE: __webpack_require__(998),
      PAN: __webpack_require__(999),
      PAUSE_ALL: __webpack_require__(1e3),
      PAUSE: __webpack_require__(1001),
      PLAY: __webpack_require__(1002),
      RATE: __webpack_require__(1003),
      RESUME_ALL: __webpack_require__(1004),
      RESUME: __webpack_require__(1005),
      SEEK: __webpack_require__(1006),
      STOP_ALL: __webpack_require__(1007),
      STOP: __webpack_require__(1008),
      UNLOCKED: __webpack_require__(1009),
      VOLUME: __webpack_require__(1010)
    };
  }, function (module, exports, __webpack_require__) {
    var Class = __webpack_require__(0),
        CONST = __webpack_require__(21),
        File = __webpack_require__(23),
        FileTypesManager = __webpack_require__(8),
        GetFastValue = __webpack_require__(2),
        IsPlainObject = __webpack_require__(7),
        ImageFile = new Class({
      Extends: File,
      initialize: function ImageFile(loader, key, fileConfig, xhrSettings, normalMap) {
        var normalMapURL,
            config,
            extension = "png";
        IsPlainObject(key) && (key = GetFastValue(config = key, "key"), fileConfig = GetFastValue(config, "url"), normalMapURL = GetFastValue(config, "normalMap"), xhrSettings = GetFastValue(config, "xhrSettings"), extension = GetFastValue(config, "extension", extension), normalMap = GetFastValue(config, "frameConfig")), Array.isArray(fileConfig) && (normalMapURL = fileConfig[1], fileConfig = fileConfig[0]);
        fileConfig = {
          type: "image",
          cache: loader.textureManager,
          extension: extension,
          responseType: "blob",
          key: key,
          url: fileConfig,
          xhrSettings: xhrSettings,
          config: normalMap
        };
        File.call(this, loader, fileConfig), normalMapURL && ((normalMap = new ImageFile(loader, this.key, normalMapURL, xhrSettings, normalMap)).type = "normalMap", this.setLink(normalMap), loader.addFile(normalMap));
      },
      onProcess: function onProcess() {
        this.state = CONST.FILE_PROCESSING, this.data = new Image(), this.data.crossOrigin = this.crossOrigin;

        var _this = this;

        this.data.onload = function () {
          File.revokeObjectURL(_this.data), _this.onProcessComplete();
        }, this.data.onerror = function () {
          File.revokeObjectURL(_this.data), _this.onProcessError();
        }, File.createObjectURL(this.data, this.xhrLoader.response, "image/png");
      },
      addToCache: function addToCache() {
        var texture,
            linkFile = this.linkFile;
        linkFile && linkFile.state === CONST.FILE_COMPLETE ? (texture = "image" === this.type ? this.cache.addImage(this.key, this.data, linkFile.data) : this.cache.addImage(linkFile.key, linkFile.data, this.data), this.pendingDestroy(texture), linkFile.pendingDestroy(texture)) : linkFile || (texture = this.cache.addImage(this.key, this.data), this.pendingDestroy(texture));
      }
    });

    FileTypesManager.register("image", function (key, url, xhrSettings) {
      if (Array.isArray(key)) for (var i = 0; i < key.length; i++) {
        this.addFile(new ImageFile(this, key[i]));
      } else this.addFile(new ImageFile(this, key, url, xhrSettings));
      return this;
    }), module.exports = ImageFile;
  }, function (module, exports) {
    module.exports = function (tile, collides) {
      collides ? tile.setCollision(!0, !0, !0, !0, !1) : tile.resetCollision(!1);
    };
  }, function (module, exports, Sprite) {
    var AnimationState = Sprite(164),
        Class = Sprite(0),
        Components = Sprite(11),
        GameObject = Sprite(15),
        Sprite = Sprite(1065),
        Sprite = new Class({
      Extends: GameObject,
      Mixins: [Components.Alpha, Components.BlendMode, Components.Depth, Components.Flip, Components.GetBounds, Components.Mask, Components.Origin, Components.Pipeline, Components.ScrollFactor, Components.Size, Components.TextureCrop, Components.Tint, Components.Transform, Components.Visible, Sprite],
      initialize: function initialize(scene, x, y, texture, frame) {
        GameObject.call(this, scene, "Sprite"), this._crop = this.resetCropObject(), this.anims = new AnimationState(this), this.setTexture(texture, frame), this.setPosition(x, y), this.setSizeToFrame(), this.setOriginFromFrame(), this.initPipeline();
      },
      addedToScene: function addedToScene() {
        this.scene.sys.updateList.add(this);
      },
      removedFromScene: function removedFromScene() {
        this.scene.sys.updateList.remove(this);
      },
      preUpdate: function preUpdate(time, delta) {
        this.anims.update(time, delta);
      },
      play: function play(key, ignoreIfPlaying) {
        return this.anims.play(key, ignoreIfPlaying);
      },
      playReverse: function playReverse(key, ignoreIfPlaying) {
        return this.anims.playReverse(key, ignoreIfPlaying);
      },
      playAfterDelay: function playAfterDelay(key, delay) {
        return this.anims.playAfterDelay(key, delay);
      },
      playAfterRepeat: function playAfterRepeat(key, repeatCount) {
        return this.anims.playAfterRepeat(key, repeatCount);
      },
      chain: function chain(key) {
        return this.anims.chain(key);
      },
      stop: function stop() {
        return this.anims.stop();
      },
      stopAfterDelay: function stopAfterDelay(delay) {
        return this.anims.stopAfterDelay(delay);
      },
      stopAfterRepeat: function stopAfterRepeat(repeatCount) {
        return this.anims.stopAfterRepeat(repeatCount);
      },
      stopOnFrame: function stopOnFrame(frame) {
        return this.anims.stopOnFrame(frame);
      },
      toJSON: function toJSON() {
        return Components.ToJSON(this);
      },
      preDestroy: function preDestroy() {
        this.anims.destroy(), this.anims = void 0;
      }
    });
    module.exports = Sprite;
  }, function (module, exports) {
    module.exports = function (array, index) {
      if (!(index >= array.length)) {
        for (var len = array.length - 1, item = array[index], i = index; i < len; i++) {
          array[i] = array[i + 1];
        }

        return array.length = len, item;
      }
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      ADDED_TO_SCENE: __webpack_require__(643),
      DESTROY: __webpack_require__(644),
      REMOVED_FROM_SCENE: __webpack_require__(645),
      VIDEO_COMPLETE: __webpack_require__(646),
      VIDEO_CREATED: __webpack_require__(647),
      VIDEO_ERROR: __webpack_require__(648),
      VIDEO_LOOP: __webpack_require__(649),
      VIDEO_PLAY: __webpack_require__(650),
      VIDEO_SEEKED: __webpack_require__(651),
      VIDEO_SEEKING: __webpack_require__(652),
      VIDEO_STOP: __webpack_require__(653),
      VIDEO_TIMEOUT: __webpack_require__(654),
      VIDEO_UNLOCKED: __webpack_require__(655)
    };
  }, function (module, exports) {
    module.exports = function (value, gap, start, divide) {
      return 0 === gap ? value : (value -= start = void 0 === start ? 0 : start, value = gap * Math.floor(value / gap), divide ? (start + value) / gap : start + value);
    };
  }, function (module, exports) {
    module.exports = function (obj) {
      var key,
          clone = {};

      for (key in obj) {
        Array.isArray(obj[key]) ? clone[key] = obj[key].slice(0) : clone[key] = obj[key];
      }

      return clone;
    };
  }, function (module, exports) {
    module.exports = function (len, startIndex, endIndex, throwError) {
      len = len.length;

      if (startIndex < 0 || len < startIndex || endIndex <= startIndex || len < endIndex || len < startIndex + endIndex) {
        if (throwError) throw new Error("Range Error: Values outside acceptable range");
        return !1;
      }

      return !0;
    };
  }, function (module, exports) {
    function Compare(a, b) {
      return String(a).localeCompare(b);
    }

    function RunPass(arr, comp, chk, result) {
      for (var r, e, li, ri, len = arr.length, i = 0, dbl = 2 * chk, l = 0; l < len; l += dbl) {
        for (len < (e = (r = l + chk) + chk) && (e = len), li = l, ri = r = len < r ? len : r;;) {
          if (li < r && ri < e) comp(arr[li], arr[ri]) <= 0 ? result[i++] = arr[li++] : result[i++] = arr[ri++];else if (li < r) result[i++] = arr[li++];else {
            if (!(ri < e)) break;
            result[i++] = arr[ri++];
          }
        }
      }
    }

    module.exports = function (array, result) {
      result = function (array, compare) {
        var len = array.length;
        if (len <= 1) return array;

        for (var buffer = new Array(len), chk = 1; chk < len; chk *= 2) {
          RunPass(array, compare, chk, buffer);
          var tmp = array;
          array = buffer, buffer = tmp;
        }

        return array;
      }(array, result = void 0 === result ? Compare : result);

      return result !== array && RunPass(result, null, array.length, array), array;
    };
  }, function (module, exports, __webpack_require__) {
    var EaseMap = __webpack_require__(134),
        UppercaseFirst = __webpack_require__(205);

    module.exports = function (ease, easeParams) {
      var direction,
          easeFunction = EaseMap.Power0;
      if ("string" == typeof ease ? EaseMap.hasOwnProperty(ease) ? easeFunction = EaseMap[ease] : (direction = "", ease.indexOf(".") && ("in" === (direction = ease.substr(ease.indexOf(".") + 1)).toLowerCase() ? direction = "easeIn" : "out" === direction.toLowerCase() ? direction = "easeOut" : "inout" === direction.toLowerCase() && (direction = "easeInOut")), ease = UppercaseFirst(ease.substr(0, ease.indexOf(".") + 1) + direction), EaseMap.hasOwnProperty(ease) && (easeFunction = EaseMap[ease])) : "function" == typeof ease ? easeFunction = ease : Array.isArray(ease) && ease.length, !easeParams) return easeFunction;
      var cloneParams = easeParams.slice(0);
      return cloneParams.unshift(0), function (v) {
        return cloneParams[0] = v, easeFunction.apply(this, cloneParams);
      };
    };
  }, function (module, exports, __webpack_require__) {
    var Utils = __webpack_require__(12);

    module.exports = function (pipeline, src, strokeTintColor, dx, dy) {
      var strokeTint = pipeline.strokeTint,
          strokeTintColor = Utils.getTintAppendFloatAlpha(src.strokeColor, src.strokeAlpha * strokeTintColor);
      strokeTint.TL = strokeTintColor, strokeTint.TR = strokeTintColor, strokeTint.BL = strokeTintColor, strokeTint.BR = strokeTintColor;
      var path = src.pathData,
          pathLength = path.length - 1,
          lineWidth = src.lineWidth,
          halfLineWidth = lineWidth / 2,
          px1 = path[0] - dx,
          py1 = path[1] - dy;
      src.closePath || (pathLength -= 2);

      for (var i = 2; i < pathLength; i += 2) {
        var px2 = path[i] - dx,
            py2 = path[i + 1] - dy;
        pipeline.batchLine(px1, py1, px2, py2, halfLineWidth, halfLineWidth, lineWidth, i - 2, !!src.closePath && i === pathLength - 1), px1 = px2, py1 = py2;
      }
    };
  }, function (module, exports, __webpack_require__) {
    var Triangle = __webpack_require__(0),
        Contains = __webpack_require__(115),
        GetPoint = __webpack_require__(476),
        GetPoints = __webpack_require__(477),
        GEOM_CONST = __webpack_require__(56),
        Line = __webpack_require__(47),
        Random = __webpack_require__(181),
        Triangle = new Triangle({
      initialize: function initialize(x1, y1, x2, y2, x3, y3) {
        void 0 === x1 && (x1 = 0), void 0 === y1 && (y1 = 0), void 0 === x2 && (x2 = 0), void 0 === y2 && (y2 = 0), void 0 === x3 && (x3 = 0), void 0 === y3 && (y3 = 0), this.type = GEOM_CONST.TRIANGLE, this.x1 = x1, this.y1 = y1, this.x2 = x2, this.y2 = y2, this.x3 = x3, this.y3 = y3;
      },
      contains: function contains(x, y) {
        return Contains(this, x, y);
      },
      getPoint: function getPoint(position, output) {
        return GetPoint(this, position, output);
      },
      getPoints: function getPoints(quantity, stepRate, output) {
        return GetPoints(this, quantity, stepRate, output);
      },
      getRandomPoint: function getRandomPoint(point) {
        return Random(this, point);
      },
      setTo: function setTo(x1, y1, x2, y2, x3, y3) {
        return void 0 === y1 && (y1 = 0), void 0 === x2 && (x2 = 0), void 0 === y2 && (y2 = 0), void 0 === x3 && (x3 = 0), void 0 === y3 && (y3 = 0), this.x1 = x1 = void 0 === x1 ? 0 : x1, this.y1 = y1, this.x2 = x2, this.y2 = y2, this.x3 = x3, this.y3 = y3, this;
      },
      getLineA: function getLineA(line) {
        return (line = void 0 === line ? new Line() : line).setTo(this.x1, this.y1, this.x2, this.y2), line;
      },
      getLineB: function getLineB(line) {
        return (line = void 0 === line ? new Line() : line).setTo(this.x2, this.y2, this.x3, this.y3), line;
      },
      getLineC: function getLineC(line) {
        return (line = void 0 === line ? new Line() : line).setTo(this.x3, this.y3, this.x1, this.y1), line;
      },
      left: {
        get: function get() {
          return Math.min(this.x1, this.x2, this.x3);
        },
        set: function set(value) {
          var diff = 0,
              diff = this.x1 <= this.x2 && this.x1 <= this.x3 ? this.x1 - value : this.x2 <= this.x1 && this.x2 <= this.x3 ? this.x2 - value : this.x3 - value;
          this.x1 -= diff, this.x2 -= diff, this.x3 -= diff;
        }
      },
      right: {
        get: function get() {
          return Math.max(this.x1, this.x2, this.x3);
        },
        set: function set(value) {
          var diff = 0,
              diff = this.x1 >= this.x2 && this.x1 >= this.x3 ? this.x1 - value : this.x2 >= this.x1 && this.x2 >= this.x3 ? this.x2 - value : this.x3 - value;
          this.x1 -= diff, this.x2 -= diff, this.x3 -= diff;
        }
      },
      top: {
        get: function get() {
          return Math.min(this.y1, this.y2, this.y3);
        },
        set: function set(value) {
          var diff = 0,
              diff = this.y1 <= this.y2 && this.y1 <= this.y3 ? this.y1 - value : this.y2 <= this.y1 && this.y2 <= this.y3 ? this.y2 - value : this.y3 - value;
          this.y1 -= diff, this.y2 -= diff, this.y3 -= diff;
        }
      },
      bottom: {
        get: function get() {
          return Math.max(this.y1, this.y2, this.y3);
        },
        set: function set(value) {
          var diff = 0,
              diff = this.y1 >= this.y2 && this.y1 >= this.y3 ? this.y1 - value : this.y2 >= this.y1 && this.y2 >= this.y3 ? this.y2 - value : this.y3 - value;
          this.y1 -= diff, this.y2 -= diff, this.y3 -= diff;
        }
      }
    });

    module.exports = Triangle;
  }, function (module, exports) {
    var Vector = {};
    (module.exports = Vector).create = function (x, y) {
      return {
        x: x || 0,
        y: y || 0
      };
    }, Vector.clone = function (vector) {
      return {
        x: vector.x,
        y: vector.y
      };
    }, Vector.magnitude = function (vector) {
      return Math.sqrt(vector.x * vector.x + vector.y * vector.y);
    }, Vector.magnitudeSquared = function (vector) {
      return vector.x * vector.x + vector.y * vector.y;
    }, Vector.rotate = function (vector, x, output) {
      var cos = Math.cos(x),
          sin = Math.sin(x),
          x = vector.x * cos - vector.y * sin;
      return (output = output || {}).y = vector.x * sin + vector.y * cos, output.x = x, output;
    }, Vector.rotateAbout = function (vector, x, point, output) {
      var cos = Math.cos(x),
          sin = Math.sin(x),
          x = point.x + ((vector.x - point.x) * cos - (vector.y - point.y) * sin);
      return (output = output || {}).y = point.y + ((vector.x - point.x) * sin + (vector.y - point.y) * cos), output.x = x, output;
    }, Vector.normalise = function (vector) {
      var magnitude = Vector.magnitude(vector);
      return 0 === magnitude ? {
        x: 0,
        y: 0
      } : {
        x: vector.x / magnitude,
        y: vector.y / magnitude
      };
    }, Vector.dot = function (vectorA, vectorB) {
      return vectorA.x * vectorB.x + vectorA.y * vectorB.y;
    }, Vector.cross = function (vectorA, vectorB) {
      return vectorA.x * vectorB.y - vectorA.y * vectorB.x;
    }, Vector.cross3 = function (vectorA, vectorB, vectorC) {
      return (vectorB.x - vectorA.x) * (vectorC.y - vectorA.y) - (vectorB.y - vectorA.y) * (vectorC.x - vectorA.x);
    }, Vector.add = function (vectorA, vectorB, output) {
      return (output = output || {}).x = vectorA.x + vectorB.x, output.y = vectorA.y + vectorB.y, output;
    }, Vector.sub = function (vectorA, vectorB, output) {
      return (output = output || {}).x = vectorA.x - vectorB.x, output.y = vectorA.y - vectorB.y, output;
    }, Vector.mult = function (vector, scalar) {
      return {
        x: vector.x * scalar,
        y: vector.y * scalar
      };
    }, Vector.div = function (vector, scalar) {
      return {
        x: vector.x / scalar,
        y: vector.y / scalar
      };
    }, Vector.perp = function (vector, negate) {
      return {
        x: (negate = !0 === negate ? -1 : 1) * -vector.y,
        y: negate * vector.x
      };
    }, Vector.neg = function (vector) {
      return {
        x: -vector.x,
        y: -vector.y
      };
    }, Vector.angle = function (vectorA, vectorB) {
      return Math.atan2(vectorB.y - vectorA.y, vectorB.x - vectorA.x);
    }, Vector._temp = [Vector.create(), Vector.create(), Vector.create(), Vector.create(), Vector.create(), Vector.create()];
  }, function (module, exports) {
    var Bounds = {};
    (module.exports = Bounds).create = function (vertices) {
      var bounds = {
        min: {
          x: 0,
          y: 0
        },
        max: {
          x: 0,
          y: 0
        }
      };
      return vertices && Bounds.update(bounds, vertices), bounds;
    }, Bounds.update = function (bounds, vertices, velocity) {
      bounds.min.x = 1 / 0, bounds.max.x = -1 / 0, bounds.min.y = 1 / 0, bounds.max.y = -1 / 0;

      for (var i = 0; i < vertices.length; i++) {
        var vertex = vertices[i];
        vertex.x > bounds.max.x && (bounds.max.x = vertex.x), vertex.x < bounds.min.x && (bounds.min.x = vertex.x), vertex.y > bounds.max.y && (bounds.max.y = vertex.y), vertex.y < bounds.min.y && (bounds.min.y = vertex.y);
      }

      velocity && (0 < velocity.x ? bounds.max.x += velocity.x : bounds.min.x += velocity.x, 0 < velocity.y ? bounds.max.y += velocity.y : bounds.min.y += velocity.y);
    }, Bounds.contains = function (bounds, point) {
      return point.x >= bounds.min.x && point.x <= bounds.max.x && point.y >= bounds.min.y && point.y <= bounds.max.y;
    }, Bounds.overlaps = function (boundsA, boundsB) {
      return boundsA.min.x <= boundsB.max.x && boundsA.max.x >= boundsB.min.x && boundsA.max.y >= boundsB.min.y && boundsA.min.y <= boundsB.max.y;
    }, Bounds.translate = function (bounds, vector) {
      bounds.min.x += vector.x, bounds.max.x += vector.x, bounds.min.y += vector.y, bounds.max.y += vector.y;
    }, Bounds.shift = function (bounds, position) {
      var deltaX = bounds.max.x - bounds.min.x,
          deltaY = bounds.max.y - bounds.min.y;
      bounds.min.x = position.x, bounds.max.x = position.x + deltaX, bounds.min.y = position.y, bounds.max.y = position.y + deltaY;
    };
  }, function (module, exports, __webpack_require__) {
    var CONST = __webpack_require__(29),
        Class = __webpack_require__(0),
        Tile = __webpack_require__(11),
        Rectangle = __webpack_require__(502),
        Tile = new Class({
      Mixins: [Tile.Alpha, Tile.Flip, Tile.Visible],
      initialize: function initialize(layer, index, x, y, width, height, baseWidth, baseHeight) {
        this.layer = layer, this.index = index, this.x = x, this.y = y, this.width = width, this.height = height, this.right, this.bottom, this.baseWidth = void 0 !== baseWidth ? baseWidth : width, this.baseHeight = void 0 !== baseHeight ? baseHeight : height, this.pixelX = 0, this.pixelY = 0, this.updatePixelXY(), this.properties = {}, this.rotation = 0, this.collideLeft = !1, this.collideRight = !1, this.collideUp = !1, this.collideDown = !1, this.faceLeft = !1, this.faceRight = !1, this.faceTop = !1, this.faceBottom = !1, this.collisionCallback = void 0, (this.collisionCallbackContext = this).tint = 16777215, this.physics = {};
      },
      containsPoint: function containsPoint(x, y) {
        return !(x < this.pixelX || y < this.pixelY || x > this.right || y > this.bottom);
      },
      copy: function copy(tile) {
        return this.index = tile.index, this.alpha = tile.alpha, this.properties = tile.properties, this.visible = tile.visible, this.setFlip(tile.flipX, tile.flipY), this.tint = tile.tint, this.rotation = tile.rotation, this.collideUp = tile.collideUp, this.collideDown = tile.collideDown, this.collideLeft = tile.collideLeft, this.collideRight = tile.collideRight, this.collisionCallback = tile.collisionCallback, this.collisionCallbackContext = tile.collisionCallbackContext, this;
      },
      getCollisionGroup: function getCollisionGroup() {
        return this.tileset ? this.tileset.getTileCollisionGroup(this.index) : null;
      },
      getTileData: function getTileData() {
        return this.tileset ? this.tileset.getTileData(this.index) : null;
      },
      getLeft: function getLeft(camera) {
        var tilemapLayer = this.tilemapLayer;
        return tilemapLayer ? tilemapLayer.tileToWorldX(this.x, camera) : this.x * this.baseWidth;
      },
      getRight: function getRight(camera) {
        var tilemapLayer = this.tilemapLayer;
        return tilemapLayer ? this.getLeft(camera) + this.width * tilemapLayer.scaleX : this.getLeft(camera) + this.width;
      },
      getTop: function getTop(camera) {
        var tilemapLayer = this.tilemapLayer;
        return tilemapLayer ? tilemapLayer.tileToWorldY(this.y, camera) - (this.height - this.baseHeight) * tilemapLayer.scaleY : this.y * this.baseHeight - (this.height - this.baseHeight);
      },
      getBottom: function getBottom(camera) {
        var tilemapLayer = this.tilemapLayer;
        return tilemapLayer ? this.getTop(camera) + this.height * tilemapLayer.scaleY : this.getTop(camera) + this.height;
      },
      getBounds: function getBounds(camera, output) {
        return (output = void 0 === output ? new Rectangle() : output).x = this.getLeft(), output.y = this.getTop(), output.width = this.getRight() - output.x, output.height = this.getBottom() - output.y, output;
      },
      getCenterX: function getCenterX(camera) {
        return (this.getLeft(camera) + this.getRight(camera)) / 2;
      },
      getCenterY: function getCenterY(camera) {
        return (this.getTop(camera) + this.getBottom(camera)) / 2;
      },
      intersects: function intersects(x, y, right, bottom) {
        return !(right <= this.pixelX || bottom <= this.pixelY || x >= this.right || y >= this.bottom);
      },
      isInteresting: function isInteresting(collides, faces) {
        return collides && faces ? this.canCollide || this.hasInterestingFace : collides ? this.collides : !!faces && this.hasInterestingFace;
      },
      resetCollision: function resetCollision(recalculateFaces) {
        return void 0 === recalculateFaces && (recalculateFaces = !0), this.collideLeft = !1, this.collideRight = !1, this.collideUp = !1, this.collideDown = !1, this.faceTop = !1, this.faceBottom = !1, this.faceLeft = !1, this.faceRight = !1, recalculateFaces && this.tilemapLayer && this.tilemapLayer.calculateFacesAt(this.x, this.y), this;
      },
      resetFaces: function resetFaces() {
        return this.faceTop = !1, this.faceBottom = !1, this.faceLeft = !1, this.faceRight = !1, this;
      },
      setCollision: function setCollision(left, right, up, down, recalculateFaces) {
        return void 0 === right && (right = left), void 0 === up && (up = left), void 0 === down && (down = left), void 0 === recalculateFaces && (recalculateFaces = !0), this.collideLeft = left, this.collideRight = right, this.collideUp = up, this.collideDown = down, this.faceLeft = left, this.faceRight = right, this.faceTop = up, this.faceBottom = down, recalculateFaces && this.tilemapLayer && this.tilemapLayer.calculateFacesAt(this.x, this.y), this;
      },
      setCollisionCallback: function setCollisionCallback(callback, context) {
        return null === callback ? (this.collisionCallback = void 0, this.collisionCallbackContext = void 0) : (this.collisionCallback = callback, this.collisionCallbackContext = context), this;
      },
      setSize: function setSize(tileWidth, tileHeight, baseWidth, baseHeight) {
        return void 0 !== tileWidth && (this.width = tileWidth), void 0 !== tileHeight && (this.height = tileHeight), void 0 !== baseWidth && (this.baseWidth = baseWidth), void 0 !== baseHeight && (this.baseHeight = baseHeight), this.updatePixelXY(), this;
      },
      updatePixelXY: function updatePixelXY() {
        var rowHeight = this.layer.orientation;
        return rowHeight === CONST.ORTHOGONAL ? (this.pixelX = this.x * this.baseWidth, this.pixelY = this.y * this.baseHeight) : rowHeight === CONST.ISOMETRIC ? (this.pixelX = (this.x - this.y) * this.baseWidth * .5, this.pixelY = (this.x + this.y) * this.baseHeight * .5) : rowHeight === CONST.STAGGERED ? (this.pixelX = this.x * this.baseWidth + this.y % 2 * (this.baseWidth / 2), this.pixelY = this.y * (this.baseHeight / 2)) : rowHeight === CONST.HEXAGONAL && (rowHeight = this.layer.hexSideLength, rowHeight = (this.baseHeight - rowHeight) / 2 + rowHeight, this.pixelX = this.x * this.baseWidth + this.y % 2 * (this.baseWidth / 2), this.pixelY = this.y * rowHeight), this.right = this.pixelX + this.baseWidth, this.bottom = this.pixelY + this.baseHeight, this;
      },
      destroy: function destroy() {
        this.collisionCallback = void 0, this.collisionCallbackContext = void 0, this.properties = void 0;
      },
      canCollide: {
        get: function get() {
          return this.collideLeft || this.collideRight || this.collideUp || this.collideDown || void 0 !== this.collisionCallback;
        }
      },
      collides: {
        get: function get() {
          return this.collideLeft || this.collideRight || this.collideUp || this.collideDown;
        }
      },
      hasInterestingFace: {
        get: function get() {
          return this.faceTop || this.faceBottom || this.faceLeft || this.faceRight;
        }
      },
      tileset: {
        get: function get() {
          var tileset = this.layer.tilemapLayer;

          if (tileset) {
            tileset = tileset.gidMap[this.index];
            if (tileset) return tileset;
          }

          return null;
        }
      },
      tilemapLayer: {
        get: function get() {
          return this.layer.tilemapLayer;
        }
      },
      tilemap: {
        get: function get() {
          var tilemapLayer = this.tilemapLayer;
          return tilemapLayer ? tilemapLayer.tilemap : null;
        }
      }
    });

    module.exports = Tile;
  }, function (module, exports, __webpack_require__) {
    var Bodies = {};
    module.exports = Bodies;

    var Vertices = __webpack_require__(64),
        Common = __webpack_require__(32),
        Body = __webpack_require__(41),
        Bounds = __webpack_require__(84),
        Vector = __webpack_require__(83),
        decomp = __webpack_require__(1393);

    Bodies.rectangle = function (x, y, rectangle, chamfer, options) {
      options = options || {};
      rectangle = {
        label: "Rectangle Body",
        position: {
          x: x,
          y: y
        },
        vertices: Vertices.fromPath("L 0 0 L " + rectangle + " 0 L " + rectangle + " " + chamfer + " L 0 " + chamfer)
      };
      return options.chamfer && (chamfer = options.chamfer, rectangle.vertices = Vertices.chamfer(rectangle.vertices, chamfer.radius, chamfer.quality, chamfer.qualityMin, chamfer.qualityMax), delete options.chamfer), Body.create(Common.extend({}, rectangle, options));
    }, Bodies.trapezoid = function (x, trapezoid, chamfer, height, slope, options) {
      options = options || {};
      var x1 = chamfer * (slope *= .5),
          x2 = x1 + (1 - 2 * slope) * chamfer,
          chamfer = x2 + x1,
          chamfer = slope < .5 ? "L 0 0 L " + x1 + " " + -height + " L " + x2 + " " + -height + " L " + chamfer + " 0" : "L 0 0 L " + x2 + " " + -height + " L " + chamfer + " 0",
          trapezoid = {
        label: "Trapezoid Body",
        position: {
          x: x,
          y: trapezoid
        },
        vertices: Vertices.fromPath(chamfer)
      };
      return options.chamfer && (chamfer = options.chamfer, trapezoid.vertices = Vertices.chamfer(trapezoid.vertices, chamfer.radius, chamfer.quality, chamfer.qualityMin, chamfer.qualityMax), delete options.chamfer), Body.create(Common.extend({}, trapezoid, options));
    }, Bodies.circle = function (x, y, radius, options, sides) {
      options = options || {};
      var circle = {
        label: "Circle Body",
        circleRadius: radius
      };
      sides = sides || 25;
      sides = Math.ceil(Math.max(10, Math.min(sides, radius)));
      return sides % 2 == 1 && (sides += 1), Bodies.polygon(x, y, sides, radius, Common.extend({}, circle, options));
    }, Bodies.polygon = function (polygon, chamfer, sides, radius, options) {
      if (options = options || {}, sides < 3) return Bodies.circle(polygon, chamfer, radius, options);

      for (var theta = 2 * Math.PI / sides, path = "", offset = .5 * theta, i = 0; i < sides; i += 1) {
        var yy = offset + i * theta,
            xx = Math.cos(yy) * radius,
            yy = Math.sin(yy) * radius;
        path += "L " + xx.toFixed(3) + " " + yy.toFixed(3) + " ";
      }

      polygon = {
        label: "Polygon Body",
        position: {
          x: polygon,
          y: chamfer
        },
        vertices: Vertices.fromPath(path)
      };
      return options.chamfer && (chamfer = options.chamfer, polygon.vertices = Vertices.chamfer(polygon.vertices, chamfer.radius, chamfer.quality, chamfer.qualityMin, chamfer.qualityMax), delete options.chamfer), Body.create(Common.extend({}, polygon, options));
    }, Bodies.fromVertices = function (x, y, vertexSets, options, body, removeCollinear, minimumArea) {
      var parts, isConvex, v;

      for (options = options || {}, parts = [], body = void 0 !== body && body, removeCollinear = void 0 !== removeCollinear ? removeCollinear : .01, minimumArea = void 0 !== minimumArea ? minimumArea : 10, decomp || Common.warn("Bodies.fromVertices: poly-decomp.js required. Could not decompose vertices. Fallback to convex hull."), Common.isArray(vertexSets[0]) || (vertexSets = [vertexSets]), v = 0; v < vertexSets.length; v += 1) {
        if (concave = vertexSets[v], (isConvex = Vertices.isConvex(concave)) || !decomp) concave = isConvex ? Vertices.clockwiseSort(concave) : Vertices.hull(concave), parts.push({
          position: {
            x: x,
            y: y
          },
          vertices: concave
        });else {
          var concave = concave.map(function (vertex) {
            return [vertex.x, vertex.y];
          });
          decomp.makeCCW(concave), !1 !== removeCollinear && decomp.removeCollinearPoints(concave, removeCollinear);

          for (var decomposed = decomp.quickDecomp(concave), i = 0; i < decomposed.length; i++) {
            var chunkVertices = decomposed[i].map(function (vertices) {
              return {
                x: vertices[0],
                y: vertices[1]
              };
            });
            0 < minimumArea && Vertices.area(chunkVertices) < minimumArea || parts.push({
              position: Vertices.centre(chunkVertices),
              vertices: chunkVertices
            });
          }
        }
      }

      for (i = 0; i < parts.length; i++) {
        parts[i] = Body.create(Common.extend(parts[i], options));
      }

      return body && Bodies.flagCoincidentParts(parts, 5), 1 < parts.length ? (body = Body.create(Common.extend({
        parts: parts.slice(0)
      }, options)), Body.setPosition(body, {
        x: x,
        y: y
      }), body) : parts[0];
    }, Bodies.flagCoincidentParts = function (parts, maxDistance) {
      void 0 === maxDistance && (maxDistance = 5);

      for (var i = 0; i < parts.length; i++) {
        for (var partA = parts[i], j = i + 1; j < parts.length; j++) {
          var partB = parts[j];
          if (Bounds.overlaps(partA.bounds, partB.bounds)) for (var pav = partA.vertices, pbv = partB.vertices, k = 0; k < partA.vertices.length; k++) {
            for (var z = 0; z < partB.vertices.length; z++) {
              var da = Vector.magnitudeSquared(Vector.sub(pav[(k + 1) % pav.length], pbv[z])),
                  db = Vector.magnitudeSquared(Vector.sub(pav[k], pbv[(z + 1) % pbv.length]));
              da < maxDistance && db < maxDistance && (pav[k].isInternal = !0, pbv[z].isInternal = !0);
            }
          }
        }
      }

      return parts;
    };
  }, function (module, exports) {
    module.exports = function (gameObject) {
      return gameObject.x - gameObject.width * gameObject.originX + .5 * gameObject.width;
    };
  }, function (module, exports) {
    module.exports = function (gameObject, x) {
      var offsetX = gameObject.width * gameObject.originX;
      return gameObject.x = x + offsetX - .5 * gameObject.width, gameObject;
    };
  }, function (module, exports) {
    module.exports = function (gameObject) {
      return gameObject.y - gameObject.height * gameObject.originY + .5 * gameObject.height;
    };
  }, function (module, exports) {
    module.exports = function (gameObject, y) {
      var offsetY = gameObject.height * gameObject.originY;
      return gameObject.y = y + offsetY - .5 * gameObject.height, gameObject;
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      POST_RENDER: __webpack_require__(628),
      PRE_RENDER: __webpack_require__(629),
      RENDER: __webpack_require__(630),
      RESIZE: __webpack_require__(631)
    };
  }, function (module, exports) {
    module.exports = {
      BITMAPMASK_PIPELINE: "BitmapMaskPipeline",
      LIGHT_PIPELINE: "Light2D",
      POINTLIGHT_PIPELINE: "PointLightPipeline",
      SINGLE_PIPELINE: "SinglePipeline",
      MULTI_PIPELINE: "MultiPipeline",
      ROPE_PIPELINE: "RopePipeline",
      GRAPHICS_PIPELINE: "GraphicsPipeline",
      POSTFX_PIPELINE: "PostFXPipeline",
      UTILITY_PIPELINE: "UtilityPipeline"
    };
  }, function (module, exports, __webpack_require__) {
    var SpliceOne = __webpack_require__(74);

    module.exports = function (array, item, callback, context) {
      if (void 0 === context && (context = array), !Array.isArray(item)) return -1 !== (index = array.indexOf(item)) ? (SpliceOne(array, index), callback && callback.call(context, item), item) : null;

      for (var itemLength = item.length - 1, removed = []; 0 <= itemLength;) {
        var index,
            entry = item[itemLength];
        -1 !== (index = array.indexOf(entry)) && (SpliceOne(array, index), removed.push(entry), callback && callback.call(context, entry)), itemLength--;
      }

      return removed;
    };
  }, function (module, exports, __webpack_require__) {
    var Curve = __webpack_require__(0),
        FromPoints = __webpack_require__(199),
        Rectangle = __webpack_require__(10),
        Vector2 = __webpack_require__(3),
        Curve = new Curve({
      initialize: function initialize(type) {
        this.type = type, this.defaultDivisions = 5, this.arcLengthDivisions = 100, this.cacheArcLengths = [], this.needsUpdate = !0, this.active = !0, this._tmpVec2A = new Vector2(), this._tmpVec2B = new Vector2();
      },
      draw: function draw(graphics, pointsTotal) {
        return graphics.strokePoints(this.getPoints(pointsTotal = void 0 === pointsTotal ? 32 : pointsTotal));
      },
      getBounds: function getBounds(out, spaced) {
        out = out || new Rectangle(), void 0 === spaced && (spaced = 16);
        var len = this.getLength();
        len < spaced && (spaced = len / 2);
        spaced = Math.max(1, Math.round(len / spaced));
        return FromPoints(this.getSpacedPoints(spaced), out);
      },
      getDistancePoints: function getDistancePoints(spaced) {
        var len = this.getLength(),
            spaced = Math.max(1, len / spaced);
        return this.getSpacedPoints(spaced);
      },
      getEndPoint: function getEndPoint(out) {
        return void 0 === out && (out = new Vector2()), this.getPointAt(1, out);
      },
      getLength: function getLength() {
        var lengths = this.getLengths();
        return lengths[lengths.length - 1];
      },
      getLengths: function getLengths(divisions) {
        if (void 0 === divisions && (divisions = this.arcLengthDivisions), this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) return this.cacheArcLengths;
        this.needsUpdate = !1;
        var current,
            cache = [],
            last = this.getPoint(0, this._tmpVec2A),
            sum = 0;
        cache.push(0);

        for (var p = 1; p <= divisions; p++) {
          sum += (current = this.getPoint(p / divisions, this._tmpVec2B)).distance(last), cache.push(sum), last.copy(current);
        }

        return this.cacheArcLengths = cache;
      },
      getPointAt: function getPointAt(t, out) {
        t = this.getUtoTmapping(t);
        return this.getPoint(t, out);
      },
      getPoints: function getPoints(divisions, stepRate, out) {
        void 0 === out && (out = []), divisions = divisions || (stepRate ? this.getLength() / stepRate : this.defaultDivisions);

        for (var d = 0; d <= divisions; d++) {
          out.push(this.getPoint(d / divisions));
        }

        return out;
      },
      getRandomPoint: function getRandomPoint(out) {
        return void 0 === out && (out = new Vector2()), this.getPoint(Math.random(), out);
      },
      getSpacedPoints: function getSpacedPoints(divisions, stepRate, out) {
        void 0 === out && (out = []), divisions = divisions || (stepRate ? this.getLength() / stepRate : this.defaultDivisions);

        for (var d = 0; d <= divisions; d++) {
          var t = this.getUtoTmapping(d / divisions, null, divisions);
          out.push(this.getPoint(t));
        }

        return out;
      },
      getStartPoint: function getStartPoint(out) {
        return void 0 === out && (out = new Vector2()), this.getPointAt(0, out);
      },
      getTangent: function getTangent(t2, out) {
        void 0 === out && (out = new Vector2());
        var t1 = t2 - 1e-4,
            t2 = t2 + 1e-4;
        return 1 < t2 && (t2 = 1), this.getPoint(t1 = t1 < 0 ? 0 : t1, this._tmpVec2A), this.getPoint(t2, out), out.subtract(this._tmpVec2A).normalize();
      },
      getTangentAt: function getTangentAt(t, out) {
        t = this.getUtoTmapping(t);
        return this.getTangent(t, out);
      },
      getTFromDistance: function getTFromDistance(distance, divisions) {
        return distance <= 0 ? 0 : this.getUtoTmapping(0, distance, divisions);
      },
      getUtoTmapping: function getUtoTmapping(lengthBefore, distance, il) {
        for (var comparison, arcLengths = this.getLengths(il), i = 0, il = arcLengths.length, targetArcLength = distance ? Math.min(distance, arcLengths[il - 1]) : lengthBefore * arcLengths[il - 1], low = 0, high = il - 1; low <= high;) {
          if ((comparison = arcLengths[i = Math.floor(low + (high - low) / 2)] - targetArcLength) < 0) low = i + 1;else {
            if (!(0 < comparison)) {
              high = i;
              break;
            }

            high = i - 1;
          }
        }

        if (arcLengths[i = high] === targetArcLength) return i / (il - 1);
        lengthBefore = arcLengths[i];
        return (i + (targetArcLength - lengthBefore) / (arcLengths[i + 1] - lengthBefore)) / (il - 1);
      },
      updateArcLengths: function updateArcLengths() {
        this.needsUpdate = !0, this.getLengths();
      }
    });

    module.exports = Curve;
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      ADD: __webpack_require__(968),
      COMPLETE: __webpack_require__(969),
      FILE_COMPLETE: __webpack_require__(970),
      FILE_KEY_COMPLETE: __webpack_require__(971),
      FILE_LOAD_ERROR: __webpack_require__(972),
      FILE_LOAD: __webpack_require__(973),
      FILE_PROGRESS: __webpack_require__(974),
      POST_PROCESS: __webpack_require__(975),
      PROGRESS: __webpack_require__(976),
      START: __webpack_require__(977)
    };
  }, function (module, exports, __webpack_require__) {
    var Point = __webpack_require__(4);

    module.exports = function (uA, uB, out) {
      void 0 === out && (out = new Point());
      var x1 = uA.x1,
          y1 = uA.y1,
          x2 = uA.x2,
          y2 = uA.y2,
          x3 = uB.x1,
          y3 = uB.y1,
          x4 = uB.x2,
          uA = uB.y2,
          uB = (uA - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
      if (0 == uB) return !1;
      uA = ((x4 - x3) * (y1 - y3) - (uA - y3) * (x1 - x3)) / uB, uB = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / uB;
      return 0 <= uA && uA <= 1 && 0 <= uB && uB <= 1 && (out.x = x1 + uA * (x2 - x1), out.y = y1 + uA * (y2 - y1), !0);
    };
  }, function (module, exports) {
    module.exports = function (line) {
      return Math.atan2(line.y2 - line.y1, line.x2 - line.x1);
    };
  }, function (module, exports, __webpack_require__) {
    var Clamp = __webpack_require__(18);

    module.exports = function (percent, min, max) {
      return (max - min) * (percent = Clamp(percent, 0, 1)) + min;
    };
  }, function (module, exports) {
    module.exports = function (source, key, defaultValue) {
      return source && source.hasOwnProperty(key) ? source[key] : defaultValue;
    };
  }, function (module, exports) {
    module.exports = {
      CREATED: 0,
      INIT: 1,
      DELAY: 2,
      OFFSET_DELAY: 3,
      PENDING_RENDER: 4,
      PLAYING_FORWARD: 5,
      PLAYING_BACKWARD: 6,
      HOLD_DELAY: 7,
      REPEAT_DELAY: 8,
      COMPLETE: 9,
      PENDING_ADD: 20,
      PAUSED: 21,
      LOOP_DELAY: 22,
      ACTIVE: 23,
      COMPLETE_DELAY: 24,
      PENDING_REMOVE: 25,
      REMOVED: 26
    };
  }, function (module, exports, __webpack_require__) {
    var DataManager = __webpack_require__(0),
        Events = __webpack_require__(315),
        DataManager = new DataManager({
      initialize: function initialize(parent, eventEmitter) {
        this.parent = parent, (this.events = eventEmitter) || (this.events = parent.events || parent), this.list = {}, this.values = {}, this._frozen = !1, !parent.hasOwnProperty("sys") && this.events && this.events.once(Events.DESTROY, this.destroy, this);
      },
      get: function get(key) {
        var list = this.list;

        if (Array.isArray(key)) {
          for (var output = [], i = 0; i < key.length; i++) {
            output.push(list[key[i]]);
          }

          return output;
        }

        return list[key];
      },
      getAll: function getAll() {
        var key,
            results = {};

        for (key in this.list) {
          this.list.hasOwnProperty(key) && (results[key] = this.list[key]);
        }

        return results;
      },
      query: function query(search) {
        var key,
            results = {};

        for (key in this.list) {
          this.list.hasOwnProperty(key) && key.match(search) && (results[key] = this.list[key]);
        }

        return results;
      },
      set: function set(key, data) {
        if (this._frozen) return this;
        if ("string" == typeof key) return this.setValue(key, data);

        for (var entry in key) {
          this.setValue(entry, key[entry]);
        }

        return this;
      },
      inc: function inc(key, data) {
        if (this._frozen) return this;
        void 0 === data && (data = 1);
        var value = this.get(key);
        return this.set(key, (value = void 0 === value ? 0 : value) + data), this;
      },
      toggle: function toggle(key) {
        return this._frozen || this.set(key, !this.get(key)), this;
      },
      setValue: function setValue(key, data) {
        return this._frozen || (this.has(key) ? this.values[key] = data : (list = (_this = this).list, events = this.events, parent = this.parent, Object.defineProperty(this.values, key, {
          enumerable: !0,
          configurable: !0,
          get: function get() {
            return list[key];
          },
          set: function set(value) {
            var previousValue;
            _this._frozen || (previousValue = list[key], list[key] = value, events.emit(Events.CHANGE_DATA, parent, key, value, previousValue), events.emit(Events.CHANGE_DATA_KEY + key, parent, value, previousValue));
          }
        }), list[key] = data, events.emit(Events.SET_DATA, parent, key, data))), this;

        var _this, list, events, parent;
      },
      each: function each(callback, context) {
        for (var key, args = [this.parent, null, void 0], i = 1; i < arguments.length; i++) {
          args.push(arguments[i]);
        }

        for (key in this.list) {
          args[1] = key, args[2] = this.list[key], callback.apply(context, args);
        }

        return this;
      },
      merge: function merge(data, overwrite) {
        for (var key in void 0 === overwrite && (overwrite = !0), data) {
          data.hasOwnProperty(key) && (overwrite || !overwrite && !this.has(key)) && this.setValue(key, data[key]);
        }

        return this;
      },
      remove: function remove(key) {
        if (this._frozen) return this;
        if (!Array.isArray(key)) return this.removeValue(key);

        for (var i = 0; i < key.length; i++) {
          this.removeValue(key[i]);
        }

        return this;
      },
      removeValue: function removeValue(key) {
        var data;
        return this.has(key) && (data = this.list[key], delete this.list[key], delete this.values[key], this.events.emit(Events.REMOVE_DATA, this.parent, key, data)), this;
      },
      pop: function pop(key) {
        var data = void 0;
        return !this._frozen && this.has(key) && (data = this.list[key], delete this.list[key], delete this.values[key], this.events.emit(Events.REMOVE_DATA, this.parent, key, data)), data;
      },
      has: function has(key) {
        return this.list.hasOwnProperty(key);
      },
      setFreeze: function setFreeze(value) {
        return this._frozen = value, this;
      },
      reset: function reset() {
        for (var key in this.list) {
          delete this.list[key], delete this.values[key];
        }

        return this._frozen = !1, this;
      },
      destroy: function destroy() {
        this.reset(), this.events.off(Events.CHANGE_DATA), this.events.off(Events.SET_DATA), this.events.off(Events.REMOVE_DATA), this.parent = null;
      },
      freeze: {
        get: function get() {
          return this._frozen;
        },
        set: function set(value) {
          this._frozen = !!value;
        }
      },
      count: {
        get: function get() {
          var key,
              i = 0;

          for (key in this.list) {
            void 0 !== this.list[key] && i++;
          }

          return i;
        }
      }
    });

    module.exports = DataManager;
  }, function (module, exports, Map) {
    Map = new (Map(0))({
      initialize: function initialize(elements) {
        if (this.entries = {}, this.size = 0, Array.isArray(elements)) for (var i = 0; i < elements.length; i++) {
          this.set(elements[i][0], elements[i][1]);
        }
      },
      set: function set(key, value) {
        return this.has(key) || this.size++, this.entries[key] = value, this;
      },
      get: function get(key) {
        if (this.has(key)) return this.entries[key];
      },
      getArray: function getArray() {
        var key,
            output = [],
            entries = this.entries;

        for (key in entries) {
          output.push(entries[key]);
        }

        return output;
      },
      has: function has(key) {
        return this.entries.hasOwnProperty(key);
      },
      delete: function _delete(key) {
        return this.has(key) && (delete this.entries[key], this.size--), this;
      },
      clear: function clear() {
        return Object.keys(this.entries).forEach(function (prop) {
          delete this.entries[prop];
        }, this), this.size = 0, this;
      },
      keys: function keys() {
        return Object.keys(this.entries);
      },
      values: function values() {
        var key,
            output = [],
            entries = this.entries;

        for (key in entries) {
          output.push(entries[key]);
        }

        return output;
      },
      dump: function dump() {
        var key,
            entries = this.entries;

        for (key in console.group("Map"), entries) {
          console.log(key, entries[key]);
        }

        console.groupEnd();
      },
      each: function each(callback) {
        var key,
            entries = this.entries;

        for (key in entries) {
          if (!1 === callback(key, entries[key])) break;
        }

        return this;
      },
      contains: function contains(value) {
        var key,
            entries = this.entries;

        for (key in entries) {
          if (entries[key] === value) return !0;
        }

        return !1;
      },
      merge: function merge(map, override) {
        void 0 === override && (override = !1);
        var key,
            local = this.entries,
            source = map.entries;

        for (key in source) {
          local.hasOwnProperty(key) && override ? local[key] = source[key] : this.set(key, source[key]);
        }

        return this;
      }
    });
    module.exports = Map;
  }, function (module, exports) {
    module.exports = function (red, green, blue) {
      return red << 16 | green << 8 | blue;
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      ENTER_FULLSCREEN: __webpack_require__(800),
      FULLSCREEN_FAILED: __webpack_require__(801),
      FULLSCREEN_UNSUPPORTED: __webpack_require__(802),
      LEAVE_FULLSCREEN: __webpack_require__(803),
      ORIENTATION_CHANGE: __webpack_require__(804),
      RESIZE: __webpack_require__(805)
    };
  }, function (module, exports, __webpack_require__) {
    !function (process) {
      var OS = {
        android: !1,
        chromeOS: !1,
        cordova: !1,
        crosswalk: !1,
        desktop: !1,
        ejecta: !1,
        electron: !1,
        iOS: !1,
        iOSVersion: 0,
        iPad: !1,
        iPhone: !1,
        kindle: !1,
        linux: !1,
        macOS: !1,
        node: !1,
        nodeWebkit: !1,
        pixelRatio: 1,
        webApp: !1,
        windows: !1,
        windowsPhone: !1
      };

      module.exports = function () {
        if ("function" == typeof importScripts) return OS;
        var ua = navigator.userAgent;
        /Windows/.test(ua) ? OS.windows = !0 : /Mac OS/.test(ua) && !/like Mac OS/.test(ua) ? navigator.maxTouchPoints && 2 < navigator.maxTouchPoints ? (OS.iOS = !0, OS.iPad = !0, navigator.appVersion.match(/Version\/(\d+)/), OS.iOSVersion = parseInt(RegExp.$1, 10)) : OS.macOS = !0 : /Android/.test(ua) ? OS.android = !0 : /Linux/.test(ua) ? OS.linux = !0 : /iP[ao]d|iPhone/i.test(ua) ? (OS.iOS = !0, navigator.appVersion.match(/OS (\d+)/), OS.iOSVersion = parseInt(RegExp.$1, 10), OS.iPhone = -1 !== ua.toLowerCase().indexOf("iphone"), OS.iPad = -1 !== ua.toLowerCase().indexOf("ipad")) : /Kindle/.test(ua) || /\bKF[A-Z][A-Z]+/.test(ua) || /Silk.*Mobile Safari/.test(ua) ? OS.kindle = !0 : /CrOS/.test(ua) && (OS.chromeOS = !0), (/Windows Phone/i.test(ua) || /IEMobile/i.test(ua)) && (OS.android = !1, OS.iOS = !1, OS.macOS = !1, OS.windows = !0, OS.windowsPhone = !0);
        var silk = /Silk/.test(ua);
        return (OS.windows || OS.macOS || OS.linux && !silk || OS.chromeOS) && (OS.desktop = !0), (OS.windowsPhone || /Windows NT/i.test(ua) && /Touch/i.test(ua)) && (OS.desktop = !1), navigator.standalone && (OS.webApp = !0), "function" != typeof importScripts && (void 0 !== window.cordova && (OS.cordova = !0), void 0 !== window.ejecta && (OS.ejecta = !0)), void 0 !== process && process.versions && process.versions.node && (OS.node = !0), OS.node && "object" == _typeof(process.versions) && (OS.nodeWebkit = !!process.versions["node-webkit"], OS.electron = !!process.versions.electron), /Crosswalk/.test(ua) && (OS.crosswalk = !0), OS.pixelRatio = window.devicePixelRatio || 1, OS;
      }();
    }.call(this, __webpack_require__(807));
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      ADD: __webpack_require__(861),
      ERROR: __webpack_require__(862),
      LOAD: __webpack_require__(863),
      READY: __webpack_require__(864),
      REMOVE: __webpack_require__(865)
    };
  }, function (module, exports) {
    module.exports = {
      BYTE: {
        enum: 5120,
        size: 1
      },
      UNSIGNED_BYTE: {
        enum: 5121,
        size: 1
      },
      SHORT: {
        enum: 5122,
        size: 2
      },
      UNSIGNED_SHORT: {
        enum: 5123,
        size: 2
      },
      INT: {
        enum: 5124,
        size: 4
      },
      UNSIGNED_INT: {
        enum: 5125,
        size: 4
      },
      FLOAT: {
        enum: 5126,
        size: 4
      }
    };
  }, function (module, exports, __webpack_require__) {
    var MultiPipeline = __webpack_require__(0),
        Earcut = __webpack_require__(59),
        GetFastValue = __webpack_require__(2),
        ShaderSourceFS = __webpack_require__(878),
        ShaderSourceVS = __webpack_require__(879),
        TransformMatrix = __webpack_require__(25),
        Utils = __webpack_require__(12),
        WEBGL_CONST = __webpack_require__(107),
        WebGLPipeline = __webpack_require__(58),
        MultiPipeline = new MultiPipeline({
      Extends: WebGLPipeline,
      initialize: function initialize(config) {
        var renderer = config.game.renderer,
            fragmentShaderSource = GetFastValue(config, "fragShader", ShaderSourceFS);
        config.fragShader = Utils.parseFragmentShaderMaxTextures(fragmentShaderSource, renderer.maxTextures), config.vertShader = GetFastValue(config, "vertShader", ShaderSourceVS), config.attributes = GetFastValue(config, "attributes", [{
          name: "inPosition",
          size: 2
        }, {
          name: "inTexCoord",
          size: 2
        }, {
          name: "inTexId"
        }, {
          name: "inTintEffect"
        }, {
          name: "inTint",
          size: 4,
          type: WEBGL_CONST.UNSIGNED_BYTE,
          normalized: !0
        }]), WebGLPipeline.call(this, config), this._tempMatrix1 = new TransformMatrix(), this._tempMatrix2 = new TransformMatrix(), this._tempMatrix3 = new TransformMatrix(), this.calcMatrix = new TransformMatrix(), this.tempTriangle = [{
          x: 0,
          y: 0,
          width: 0
        }, {
          x: 0,
          y: 0,
          width: 0
        }, {
          x: 0,
          y: 0,
          width: 0
        }, {
          x: 0,
          y: 0,
          width: 0
        }], this.strokeTint = {
          TL: 0,
          TR: 0,
          BL: 0,
          BR: 0
        }, this.fillTint = {
          TL: 0,
          TR: 0,
          BL: 0,
          BR: 0
        }, this.currentFrame = {
          u0: 0,
          v0: 0,
          u1: 1,
          v1: 1
        }, this.firstQuad = [0, 0, 0, 0, 0], this.prevQuad = [0, 0, 0, 0, 0], this.polygonCache = [];
      },
      boot: function boot() {
        WebGLPipeline.prototype.boot.call(this), this.currentShader.set1iv("uMainSampler", this.renderer.textureIndexes);
      },
      batchSprite: function batchSprite(gameObject, tintBL, ty0) {
        this.manager.set(this, gameObject);
        var tx1 = this._tempMatrix1,
            ty1 = this._tempMatrix2,
            getTint = this._tempMatrix3,
            unit = gameObject.frame,
            texture = unit.glTexture,
            u0 = unit.u0,
            v0 = unit.v0,
            u1 = unit.u1,
            v1 = unit.v1,
            tintTL = unit.x,
            tintTR = unit.y,
            tx2 = unit.cutWidth,
            ty2 = unit.cutHeight,
            tintBR = unit.customPivot,
            displayOriginX = gameObject.displayOriginX,
            ty3 = gameObject.displayOriginY,
            tx3 = -displayOriginX + tintTL,
            tintTL = -ty3 + tintTR;
        gameObject.isCropped && ((tx0 = gameObject._crop).flipX === gameObject.flipX && tx0.flipY === gameObject.flipY || unit.updateCropUVs(tx0, gameObject.flipX, gameObject.flipY), u0 = tx0.u0, v0 = tx0.v0, u1 = tx0.u1, v1 = tx0.v1, tx2 = tx0.width, ty2 = tx0.height, tx3 = -displayOriginX + tx0.x, tintTL = -ty3 + tx0.y);
        var tintTR = 1,
            tx0 = 1;
        gameObject.flipX && (tintBR || (tx3 += -unit.realWidth + 2 * displayOriginX), tintTR = -1), (gameObject.flipY || unit.source.isGLTexture && !texture.flipY) && (tintBR || (tintTL += -unit.realHeight + 2 * ty3), tx0 = -1), ty1.applyITRS(gameObject.x, gameObject.y, gameObject.rotation, gameObject.scaleX * tintTR, gameObject.scaleY * tx0), tx1.copyFrom(tintBL.matrix), ty0 ? (tx1.multiplyWithOffset(ty0, -tintBL.scrollX * gameObject.scrollFactorX, -tintBL.scrollY * gameObject.scrollFactorY), ty1.e = gameObject.x, ty1.f = gameObject.y) : (ty1.e -= tintBL.scrollX * gameObject.scrollFactorX, ty1.f -= tintBL.scrollY * gameObject.scrollFactorY), tx1.multiply(ty1, getTint);
        tintBR = tx3 + tx2, ty3 = tintTL + ty2, tintTR = tintBL.roundPixels, tx0 = getTint.getXRound(tx3, tintTL, tintTR), ty0 = getTint.getYRound(tx3, tintTL, tintTR), tx1 = getTint.getXRound(tx3, ty3, tintTR), ty1 = getTint.getYRound(tx3, ty3, tintTR), tx2 = getTint.getXRound(tintBR, ty3, tintTR), ty2 = getTint.getYRound(tintBR, ty3, tintTR), tx3 = getTint.getXRound(tintBR, tintTL, tintTR), ty3 = getTint.getYRound(tintBR, tintTL, tintTR), getTint = Utils.getTintAppendFloatAlpha, tintBR = tintBL.alpha, tintTL = getTint(gameObject.tintTopLeft, tintBR * gameObject._alphaTL), tintTR = getTint(gameObject.tintTopRight, tintBR * gameObject._alphaTR), tintBL = getTint(gameObject.tintBottomLeft, tintBR * gameObject._alphaBL), tintBR = getTint(gameObject.tintBottomRight, tintBR * gameObject._alphaBR);
        this.shouldFlush(6) && this.flush();
        unit = this.setGameObject(gameObject, unit);
        this.manager.preBatch(gameObject), this.batchQuad(gameObject, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, u0, v0, u1, v1, tintTL, tintTR, tintBL, tintBR, gameObject.tintFill, texture, unit), this.manager.postBatch(gameObject);
      },
      batchTexture: function batchTexture(gameObject, texture, textureWidth, textureHeight, srcX, ty3, srcWidth, srcHeight, scaleX, scaleY, rotation, flipX, flipY, tx0, ty0, displayOriginX, displayOriginY, frameX, frameY, frameWidth, frameHeight, tintTL, tintTR, tintBL, tintBR, tintEffect, uOffset, vOffset, tx2, parentTransformMatrix, skipFlip, textureUnit) {
        this.manager.set(this, gameObject);
        var crop,
            cropWidth,
            cropHeight,
            ox,
            oy,
            tx1 = this._tempMatrix1,
            ty1 = this._tempMatrix2,
            calcMatrix = this._tempMatrix3,
            u0 = frameX / textureWidth + uOffset,
            v0 = frameY / textureHeight + vOffset,
            u1 = (frameX + frameWidth) / textureWidth + uOffset,
            v1 = (frameY + frameHeight) / textureHeight + vOffset,
            xw = srcWidth,
            tx3 = srcHeight,
            ty2 = -displayOriginX,
            y = -displayOriginY;
        gameObject.isCropped && (cropWidth = (crop = gameObject._crop).width, cropHeight = crop.height, ox = frameX = crop.x, oy = frameY = crop.y, u0 = (ox = flipX ? frameWidth - crop.x - cropWidth : ox) / textureWidth + uOffset, v0 = (oy = flipY ? frameHeight - crop.y - cropHeight : oy) / textureHeight + vOffset, u1 = (ox + (srcWidth = xw = cropWidth)) / textureWidth + uOffset, v1 = (oy + (srcHeight = tx3 = cropHeight)) / textureHeight + vOffset, ty2 = -displayOriginX + frameX, y = -displayOriginY + frameY), flipX && (xw *= -1, ty2 += srcWidth), (flipY ^= !skipFlip && texture.isRenderTexture ? 1 : 0) && (tx3 *= -1, y += srcHeight);
        xw = ty2 + xw, tx3 = y + tx3;
        ty1.applyITRS(srcX, ty3, rotation, scaleX, scaleY), tx1.copyFrom(tx2.matrix), parentTransformMatrix ? (tx1.multiplyWithOffset(parentTransformMatrix, -tx2.scrollX * tx0, -tx2.scrollY * ty0), ty1.e = srcX, ty1.f = ty3) : (ty1.e -= tx2.scrollX * tx0, ty1.f -= tx2.scrollY * ty0), tx1.multiply(ty1, calcMatrix);
        ty3 = tx2.roundPixels, tx0 = calcMatrix.getXRound(ty2, y, ty3), ty0 = calcMatrix.getYRound(ty2, y, ty3), tx1 = calcMatrix.getXRound(ty2, tx3, ty3), ty1 = calcMatrix.getYRound(ty2, tx3, ty3), tx2 = calcMatrix.getXRound(xw, tx3, ty3), ty2 = calcMatrix.getYRound(xw, tx3, ty3), tx3 = calcMatrix.getXRound(xw, y, ty3), ty3 = calcMatrix.getYRound(xw, y, ty3);
        void 0 === textureUnit && (textureUnit = this.renderer.setTexture2D(texture)), gameObject && this.manager.preBatch(gameObject), this.batchQuad(gameObject, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, u0, v0, u1, v1, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, textureUnit), gameObject && this.manager.postBatch(gameObject);
      },
      batchTextureFrame: function batchTextureFrame(frame, ty2, unit, tint, alpha, tx1, ty1) {
        this.manager.set(this);

        var tx2 = this._tempMatrix1.copyFrom(tx1),
            calcMatrix = this._tempMatrix2,
            ty3 = ty2 + frame.width,
            tx3 = unit + frame.height;

        ty1 ? tx2.multiply(ty1, calcMatrix) : calcMatrix = tx2;
        var tx0 = calcMatrix.getX(ty2, unit),
            ty0 = calcMatrix.getY(ty2, unit),
            tx1 = calcMatrix.getX(ty2, tx3),
            ty1 = calcMatrix.getY(ty2, tx3),
            tx2 = calcMatrix.getX(ty3, tx3),
            ty2 = calcMatrix.getY(ty3, tx3),
            tx3 = calcMatrix.getX(ty3, unit),
            ty3 = calcMatrix.getY(ty3, unit),
            unit = this.renderer.setTextureSource(frame.source);
        tint = Utils.getTintAppendFloatAlpha(tint, alpha), this.batchQuad(null, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, frame.u0, frame.v0, frame.u1, frame.v1, tint, tint, tint, tint, 0, frame.glTexture, unit);
      },
      batchFillRect: function batchFillRect(y2, tint, y1, x2, x1, y0) {
        this.renderer.pipelines.set(this);
        var calcMatrix = this.calcMatrix;
        y0 && y0.multiply(x1, calcMatrix);
        var y3 = y2 + y1,
            x3 = tint + x2,
            x0 = calcMatrix.getX(y2, tint),
            y0 = calcMatrix.getY(y2, tint),
            x1 = calcMatrix.getX(y2, x3),
            y1 = calcMatrix.getY(y2, x3),
            x2 = calcMatrix.getX(y3, x3),
            y2 = calcMatrix.getY(y3, x3),
            x3 = calcMatrix.getX(y3, tint),
            y3 = calcMatrix.getY(y3, tint),
            tint = this.fillTint;
        this.batchQuad(null, x0, y0, x1, y1, x2, y2, x3, y3, 0, 0, 1, 1, tint.TL, tint.TR, tint.BL, tint.BR, 2);
      },
      batchFillTriangle: function batchFillTriangle(ty0, tx1, ty1, tx2, ty2, tint, tx0, parentMatrix) {
        this.renderer.pipelines.set(this);
        var calcMatrix = this.calcMatrix;
        parentMatrix && parentMatrix.multiply(tx0, calcMatrix);
        tx0 = calcMatrix.getX(ty0, tx1), ty0 = calcMatrix.getY(ty0, tx1), tx1 = calcMatrix.getX(ty1, tx2), ty1 = calcMatrix.getY(ty1, tx2), tx2 = calcMatrix.getX(ty2, tint), ty2 = calcMatrix.getY(ty2, tint), tint = this.fillTint;
        this.batchTri(null, tx0, ty0, tx1, ty1, tx2, ty2, 0, 0, 1, 1, tint.TL, tint.TR, tint.BL, 2);
      },
      batchStrokeTriangle: function batchStrokeTriangle(x0, y0, x1, y1, x2, y2, lineWidth, currentMatrix, parentMatrix) {
        var tempTriangle = this.tempTriangle;
        tempTriangle[0].x = x0, tempTriangle[0].y = y0, tempTriangle[0].width = lineWidth, tempTriangle[1].x = x1, tempTriangle[1].y = y1, tempTriangle[1].width = lineWidth, tempTriangle[2].x = x2, tempTriangle[2].y = y2, tempTriangle[2].width = lineWidth, tempTriangle[3].x = x0, tempTriangle[3].y = y0, tempTriangle[3].width = lineWidth, this.batchStrokePath(tempTriangle, lineWidth, !1, currentMatrix, parentMatrix);
      },
      batchFillPath: function batchFillPath(path, currentMatrix, parentMatrix) {
        this.renderer.pipelines.set(this);
        var calcMatrix = this.calcMatrix;
        parentMatrix && parentMatrix.multiply(currentMatrix, calcMatrix);

        for (var point, length = path.length, polygonCache = this.polygonCache, tintTL = this.fillTint.TL, tintTR = this.fillTint.TR, tintBL = this.fillTint.BL, pathIndex = 0; pathIndex < length; ++pathIndex) {
          point = path[pathIndex], polygonCache.push(point.x, point.y);
        }

        for (var polygonIndexArray, length = (polygonIndexArray = Earcut(polygonCache)).length, index = 0; index < length; index += 3) {
          var x2 = 2 * polygonIndexArray[index + 0],
              ty2 = 2 * polygonIndexArray[index + 1],
              tx0 = 2 * polygonIndexArray[index + 2],
              ty0 = polygonCache[0 + x2],
              tx1 = polygonCache[1 + x2],
              ty1 = polygonCache[0 + ty2],
              tx2 = polygonCache[1 + ty2],
              x2 = polygonCache[0 + tx0],
              ty2 = polygonCache[1 + tx0],
              tx0 = calcMatrix.getX(ty0, tx1),
              ty0 = calcMatrix.getY(ty0, tx1),
              tx1 = calcMatrix.getX(ty1, tx2),
              ty1 = calcMatrix.getY(ty1, tx2),
              tx2 = calcMatrix.getX(x2, ty2),
              ty2 = calcMatrix.getY(x2, ty2);
          this.batchTri(null, tx0, ty0, tx1, ty1, tx2, ty2, 0, 0, 1, 1, tintTL, tintTR, tintBL, 2);
        }

        polygonCache.length = 0;
      },
      batchStrokePath: function batchStrokePath(path, lineWidth, pathOpen, currentMatrix, parentMatrix) {
        this.renderer.pipelines.set(this), this.prevQuad[4] = 0, this.firstQuad[4] = 0;

        for (var pathLength = path.length - 1, pathIndex = 0; pathIndex < pathLength; pathIndex++) {
          var point0 = path[pathIndex],
              point1 = path[pathIndex + 1];
          this.batchLine(point0.x, point0.y, point1.x, point1.y, point0.width / 2, point1.width / 2, lineWidth, pathIndex, !pathOpen && pathIndex === pathLength - 1, currentMatrix, parentMatrix);
        }
      },
      batchLine: function batchLine(brX, blX, prev, tintBL, trY, tlX, first, index, closePath, tintTL, blY) {
        this.renderer.pipelines.set(this);
        var tintTR = this.calcMatrix;
        blY && blY.multiply(tintTL, tintTR);
        var tintBR = prev - brX,
            trX = tintBL - blX,
            tlY = Math.sqrt(tintBR * tintBR + trX * trX),
            brY = trY * (tintBL - blX) / tlY,
            blY = trY * (brX - prev) / tlY,
            tintTL = tlX * (tintBL - blX) / tlY,
            tintBR = tlX * (brX - prev) / tlY,
            trX = prev - tintTL,
            trY = tintBL - tintBR,
            tlX = brX - brY,
            tlY = blX - blY,
            prev = prev + tintTL,
            tintTL = tintBL + tintBR,
            tintBL = brX + brY,
            tintBR = blX + blY,
            brX = tintTR.getX(trX, trY),
            brY = tintTR.getY(trX, trY),
            blX = tintTR.getX(tlX, tlY),
            blY = tintTR.getY(tlX, tlY),
            trX = tintTR.getX(prev, tintTL),
            trY = tintTR.getY(prev, tintTL),
            tlX = tintTR.getX(tintBL, tintBR),
            tlY = tintTR.getY(tintBL, tintBR),
            prev = this.strokeTint,
            tintTL = prev.TL,
            tintTR = prev.TR,
            tintBL = prev.BL,
            tintBR = prev.BR;
        this.batchQuad(null, tlX, tlY, blX, blY, brX, brY, trX, trY, 0, 0, 1, 1, tintTL, tintTR, tintBL, tintBR, 2), first <= 2 || (prev = this.prevQuad, first = this.firstQuad, 0 < index && prev[4] ? this.batchQuad(null, tlX, tlY, blX, blY, prev[0], prev[1], prev[2], prev[3], 0, 0, 1, 1, tintTL, tintTR, tintBL, tintBR, 2) : (first[0] = tlX, first[1] = tlY, first[2] = blX, first[3] = blY, first[4] = 1), closePath && first[4] ? this.batchQuad(null, brX, brY, trX, trY, first[0], first[1], first[2], first[3], 0, 0, 1, 1, tintTL, tintTR, tintBL, tintBR, 2) : (prev[0] = brX, prev[1] = brY, prev[2] = trX, prev[3] = trY, prev[4] = 1));
      }
    });

    module.exports = MultiPipeline;
  }, function (module, exports, __webpack_require__) {
    var Class = __webpack_require__(0),
        Clamp = __webpack_require__(18),
        Extend = __webpack_require__(17),
        Frame = new Class({
      initialize: function initialize(texture, name, sourceIndex, x, y, width, height) {
        this.texture = texture, this.name = name, this.source = texture.source[sourceIndex], this.sourceIndex = sourceIndex, this.glTexture = this.source.glTexture, this.cutX, this.cutY, this.cutWidth, this.cutHeight, this.x = 0, this.y = 0, this.width, this.height, this.halfWidth, this.halfHeight, this.centerX, this.centerY, this.pivotX = 0, this.pivotY = 0, this.customPivot = !1, this.rotated = !1, this.autoRound = -1, this.customData = {}, this.u0 = 0, this.v0 = 0, this.u1 = 0, this.v1 = 0, this.data = {
          cut: {
            x: 0,
            y: 0,
            w: 0,
            h: 0,
            r: 0,
            b: 0
          },
          trim: !1,
          sourceSize: {
            w: 0,
            h: 0
          },
          spriteSourceSize: {
            x: 0,
            y: 0,
            w: 0,
            h: 0,
            r: 0,
            b: 0
          },
          radius: 0,
          drawImage: {
            x: 0,
            y: 0,
            width: 0,
            height: 0
          }
        }, this.setSize(width, height, x, y);
      },
      setSize: function setSize(width, height, x, y) {
        void 0 === y && (y = 0), this.cutX = x = void 0 === x ? 0 : x, this.cutY = y, this.cutWidth = width, this.cutHeight = height, this.width = width, this.height = height, this.halfWidth = Math.floor(.5 * width), this.halfHeight = Math.floor(.5 * height), this.centerX = Math.floor(width / 2), this.centerY = Math.floor(height / 2);
        var drawImage = this.data,
            cut = drawImage.cut;
        cut.x = x, cut.y = y, cut.w = width, cut.h = height, cut.r = x + width, cut.b = y + height, drawImage.sourceSize.w = width, drawImage.sourceSize.h = height, drawImage.spriteSourceSize.w = width, drawImage.spriteSourceSize.h = height, drawImage.radius = .5 * Math.sqrt(width * width + height * height);
        drawImage = drawImage.drawImage;
        return drawImage.x = x, drawImage.y = y, drawImage.width = width, drawImage.height = height, this.updateUVs();
      },
      setTrim: function setTrim(actualWidth, actualHeight, destX, destY, destWidth, destHeight) {
        var data = this.data,
            ss = data.spriteSourceSize;
        return data.trim = !0, data.sourceSize.w = actualWidth, data.sourceSize.h = actualHeight, ss.x = destX, ss.y = destY, ss.w = destWidth, ss.h = destHeight, ss.r = destX + destWidth, ss.b = destY + destHeight, this.x = destX, this.y = destY, this.width = destWidth, this.height = destHeight, this.halfWidth = .5 * destWidth, this.halfHeight = .5 * destHeight, this.centerX = Math.floor(destWidth / 2), this.centerY = Math.floor(destHeight / 2), this.updateUVs();
      },
      setCropUVs: function setCropUVs(crop, x, y, width, height, flipX, flipY) {
        var ss,
            iw,
            cx = this.cutX,
            tw = this.cutY,
            cw = this.cutWidth,
            th = this.cutHeight,
            ih = this.realWidth,
            ix = this.realHeight,
            ox = cx + (x = Clamp(x, 0, ih)),
            oy = tw + (y = Clamp(y, 0, ix)),
            ow = width = Clamp(width, 0, ih - x),
            oh = height = Clamp(height, 0, ix - y),
            iy = this.data;
        iy.trim ? (ss = iy.spriteSourceSize, iw = x + (width = Clamp(width, 0, cw - x)), ih = y + (height = Clamp(height, 0, th - y)), !(ss.r < x || ss.b < y || ss.x > iw || ss.y > ih) ? (ix = Math.max(ss.x, x), iy = Math.max(ss.y, y), iw = Math.min(ss.r, iw) - ix, ih = Math.min(ss.b, ih) - iy, ox = flipX ? cx + (cw - (ix - ss.x) - iw) : cx + (ix - ss.x), oy = flipY ? tw + (th - (iy - ss.y) - ih) : tw + (iy - ss.y), x = ix, y = iy, width = ow = iw, height = oh = ih) : oh = ow = oy = ox = 0) : (flipX && (ox = cx + (cw - x - width)), flipY && (oy = tw + (th - y - height)));
        tw = this.source.width, th = this.source.height;
        return crop.u0 = Math.max(0, ox / tw), crop.v0 = Math.max(0, oy / th), crop.u1 = Math.min(1, (ox + ow) / tw), crop.v1 = Math.min(1, (oy + oh) / th), crop.x = x, crop.y = y, crop.cx = ox, crop.cy = oy, crop.cw = ow, crop.ch = oh, crop.width = width, crop.height = height, crop.flipX = flipX, crop.flipY = flipY, crop;
      },
      updateCropUVs: function updateCropUVs(crop, flipX, flipY) {
        return this.setCropUVs(crop, crop.x, crop.y, crop.width, crop.height, flipX, flipY);
      },
      setUVs: function setUVs(width, height, u0, v0, u1, v1) {
        var cd = this.data.drawImage;
        return cd.width = width, cd.height = height, this.u0 = u0, this.v0 = v0, this.u1 = u1, this.v1 = v1, this;
      },
      updateUVs: function updateUVs() {
        var cx = this.cutX,
            cy = this.cutY,
            cw = this.cutWidth,
            ch = this.cutHeight,
            th = this.data.drawImage;
        th.width = cw, th.height = ch;
        var tw = this.source.width,
            th = this.source.height;
        return this.u0 = cx / tw, this.v0 = cy / th, this.u1 = (cx + cw) / tw, this.v1 = (cy + ch) / th, this;
      },
      updateUVsInverted: function updateUVsInverted() {
        var tw = this.source.width,
            th = this.source.height;
        return this.u0 = (this.cutX + this.cutHeight) / tw, this.v0 = this.cutY / th, this.u1 = this.cutX / tw, this.v1 = (this.cutY + this.cutWidth) / th, this;
      },
      clone: function clone() {
        var clone = new Frame(this.texture, this.name, this.sourceIndex);
        return clone.cutX = this.cutX, clone.cutY = this.cutY, clone.cutWidth = this.cutWidth, clone.cutHeight = this.cutHeight, clone.x = this.x, clone.y = this.y, clone.width = this.width, clone.height = this.height, clone.halfWidth = this.halfWidth, clone.halfHeight = this.halfHeight, clone.centerX = this.centerX, clone.centerY = this.centerY, clone.rotated = this.rotated, clone.data = Extend(!0, clone.data, this.data), clone.updateUVs(), clone;
      },
      destroy: function destroy() {
        this.source = null, this.texture = null, this.glTexture = null, this.customData = null, this.data = null;
      },
      realWidth: {
        get: function get() {
          return this.data.sourceSize.w;
        }
      },
      realHeight: {
        get: function get() {
          return this.data.sourceSize.h;
        }
      },
      radius: {
        get: function get() {
          return this.data.radius;
        }
      },
      trimmed: {
        get: function get() {
          return this.data.trim;
        }
      },
      canvasData: {
        get: function get() {
          return this.data.drawImage;
        }
      }
    });

    module.exports = Frame;
  }, function (module, exports, __webpack_require__) {
    var ArrayUtils = __webpack_require__(208),
        List = __webpack_require__(0),
        NOOP = __webpack_require__(1),
        StableSort = __webpack_require__(79),
        List = new List({
      initialize: function initialize(parent) {
        this.parent = parent, this.list = [], this.position = 0, this.addCallback = NOOP, this.removeCallback = NOOP, this._sortKey = "";
      },
      add: function add(child, skipCallback) {
        return skipCallback ? ArrayUtils.Add(this.list, child) : ArrayUtils.Add(this.list, child, 0, this.addCallback, this);
      },
      addAt: function addAt(child, index, skipCallback) {
        return skipCallback ? ArrayUtils.AddAt(this.list, child, index) : ArrayUtils.AddAt(this.list, child, index, 0, this.addCallback, this);
      },
      getAt: function getAt(index) {
        return this.list[index];
      },
      getIndex: function getIndex(child) {
        return this.list.indexOf(child);
      },
      sort: function sort(property, handler) {
        return property && StableSort(this.list, handler = void 0 === handler ? function (childA, childB) {
          return childA[property] - childB[property];
        } : handler), this;
      },
      getByName: function getByName(name) {
        return ArrayUtils.GetFirst(this.list, "name", name);
      },
      getRandom: function getRandom(startIndex, length) {
        return ArrayUtils.GetRandom(this.list, startIndex, length);
      },
      getFirst: function getFirst(property, value, startIndex, endIndex) {
        return ArrayUtils.GetFirst(this.list, property, value, startIndex, endIndex);
      },
      getAll: function getAll(property, value, startIndex, endIndex) {
        return ArrayUtils.GetAll(this.list, property, value, startIndex, endIndex);
      },
      count: function count(property, value) {
        return ArrayUtils.CountAllMatching(this.list, property, value);
      },
      swap: function swap(child1, child2) {
        ArrayUtils.Swap(this.list, child1, child2);
      },
      moveTo: function moveTo(child, index) {
        return ArrayUtils.MoveTo(this.list, child, index);
      },
      moveAbove: function moveAbove(child1, child2) {
        return ArrayUtils.MoveAbove(this.list, child1, child2);
      },
      moveBelow: function moveBelow(child1, child2) {
        return ArrayUtils.MoveBelow(this.list, child1, child2);
      },
      remove: function remove(child, skipCallback) {
        return skipCallback ? ArrayUtils.Remove(this.list, child) : ArrayUtils.Remove(this.list, child, this.removeCallback, this);
      },
      removeAt: function removeAt(index, skipCallback) {
        return skipCallback ? ArrayUtils.RemoveAt(this.list, index) : ArrayUtils.RemoveAt(this.list, index, this.removeCallback, this);
      },
      removeBetween: function removeBetween(startIndex, endIndex, skipCallback) {
        return skipCallback ? ArrayUtils.RemoveBetween(this.list, startIndex, endIndex) : ArrayUtils.RemoveBetween(this.list, startIndex, endIndex, this.removeCallback, this);
      },
      removeAll: function removeAll(skipCallback) {
        for (var i = this.list.length; i--;) {
          this.remove(this.list[i], skipCallback);
        }

        return this;
      },
      bringToTop: function bringToTop(child) {
        return ArrayUtils.BringToTop(this.list, child);
      },
      sendToBack: function sendToBack(child) {
        return ArrayUtils.SendToBack(this.list, child);
      },
      moveUp: function moveUp(child) {
        return ArrayUtils.MoveUp(this.list, child), child;
      },
      moveDown: function moveDown(child) {
        return ArrayUtils.MoveDown(this.list, child), child;
      },
      reverse: function reverse() {
        return this.list.reverse(), this;
      },
      shuffle: function shuffle() {
        return ArrayUtils.Shuffle(this.list), this;
      },
      replace: function replace(oldChild, newChild) {
        return ArrayUtils.Replace(this.list, oldChild, newChild);
      },
      exists: function exists(child) {
        return -1 < this.list.indexOf(child);
      },
      setAll: function setAll(property, value, startIndex, endIndex) {
        return ArrayUtils.SetAll(this.list, property, value, startIndex, endIndex), this;
      },
      each: function each(callback, context) {
        for (var args = [null], i = 2; i < arguments.length; i++) {
          args.push(arguments[i]);
        }

        for (i = 0; i < this.list.length; i++) {
          args[0] = this.list[i], callback.apply(context, args);
        }
      },
      shutdown: function shutdown() {
        this.removeAll(), this.list = [];
      },
      destroy: function destroy() {
        this.removeAll(), this.parent = null, this.addCallback = null, this.removeCallback = null;
      },
      length: {
        get: function get() {
          return this.list.length;
        }
      },
      first: {
        get: function get() {
          return (this.position = 0) < this.list.length ? this.list[0] : null;
        }
      },
      last: {
        get: function get() {
          return 0 < this.list.length ? (this.position = this.list.length - 1, this.list[this.position]) : null;
        }
      },
      next: {
        get: function get() {
          return this.position < this.list.length ? (this.position++, this.list[this.position]) : null;
        }
      },
      previous: {
        get: function get() {
          return 0 < this.position ? (this.position--, this.list[this.position]) : null;
        }
      }
    });

    module.exports = List;
  }, function (module, exports, __webpack_require__) {
    var Ellipse = __webpack_require__(0),
        Contains = __webpack_require__(112),
        GetPoint = __webpack_require__(445),
        GetPoints = __webpack_require__(446),
        GEOM_CONST = __webpack_require__(56),
        Random = __webpack_require__(180),
        Ellipse = new Ellipse({
      initialize: function initialize(x, y, width, height) {
        void 0 === x && (x = 0), void 0 === y && (y = 0), void 0 === width && (width = 0), void 0 === height && (height = 0), this.type = GEOM_CONST.ELLIPSE, this.x = x, this.y = y, this.width = width, this.height = height;
      },
      contains: function contains(x, y) {
        return Contains(this, x, y);
      },
      getPoint: function getPoint(position, point) {
        return GetPoint(this, position, point);
      },
      getPoints: function getPoints(quantity, stepRate, output) {
        return GetPoints(this, quantity, stepRate, output);
      },
      getRandomPoint: function getRandomPoint(point) {
        return Random(this, point);
      },
      setTo: function setTo(x, y, width, height) {
        return this.x = x, this.y = y, this.width = width, this.height = height, this;
      },
      setEmpty: function setEmpty() {
        return this.width = 0, this.height = 0, this;
      },
      setPosition: function setPosition(x, y) {
        return void 0 === y && (y = x), this.x = x, this.y = y, this;
      },
      setSize: function setSize(width, height) {
        return void 0 === height && (height = width), this.width = width, this.height = height, this;
      },
      isEmpty: function isEmpty() {
        return this.width <= 0 || this.height <= 0;
      },
      getMinorRadius: function getMinorRadius() {
        return Math.min(this.width, this.height) / 2;
      },
      getMajorRadius: function getMajorRadius() {
        return Math.max(this.width, this.height) / 2;
      },
      left: {
        get: function get() {
          return this.x - this.width / 2;
        },
        set: function set(value) {
          this.x = value + this.width / 2;
        }
      },
      right: {
        get: function get() {
          return this.x + this.width / 2;
        },
        set: function set(value) {
          this.x = value - this.width / 2;
        }
      },
      top: {
        get: function get() {
          return this.y - this.height / 2;
        },
        set: function set(value) {
          this.y = value + this.height / 2;
        }
      },
      bottom: {
        get: function get() {
          return this.y + this.height / 2;
        },
        set: function set(value) {
          this.y = value - this.height / 2;
        }
      }
    });

    module.exports = Ellipse;
  }, function (module, exports) {
    module.exports = function (normy, normx, y) {
      if (normy.width <= 0 || normy.height <= 0) return !1;
      normx = (normx - normy.x) / normy.width, normy = (y - normy.y) / normy.height;
      return (normx *= normx) + (normy *= normy) < .25;
    };
  }, function (module, exports, __webpack_require__) {
    var Actions = __webpack_require__(275),
        Group = __webpack_require__(0),
        Events = __webpack_require__(75),
        EventEmitter = __webpack_require__(9),
        GetAll = __webpack_require__(207),
        GetFastValue = __webpack_require__(2),
        GetValue = __webpack_require__(6),
        IsPlainObject = __webpack_require__(7),
        Range = __webpack_require__(437),
        Set = __webpack_require__(149),
        Sprite = __webpack_require__(73),
        Group = new Group({
      Extends: EventEmitter,
      initialize: function initialize(scene, children, config) {
        EventEmitter.call(this), config ? children && !Array.isArray(children) && (children = [children]) : Array.isArray(children) ? IsPlainObject(children[0]) && (config = children, children = null) : IsPlainObject(children) && (config = children, children = null), this.scene = scene, this.children = new Set(), this.isParent = !0, this.type = "Group", this.classType = GetFastValue(config, "classType", Sprite), this.name = GetFastValue(config, "name", ""), this.active = GetFastValue(config, "active", !0), this.maxSize = GetFastValue(config, "maxSize", -1), this.defaultKey = GetFastValue(config, "defaultKey", null), this.defaultFrame = GetFastValue(config, "defaultFrame", null), this.runChildUpdate = GetFastValue(config, "runChildUpdate", !1), this.createCallback = GetFastValue(config, "createCallback", null), this.removeCallback = GetFastValue(config, "removeCallback", null), this.createMultipleCallback = GetFastValue(config, "createMultipleCallback", null), this.internalCreateCallback = GetFastValue(config, "internalCreateCallback", null), this.internalRemoveCallback = GetFastValue(config, "internalRemoveCallback", null), children && this.addMultiple(children), config && this.createMultiple(config), this.on(Events.ADDED_TO_SCENE, this.addedToScene, this), this.on(Events.REMOVED_FROM_SCENE, this.removedFromScene, this);
      },
      addedToScene: function addedToScene() {
        this.scene.sys.updateList.add(this);
      },
      removedFromScene: function removedFromScene() {
        this.scene.sys.updateList.remove(this);
      },
      create: function create(x, y, key, child, visible, active) {
        if (void 0 === x && (x = 0), void 0 === y && (y = 0), void 0 === key && (key = this.defaultKey), void 0 === child && (child = this.defaultFrame), void 0 === visible && (visible = !0), void 0 === active && (active = !0), this.isFull()) return null;
        child = new this.classType(this.scene, x, y, key, child);
        return child.addToDisplayList(this.scene.sys.displayList), child.addToUpdateList(), child.visible = visible, child.setActive(active), this.add(child), child;
      },
      createMultiple: function createMultiple(config) {
        if (this.isFull()) return [];
        var output = [];
        if ((config = !Array.isArray(config) ? [config] : config)[0].key) for (var i = 0; i < config.length; i++) {
          var entries = this.createFromConfig(config[i]),
              output = output.concat(entries);
        }
        return output;
      },
      createFromConfig: function createFromConfig(grid) {
        if (this.isFull()) return [];
        this.classType = GetFastValue(grid, "classType", this.classType);
        var key = GetFastValue(grid, "key", void 0),
            frame = GetFastValue(grid, "frame", null),
            visible = GetFastValue(grid, "visible", !0),
            active = GetFastValue(grid, "active", !0),
            entries = [];
        if (void 0 === key) return entries;
        Array.isArray(key) || (key = [key]), Array.isArray(frame) || (frame = [frame]);
        var scrollFactorX = GetFastValue(grid, "repeat", 0),
            hitArea = GetFastValue(grid, "randomKey", !1),
            hitAreaCallback = GetFastValue(grid, "randomFrame", !1),
            scrollFactorY = GetFastValue(grid, "yoyo", !1),
            quantity = GetFastValue(grid, "quantity", !1),
            frameQuantity = GetFastValue(grid, "frameQuantity", 1),
            max = GetFastValue(grid, "max", 0),
            range = Range(key, frame, {
          max: max,
          qty: quantity || frameQuantity,
          random: hitArea,
          randomB: hitAreaCallback,
          repeat: scrollFactorX,
          yoyo: scrollFactorY
        });
        grid.createCallback && (this.createCallback = grid.createCallback), grid.removeCallback && (this.removeCallback = grid.removeCallback);

        for (var c = 0; c < range.length; c++) {
          var created = this.create(0, 0, range[c].a, range[c].b, visible, active);
          if (!created) break;
          entries.push(created);
        }

        hitArea = GetValue(grid, "setXY.x", 0), hitAreaCallback = GetValue(grid, "setXY.y", 0), scrollFactorX = GetValue(grid, "setXY.stepX", 0), scrollFactorY = GetValue(grid, "setXY.stepY", 0);
        Actions.SetXY(entries, hitArea, hitAreaCallback, scrollFactorX, scrollFactorY);
        hitArea = GetValue(grid, "setRotation.value", 0), hitAreaCallback = GetValue(grid, "setRotation.step", 0);
        Actions.SetRotation(entries, hitArea, hitAreaCallback);
        scrollFactorX = GetValue(grid, "setScale.x", 1), scrollFactorY = GetValue(grid, "setScale.y", scrollFactorX), hitArea = GetValue(grid, "setScale.stepX", 0), hitAreaCallback = GetValue(grid, "setScale.stepY", 0);
        Actions.SetScale(entries, scrollFactorX, scrollFactorY, hitArea, hitAreaCallback);
        scrollFactorX = GetValue(grid, "setOrigin.x", .5), scrollFactorY = GetValue(grid, "setOrigin.y", scrollFactorX), hitArea = GetValue(grid, "setOrigin.stepX", 0), hitAreaCallback = GetValue(grid, "setOrigin.stepY", 0);
        Actions.SetOrigin(entries, scrollFactorX, scrollFactorY, hitArea, hitAreaCallback);
        scrollFactorX = GetValue(grid, "setAlpha.value", 1), scrollFactorY = GetValue(grid, "setAlpha.step", 0);
        Actions.SetAlpha(entries, scrollFactorX, scrollFactorY);
        hitArea = GetValue(grid, "setDepth.value", 0), hitAreaCallback = GetValue(grid, "setDepth.step", 0);
        Actions.SetDepth(entries, hitArea, hitAreaCallback);
        scrollFactorX = GetValue(grid, "setScrollFactor.x", 1), scrollFactorY = GetValue(grid, "setScrollFactor.y", scrollFactorX), hitArea = GetValue(grid, "setScrollFactor.stepX", 0), hitAreaCallback = GetValue(grid, "setScrollFactor.stepY", 0);
        Actions.SetScrollFactor(entries, scrollFactorX, scrollFactorY, hitArea, hitAreaCallback);
        hitArea = GetFastValue(grid, "hitArea", null), hitAreaCallback = GetFastValue(grid, "hitAreaCallback", null);
        hitArea && Actions.SetHitArea(entries, hitArea, hitAreaCallback);
        grid = GetFastValue(grid, "gridAlign", !1);
        return grid && Actions.GridAlign(entries, grid), this.createMultipleCallback && this.createMultipleCallback.call(this, entries), entries;
      },
      preUpdate: function preUpdate(time, delta) {
        if (this.runChildUpdate && 0 !== this.children.size) for (var temp = this.children.entries.slice(), i = 0; i < temp.length; i++) {
          var item = temp[i];
          item.active && item.update(time, delta);
        }
      },
      add: function add(child, addToScene) {
        return void 0 === addToScene && (addToScene = !1), this.isFull() || (this.children.set(child), this.internalCreateCallback && this.internalCreateCallback.call(this, child), this.createCallback && this.createCallback.call(this, child), addToScene && (child.addToDisplayList(this.scene.sys.displayList), child.addToUpdateList()), child.on(Events.DESTROY, this.remove, this)), this;
      },
      addMultiple: function addMultiple(children, addToScene) {
        if (void 0 === addToScene && (addToScene = !1), Array.isArray(children)) for (var i = 0; i < children.length; i++) {
          this.add(children[i], addToScene);
        }
        return this;
      },
      remove: function remove(child, removeFromScene, destroyChild) {
        return void 0 === removeFromScene && (removeFromScene = !1), void 0 === destroyChild && (destroyChild = !1), this.children.contains(child) && (this.children.delete(child), this.internalRemoveCallback && this.internalRemoveCallback.call(this, child), this.removeCallback && this.removeCallback.call(this, child), child.off(Events.DESTROY, this.remove, this), destroyChild ? child.destroy() : removeFromScene && (child.removeFromDisplayList(), child.removeFromUpdateList())), this;
      },
      clear: function clear(removeFromScene, destroyChild) {
        void 0 === removeFromScene && (removeFromScene = !1), void 0 === destroyChild && (destroyChild = !1);

        for (var children = this.children, i = 0; i < children.size; i++) {
          var gameObject = children.entries[i];
          gameObject.off(Events.DESTROY, this.remove, this), destroyChild ? gameObject.destroy() : removeFromScene && (gameObject.removeFromDisplayList(), gameObject.removeFromUpdateList());
        }

        return this.children.clear(), this;
      },
      contains: function contains(child) {
        return this.children.contains(child);
      },
      getChildren: function getChildren() {
        return this.children.entries;
      },
      getLength: function getLength() {
        return this.children.size;
      },
      getMatching: function getMatching(property, value, startIndex, endIndex) {
        return GetAll(this.children.entries, property, value, startIndex, endIndex);
      },
      getFirst: function getFirst(state, createIfNull, x, y, key, frame, visible) {
        return this.getHandler(!0, 1, state, createIfNull, x, y, key, frame, visible);
      },
      getFirstNth: function getFirstNth(nth, state, createIfNull, x, y, key, frame, visible) {
        return this.getHandler(!0, nth, state, createIfNull, x, y, key, frame, visible);
      },
      getLast: function getLast(state, createIfNull, x, y, key, frame, visible) {
        return this.getHandler(!1, 1, state, createIfNull, x, y, key, frame, visible);
      },
      getLastNth: function getLastNth(nth, state, createIfNull, x, y, key, frame, visible) {
        return this.getHandler(!1, nth, state, createIfNull, x, y, key, frame, visible);
      },
      getHandler: function getHandler(forwards, nth, state, createIfNull, x, y, key, frame, visible) {
        var gameObject, i;
        void 0 === state && (state = !1), void 0 === createIfNull && (createIfNull = !1);
        var total = 0,
            children = this.children.entries;
        if (forwards) for (i = 0; i < children.length; i++) {
          if ((gameObject = children[i]).active === state) {
            if (++total === nth) break;
          } else gameObject = null;
        } else for (i = children.length - 1; 0 <= i; i--) {
          if ((gameObject = children[i]).active === state) {
            if (++total === nth) break;
          } else gameObject = null;
        }
        return gameObject ? ("number" == typeof x && (gameObject.x = x), "number" == typeof y && (gameObject.y = y), gameObject) : createIfNull ? this.create(x, y, key, frame, visible) : null;
      },
      get: function get(x, y, key, frame, visible) {
        return this.getFirst(!1, !0, x, y, key, frame, visible);
      },
      getFirstAlive: function getFirstAlive(createIfNull, x, y, key, frame, visible) {
        return this.getFirst(!0, createIfNull, x, y, key, frame, visible);
      },
      getFirstDead: function getFirstDead(createIfNull, x, y, key, frame, visible) {
        return this.getFirst(!1, createIfNull, x, y, key, frame, visible);
      },
      playAnimation: function playAnimation(key, startFrame) {
        return Actions.PlayAnimation(this.children.entries, key, startFrame), this;
      },
      isFull: function isFull() {
        return -1 !== this.maxSize && this.children.size >= this.maxSize;
      },
      countActive: function countActive(value) {
        void 0 === value && (value = !0);

        for (var total = 0, i = 0; i < this.children.size; i++) {
          this.children.entries[i].active === value && total++;
        }

        return total;
      },
      getTotalUsed: function getTotalUsed() {
        return this.countActive();
      },
      getTotalFree: function getTotalFree() {
        var used = this.getTotalUsed();
        return (-1 === this.maxSize ? 999999999999 : this.maxSize) - used;
      },
      setActive: function setActive(value) {
        return this.active = value, this;
      },
      setName: function setName(value) {
        return this.name = value, this;
      },
      propertyValueSet: function propertyValueSet(key, value, step, index, direction) {
        return Actions.PropertyValueSet(this.children.entries, key, value, step, index, direction), this;
      },
      propertyValueInc: function propertyValueInc(key, value, step, index, direction) {
        return Actions.PropertyValueInc(this.children.entries, key, value, step, index, direction), this;
      },
      setX: function setX(value, step) {
        return Actions.SetX(this.children.entries, value, step), this;
      },
      setY: function setY(value, step) {
        return Actions.SetY(this.children.entries, value, step), this;
      },
      setXY: function setXY(x, y, stepX, stepY) {
        return Actions.SetXY(this.children.entries, x, y, stepX, stepY), this;
      },
      incX: function incX(value, step) {
        return Actions.IncX(this.children.entries, value, step), this;
      },
      incY: function incY(value, step) {
        return Actions.IncY(this.children.entries, value, step), this;
      },
      incXY: function incXY(x, y, stepX, stepY) {
        return Actions.IncXY(this.children.entries, x, y, stepX, stepY), this;
      },
      shiftPosition: function shiftPosition(x, y, direction) {
        return Actions.ShiftPosition(this.children.entries, x, y, direction), this;
      },
      angle: function angle(value, step) {
        return Actions.Angle(this.children.entries, value, step), this;
      },
      rotate: function rotate(value, step) {
        return Actions.Rotate(this.children.entries, value, step), this;
      },
      rotateAround: function rotateAround(point, angle) {
        return Actions.RotateAround(this.children.entries, point, angle), this;
      },
      rotateAroundDistance: function rotateAroundDistance(point, angle, distance) {
        return Actions.RotateAroundDistance(this.children.entries, point, angle, distance), this;
      },
      setAlpha: function setAlpha(value, step) {
        return Actions.SetAlpha(this.children.entries, value, step), this;
      },
      setTint: function setTint(topLeft, topRight, bottomLeft, bottomRight) {
        return Actions.SetTint(this.children.entries, topLeft, topRight, bottomLeft, bottomRight), this;
      },
      setOrigin: function setOrigin(originX, originY, stepX, stepY) {
        return Actions.SetOrigin(this.children.entries, originX, originY, stepX, stepY), this;
      },
      scaleX: function scaleX(value, step) {
        return Actions.ScaleX(this.children.entries, value, step), this;
      },
      scaleY: function scaleY(value, step) {
        return Actions.ScaleY(this.children.entries, value, step), this;
      },
      scaleXY: function scaleXY(scaleX, scaleY, stepX, stepY) {
        return Actions.ScaleXY(this.children.entries, scaleX, scaleY, stepX, stepY), this;
      },
      setDepth: function setDepth(value, step) {
        return Actions.SetDepth(this.children.entries, value, step), this;
      },
      setBlendMode: function setBlendMode(value) {
        return Actions.SetBlendMode(this.children.entries, value), this;
      },
      setHitArea: function setHitArea(hitArea, hitAreaCallback) {
        return Actions.SetHitArea(this.children.entries, hitArea, hitAreaCallback), this;
      },
      shuffle: function shuffle() {
        return Actions.Shuffle(this.children.entries), this;
      },
      kill: function kill(gameObject) {
        this.children.contains(gameObject) && gameObject.setActive(!1);
      },
      killAndHide: function killAndHide(gameObject) {
        this.children.contains(gameObject) && (gameObject.setActive(!1), gameObject.setVisible(!1));
      },
      setVisible: function setVisible(value, index, direction) {
        return Actions.SetVisible(this.children.entries, value, index, direction), this;
      },
      toggleVisible: function toggleVisible() {
        return Actions.ToggleVisible(this.children.entries), this;
      },
      destroy: function destroy(destroyChildren, removeFromScene) {
        void 0 === destroyChildren && (destroyChildren = !1), void 0 === removeFromScene && (removeFromScene = !1), this.scene && !this.ignoreDestroy && (this.emit(Events.DESTROY, this), this.removeAllListeners(), this.scene.sys.updateList.remove(this), this.clear(removeFromScene, destroyChildren), this.scene = void 0, this.children = void 0);
      }
    });

    module.exports = Group;
  }, function (module, exports, __webpack_require__) {
    var Utils = __webpack_require__(12);

    module.exports = function (pipeline, calcMatrix, src, alpha, dx, dy) {
      for (var fillTintColor = Utils.getTintAppendFloatAlpha(src.fillColor, src.fillAlpha * alpha), path = src.pathData, pathIndexes = src.pathIndexes, i = 0; i < pathIndexes.length; i += 3) {
        var x2 = 2 * pathIndexes[i],
            ty2 = 2 * pathIndexes[i + 1],
            tx0 = 2 * pathIndexes[i + 2],
            ty0 = path[0 + x2] - dx,
            tx1 = path[1 + x2] - dy,
            ty1 = path[0 + ty2] - dx,
            tx2 = path[1 + ty2] - dy,
            x2 = path[0 + tx0] - dx,
            ty2 = path[1 + tx0] - dy,
            tx0 = calcMatrix.getX(ty0, tx1),
            ty0 = calcMatrix.getY(ty0, tx1),
            tx1 = calcMatrix.getX(ty1, tx2),
            ty1 = calcMatrix.getY(ty1, tx2),
            tx2 = calcMatrix.getX(x2, ty2),
            ty2 = calcMatrix.getY(x2, ty2);
        pipeline.batchTri(src, tx0, ty0, tx1, ty1, tx2, ty2, 0, 0, 1, 1, fillTintColor, fillTintColor, fillTintColor, 2);
      }
    };
  }, function (module, exports) {
    module.exports = function (dot01, v, dot00) {
      var dot02 = dot01.x3 - dot01.x1,
          u = dot01.y3 - dot01.y1,
          v1x = dot01.x2 - dot01.x1,
          dot12 = dot01.y2 - dot01.y1,
          v2x = v - dot01.x1,
          v = dot00 - dot01.y1,
          dot00 = dot02 * dot02 + u * u,
          dot01 = dot02 * v1x + u * dot12,
          dot02 = dot02 * v2x + u * v,
          u = v1x * v1x + dot12 * dot12,
          dot12 = v1x * v2x + dot12 * v,
          v = dot00 * u - dot01 * dot01,
          v = 0 == v ? 0 : 1 / v,
          u = (u * dot02 - dot01 * dot12) * v,
          v = (dot00 * dot12 - dot01 * dot02) * v;
      return 0 <= u && 0 <= v && u + v < 1;
    };
  }, function (module, exports, __webpack_require__) {
    var Face = __webpack_require__(0),
        Rectangle = __webpack_require__(10),
        Vector2 = __webpack_require__(3);

    function GetLength(x1, y1, x, y) {
      x = x1 - x, y = y1 - y;
      return Math.sqrt(x * x + y * y);
    }

    Face = new Face({
      initialize: function initialize(vertex1, vertex2, vertex3) {
        this.vertex1 = vertex1, this.vertex2 = vertex2, this.vertex3 = vertex3, this.bounds = new Rectangle(), this._inCenter = new Vector2();
      },
      getInCenter: function getInCenter(d1) {
        var v1x,
            v1y,
            v2x,
            v2y,
            v3x,
            d2 = this.vertex1,
            d3 = this.vertex2,
            p = this.vertex3,
            v3y = (d1 = void 0 === d1 ? !0 : d1) ? (v1x = d2.x, v1y = d2.y, v2x = d3.x, v2y = d3.y, v3x = p.x, p.y) : (v1x = d2.vx, v1y = d2.vy, v2x = d3.vx, v2y = d3.vy, v3x = p.vx, p.vy),
            d1 = GetLength(v3x, v3y, v2x, v2y),
            d2 = GetLength(v1x, v1y, v3x, v3y),
            d3 = GetLength(v2x, v2y, v1x, v1y),
            p = d1 + d2 + d3;
        return this._inCenter.set((v1x * d1 + v2x * d2 + v3x * d3) / p, (v1y * d1 + v2y * d2 + v3y * d3) / p);
      },
      contains: function contains(t2x, dot00, f) {
        var a,
            b,
            c,
            d,
            e,
            vertex1 = this.vertex1,
            vertex2 = this.vertex2,
            vertex3 = this.vertex3,
            v = vertex1.vx,
            dot01 = vertex1.vy,
            t1x = vertex2.vx,
            dot12 = vertex2.vy,
            dot02 = vertex3.vx,
            u = vertex3.vy;
        f && (a = f.a, b = f.b, c = f.c, d = f.d, e = f.e, f = f.f, v = vertex1.vx * a + vertex1.vy * c + e, dot01 = vertex1.vx * b + vertex1.vy * d + f, t1x = vertex2.vx * a + vertex2.vy * c + e, dot12 = vertex2.vx * b + vertex2.vy * d + f, dot02 = vertex3.vx * a + vertex3.vy * c + e, u = vertex3.vx * b + vertex3.vy * d + f);
        dot02 -= v, u -= dot01, t1x -= v, dot12 -= dot01, t2x -= v, v = dot00 - dot01, dot00 = dot02 * dot02 + u * u, dot01 = dot02 * t1x + u * dot12, dot02 = dot02 * t2x + u * v, u = t1x * t1x + dot12 * dot12, dot12 = t1x * t2x + dot12 * v, v = dot00 * u - dot01 * dot01, v = 0 == v ? 0 : 1 / v, u = (u * dot02 - dot01 * dot12) * v, v *= dot00 * dot12 - dot01 * dot02;
        return 0 <= u && 0 <= v && u + v < 1;
      },
      isCounterClockwise: function isCounterClockwise(z) {
        var d = this.vertex1,
            v2 = this.vertex2,
            v3 = this.vertex3,
            d = (v2.vx - d.vx) * (v3.vy - d.vy) - (v2.vy - d.vy) * (v3.vx - d.vx);
        return z <= 0 ? 0 <= d : d < 0;
      },
      load: function load(F32, U32, offset, textureUnit, tintEffect) {
        return offset = this.vertex1.load(F32, U32, offset, textureUnit, tintEffect), offset = this.vertex2.load(F32, U32, offset, textureUnit, tintEffect), offset = this.vertex3.load(F32, U32, offset, textureUnit, tintEffect);
      },
      transformCoordinatesLocal: function transformCoordinatesLocal(transformMatrix, width, height, cameraZ) {
        return this.vertex1.transformCoordinatesLocal(transformMatrix, width, height, cameraZ), this.vertex2.transformCoordinatesLocal(transformMatrix, width, height, cameraZ), this.vertex3.transformCoordinatesLocal(transformMatrix, width, height, cameraZ), this;
      },
      updateBounds: function updateBounds() {
        var v1 = this.vertex1,
            v2 = this.vertex2,
            v3 = this.vertex3,
            bounds = this.bounds;
        return bounds.x = Math.min(v1.vx, v2.vx, v3.vx), bounds.y = Math.min(v1.vy, v2.vy, v3.vy), bounds.width = Math.max(v1.vx, v2.vx, v3.vx) - bounds.x, bounds.height = Math.max(v1.vy, v2.vy, v3.vy) - bounds.y, this;
      },
      isInView: function isInView(camera, hideCCW, bounds, cb, a, b, c, d, e, f, roundPixels) {
        var v1 = this.vertex1.update(a, b, c, d, e, f, roundPixels, cb),
            cr = this.vertex2.update(a, b, c, d, e, f, roundPixels, cb),
            cb = this.vertex3.update(a, b, c, d, e, f, roundPixels, cb);
        if (v1.ta <= 0 && cr.ta <= 0 && cb.ta <= 0) return !1;
        if (hideCCW && !this.isCounterClockwise(bounds)) return !1;
        bounds = this.bounds;
        bounds.x = Math.min(v1.tx, cr.tx, cb.tx), bounds.y = Math.min(v1.ty, cr.ty, cb.ty), bounds.width = Math.max(v1.tx, cr.tx, cb.tx) - bounds.x, bounds.height = Math.max(v1.ty, cr.ty, cb.ty) - bounds.y;
        cr = camera.x + camera.width, cb = camera.y + camera.height;
        return !(bounds.width <= 0 || bounds.height <= 0 || camera.width <= 0 || camera.height <= 0) && !(bounds.right < camera.x || bounds.bottom < camera.y || bounds.x > cr || bounds.y > cb);
      },
      translate: function translate(x, y) {
        void 0 === y && (y = 0);
        var v1 = this.vertex1,
            v2 = this.vertex2,
            v3 = this.vertex3;
        return v1.x += x, v1.y += y, v2.x += x, v2.y += y, v3.x += x, v3.y += y, this;
      },
      x: {
        get: function get() {
          return this.getInCenter().x;
        },
        set: function set(value) {
          var current = this.getInCenter();
          this.translate(value - current.x, 0);
        }
      },
      y: {
        get: function get() {
          return this.getInCenter().y;
        },
        set: function set(value) {
          var current = this.getInCenter();
          this.translate(0, value - current.y);
        }
      },
      alpha: {
        get: function get() {
          var v1 = this.vertex1,
              v2 = this.vertex2,
              v3 = this.vertex3;
          return (v1.alpha + v2.alpha + v3.alpha) / 3;
        },
        set: function set(value) {
          this.vertex1.alpha = value, this.vertex2.alpha = value, this.vertex3.alpha = value;
        }
      },
      depth: {
        get: function get() {
          var v1 = this.vertex1,
              v2 = this.vertex2,
              v3 = this.vertex3;
          return (v1.vz + v2.vz + v3.vz) / 3;
        }
      },
      destroy: function destroy() {
        this.vertex1 = null, this.vertex2 = null, this.vertex3 = null;
      }
    });
    module.exports = Face;
  }, function (module, exports, __webpack_require__) {
    var Vertex = __webpack_require__(0),
        Utils = __webpack_require__(12),
        Vector3 = __webpack_require__(39),
        Vertex = new Vertex({
      Extends: Vector3,
      initialize: function initialize(x, y, z, u, v, color, alpha, nx, ny, nz) {
        void 0 === color && (color = 16777215), void 0 === alpha && (alpha = 1), void 0 === nx && (nx = 0), void 0 === ny && (ny = 0), void 0 === nz && (nz = 0), Vector3.call(this, x, y, z), this.vx = 0, this.vy = 0, this.vz = 0, this.nx = nx, this.ny = ny, this.nz = nz, this.u = u, this.v = v, this.color = color, this.alpha = alpha, this.tx = 0, this.ty = 0, this.ta = 0;
      },
      setUVs: function setUVs(u, v) {
        return this.u = u, this.v = v, this;
      },
      transformCoordinatesLocal: function transformCoordinatesLocal(tz, width, height, cameraZ) {
        var x = this.x,
            y = this.y,
            z = this.z,
            tw = tz.val,
            tx = x * tw[0] + y * tw[4] + z * tw[8] + tw[12],
            ty = x * tw[1] + y * tw[5] + z * tw[9] + tw[13],
            tz = x * tw[2] + y * tw[6] + z * tw[10] + tw[14],
            tw = x * tw[3] + y * tw[7] + z * tw[11] + tw[15];
        this.vx = tx / tw * width, this.vy = -ty / tw * height, this.vz = cameraZ <= 0 ? tz / tw : -tz / tw;
      },
      update: function update(a, b, c, d, tx, ty, roundPixels, alpha) {
        tx = this.vx * a + this.vy * c + tx, ty = this.vx * b + this.vy * d + ty;
        return roundPixels && (tx = Math.round(tx), ty = Math.round(ty)), this.tx = tx, this.ty = ty, this.ta = this.alpha * alpha, this;
      },
      load: function load(F32, U32, offset, textureUnit, tintEffect) {
        return F32[++offset] = this.tx, F32[++offset] = this.ty, F32[++offset] = this.u, F32[++offset] = this.v, F32[++offset] = textureUnit, F32[++offset] = tintEffect, U32[++offset] = Utils.getTintAppendFloatAlpha(this.color, this.ta), offset;
      }
    });

    module.exports = Vertex;
  }, function (module, exports, __webpack_require__) {
    var Composite = {};
    module.exports = Composite;

    var Events = __webpack_require__(166),
        Common = __webpack_require__(32),
        Bounds = __webpack_require__(84),
        Body = __webpack_require__(41);

    Composite.create = function (options) {
      return Common.extend({
        id: Common.nextId(),
        type: "composite",
        parent: null,
        isModified: !1,
        bodies: [],
        constraints: [],
        composites: [],
        label: "Composite",
        plugin: {}
      }, options);
    }, Composite.setModified = function (composite, isModified, updateParents, updateChildren) {
      if (Events.trigger(composite, "compositeModified", composite), composite.isModified = isModified, updateParents && composite.parent && Composite.setModified(composite.parent, isModified, updateParents, updateChildren), updateChildren) for (var i = 0; i < composite.composites.length; i++) {
        var childComposite = composite.composites[i];
        Composite.setModified(childComposite, isModified, updateParents, updateChildren);
      }
    }, Composite.add = function (composite, object) {
      var objects = [].concat(object);
      Events.trigger(composite, "beforeAdd", {
        object: object
      });

      for (var i = 0; i < objects.length; i++) {
        var obj = objects[i];

        switch (obj.type) {
          case "body":
            if (obj.parent !== obj) {
              Common.warn("Composite.add: skipped adding a compound body part (you must add its parent instead)");
              break;
            }

            Composite.addBody(composite, obj);
            break;

          case "constraint":
            Composite.addConstraint(composite, obj);
            break;

          case "composite":
            Composite.addComposite(composite, obj);
            break;

          case "mouseConstraint":
            Composite.addConstraint(composite, obj.constraint);
        }
      }

      return Events.trigger(composite, "afterAdd", {
        object: object
      }), composite;
    }, Composite.remove = function (composite, object, deep) {
      var objects = [].concat(object);
      Events.trigger(composite, "beforeRemove", {
        object: object
      });

      for (var i = 0; i < objects.length; i++) {
        var obj = objects[i];

        switch (obj.type) {
          case "body":
            Composite.removeBody(composite, obj, deep);
            break;

          case "constraint":
            Composite.removeConstraint(composite, obj, deep);
            break;

          case "composite":
            Composite.removeComposite(composite, obj, deep);
            break;

          case "mouseConstraint":
            Composite.removeConstraint(composite, obj.constraint);
        }
      }

      return Events.trigger(composite, "afterRemove", {
        object: object
      }), composite;
    }, Composite.addComposite = function (compositeA, compositeB) {
      return compositeA.composites.push(compositeB), compositeB.parent = compositeA, Composite.setModified(compositeA, !0, !0, !1), compositeA;
    }, Composite.removeComposite = function (compositeA, compositeB, deep) {
      var position = compositeA.composites.indexOf(compositeB);
      if (-1 !== position && (Composite.removeCompositeAt(compositeA, position), Composite.setModified(compositeA, !0, !0, !1)), deep) for (var i = 0; i < compositeA.composites.length; i++) {
        Composite.removeComposite(compositeA.composites[i], compositeB, !0);
      }
      return compositeA;
    }, Composite.removeCompositeAt = function (composite, position) {
      return composite.composites.splice(position, 1), Composite.setModified(composite, !0, !0, !1), composite;
    }, Composite.addBody = function (composite, body) {
      return composite.bodies.push(body), Composite.setModified(composite, !0, !0, !1), composite;
    }, Composite.removeBody = function (composite, body, deep) {
      var position = composite.bodies.indexOf(body);
      if (-1 !== position && (Composite.removeBodyAt(composite, position), Composite.setModified(composite, !0, !0, !1)), deep) for (var i = 0; i < composite.composites.length; i++) {
        Composite.removeBody(composite.composites[i], body, !0);
      }
      return composite;
    }, Composite.removeBodyAt = function (composite, position) {
      return composite.bodies.splice(position, 1), Composite.setModified(composite, !0, !0, !1), composite;
    }, Composite.addConstraint = function (composite, constraint) {
      return composite.constraints.push(constraint), Composite.setModified(composite, !0, !0, !1), composite;
    }, Composite.removeConstraint = function (composite, constraint, deep) {
      var position = composite.constraints.indexOf(constraint);
      if (-1 !== position && Composite.removeConstraintAt(composite, position), deep) for (var i = 0; i < composite.composites.length; i++) {
        Composite.removeConstraint(composite.composites[i], constraint, !0);
      }
      return composite;
    }, Composite.removeConstraintAt = function (composite, position) {
      return composite.constraints.splice(position, 1), Composite.setModified(composite, !0, !0, !1), composite;
    }, Composite.clear = function (composite, keepStatic, deep) {
      if (deep) for (var i = 0; i < composite.composites.length; i++) {
        Composite.clear(composite.composites[i], keepStatic, !0);
      }
      return keepStatic ? composite.bodies = composite.bodies.filter(function (body) {
        return body.isStatic;
      }) : composite.bodies.length = 0, composite.constraints.length = 0, composite.composites.length = 0, Composite.setModified(composite, !0, !0, !1), composite;
    }, Composite.allBodies = function (composite) {
      for (var bodies = [].concat(composite.bodies), i = 0; i < composite.composites.length; i++) {
        bodies = bodies.concat(Composite.allBodies(composite.composites[i]));
      }

      return bodies;
    }, Composite.allConstraints = function (composite) {
      for (var constraints = [].concat(composite.constraints), i = 0; i < composite.composites.length; i++) {
        constraints = constraints.concat(Composite.allConstraints(composite.composites[i]));
      }

      return constraints;
    }, Composite.allComposites = function (composite) {
      for (var composites = [].concat(composite.composites), i = 0; i < composite.composites.length; i++) {
        composites = composites.concat(Composite.allComposites(composite.composites[i]));
      }

      return composites;
    }, Composite.get = function (composite, id, object) {
      var objects;

      switch (object) {
        case "body":
          objects = Composite.allBodies(composite);
          break;

        case "constraint":
          objects = Composite.allConstraints(composite);
          break;

        case "composite":
          objects = Composite.allComposites(composite).concat(composite);
      }

      return !objects || 0 === (object = objects.filter(function (object) {
        return object.id.toString() === id.toString();
      })).length ? null : object[0];
    }, Composite.move = function (compositeA, objects, compositeB) {
      return Composite.remove(compositeA, objects), Composite.add(compositeB, objects), compositeA;
    }, Composite.rebase = function (composite) {
      for (var objects = Composite.allBodies(composite).concat(Composite.allConstraints(composite)).concat(Composite.allComposites(composite)), i = 0; i < objects.length; i++) {
        objects[i].id = Common.nextId();
      }

      return Composite.setModified(composite, !0, !0, !1), composite;
    }, Composite.translate = function (composite, translation, recursive) {
      for (var bodies = recursive ? Composite.allBodies(composite) : composite.bodies, i = 0; i < bodies.length; i++) {
        Body.translate(bodies[i], translation);
      }

      return Composite.setModified(composite, !0, !0, !1), composite;
    }, Composite.rotate = function (composite, rotation, point, recursive) {
      for (var cos = Math.cos(rotation), sin = Math.sin(rotation), bodies = recursive ? Composite.allBodies(composite) : composite.bodies, i = 0; i < bodies.length; i++) {
        var body = bodies[i],
            dx = body.position.x - point.x,
            dy = body.position.y - point.y;
        Body.setPosition(body, {
          x: point.x + (dx * cos - dy * sin),
          y: point.y + (dx * sin + dy * cos)
        }), Body.rotate(body, rotation);
      }

      return Composite.setModified(composite, !0, !0, !1), composite;
    }, Composite.scale = function (composite, scaleX, scaleY, point, recursive) {
      for (var bodies = recursive ? Composite.allBodies(composite) : composite.bodies, i = 0; i < bodies.length; i++) {
        var body = bodies[i],
            dx = body.position.x - point.x,
            dy = body.position.y - point.y;
        Body.setPosition(body, {
          x: point.x + dx * scaleX,
          y: point.y + dy * scaleY
        }), Body.scale(body, scaleX, scaleY);
      }

      return Composite.setModified(composite, !0, !0, !1), composite;
    }, Composite.bounds = function (composite) {
      for (var bodies = Composite.allBodies(composite), vertices = [], i = 0; i < bodies.length; i += 1) {
        var body = bodies[i];
        vertices.push(body.bounds.min, body.bounds.max);
      }

      return Bounds.create(vertices);
    };
  }, function (module, exports) {
    module.exports = function (tileX, tileY, layer) {
      return 0 <= tileX && tileX < layer.width && 0 <= tileY && tileY < layer.height;
    };
  }, function (module, exports, __webpack_require__) {
    var LayerData = __webpack_require__(0),
        CONST = __webpack_require__(29),
        GetFastValue = __webpack_require__(2),
        LayerData = new LayerData({
      initialize: function initialize(config) {
        this.name = GetFastValue(config = void 0 === config ? {} : config, "name", "layer"), this.x = GetFastValue(config, "x", 0), this.y = GetFastValue(config, "y", 0), this.width = GetFastValue(config, "width", 0), this.height = GetFastValue(config, "height", 0), this.tileWidth = GetFastValue(config, "tileWidth", 0), this.tileHeight = GetFastValue(config, "tileHeight", 0), this.baseTileWidth = GetFastValue(config, "baseTileWidth", this.tileWidth), this.baseTileHeight = GetFastValue(config, "baseTileHeight", this.tileHeight), this.orientation = GetFastValue(config, "orientation", CONST.ORTHOGONAL), this.widthInPixels = GetFastValue(config, "widthInPixels", this.width * this.baseTileWidth), this.heightInPixels = GetFastValue(config, "heightInPixels", this.height * this.baseTileHeight), this.alpha = GetFastValue(config, "alpha", 1), this.visible = GetFastValue(config, "visible", !0), this.properties = GetFastValue(config, "properties", []), this.indexes = GetFastValue(config, "indexes", []), this.collideIndexes = GetFastValue(config, "collideIndexes", []), this.callbacks = GetFastValue(config, "callbacks", []), this.bodies = GetFastValue(config, "bodies", []), this.data = GetFastValue(config, "data", []), this.tilemapLayer = GetFastValue(config, "tilemapLayer", null), this.hexSideLength = GetFastValue(config, "hexSideLength", 0);
      }
    });

    module.exports = LayerData;
  }, function (module, exports, __webpack_require__) {
    var MapData = __webpack_require__(0),
        CONST = __webpack_require__(29),
        GetFastValue = __webpack_require__(2),
        MapData = new MapData({
      initialize: function initialize(config) {
        this.name = GetFastValue(config = void 0 === config ? {} : config, "name", "map"), this.width = GetFastValue(config, "width", 0), this.height = GetFastValue(config, "height", 0), this.infinite = GetFastValue(config, "infinite", !1), this.tileWidth = GetFastValue(config, "tileWidth", 0), this.tileHeight = GetFastValue(config, "tileHeight", 0), this.widthInPixels = GetFastValue(config, "widthInPixels", this.width * this.tileWidth), this.heightInPixels = GetFastValue(config, "heightInPixels", this.height * this.tileHeight), this.format = GetFastValue(config, "format", null), this.orientation = GetFastValue(config, "orientation", CONST.ORTHOGONAL), this.renderOrder = GetFastValue(config, "renderOrder", "right-down"), this.version = GetFastValue(config, "version", "1"), this.properties = GetFastValue(config, "properties", {}), this.layers = GetFastValue(config, "layers", []), this.images = GetFastValue(config, "images", []), this.objects = GetFastValue(config, "objects", {}), this.collision = GetFastValue(config, "collision", {}), this.tilesets = GetFastValue(config, "tilesets", []), this.imageCollections = GetFastValue(config, "imageCollections", []), this.tiles = GetFastValue(config, "tiles", []), this.hexSideLength = GetFastValue(config, "hexSideLength", 0);
      }
    });

    module.exports = MapData;
  }, function (module, exports, Tileset) {
    Tileset = new (Tileset(0))({
      initialize: function initialize(name, firstgid, tileWidth, tileHeight, tileMargin, tileSpacing, tileProperties, tileData) {
        (void 0 === tileWidth || tileWidth <= 0) && (tileWidth = 32), (void 0 === tileHeight || tileHeight <= 0) && (tileHeight = 32), void 0 === tileMargin && (tileMargin = 0), void 0 === tileSpacing && (tileSpacing = 0), void 0 === tileProperties && (tileProperties = {}), void 0 === tileData && (tileData = {}), this.name = name, this.firstgid = firstgid, this.tileWidth = tileWidth, this.tileHeight = tileHeight, this.tileMargin = tileMargin, this.tileSpacing = tileSpacing, this.tileProperties = tileProperties, this.tileData = tileData, this.image = null, this.glTexture = null, this.rows = 0, this.columns = 0, this.total = 0, this.texCoordinates = [];
      },
      getTileProperties: function getTileProperties(tileIndex) {
        return this.containsTileIndex(tileIndex) ? this.tileProperties[tileIndex - this.firstgid] : null;
      },
      getTileData: function getTileData(tileIndex) {
        return this.containsTileIndex(tileIndex) ? this.tileData[tileIndex - this.firstgid] : null;
      },
      getTileCollisionGroup: function getTileCollisionGroup(data) {
        data = this.getTileData(data);
        return data && data.objectgroup ? data.objectgroup : null;
      },
      containsTileIndex: function containsTileIndex(tileIndex) {
        return tileIndex >= this.firstgid && tileIndex < this.firstgid + this.total;
      },
      getTileTextureCoordinates: function getTileTextureCoordinates(tileIndex) {
        return this.containsTileIndex(tileIndex) ? this.texCoordinates[tileIndex - this.firstgid] : null;
      },
      setImage: function setImage(texture) {
        return this.image = texture, this.glTexture = texture.get().source.glTexture, this.updateTileData(this.image.source[0].width, this.image.source[0].height), this;
      },
      setTileSize: function setTileSize(tileWidth, tileHeight) {
        return void 0 !== tileWidth && (this.tileWidth = tileWidth), void 0 !== tileHeight && (this.tileHeight = tileHeight), this.image && this.updateTileData(this.image.source[0].width, this.image.source[0].height), this;
      },
      setSpacing: function setSpacing(margin, spacing) {
        return void 0 !== margin && (this.tileMargin = margin), void 0 !== spacing && (this.tileSpacing = spacing), this.image && this.updateTileData(this.image.source[0].width, this.image.source[0].height), this;
      },
      updateTileData: function updateTileData(colCount, rowCount) {
        rowCount = (rowCount - 2 * this.tileMargin + this.tileSpacing) / (this.tileHeight + this.tileSpacing), colCount = (colCount - 2 * this.tileMargin + this.tileSpacing) / (this.tileWidth + this.tileSpacing);
        rowCount % 1 == 0 && colCount % 1 == 0 || console.warn("Image tile area not tile size multiple in: " + this.name), rowCount = Math.floor(rowCount), colCount = Math.floor(colCount), this.rows = rowCount, this.columns = colCount, this.total = rowCount * colCount, this.texCoordinates.length = 0;

        for (var tx = this.tileMargin, ty = this.tileMargin, y = 0; y < this.rows; y++) {
          for (var x = 0; x < this.columns; x++) {
            this.texCoordinates.push({
              x: tx,
              y: ty
            }), tx += this.tileWidth + this.tileSpacing;
          }

          tx = this.tileMargin, ty += this.tileHeight + this.tileSpacing;
        }

        return this;
      }
    });
    module.exports = Tileset;
  }, function (module, exports) {
    module.exports = {
      TOP_LEFT: 0,
      TOP_CENTER: 1,
      TOP_RIGHT: 2,
      LEFT_TOP: 3,
      LEFT_CENTER: 4,
      LEFT_BOTTOM: 5,
      CENTER: 6,
      RIGHT_TOP: 7,
      RIGHT_CENTER: 8,
      RIGHT_BOTTOM: 9,
      BOTTOM_LEFT: 10,
      BOTTOM_CENTER: 11,
      BOTTOM_RIGHT: 12
    };
  }, function (module, exports) {
    module.exports = function (a, b, epsilon) {
      return void 0 === epsilon && (epsilon = 1e-4), Math.abs(a - b) < epsilon;
    };
  }, function (module, exports, Image) {
    var Class = Image(0),
        Components = Image(11),
        GameObject = Image(15),
        Image = Image(1068),
        Image = new Class({
      Extends: GameObject,
      Mixins: [Components.Alpha, Components.BlendMode, Components.Depth, Components.Flip, Components.GetBounds, Components.Mask, Components.Origin, Components.Pipeline, Components.ScrollFactor, Components.Size, Components.TextureCrop, Components.Tint, Components.Transform, Components.Visible, Image],
      initialize: function initialize(scene, x, y, texture, frame) {
        GameObject.call(this, scene, "Image"), this._crop = this.resetCropObject(), this.setTexture(texture, frame), this.setPosition(x, y), this.setSizeToFrame(), this.setOriginFromFrame(), this.initPipeline();
      }
    });
    module.exports = Image;
  }, function (module, exports) {
    module.exports = function (source, key) {
      return source.hasOwnProperty(key);
    };
  }, function (module, exports, __webpack_require__) {
    var Clone = __webpack_require__(77);

    module.exports = function (obj1, obj2) {
      var key,
          clone = Clone(obj1);

      for (key in obj2) {
        clone.hasOwnProperty(key) || (clone[key] = obj2[key]);
      }

      return clone;
    };
  }, function (module, exports, __webpack_require__) {
    var Constraint = {};
    module.exports = Constraint;

    var Vertices = __webpack_require__(64),
        Vector = __webpack_require__(83),
        Sleeping = __webpack_require__(165),
        Bounds = __webpack_require__(84),
        Axes = __webpack_require__(271),
        Common = __webpack_require__(32);

    Constraint._warming = .4, Constraint._torqueDampen = 1, Constraint._minLength = 1e-6, Constraint.create = function (render) {
      var constraint = render;
      constraint.bodyA && !constraint.pointA && (constraint.pointA = {
        x: 0,
        y: 0
      }), constraint.bodyB && !constraint.pointB && (constraint.pointB = {
        x: 0,
        y: 0
      });
      var initialPointA = constraint.bodyA ? Vector.add(constraint.bodyA.position, constraint.pointA) : constraint.pointA,
          render = constraint.bodyB ? Vector.add(constraint.bodyB.position, constraint.pointB) : constraint.pointB,
          render = Vector.magnitude(Vector.sub(initialPointA, render));
      constraint.length = void 0 !== constraint.length ? constraint.length : render, constraint.id = constraint.id || Common.nextId(), constraint.label = constraint.label || "Constraint", constraint.type = "constraint", constraint.stiffness = constraint.stiffness || (0 < constraint.length ? 1 : .7), constraint.damping = constraint.damping || 0, constraint.angularStiffness = constraint.angularStiffness || 0, constraint.angleA = constraint.bodyA ? constraint.bodyA.angle : constraint.angleA, constraint.angleB = constraint.bodyB ? constraint.bodyB.angle : constraint.angleB, constraint.plugin = {};
      render = {
        visible: !0,
        type: "line",
        anchors: !0,
        lineColor: null,
        lineOpacity: null,
        lineThickness: null,
        pinSize: null,
        anchorColor: null,
        anchorSize: null
      };
      return 0 === constraint.length && .1 < constraint.stiffness ? (render.type = "pin", render.anchors = !1) : constraint.stiffness < .9 && (render.type = "spring"), constraint.render = Common.extend(render, constraint.render), constraint;
    }, Constraint.preSolveAll = function (bodies) {
      for (var i = 0; i < bodies.length; i += 1) {
        var body = bodies[i],
            impulse = body.constraintImpulse;
        body.isStatic || 0 === impulse.x && 0 === impulse.y && 0 === impulse.angle || (body.position.x += impulse.x, body.position.y += impulse.y, body.angle += impulse.angle);
      }
    }, Constraint.solveAll = function (constraints, timeScale) {
      for (var i = 0; i < constraints.length; i += 1) {
        var constraint = constraints[i],
            fixedA = !constraint.bodyA || constraint.bodyA && constraint.bodyA.isStatic,
            fixedB = !constraint.bodyB || constraint.bodyB && constraint.bodyB.isStatic;
        (fixedA || fixedB) && Constraint.solve(constraints[i], timeScale);
      }

      for (i = 0; i < constraints.length; i += 1) {
        fixedA = !(constraint = constraints[i]).bodyA || constraint.bodyA && constraint.bodyA.isStatic, fixedB = !constraint.bodyB || constraint.bodyB && constraint.bodyB.isStatic, fixedA || fixedB || Constraint.solve(constraints[i], timeScale);
      }
    }, Constraint.solve = function (constraint, force) {
      var delta,
          currentLength,
          massTotal,
          resistanceTotal,
          torque,
          share,
          normal,
          normalVelocity,
          bodyA = constraint.bodyA,
          bodyB = constraint.bodyB,
          pointA = constraint.pointA,
          pointB = constraint.pointB;
      (bodyA || bodyB) && (bodyA && !bodyA.isStatic && (Vector.rotate(pointA, bodyA.angle - constraint.angleA, pointA), constraint.angleA = bodyA.angle), bodyB && !bodyB.isStatic && (Vector.rotate(pointB, bodyB.angle - constraint.angleB, pointB), constraint.angleB = bodyB.angle), massTotal = pointA, resistanceTotal = pointB, bodyA && (massTotal = Vector.add(bodyA.position, pointA)), bodyB && (resistanceTotal = Vector.add(bodyB.position, pointB)), massTotal && resistanceTotal && (delta = Vector.sub(massTotal, resistanceTotal), massTotal = ((currentLength = (currentLength = Vector.magnitude(delta)) < Constraint._minLength ? Constraint._minLength : currentLength) - constraint.length) / currentLength, resistanceTotal = constraint.stiffness < 1 ? constraint.stiffness * force : constraint.stiffness, force = Vector.mult(delta, massTotal * resistanceTotal), resistanceTotal = (massTotal = (bodyA ? bodyA.inverseMass : 0) + (bodyB ? bodyB.inverseMass : 0)) + ((bodyA ? bodyA.inverseInertia : 0) + (bodyB ? bodyB.inverseInertia : 0)), constraint.damping && (normalVelocity = Vector.create(), normal = Vector.div(delta, currentLength), normalVelocity = Vector.sub(bodyB && Vector.sub(bodyB.position, bodyB.positionPrev) || normalVelocity, bodyA && Vector.sub(bodyA.position, bodyA.positionPrev) || normalVelocity), normalVelocity = Vector.dot(normal, normalVelocity)), bodyA && !bodyA.isStatic && (share = bodyA.inverseMass / massTotal, bodyA.constraintImpulse.x -= force.x * share, bodyA.constraintImpulse.y -= force.y * share, bodyA.position.x -= force.x * share, bodyA.position.y -= force.y * share, constraint.damping && (bodyA.positionPrev.x -= constraint.damping * normal.x * normalVelocity * share, bodyA.positionPrev.y -= constraint.damping * normal.y * normalVelocity * share), torque = Vector.cross(pointA, force) / resistanceTotal * Constraint._torqueDampen * bodyA.inverseInertia * (1 - constraint.angularStiffness), bodyA.constraintImpulse.angle -= torque, bodyA.angle -= torque), bodyB && !bodyB.isStatic && (share = bodyB.inverseMass / massTotal, bodyB.constraintImpulse.x += force.x * share, bodyB.constraintImpulse.y += force.y * share, bodyB.position.x += force.x * share, bodyB.position.y += force.y * share, constraint.damping && (bodyB.positionPrev.x += constraint.damping * normal.x * normalVelocity * share, bodyB.positionPrev.y += constraint.damping * normal.y * normalVelocity * share), torque = Vector.cross(pointB, force) / resistanceTotal * Constraint._torqueDampen * bodyB.inverseInertia * (1 - constraint.angularStiffness), bodyB.constraintImpulse.angle += torque, bodyB.angle += torque)));
    }, Constraint.postSolveAll = function (bodies) {
      for (var i = 0; i < bodies.length; i++) {
        var body = bodies[i],
            impulse = body.constraintImpulse;

        if (!(body.isStatic || 0 === impulse.x && 0 === impulse.y && 0 === impulse.angle)) {
          Sleeping.set(body, !1);

          for (var j = 0; j < body.parts.length; j++) {
            var part = body.parts[j];
            Vertices.translate(part.vertices, impulse), 0 < j && (part.position.x += impulse.x, part.position.y += impulse.y), 0 !== impulse.angle && (Vertices.rotate(part.vertices, impulse.angle, body.position), Axes.rotate(part.axes, impulse.angle), 0 < j && Vector.rotateAbout(part.position, impulse.angle, body.position, part.position)), Bounds.update(part.bounds, part.vertices, body.velocity);
          }

          impulse.angle *= Constraint._warming, impulse.x *= Constraint._warming, impulse.y *= Constraint._warming;
        }
      }
    }, Constraint.pointAWorld = function (constraint) {
      return {
        x: (constraint.bodyA ? constraint.bodyA.position.x : 0) + constraint.pointA.x,
        y: (constraint.bodyA ? constraint.bodyA.position.y : 0) + constraint.pointA.y
      };
    }, Constraint.pointBWorld = function (constraint) {
      return {
        x: (constraint.bodyB ? constraint.bodyB.position.x : 0) + constraint.pointB.x,
        y: (constraint.bodyB ? constraint.bodyB.position.y : 0) + constraint.pointB.y
      };
    };
  }, function (module, exports, __webpack_require__) {
    var BlendModes = __webpack_require__(35),
        Circle = __webpack_require__(65),
        CircleContains = __webpack_require__(66),
        Class = __webpack_require__(0),
        Zone = __webpack_require__(11),
        GameObject = __webpack_require__(15),
        Rectangle = __webpack_require__(10),
        RectangleContains = __webpack_require__(57),
        Zone = new Class({
      Extends: GameObject,
      Mixins: [Zone.Depth, Zone.GetBounds, Zone.Origin, Zone.Transform, Zone.ScrollFactor, Zone.Visible],
      initialize: function initialize(scene, x, y, width, height) {
        void 0 === width && (width = 1), void 0 === height && (height = width), GameObject.call(this, scene, "Zone"), this.setPosition(x, y), this.width = width, this.height = height, this.blendMode = BlendModes.NORMAL, this.updateDisplayOrigin();
      },
      displayWidth: {
        get: function get() {
          return this.scaleX * this.width;
        },
        set: function set(value) {
          this.scaleX = value / this.width;
        }
      },
      displayHeight: {
        get: function get() {
          return this.scaleY * this.height;
        },
        set: function set(value) {
          this.scaleY = value / this.height;
        }
      },
      setSize: function setSize(width, height, resizeInput) {
        void 0 === resizeInput && (resizeInput = !0), this.width = width, this.height = height, this.updateDisplayOrigin();
        var input = this.input;
        return resizeInput && input && !input.customHitArea && (input.hitArea.width = width, input.hitArea.height = height), this;
      },
      setDisplaySize: function setDisplaySize(width, height) {
        return this.displayWidth = width, this.displayHeight = height, this;
      },
      setCircleDropZone: function setCircleDropZone(radius) {
        return this.setDropZone(new Circle(0, 0, radius), CircleContains);
      },
      setRectangleDropZone: function setRectangleDropZone(width, height) {
        return this.setDropZone(new Rectangle(0, 0, width, height), RectangleContains);
      },
      setDropZone: function setDropZone(hitArea, hitAreaCallback) {
        return void 0 === hitArea ? this.setRectangleDropZone(this.width, this.height) : this.input || this.setInteractive(hitArea, hitAreaCallback, !0), this;
      },
      setAlpha: function setAlpha() {},
      setBlendMode: function setBlendMode() {},
      renderCanvas: function renderCanvas(renderer, src, camera) {
        camera.addToRenderList(src);
      },
      renderWebGL: function renderWebGL(renderer, src, camera) {
        camera.addToRenderList(src);
      }
    });

    module.exports = Zone;
  }, function (module, exports) {
    module.exports = function (rect) {
      return 2 * (rect.width + rect.height);
    };
  }, function (module, exports) {
    module.exports = function (array) {
      for (var i = array.length - 1; 0 < i; i--) {
        var j = Math.floor(Math.random() * (i + 1)),
            temp = array[i];
        array[i] = array[j], array[j] = temp;
      }

      return array;
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      ADD_ANIMATION: __webpack_require__(724),
      ANIMATION_COMPLETE: __webpack_require__(725),
      ANIMATION_COMPLETE_KEY: __webpack_require__(726),
      ANIMATION_REPEAT: __webpack_require__(727),
      ANIMATION_RESTART: __webpack_require__(728),
      ANIMATION_START: __webpack_require__(729),
      ANIMATION_STOP: __webpack_require__(730),
      ANIMATION_UPDATE: __webpack_require__(731),
      PAUSE_ALL: __webpack_require__(732),
      REMOVE_ANIMATION: __webpack_require__(733),
      RESUME_ALL: __webpack_require__(734)
    };
  }, function (module, exports, __webpack_require__) {
    var Class = __webpack_require__(0),
        BaseCamera = __webpack_require__(11),
        DegToRad = __webpack_require__(36),
        EventEmitter = __webpack_require__(9),
        Events = __webpack_require__(37),
        Rectangle = __webpack_require__(10),
        TransformMatrix = __webpack_require__(25),
        ValueToColor = __webpack_require__(187),
        Vector2 = __webpack_require__(3),
        BaseCamera = new Class({
      Extends: EventEmitter,
      Mixins: [BaseCamera.Alpha, BaseCamera.Visible],
      initialize: function initialize(x, y, width, height) {
        void 0 === x && (x = 0), void 0 === y && (y = 0), void 0 === width && (width = 0), void 0 === height && (height = 0), EventEmitter.call(this), this.scene, this.sceneManager, this.scaleManager, this.cameraManager, this.id = 0, this.name = "", this.roundPixels = !1, this.useBounds = !1, this.worldView = new Rectangle(), this.dirty = !0, this._x = x, this._y = y, this._width = width, this._height = height, this._bounds = new Rectangle(), this._scrollX = 0, this._scrollY = 0, this._zoomX = 1, this._zoomY = 1, this._rotation = 0, this.matrix = new TransformMatrix(), this.transparent = !0, this.backgroundColor = ValueToColor("rgba(0,0,0,0)"), this.disableCull = !1, this.culledObjects = [], this.midPoint = new Vector2(width / 2, height / 2), this.originX = .5, this.originY = .5, this._customViewport = !1, this.mask = null, this._maskCamera = null, this.renderList = [];
      },
      addToRenderList: function addToRenderList(child) {
        this.renderList.push(child);
      },
      setOrigin: function setOrigin(x, y) {
        return void 0 === x && (x = .5), void 0 === y && (y = x), this.originX = x, this.originY = y, this;
      },
      getScroll: function getScroll(x, y, out) {
        void 0 === out && (out = new Vector2());
        var originX = .5 * this.width,
            originY = .5 * this.height;
        return out.x = x - originX, out.y = y - originY, this.useBounds && (out.x = this.clampX(out.x), out.y = this.clampY(out.y)), out;
      },
      centerOnX: function centerOnX(x) {
        var originX = .5 * this.width;
        return this.midPoint.x = x, this.scrollX = x - originX, this.useBounds && (this.scrollX = this.clampX(this.scrollX)), this;
      },
      centerOnY: function centerOnY(y) {
        var originY = .5 * this.height;
        return this.midPoint.y = y, this.scrollY = y - originY, this.useBounds && (this.scrollY = this.clampY(this.scrollY)), this;
      },
      centerOn: function centerOn(x, y) {
        return this.centerOnX(x), this.centerOnY(y), this;
      },
      centerToBounds: function centerToBounds() {
        var bounds, originX, originY;
        return this.useBounds && (bounds = this._bounds, originX = .5 * this.width, originY = .5 * this.height, this.midPoint.set(bounds.centerX, bounds.centerY), this.scrollX = bounds.centerX - originX, this.scrollY = bounds.centerY - originY), this;
      },
      centerToSize: function centerToSize() {
        return this.scrollX = .5 * this.width, this.scrollY = .5 * this.height, this;
      },
      cull: function cull(renderableObjects) {
        if (this.disableCull) return renderableObjects;
        var cameraH = this.matrix.matrix,
            mva = cameraH[0],
            mvb = cameraH[1],
            mvc = cameraH[2],
            mvd = cameraH[3];
        if (!(mva * mvd - mvb * mvc)) return renderableObjects;

        for (var mve = cameraH[4], mvf = cameraH[5], scrollX = this.scrollX, scrollY = this.scrollY, cameraW = this.width, cameraH = this.height, cullTop = this.y, cullBottom = cullTop + cameraH, cullLeft = this.x, cullRight = cullLeft + cameraW, culledObjects = this.culledObjects, length = renderableObjects.length, index = culledObjects.length = 0; index < length; ++index) {
          var objectW,
              objectH,
              objectX,
              objectY,
              object = renderableObjects[index];
          object.hasOwnProperty("width") && !object.parentContainer ? (objectW = object.width, objectH = object.height, cullLeft < ((objectX = object.x - scrollX * object.scrollFactorX - objectW * object.originX) + objectW) * mva + ((objectY = object.y - scrollY * object.scrollFactorY - objectH * object.originY) + objectH) * mvc + mve && objectX * mva + objectY * mvc + mve < cullRight && cullTop < (objectX + objectW) * mvb + (objectY + objectH) * mvd + mvf && objectX * mvb + objectY * mvd + mvf < cullBottom && culledObjects.push(object)) : culledObjects.push(object);
        }

        return culledObjects;
      },
      getWorldPoint: function getWorldPoint(x, y, output) {
        void 0 === output && (output = new Vector2());
        var ime = this.matrix.matrix,
            sy = ime[0],
            s = ime[1],
            imf = ime[2],
            c = ime[3],
            sx = ime[4],
            scrollX = ime[5],
            scrollY = sy * c - s * imf;
        if (!scrollY) return output.x = x, output.y = y, output;
        var ima = c * (scrollY = 1 / scrollY),
            imb = -s * scrollY,
            imc = -imf * scrollY,
            imd = sy * scrollY,
            ime = (imf * scrollX - c * sx) * scrollY,
            imf = (s * sx - sy * scrollX) * scrollY,
            c = Math.cos(this.rotation),
            s = Math.sin(this.rotation),
            sx = this.zoomX,
            sy = this.zoomY,
            scrollX = this.scrollX,
            scrollY = this.scrollY,
            sx = x + (scrollX * c - scrollY * s) * sx,
            sy = y + (scrollX * s + scrollY * c) * sy;
        return output.x = sx * ima + sy * imc + ime, output.y = sx * imb + sy * imd + imf, output;
      },
      ignore: function ignore(entries) {
        var id = this.id;
        Array.isArray(entries) || (entries = [entries]);

        for (var i = 0; i < entries.length; i++) {
          var entry = entries[i];
          Array.isArray(entry) ? this.ignore(entry) : entry.isParent ? this.ignore(entry.getChildren()) : entry.cameraFilter |= id;
        }

        return this;
      },
      preRender: function preRender() {
        this.renderList.length = 0;
        var displayWidth = this.width,
            displayHeight = this.height,
            midX = .5 * displayWidth,
            midY = .5 * displayHeight,
            zoomX = this.zoomX,
            zoomY = this.zoomY,
            matrix = this.matrix,
            originX = displayWidth * this.originX,
            originY = displayHeight * this.originY,
            sx = this.scrollX,
            sy = this.scrollY;
        this.useBounds && (sx = this.clampX(sx), sy = this.clampY(sy)), this.roundPixels && (originX = Math.round(originX), originY = Math.round(originY));
        midX = (this.scrollX = sx) + midX, midY = (this.scrollY = sy) + midY;
        this.midPoint.set(midX, midY);
        displayWidth /= zoomX, displayHeight /= zoomY;
        this.worldView.setTo(midX - displayWidth / 2, midY - displayHeight / 2, displayWidth, displayHeight), matrix.applyITRS(this.x + originX, this.y + originY, this.rotation, zoomX, zoomY), matrix.translate(-originX, -originY);
      },
      clampX: function clampX(x) {
        var bounds = this._bounds,
            bw = this.displayWidth,
            bx = bounds.x + (bw - this.width) / 2,
            bw = Math.max(bx, bx + bounds.width - bw);
        return x < bx ? x = bx : bw < x && (x = bw), x;
      },
      clampY: function clampY(y) {
        var bounds = this._bounds,
            bh = this.displayHeight,
            by = bounds.y + (bh - this.height) / 2,
            bh = Math.max(by, by + bounds.height - bh);
        return y < by ? y = by : bh < y && (y = bh), y;
      },
      removeBounds: function removeBounds() {
        return this.useBounds = !1, this.dirty = !0, this._bounds.setEmpty(), this;
      },
      setAngle: function setAngle(value) {
        return this.rotation = DegToRad(value = void 0 === value ? 0 : value), this;
      },
      setBackgroundColor: function setBackgroundColor(color) {
        return this.backgroundColor = ValueToColor(color = void 0 === color ? "rgba(0,0,0,0)" : color), this.transparent = 0 === this.backgroundColor.alpha, this;
      },
      setBounds: function setBounds(x, y, width, height, centerOn) {
        return void 0 === centerOn && (centerOn = !1), this._bounds.setTo(x, y, width, height), this.dirty = !0, this.useBounds = !0, centerOn ? this.centerToBounds() : (this.scrollX = this.clampX(this.scrollX), this.scrollY = this.clampY(this.scrollY)), this;
      },
      getBounds: function getBounds(out) {
        void 0 === out && (out = new Rectangle());
        var source = this._bounds;
        return out.setTo(source.x, source.y, source.width, source.height), out;
      },
      setName: function setName(value) {
        return this.name = value = void 0 === value ? "" : value, this;
      },
      setPosition: function setPosition(x, y) {
        return void 0 === y && (y = x), this.x = x, this.y = y, this;
      },
      setRotation: function setRotation(value) {
        return this.rotation = value = void 0 === value ? 0 : value, this;
      },
      setRoundPixels: function setRoundPixels(value) {
        return this.roundPixels = value, this;
      },
      setScene: function setScene(sys) {
        this.scene && this._customViewport && this.sceneManager.customViewports--;
        sys = (this.scene = sys).sys;
        return this.sceneManager = sys.game.scene, this.scaleManager = sys.scale, this.cameraManager = sys.cameras, this.updateSystem(), this;
      },
      setScroll: function setScroll(x, y) {
        return void 0 === y && (y = x), this.scrollX = x, this.scrollY = y, this;
      },
      setSize: function setSize(width, height) {
        return void 0 === height && (height = width), this.width = width, this.height = height, this;
      },
      setViewport: function setViewport(x, y, width, height) {
        return this.x = x, this.y = y, this.width = width, this.height = height, this;
      },
      setZoom: function setZoom(x, y) {
        return void 0 === x && (x = 1), 0 === (y = void 0 === y ? x : y) && (y = .001), this.zoomX = x = 0 === x ? .001 : x, this.zoomY = y, this;
      },
      setMask: function setMask(mask, fixedPosition) {
        return void 0 === fixedPosition && (fixedPosition = !0), this.mask = mask, this._maskCamera = fixedPosition ? this.cameraManager.default : this, this;
      },
      clearMask: function clearMask(destroyMask) {
        return (destroyMask = void 0 === destroyMask ? !1 : destroyMask) && this.mask && this.mask.destroy(), this.mask = null, this;
      },
      toJSON: function toJSON() {
        var output = {
          name: this.name,
          x: this.x,
          y: this.y,
          width: this.width,
          height: this.height,
          zoom: this.zoom,
          rotation: this.rotation,
          roundPixels: this.roundPixels,
          scrollX: this.scrollX,
          scrollY: this.scrollY,
          backgroundColor: this.backgroundColor.rgba
        };
        return this.useBounds && (output.bounds = {
          x: this._bounds.x,
          y: this._bounds.y,
          width: this._bounds.width,
          height: this._bounds.height
        }), output;
      },
      update: function update() {},
      updateSystem: function updateSystem() {
        var custom, sceneManager;
        this.scaleManager && (custom = 0 !== this._x || 0 !== this._y || this.scaleManager.width !== this._width || this.scaleManager.height !== this._height, sceneManager = this.sceneManager, custom && !this._customViewport ? sceneManager.customViewports++ : !custom && this._customViewport && sceneManager.customViewports--, this.dirty = !0, this._customViewport = custom);
      },
      destroy: function destroy() {
        this.emit(Events.DESTROY, this), this.removeAllListeners(), this.matrix.destroy(), this.culledObjects = [], this._customViewport && this.sceneManager.customViewports--, this.renderList = [], this._bounds = null, this.scene = null, this.scaleManager = null, this.sceneManager = null, this.cameraManager = null;
      },
      x: {
        get: function get() {
          return this._x;
        },
        set: function set(value) {
          this._x = value, this.updateSystem();
        }
      },
      y: {
        get: function get() {
          return this._y;
        },
        set: function set(value) {
          this._y = value, this.updateSystem();
        }
      },
      width: {
        get: function get() {
          return this._width;
        },
        set: function set(value) {
          this._width = value, this.updateSystem();
        }
      },
      height: {
        get: function get() {
          return this._height;
        },
        set: function set(value) {
          this._height = value, this.updateSystem();
        }
      },
      scrollX: {
        get: function get() {
          return this._scrollX;
        },
        set: function set(value) {
          this._scrollX = value, this.dirty = !0;
        }
      },
      scrollY: {
        get: function get() {
          return this._scrollY;
        },
        set: function set(value) {
          this._scrollY = value, this.dirty = !0;
        }
      },
      zoom: {
        get: function get() {
          return (this._zoomX + this._zoomY) / 2;
        },
        set: function set(value) {
          this._zoomX = value, this._zoomY = value, this.dirty = !0;
        }
      },
      zoomX: {
        get: function get() {
          return this._zoomX;
        },
        set: function set(value) {
          this._zoomX = value, this.dirty = !0;
        }
      },
      zoomY: {
        get: function get() {
          return this._zoomY;
        },
        set: function set(value) {
          this._zoomY = value, this.dirty = !0;
        }
      },
      rotation: {
        get: function get() {
          return this._rotation;
        },
        set: function set(value) {
          this._rotation = value, this.dirty = !0;
        }
      },
      centerX: {
        get: function get() {
          return this.x + .5 * this.width;
        }
      },
      centerY: {
        get: function get() {
          return this.y + .5 * this.height;
        }
      },
      displayWidth: {
        get: function get() {
          return this.width / this.zoomX;
        }
      },
      displayHeight: {
        get: function get() {
          return this.height / this.zoomY;
        }
      }
    });

    module.exports = BaseCamera;
  }, function (module, exports, Stepped) {
    var Back = Stepped(334),
        Bounce = Stepped(335),
        Circular = Stepped(336),
        Cubic = Stepped(337),
        Elastic = Stepped(338),
        Expo = Stepped(339),
        Linear = Stepped(340),
        Quadratic = Stepped(341),
        Quartic = Stepped(342),
        Quintic = Stepped(343),
        Sine = Stepped(344),
        Stepped = Stepped(345);
    module.exports = {
      Power0: Linear,
      Power1: Quadratic.Out,
      Power2: Cubic.Out,
      Power3: Quartic.Out,
      Power4: Quintic.Out,
      Linear: Linear,
      Quad: Quadratic.Out,
      Cubic: Cubic.Out,
      Quart: Quartic.Out,
      Quint: Quintic.Out,
      Sine: Sine.Out,
      Expo: Expo.Out,
      Circ: Circular.Out,
      Elastic: Elastic.Out,
      Back: Back.Out,
      Bounce: Bounce.Out,
      Stepped: Stepped,
      "Quad.easeIn": Quadratic.In,
      "Cubic.easeIn": Cubic.In,
      "Quart.easeIn": Quartic.In,
      "Quint.easeIn": Quintic.In,
      "Sine.easeIn": Sine.In,
      "Expo.easeIn": Expo.In,
      "Circ.easeIn": Circular.In,
      "Elastic.easeIn": Elastic.In,
      "Back.easeIn": Back.In,
      "Bounce.easeIn": Bounce.In,
      "Quad.easeOut": Quadratic.Out,
      "Cubic.easeOut": Cubic.Out,
      "Quart.easeOut": Quartic.Out,
      "Quint.easeOut": Quintic.Out,
      "Sine.easeOut": Sine.Out,
      "Expo.easeOut": Expo.Out,
      "Circ.easeOut": Circular.Out,
      "Elastic.easeOut": Elastic.Out,
      "Back.easeOut": Back.Out,
      "Bounce.easeOut": Bounce.Out,
      "Quad.easeInOut": Quadratic.InOut,
      "Cubic.easeInOut": Cubic.InOut,
      "Quart.easeInOut": Quartic.InOut,
      "Quint.easeInOut": Quintic.InOut,
      "Sine.easeInOut": Sine.InOut,
      "Expo.easeInOut": Expo.InOut,
      "Circ.easeInOut": Circular.InOut,
      "Elastic.easeInOut": Elastic.InOut,
      "Back.easeInOut": Back.InOut,
      "Bounce.easeInOut": Bounce.InOut
    };
  }, function (module, exports) {
    module.exports = function (p0, p1, t) {
      return (p1 - p0) * t + p0;
    };
  }, function (ua, exports, Browser) {
    var OS = Browser(105),
        Browser = {
      chrome: !1,
      chromeVersion: 0,
      edge: !1,
      firefox: !1,
      firefoxVersion: 0,
      ie: !1,
      ieVersion: 0,
      mobileSafari: !1,
      opera: !1,
      safari: !1,
      safariVersion: 0,
      silk: !1,
      trident: !1,
      tridentVersion: 0
    };
    ua.exports = (ua = navigator.userAgent, /Edge\/\d+/.test(ua) ? Browser.edge = !0 : /Chrome\/(\d+)/.test(ua) && !OS.windowsPhone ? (Browser.chrome = !0, Browser.chromeVersion = parseInt(RegExp.$1, 10)) : /Firefox\D+(\d+)/.test(ua) ? (Browser.firefox = !0, Browser.firefoxVersion = parseInt(RegExp.$1, 10)) : /AppleWebKit/.test(ua) && OS.iOS ? Browser.mobileSafari = !0 : /MSIE (\d+\.\d+);/.test(ua) ? (Browser.ie = !0, Browser.ieVersion = parseInt(RegExp.$1, 10)) : /Opera/.test(ua) ? Browser.opera = !0 : /Safari/.test(ua) && !OS.windowsPhone ? Browser.safari = !0 : /Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/.test(ua) && (Browser.ie = !0, Browser.trident = !0, Browser.tridentVersion = parseInt(RegExp.$1, 10), Browser.ieVersion = parseInt(RegExp.$3, 10)), /Silk/.test(ua) && (Browser.silk = !0), Browser);
  }, function (module, exports) {
    module.exports = function (min, max) {
      return Math.random() * (max - min) + min;
    };
  }, function (module, exports) {
    module.exports = function (width, height) {
      return 0 < width && 0 == (width & width - 1) && 0 < height && 0 == (height & height - 1);
    };
  }, function (module, exports) {
    module.exports = function (value, gap, start, divide) {
      return 0 === gap ? value : (value -= start = void 0 === start ? 0 : start, value = gap * Math.ceil(value / gap), divide ? (start + value) / gap : start + value);
    };
  }, function (module, exports, __webpack_require__) {
    var Vector4 = new (__webpack_require__(0))({
      initialize: function initialize(x, y, z, w) {
        this.x = 0, this.y = 0, this.z = 0, this.w = 0, "object" == _typeof(x) ? (this.x = x.x || 0, this.y = x.y || 0, this.z = x.z || 0, this.w = x.w || 0) : (this.x = x || 0, this.y = y || 0, this.z = z || 0, this.w = w || 0);
      },
      clone: function clone() {
        return new Vector4(this.x, this.y, this.z, this.w);
      },
      copy: function copy(src) {
        return this.x = src.x, this.y = src.y, this.z = src.z || 0, this.w = src.w || 0, this;
      },
      equals: function equals(v) {
        return this.x === v.x && this.y === v.y && this.z === v.z && this.w === v.w;
      },
      set: function set(x, y, z, w) {
        return "object" == _typeof(x) ? (this.x = x.x || 0, this.y = x.y || 0, this.z = x.z || 0, this.w = x.w || 0) : (this.x = x || 0, this.y = y || 0, this.z = z || 0, this.w = w || 0), this;
      },
      add: function add(v) {
        return this.x += v.x, this.y += v.y, this.z += v.z || 0, this.w += v.w || 0, this;
      },
      subtract: function subtract(v) {
        return this.x -= v.x, this.y -= v.y, this.z -= v.z || 0, this.w -= v.w || 0, this;
      },
      scale: function scale(_scale2) {
        return this.x *= _scale2, this.y *= _scale2, this.z *= _scale2, this.w *= _scale2, this;
      },
      length: function length() {
        var x = this.x,
            y = this.y,
            z = this.z,
            w = this.w;
        return Math.sqrt(x * x + y * y + z * z + w * w);
      },
      lengthSq: function lengthSq() {
        var x = this.x,
            y = this.y,
            z = this.z,
            w = this.w;
        return x * x + y * y + z * z + w * w;
      },
      normalize: function normalize() {
        var x = this.x,
            y = this.y,
            z = this.z,
            w = this.w,
            len = x * x + y * y + z * z + w * w;
        return 0 < len && (len = 1 / Math.sqrt(len), this.x = x * len, this.y = y * len, this.z = z * len, this.w = w * len), this;
      },
      dot: function dot(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
      },
      lerp: function lerp(v, t) {
        var ax = this.x,
            ay = this.y,
            az = this.z,
            aw = this.w;
        return this.x = ax + (t = void 0 === t ? 0 : t) * (v.x - ax), this.y = ay + t * (v.y - ay), this.z = az + t * (v.z - az), this.w = aw + t * (v.w - aw), this;
      },
      multiply: function multiply(v) {
        return this.x *= v.x, this.y *= v.y, this.z *= v.z || 1, this.w *= v.w || 1, this;
      },
      divide: function divide(v) {
        return this.x /= v.x, this.y /= v.y, this.z /= v.z || 1, this.w /= v.w || 1, this;
      },
      distance: function distance(dw) {
        var dx = dw.x - this.x,
            dy = dw.y - this.y,
            dz = dw.z - this.z || 0,
            dw = dw.w - this.w || 0;
        return Math.sqrt(dx * dx + dy * dy + dz * dz + dw * dw);
      },
      distanceSq: function distanceSq(dw) {
        var dx = dw.x - this.x,
            dy = dw.y - this.y,
            dz = dw.z - this.z || 0,
            dw = dw.w - this.w || 0;
        return dx * dx + dy * dy + dz * dz + dw * dw;
      },
      negate: function negate() {
        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
      },
      transformMat4: function transformMat4(m) {
        var x = this.x,
            y = this.y,
            z = this.z,
            w = this.w,
            m = m.val;
        return this.x = m[0] * x + m[4] * y + m[8] * z + m[12] * w, this.y = m[1] * x + m[5] * y + m[9] * z + m[13] * w, this.z = m[2] * x + m[6] * y + m[10] * z + m[14] * w, this.w = m[3] * x + m[7] * y + m[11] * z + m[15] * w, this;
      },
      transformQuat: function transformQuat(iz) {
        var x = this.x,
            y = this.y,
            iw = this.z,
            qx = iz.x,
            qy = iz.y,
            qz = iz.z,
            qw = iz.w,
            ix = qw * x + qy * iw - qz * y,
            iy = qw * y + qz * x - qx * iw,
            iz = qw * iw + qx * y - qy * x,
            iw = -qx * x - qy * y - qz * iw;
        return this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy, this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz, this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx, this;
      },
      reset: function reset() {
        return this.x = 0, this.y = 0, this.z = 0, this.w = 0, this;
      }
    });
    Vector4.prototype.sub = Vector4.prototype.subtract, Vector4.prototype.mul = Vector4.prototype.multiply, Vector4.prototype.div = Vector4.prototype.divide, Vector4.prototype.dist = Vector4.prototype.distance, Vector4.prototype.distSq = Vector4.prototype.distanceSq, Vector4.prototype.len = Vector4.prototype.length, Vector4.prototype.lenSq = Vector4.prototype.lengthSq, module.exports = Vector4;
  }, function (module, exports, __webpack_require__) {
    var RenderTarget = __webpack_require__(0),
        Events = __webpack_require__(91),
        RenderTarget = new RenderTarget({
      initialize: function initialize(renderer, width, height, scale, minFilter, autoClear, autoResize) {
        void 0 === scale && (scale = 1), void 0 === minFilter && (minFilter = 0), void 0 === autoClear && (autoClear = !0), void 0 === autoResize && (autoResize = !1), this.renderer = renderer, this.framebuffer = null, this.texture = null, this.width = 0, this.height = 0, this.scale = scale, this.minFilter = minFilter, this.autoClear = autoClear, this.autoResize = !1, this.resize(width, height), autoResize && this.setAutoResize(!0);
      },
      setAutoResize: function setAutoResize(autoResize) {
        return autoResize && !this.autoResize ? (this.renderer.on(Events.RESIZE, this.resize, this), this.autoResize = !0) : !autoResize && this.autoResize && (this.renderer.off(Events.RESIZE, this.resize, this), this.autoResize = !1), this;
      },
      resize: function resize(width, height) {
        var scaledWidth = width * this.scale,
            renderer = height * this.scale;
        return scaledWidth === this.width && renderer === this.height || ((renderer = this.renderer).deleteFramebuffer(this.framebuffer), renderer.deleteTexture(this.texture), width *= this.scale, height *= this.scale, width = Math.round(width), height = Math.round(height), this.texture = renderer.createTextureFromSource(null, width = width <= 0 ? 1 : width, height = height <= 0 ? 1 : height, this.minFilter), this.framebuffer = renderer.createFramebuffer(width, height, this.texture, !1), this.width = width, this.height = height), this;
      },
      bind: function bind(gl, width, height) {
        (gl = void 0 === gl ? !1 : gl) && this.renderer.flush(), width && height && this.resize(width, height), this.renderer.pushFramebuffer(this.framebuffer, !1, !1, !1), gl && this.adjustViewport(), this.autoClear && ((gl = this.renderer.gl).clearColor(0, 0, 0, 0), gl.clear(gl.COLOR_BUFFER_BIT));
      },
      adjustViewport: function adjustViewport() {
        var gl = this.renderer.gl;
        gl.viewport(0, 0, this.width, this.height), gl.disable(gl.SCISSOR_TEST);
      },
      clear: function clear() {
        var renderer = this.renderer,
            gl = renderer.gl;
        renderer.pushFramebuffer(this.framebuffer), gl.disable(gl.SCISSOR_TEST), gl.clearColor(0, 0, 0, 0), gl.clear(gl.COLOR_BUFFER_BIT), renderer.popFramebuffer(), renderer.resetScissor();
      },
      unbind: function unbind(flush) {
        var renderer = this.renderer;
        return (flush = void 0 === flush ? !1 : flush) && renderer.flush(), renderer.popFramebuffer();
      },
      destroy: function destroy() {
        var renderer = this.renderer;
        renderer.deleteFramebuffer(this.framebuffer), renderer.deleteTexture(this.texture), renderer.off(Events.RESIZE, this.resize, this), this.renderer = null, this.framebuffer = null, this.texture = null;
      }
    });

    module.exports = RenderTarget;
  }, function (module, exports) {
    module.exports = function (element, parent) {
      var target;
      if (parent) "string" == typeof parent ? target = document.getElementById(parent) : "object" == _typeof(parent) && 1 === parent.nodeType && (target = parent);else if (element.parentElement || null === parent) return element;
      return (target = target || document.body).appendChild(element), element;
    };
  }, function (module, exports) {
    module.exports = {
      BACKSPACE: 8,
      TAB: 9,
      ENTER: 13,
      SHIFT: 16,
      CTRL: 17,
      ALT: 18,
      PAUSE: 19,
      CAPS_LOCK: 20,
      ESC: 27,
      SPACE: 32,
      PAGE_UP: 33,
      PAGE_DOWN: 34,
      END: 35,
      HOME: 36,
      LEFT: 37,
      UP: 38,
      RIGHT: 39,
      DOWN: 40,
      PRINT_SCREEN: 42,
      INSERT: 45,
      DELETE: 46,
      ZERO: 48,
      ONE: 49,
      TWO: 50,
      THREE: 51,
      FOUR: 52,
      FIVE: 53,
      SIX: 54,
      SEVEN: 55,
      EIGHT: 56,
      NINE: 57,
      NUMPAD_ZERO: 96,
      NUMPAD_ONE: 97,
      NUMPAD_TWO: 98,
      NUMPAD_THREE: 99,
      NUMPAD_FOUR: 100,
      NUMPAD_FIVE: 101,
      NUMPAD_SIX: 102,
      NUMPAD_SEVEN: 103,
      NUMPAD_EIGHT: 104,
      NUMPAD_NINE: 105,
      NUMPAD_ADD: 107,
      NUMPAD_SUBTRACT: 109,
      A: 65,
      B: 66,
      C: 67,
      D: 68,
      E: 69,
      F: 70,
      G: 71,
      H: 72,
      I: 73,
      J: 74,
      K: 75,
      L: 76,
      M: 77,
      N: 78,
      O: 79,
      P: 80,
      Q: 81,
      R: 82,
      S: 83,
      T: 84,
      U: 85,
      V: 86,
      W: 87,
      X: 88,
      Y: 89,
      Z: 90,
      F1: 112,
      F2: 113,
      F3: 114,
      F4: 115,
      F5: 116,
      F6: 117,
      F7: 118,
      F8: 119,
      F9: 120,
      F10: 121,
      F11: 122,
      F12: 123,
      SEMICOLON: 186,
      PLUS: 187,
      COMMA: 188,
      MINUS: 189,
      PERIOD: 190,
      FORWARD_SLASH: 191,
      BACK_SLASH: 220,
      QUOTES: 222,
      BACKTICK: 192,
      OPEN_BRACKET: 219,
      CLOSED_BRACKET: 221,
      SEMICOLON_FIREFOX: 59,
      COLON: 58,
      COMMA_FIREFOX_WINDOWS: 60,
      COMMA_FIREFOX: 62,
      BRACKET_RIGHT_FIREFOX: 174,
      BRACKET_LEFT_FIREFOX: 175
    };
  }, function (module, exports) {
    module.exports = {
      PENDING: 0,
      INIT: 1,
      START: 2,
      LOADING: 3,
      CREATING: 4,
      RUNNING: 5,
      PAUSED: 6,
      SLEEPING: 7,
      SHUTDOWN: 8,
      DESTROYED: 9
    };
  }, function (module, exports, __webpack_require__) {
    var Class = __webpack_require__(0),
        Clone = __webpack_require__(77),
        EventEmitter = __webpack_require__(9),
        Events = __webpack_require__(70),
        GameEvents = __webpack_require__(22),
        BaseSoundManager = __webpack_require__(1),
        GetAll = __webpack_require__(207),
        GetFirst = __webpack_require__(428),
        BaseSoundManager = new Class({
      Extends: EventEmitter,
      initialize: function initialize(game) {
        EventEmitter.call(this), this.game = game, this.jsonCache = game.cache.json, this.sounds = [], this.mute = !1, this.volume = 1, this.pauseOnBlur = !0, this._rate = 1, this._detune = 0, this.locked = this.locked || !1, this.unlocked = !1, game.events.on(GameEvents.BLUR, this.onGameBlur, this), game.events.on(GameEvents.FOCUS, this.onGameFocus, this), game.events.on(GameEvents.PRE_STEP, this.update, this), game.events.once(GameEvents.DESTROY, this.destroy, this);
      },
      add: BaseSoundManager,
      addAudioSprite: function addAudioSprite(key, config) {
        var markerName,
            markerConfig,
            marker,
            sound = this.add(key, config = void 0 === config ? {} : config);

        for (markerName in sound.spritemap = this.jsonCache.get(key).spritemap, sound.spritemap) {
          sound.spritemap.hasOwnProperty(markerName) && (markerConfig = Clone(config), marker = sound.spritemap[markerName], markerConfig.loop = !!marker.hasOwnProperty("loop") && marker.loop, sound.addMarker({
            name: markerName,
            start: marker.start,
            duration: marker.end - marker.start,
            config: markerConfig
          }));
        }

        return sound;
      },
      get: function get(key) {
        return GetFirst(this.sounds, "key", key);
      },
      getAll: function getAll(key) {
        return GetAll(this.sounds, "key", key);
      },
      play: function play(sound, extra) {
        sound = this.add(sound);
        return sound.once(Events.COMPLETE, sound.destroy, sound), extra ? extra.name ? (sound.addMarker(extra), sound.play(extra.name)) : sound.play(extra) : sound.play();
      },
      playAudioSprite: function playAudioSprite(sound, spriteName, config) {
        sound = this.addAudioSprite(sound);
        return sound.once(Events.COMPLETE, sound.destroy, sound), sound.play(spriteName, config);
      },
      remove: function remove(sound) {
        var index = this.sounds.indexOf(sound);
        return -1 !== index && (sound.destroy(), this.sounds.splice(index, 1), !0);
      },
      removeAll: function removeAll() {
        this.sounds.forEach(function (sound) {
          sound.destroy();
        }), this.sounds.length = 0;
      },
      removeByKey: function removeByKey(key) {
        for (var removed = 0, i = this.sounds.length - 1; 0 <= i; i--) {
          var sound = this.sounds[i];
          sound.key === key && (sound.destroy(), this.sounds.splice(i, 1), removed++);
        }

        return removed;
      },
      pauseAll: function pauseAll() {
        this.forEachActiveSound(function (sound) {
          sound.pause();
        }), this.emit(Events.PAUSE_ALL, this);
      },
      resumeAll: function resumeAll() {
        this.forEachActiveSound(function (sound) {
          sound.resume();
        }), this.emit(Events.RESUME_ALL, this);
      },
      stopAll: function stopAll() {
        this.forEachActiveSound(function (sound) {
          sound.stop();
        }), this.emit(Events.STOP_ALL, this);
      },
      stopByKey: function stopByKey(key) {
        var stopped = 0;
        return this.getAll(key).forEach(function (sound) {
          sound.stop() && stopped++;
        }), stopped;
      },
      unlock: BaseSoundManager,
      onBlur: BaseSoundManager,
      onFocus: BaseSoundManager,
      onGameBlur: function onGameBlur() {
        this.pauseOnBlur && this.onBlur();
      },
      onGameFocus: function onGameFocus() {
        this.pauseOnBlur && this.onFocus();
      },
      update: function update(time, delta) {
        this.unlocked && (this.unlocked = !1, this.locked = !1, this.emit(Events.UNLOCKED, this));

        for (var i = this.sounds.length - 1; 0 <= i; i--) {
          this.sounds[i].pendingRemove && this.sounds.splice(i, 1);
        }

        this.sounds.forEach(function (sound) {
          sound.update(time, delta);
        });
      },
      destroy: function destroy() {
        this.game.events.off(GameEvents.BLUR, this.onGameBlur, this), this.game.events.off(GameEvents.FOCUS, this.onGameFocus, this), this.game.events.off(GameEvents.PRE_STEP, this.update, this), this.removeAllListeners(), this.removeAll(), this.sounds.length = 0, this.sounds = null, this.game = null;
      },
      forEachActiveSound: function forEachActiveSound(callback, scope) {
        var _this = this;

        this.sounds.forEach(function (sound, index) {
          sound && !sound.pendingRemove && callback.call(scope || _this, sound, index, _this.sounds);
        });
      },
      setRate: function setRate(value) {
        return this.rate = value, this;
      },
      rate: {
        get: function get() {
          return this._rate;
        },
        set: function set(value) {
          this._rate = value, this.forEachActiveSound(function (sound) {
            sound.calculateRate();
          }), this.emit(Events.GLOBAL_RATE, this, value);
        }
      },
      setDetune: function setDetune(value) {
        return this.detune = value, this;
      },
      detune: {
        get: function get() {
          return this._detune;
        },
        set: function set(value) {
          this._detune = value, this.forEachActiveSound(function (sound) {
            sound.calculateRate();
          }), this.emit(Events.GLOBAL_DETUNE, this, value);
        }
      }
    });

    module.exports = BaseSoundManager;
  }, function (module, exports, BaseSound) {
    var Class = BaseSound(0),
        EventEmitter = BaseSound(9),
        Events = BaseSound(70),
        Extend = BaseSound(17),
        BaseSound = BaseSound(1),
        BaseSound = new Class({
      Extends: EventEmitter,
      initialize: function initialize(manager, key, config) {
        EventEmitter.call(this), this.manager = manager, this.key = key, this.isPlaying = !1, this.isPaused = !1, this.totalRate = 1, this.duration = this.duration || 0, this.totalDuration = this.totalDuration || 0, this.config = {
          mute: !1,
          volume: 1,
          rate: 1,
          detune: 0,
          seek: 0,
          loop: !1,
          delay: 0,
          pan: 0
        }, this.currentConfig = this.config, this.config = Extend(this.config, config), this.markers = {}, this.currentMarker = null, this.pendingRemove = !1;
      },
      addMarker: function addMarker(marker) {
        return !(!marker || !marker.name || "string" != typeof marker.name) && (this.markers[marker.name] ? (console.error("addMarker " + marker.name + " already exists in Sound"), !1) : (marker = Extend(!0, {
          name: "",
          start: 0,
          duration: this.totalDuration - (marker.start || 0),
          config: {
            mute: !1,
            volume: 1,
            rate: 1,
            detune: 0,
            seek: 0,
            loop: !1,
            delay: 0,
            pan: 0
          }
        }, marker), this.markers[marker.name] = marker, !0));
      },
      updateMarker: function updateMarker(marker) {
        return !(!marker || !marker.name || "string" != typeof marker.name) && (this.markers[marker.name] ? (this.markers[marker.name] = Extend(!0, this.markers[marker.name], marker), !0) : (console.warn("Audio Marker: " + marker.name + " missing in Sound: " + this.key), !1));
      },
      removeMarker: function removeMarker(markerName) {
        var marker = this.markers[markerName];
        return marker ? (this.markers[markerName] = null, marker) : null;
      },
      play: function play(markerName, config) {
        if ("object" == _typeof(markerName = void 0 === markerName ? "" : markerName) && (config = markerName, markerName = ""), "string" != typeof markerName) return !1;

        if (markerName) {
          if (!this.markers[markerName]) return console.warn("Marker: " + markerName + " missing in Sound: " + this.key), !1;
          this.currentMarker = this.markers[markerName], this.currentConfig = this.currentMarker.config, this.duration = this.currentMarker.duration;
        } else this.currentMarker = null, this.currentConfig = this.config, this.duration = this.totalDuration;

        return this.resetConfig(), this.currentConfig = Extend(this.currentConfig, config), this.isPlaying = !0, !(this.isPaused = !1);
      },
      pause: function pause() {
        return !(this.isPaused || !this.isPlaying) && (this.isPlaying = !1, this.isPaused = !0);
      },
      resume: function resume() {
        return !(!this.isPaused || this.isPlaying) && (this.isPlaying = !0, !(this.isPaused = !1));
      },
      stop: function stop() {
        return !(!this.isPaused && !this.isPlaying) && (this.isPlaying = !1, this.isPaused = !1, this.resetConfig(), !0);
      },
      applyConfig: function applyConfig() {
        this.mute = this.currentConfig.mute, this.volume = this.currentConfig.volume, this.rate = this.currentConfig.rate, this.detune = this.currentConfig.detune, this.loop = this.currentConfig.loop, this.pan = this.currentConfig.pan;
      },
      resetConfig: function resetConfig() {
        this.currentConfig.seek = 0, this.currentConfig.delay = 0;
      },
      update: BaseSound,
      calculateRate: function calculateRate() {
        var detuneRate = this.currentConfig.detune + this.manager.detune,
            detuneRate = Math.pow(1.0005777895065548, detuneRate);
        this.totalRate = this.currentConfig.rate * this.manager.rate * detuneRate;
      },
      destroy: function destroy() {
        this.pendingRemove || (this.emit(Events.DESTROY, this), this.pendingRemove = !0, this.manager = null, this.key = "", this.removeAllListeners(), this.isPlaying = !1, this.isPaused = !1, this.config = null, this.currentConfig = null, this.markers = null, this.currentMarker = null);
      }
    });
    module.exports = BaseSound;
  }, function (module, exports, __webpack_require__) {
    var CheckMatrix = __webpack_require__(209),
        TransposeMatrix = __webpack_require__(435);

    module.exports = function (matrix, direction) {
      if (void 0 === direction && (direction = 90), !CheckMatrix(matrix)) return null;
      if (90 === (direction = "string" != typeof direction ? (direction % 360 + 360) % 360 : direction) || -270 === direction || "rotateLeft" === direction) (matrix = TransposeMatrix(matrix)).reverse();else if (-90 === direction || 270 === direction || "rotateRight" === direction) matrix.reverse(), matrix = TransposeMatrix(matrix);else if (180 === Math.abs(direction) || "rotate180" === direction) {
        for (var i = 0; i < matrix.length; i++) {
          matrix[i].reverse();
        }

        matrix.reverse();
      }
      return matrix;
    };
  }, function (module, exports, Render) {
    var Class = Render(0),
        Clamp = Render(18),
        Components = Render(11),
        GameObject = Render(15),
        GetBitmapTextSize = Render(1043),
        ParseFromAtlas = Render(1044),
        ParseXMLBitmapFont = Render(212),
        Rectangle = Render(10),
        Render = Render(1045),
        BitmapText = new Class({
      Extends: GameObject,
      Mixins: [Components.Alpha, Components.BlendMode, Components.Depth, Components.Mask, Components.Origin, Components.Pipeline, Components.ScrollFactor, Components.Texture, Components.Tint, Components.Transform, Components.Visible, Render],
      initialize: function initialize(entry, x, y, font, text, size, align) {
        void 0 === text && (text = ""), void 0 === align && (align = 0), GameObject.call(this, entry, "BitmapText"), this.font = font;
        entry = this.scene.sys.cache.bitmapFont.get(font);
        entry || console.warn("Invalid BitmapText key: " + font), this.fontData = entry.data, this._text = "", this._fontSize = size || this.fontData.size, this._letterSpacing = 0, this._align = align, this._bounds = GetBitmapTextSize(), this._dirty = !0, this._maxWidth = 0, this.wordWrapCharCode = 32, this.charColors = [], this.dropShadowX = 0, this.dropShadowY = 0, this.dropShadowColor = 0, this.dropShadowAlpha = .5, this.fromAtlas = entry.fromAtlas, this.setTexture(entry.texture, entry.frame), this.setPosition(x, y), this.setOrigin(0, 0), this.initPipeline(), this.setText(text);
      },
      setLeftAlign: function setLeftAlign() {
        return this._align = BitmapText.ALIGN_LEFT, this._dirty = !0, this;
      },
      setCenterAlign: function setCenterAlign() {
        return this._align = BitmapText.ALIGN_CENTER, this._dirty = !0, this;
      },
      setRightAlign: function setRightAlign() {
        return this._align = BitmapText.ALIGN_RIGHT, this._dirty = !0, this;
      },
      setFontSize: function setFontSize(size) {
        return this._fontSize = size, this._dirty = !0, this;
      },
      setLetterSpacing: function setLetterSpacing(spacing) {
        return this._letterSpacing = spacing = void 0 === spacing ? 0 : spacing, this._dirty = !0, this;
      },
      setText: function setText(value) {
        return value || 0 === value || (value = ""), (value = Array.isArray(value) ? value.join("\n") : value) !== this.text && (this._text = value.toString(), this._dirty = !0, this.updateDisplayOrigin()), this;
      },
      setDropShadow: function setDropShadow(x, y, color, alpha) {
        return void 0 === y && (y = 0), void 0 === color && (color = 0), void 0 === alpha && (alpha = .5), this.dropShadowX = x = void 0 === x ? 0 : x, this.dropShadowY = y, this.dropShadowColor = color, this.dropShadowAlpha = alpha, this;
      },
      setCharacterTint: function setCharacterTint(start, length, tintFill, topLeft, topRight, bottomLeft, bottomRight) {
        void 0 === tintFill && (tintFill = !1), void 0 === topLeft && (topLeft = -1), void 0 === topRight && (bottomRight = bottomLeft = topRight = topLeft);
        var len = this.text.length;
        -1 === (length = void 0 === length ? 1 : length) && (length = len), start = Clamp(start = (start = void 0 === start ? 0 : start) < 0 ? len + start : start, 0, len - 1);

        for (var end = Clamp(start + length, start, len), charColors = this.charColors, i = start; i < end; i++) {
          var tintEffect,
              color = charColors[i];
          -1 === topLeft ? charColors[i] = null : (tintEffect = tintFill ? 1 : 0, color ? (color.tintEffect = tintEffect, color.tintTL = topLeft, color.tintTR = topRight, color.tintBL = bottomLeft, color.tintBR = bottomRight) : charColors[i] = {
            tintEffect: tintEffect,
            tintTL: topLeft,
            tintTR: topRight,
            tintBL: bottomLeft,
            tintBR: bottomRight
          });
        }

        return this;
      },
      setWordTint: function setWordTint(word, count, tintFill, topLeft, topRight, bottomLeft, bottomRight) {
        void 0 === count && (count = 1);

        for (var words = this.getTextBounds().words, wordIsNumber = "number" == typeof word, total = 0, i = 0; i < words.length; i++) {
          var lineword = words[i];
          if ((wordIsNumber && i === word || !wordIsNumber && lineword.word === word) && (this.setCharacterTint(lineword.i, lineword.word.length, tintFill, topLeft, topRight, bottomLeft, bottomRight), ++total === count)) return this;
        }

        return this;
      },
      getTextBounds: function getTextBounds(round) {
        var bounds = this._bounds;
        return (this._dirty || round || this.scaleX !== bounds.scaleX || this.scaleY !== bounds.scaleY) && (GetBitmapTextSize(this, round, !0, bounds), this._dirty = !1), bounds;
      },
      getCharacterAt: function getCharacterAt(x, y, camera) {
        for (var point = this.getLocalPoint(x, y, null, camera), chars = this.getTextBounds().characters, tempRect = new Rectangle(), i = 0; i < chars.length; i++) {
          var char = chars[i];
          if (tempRect.setTo(char.x, char.t, char.r - char.x, char.b), tempRect.contains(point.x, point.y)) return char;
        }

        return null;
      },
      updateDisplayOrigin: function updateDisplayOrigin() {
        return this._dirty = !0, this.getTextBounds(!1), this;
      },
      setFont: function setFont(key, size, align) {
        var entry;
        return void 0 === size && (size = this._fontSize), void 0 === align && (align = this._align), key === this.font || (entry = this.scene.sys.cache.bitmapFont.get(key)) && (this.font = key, this.fontData = entry.data, this._fontSize = size, this._align = align, this.fromAtlas = !0 === entry.fromAtlas, this.setTexture(entry.texture, entry.frame), GetBitmapTextSize(this, !1, !0, this._bounds)), this;
      },
      setMaxWidth: function setMaxWidth(value, wordWrapCharCode) {
        return this._maxWidth = value, this._dirty = !0, void 0 !== wordWrapCharCode && (this.wordWrapCharCode = wordWrapCharCode), this;
      },
      align: {
        set: function set(value) {
          this._align = value, this._dirty = !0;
        },
        get: function get() {
          return this._align;
        }
      },
      text: {
        set: function set(value) {
          this.setText(value);
        },
        get: function get() {
          return this._text;
        }
      },
      fontSize: {
        set: function set(value) {
          this._fontSize = value, this._dirty = !0;
        },
        get: function get() {
          return this._fontSize;
        }
      },
      letterSpacing: {
        set: function set(value) {
          this._letterSpacing = value, this._dirty = !0;
        },
        get: function get() {
          return this._letterSpacing;
        }
      },
      maxWidth: {
        set: function set(value) {
          this._maxWidth = value, this._dirty = !0;
        },
        get: function get() {
          return this._maxWidth;
        }
      },
      width: {
        get: function get() {
          return this.getTextBounds(!1), this._bounds.global.width;
        }
      },
      height: {
        get: function get() {
          return this.getTextBounds(!1), this._bounds.global.height;
        }
      },
      toJSON: function toJSON() {
        var out = Components.ToJSON(this),
            data = {
          font: this.font,
          text: this.text,
          fontSize: this.fontSize,
          letterSpacing: this.letterSpacing,
          align: this.align
        };
        return out.data = data, out;
      },
      preDestroy: function preDestroy() {
        this.charColors.length = 0, this._bounds = null, this.fontData = null;
      }
    });
    BitmapText.ALIGN_LEFT = 0, BitmapText.ALIGN_CENTER = 1, BitmapText.ALIGN_RIGHT = 2, BitmapText.ParseFromAtlas = ParseFromAtlas, BitmapText.ParseXMLBitmapFont = ParseXMLBitmapFont, module.exports = BitmapText;
  }, function (module, exports, __webpack_require__) {
    var Set = new (__webpack_require__(0))({
      initialize: function initialize(elements) {
        if (this.entries = [], Array.isArray(elements)) for (var i = 0; i < elements.length; i++) {
          this.set(elements[i]);
        }
      },
      set: function set(value) {
        return -1 === this.entries.indexOf(value) && this.entries.push(value), this;
      },
      get: function get(property, value) {
        for (var i = 0; i < this.entries.length; i++) {
          var entry = this.entries[i];
          if (entry[property] === value) return entry;
        }
      },
      getArray: function getArray() {
        return this.entries.slice(0);
      },
      delete: function _delete(index) {
        index = this.entries.indexOf(index);
        return -1 < index && this.entries.splice(index, 1), this;
      },
      dump: function dump() {
        console.group("Set");

        for (var i = 0; i < this.entries.length; i++) {
          var entry = this.entries[i];
          console.log(entry);
        }

        console.groupEnd();
      },
      each: function each(callback, callbackScope) {
        var i,
            temp = this.entries.slice(),
            len = temp.length;
        if (callbackScope) for (i = 0; i < len && !1 !== callback.call(callbackScope, temp[i], i); i++) {
          ;
        } else for (i = 0; i < len && !1 !== callback(temp[i], i); i++) {
          ;
        }
        return this;
      },
      iterate: function iterate(callback, callbackScope) {
        var i,
            len = this.entries.length;
        if (callbackScope) for (i = 0; i < len && !1 !== callback.call(callbackScope, this.entries[i], i); i++) {
          ;
        } else for (i = 0; i < len && !1 !== callback(this.entries[i], i); i++) {
          ;
        }
        return this;
      },
      iterateLocal: function iterateLocal(callbackKey) {
        for (var args = [], i = 1; i < arguments.length; i++) {
          args.push(arguments[i]);
        }

        var len = this.entries.length;

        for (i = 0; i < len; i++) {
          var entry = this.entries[i];
          entry[callbackKey].apply(entry, args);
        }

        return this;
      },
      clear: function clear() {
        return this.entries.length = 0, this;
      },
      contains: function contains(value) {
        return -1 < this.entries.indexOf(value);
      },
      union: function union(set) {
        var newSet = new Set();
        return set.entries.forEach(function (value) {
          newSet.set(value);
        }), this.entries.forEach(function (value) {
          newSet.set(value);
        }), newSet;
      },
      intersect: function intersect(set) {
        var newSet = new Set();
        return this.entries.forEach(function (value) {
          set.contains(value) && newSet.set(value);
        }), newSet;
      },
      difference: function difference(set) {
        var newSet = new Set();
        return this.entries.forEach(function (value) {
          set.contains(value) || newSet.set(value);
        }), newSet;
      },
      size: {
        get: function get() {
          return this.entries.length;
        },
        set: function set(value) {
          return value < this.entries.length ? this.entries.length = value : this.entries.length;
        }
      }
    });
    module.exports = Set;
  }, function (module, exports, PointLight) {
    var Class = PointLight(0),
        Components = PointLight(11),
        GameObject = PointLight(15),
        IntegerToColor = PointLight(189),
        PIPELINES_CONST = PointLight(92),
        PointLight = PointLight(1182),
        PointLight = new Class({
      Extends: GameObject,
      Mixins: [Components.AlphaSingle, Components.BlendMode, Components.Depth, Components.GetBounds, Components.Mask, Components.Pipeline, Components.ScrollFactor, Components.Transform, Components.Visible, PointLight],
      initialize: function initialize(scene, x, y, color, radius, intensity, attenuation) {
        void 0 === color && (color = 16777215), void 0 === radius && (radius = 128), void 0 === intensity && (intensity = 1), void 0 === attenuation && (attenuation = .1), GameObject.call(this, scene, "PointLight"), this.initPipeline(PIPELINES_CONST.POINTLIGHT_PIPELINE), this.setPosition(x, y), this.color = IntegerToColor(color), this.intensity = intensity, this.attenuation = attenuation, this.width = 2 * radius, this.height = 2 * radius, this._radius = radius;
      },
      radius: {
        get: function get() {
          return this._radius;
        },
        set: function set(value) {
          this._radius = value, this.width = 2 * value, this.height = 2 * value;
        }
      },
      originX: {
        get: function get() {
          return .5;
        }
      },
      originY: {
        get: function get() {
          return .5;
        }
      },
      displayOriginX: {
        get: function get() {
          return this._radius;
        }
      },
      displayOriginY: {
        get: function get() {
          return this._radius;
        }
      }
    });
    module.exports = PointLight;
  }, function (module, exports) {
    module.exports = function (circle, yDist) {
      var xCornerDist = yDist.width / 2,
          yCornerDist = yDist.height / 2,
          cx = Math.abs(circle.x - yDist.x - xCornerDist),
          cy = Math.abs(circle.y - yDist.y - yCornerDist),
          xDist = xCornerDist + circle.radius,
          yDist = yCornerDist + circle.radius;
      if (xDist < cx || yDist < cy) return !1;
      if (cx <= xCornerDist || cy <= yCornerDist) return !0;
      xCornerDist = cx - xCornerDist, yCornerDist = cy - yCornerDist;
      return xCornerDist * xCornerDist + yCornerDist * yCornerDist <= circle.radius * circle.radius;
    };
  }, function (module, exports) {
    module.exports = function (rectA, rectB) {
      return !(rectA.width <= 0 || rectA.height <= 0 || rectB.width <= 0 || rectB.height <= 0) && !(rectA.right < rectB.x || rectA.bottom < rectB.y || rectA.x > rectB.right || rectA.y > rectB.bottom);
    };
  }, function (module, exports, InputPluginCache) {
    var GetValue = InputPluginCache(6),
        inputPlugins = {},
        InputPluginCache = {
      register: function register(key, plugin, mapping, settingsKey, configKey) {
        inputPlugins[key] = {
          plugin: plugin,
          mapping: mapping,
          settingsKey: settingsKey,
          configKey: configKey
        };
      },
      getPlugin: function getPlugin(key) {
        return inputPlugins[key];
      },
      install: function install(target) {
        var key,
            sys = target.scene.sys,
            settings = sys.settings.input,
            config = sys.game.config;

        for (key in inputPlugins) {
          var source = inputPlugins[key].plugin,
              mapping = inputPlugins[key].mapping,
              settingsKey = inputPlugins[key].settingsKey,
              configKey = inputPlugins[key].configKey;
          GetValue(settings, settingsKey, config[configKey]) && (target[mapping] = new source(target));
        }
      },
      remove: function remove(key) {
        inputPlugins.hasOwnProperty(key) && delete inputPlugins[key];
      }
    };
    module.exports = InputPluginCache;
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      ANY_KEY_DOWN: __webpack_require__(1323),
      ANY_KEY_UP: __webpack_require__(1324),
      COMBO_MATCH: __webpack_require__(1325),
      DOWN: __webpack_require__(1326),
      KEY_DOWN: __webpack_require__(1327),
      KEY_UP: __webpack_require__(1328),
      UP: __webpack_require__(1329)
    };
  }, function (module, exports) {
    module.exports = function (file, baseURL) {
      return !!file.url && (file.url.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/) ? file.url : baseURL + file.url);
    };
  }, function (module, exports) {
    module.exports = function (responseType, async, user, password, timeout, withCredentials) {
      return {
        responseType: responseType = void 0 === responseType ? "" : responseType,
        async: async = void 0 === async ? !0 : async,
        user: user = void 0 === user ? "" : user,
        password: password = void 0 === password ? "" : password,
        timeout: timeout = void 0 === timeout ? 0 : timeout,
        headers: void 0,
        header: void 0,
        headerValue: void 0,
        requestedWith: !1,
        overrideMimeType: void 0,
        withCredentials: withCredentials = void 0 === withCredentials ? !1 : withCredentials
      };
    };
  }, function (module, exports, __webpack_require__) {
    var Class = __webpack_require__(0),
        ArcadeSprite = __webpack_require__(243),
        Sprite = __webpack_require__(73),
        ArcadeSprite = new Class({
      Extends: Sprite,
      Mixins: [ArcadeSprite.Acceleration, ArcadeSprite.Angular, ArcadeSprite.Bounce, ArcadeSprite.Debug, ArcadeSprite.Drag, ArcadeSprite.Enable, ArcadeSprite.Friction, ArcadeSprite.Gravity, ArcadeSprite.Immovable, ArcadeSprite.Mass, ArcadeSprite.Pushable, ArcadeSprite.Size, ArcadeSprite.Velocity],
      initialize: function initialize(scene, x, y, texture, frame) {
        Sprite.call(this, scene, x, y, texture, frame), this.body = null;
      }
    });

    module.exports = ArcadeSprite;
  }, function (module, exports, __webpack_require__) {
    var IsInLayerBounds = __webpack_require__(119);

    module.exports = function (tile, tileY, nonNull, layer) {
      if (void 0 === nonNull && (nonNull = !1), IsInLayerBounds(tile, tileY, layer)) {
        tile = layer.data[tileY][tile] || null;
        return tile && (-1 !== tile.index || nonNull) ? tile : null;
      }

      return null;
    };
  }, function (module, exports) {
    module.exports = function (tilemapLayer, bounds, renderOrder, outputArray) {
      var x,
          y,
          tile,
          mapData = tilemapLayer.data,
          mapWidth = tilemapLayer.width,
          mapHeight = tilemapLayer.height,
          tilemapLayer = tilemapLayer.tilemapLayer,
          drawLeft = Math.max(0, bounds.left),
          drawRight = Math.min(mapWidth, bounds.right),
          drawTop = Math.max(0, bounds.top),
          drawBottom = Math.min(mapHeight, bounds.bottom);
      if (0 === renderOrder) for (y = drawTop; y < drawBottom; y++) {
        for (x = drawLeft; mapData[y] && x < drawRight; x++) {
          (tile = mapData[y][x]) && -1 !== tile.index && tile.visible && 0 !== tile.alpha && outputArray.push(tile);
        }
      } else if (1 === renderOrder) for (y = drawTop; y < drawBottom; y++) {
        for (x = drawRight; mapData[y] && drawLeft <= x; x--) {
          (tile = mapData[y][x]) && -1 !== tile.index && tile.visible && 0 !== tile.alpha && outputArray.push(tile);
        }
      } else if (2 === renderOrder) for (y = drawBottom; drawTop <= y; y--) {
        for (x = drawLeft; mapData[y] && x < drawRight; x++) {
          (tile = mapData[y][x]) && -1 !== tile.index && tile.visible && 0 !== tile.alpha && outputArray.push(tile);
        }
      } else if (3 === renderOrder) for (y = drawBottom; drawTop <= y; y--) {
        for (x = drawRight; mapData[y] && drawLeft <= x; x--) {
          (tile = mapData[y][x]) && -1 !== tile.index && tile.visible && 0 !== tile.alpha && outputArray.push(tile);
        }
      }
      return tilemapLayer.tilesDrawn = outputArray.length, tilemapLayer.tilesTotal = mapWidth * mapHeight, outputArray;
    };
  }, function (module, exports) {
    module.exports = function (tileIndex, collides, layer) {
      var loc = layer.collideIndexes.indexOf(tileIndex);
      collides && -1 === loc ? layer.collideIndexes.push(tileIndex) : collides || -1 === loc || layer.collideIndexes.splice(loc, 1);
    };
  }, function (module, exports, __webpack_require__) {
    var GetFastValue = __webpack_require__(2);

    module.exports = function (layerY, groupl, parentstate) {
      if (!groupl) return {
        i: 0,
        layers: layerY.layers,
        name: "",
        opacity: 1,
        visible: !0,
        x: 0,
        y: 0
      };
      var layerX = groupl.x + GetFastValue(groupl, "startx", 0) * layerY.tilewidth + GetFastValue(groupl, "offsetx", 0),
          layerY = groupl.y + GetFastValue(groupl, "starty", 0) * layerY.tileheight + GetFastValue(groupl, "offsety", 0);
      return {
        i: 0,
        layers: groupl.layers,
        name: parentstate.name + groupl.name + "/",
        opacity: parentstate.opacity * groupl.opacity,
        visible: parentstate.visible && groupl.visible,
        x: parentstate.x + layerX,
        y: parentstate.y + layerY
      };
    };
  }, function (module, exports) {
    module.exports = function (source, key, defaultValue) {
      return source.hasOwnProperty(key) ? "function" == typeof source[key] ? function (target, targetKey, value, targetIndex, totalTargets, tween) {
        return source[key](target, targetKey, value, targetIndex, totalTargets, tween);
      } : function () {
        return source[key];
      } : "function" == typeof defaultValue ? defaultValue : function () {
        return defaultValue;
      };
    };
  }, function (module, exports, __webpack_require__) {
    var Defaults = __webpack_require__(265),
        GetAdvancedValue = __webpack_require__(13),
        GetBoolean = __webpack_require__(99),
        GetEaseFunction = __webpack_require__(80),
        GetNewValue = __webpack_require__(162),
        GetProps = __webpack_require__(583),
        GetTargets = __webpack_require__(263),
        GetValue = __webpack_require__(6),
        GetValueOp = __webpack_require__(264),
        Tween = __webpack_require__(266),
        TweenData = __webpack_require__(268);

    module.exports = function (parent, config, defaults) {
      for (var targets = (defaults = void 0 === defaults ? Defaults : defaults).targets || GetTargets(config), props = GetProps(config), delay = GetNewValue(config, "delay", defaults.delay), duration = GetNewValue(config, "duration", defaults.duration), easeParams = GetValue(config, "easeParams", defaults.easeParams), ease = GetEaseFunction(GetValue(config, "ease", defaults.ease), easeParams), hold = GetNewValue(config, "hold", defaults.hold), repeat = GetNewValue(config, "repeat", defaults.repeat), repeatDelay = GetNewValue(config, "repeatDelay", defaults.repeatDelay), yoyo = GetBoolean(config, "yoyo", defaults.yoyo), flipX = GetBoolean(config, "flipX", defaults.flipX), flipY = GetBoolean(config, "flipY", defaults.flipY), data = [], p = 0; p < props.length; p++) {
        for (var key = props[p].key, value = props[p].value, t = 0; t < targets.length; t++) {
          var tweenData = GetValueOp(key, value),
              tweenData = TweenData(targets[t], t, key, tweenData.getEnd, tweenData.getStart, tweenData.getActive, GetEaseFunction(GetValue(value, "ease", ease), GetValue(value, "easeParams", easeParams)), GetNewValue(value, "delay", delay), GetNewValue(value, "duration", duration), GetBoolean(value, "yoyo", yoyo), GetNewValue(value, "hold", hold), GetNewValue(value, "repeat", repeat), GetNewValue(value, "repeatDelay", repeatDelay), GetBoolean(value, "flipX", flipX), GetBoolean(value, "flipY", flipY));
          data.push(tweenData);
        }
      }

      var tween = new Tween(parent, data, targets);
      tween.offset = GetAdvancedValue(config, "offset", null), tween.completeDelay = GetAdvancedValue(config, "completeDelay", 0), tween.loop = Math.round(GetAdvancedValue(config, "loop", 0)), tween.loopDelay = Math.round(GetAdvancedValue(config, "loopDelay", 0)), tween.paused = GetBoolean(config, "paused", !1), tween.useFrames = GetBoolean(config, "useFrames", !1);

      for (var scope = GetValue(config, "callbackScope", tween), tweenArray = [tween, null], callbacks = Tween.TYPES, i = 0; i < callbacks.length; i++) {
        var callbackScope,
            callbackParams,
            type = callbacks[i],
            callback = GetValue(config, type, !1);
        callback && (callbackScope = GetValue(config, type + "Scope", scope), callbackParams = GetValue(config, type + "Params", []), tween.setCallback(type, callback, tweenArray.concat(callbackParams), callbackScope));
      }

      return tween;
    };
  }, function (module, exports, __webpack_require__) {
    var AnimationState = __webpack_require__(0),
        CustomMap = __webpack_require__(102),
        GetFastValue = __webpack_require__(2),
        Events = __webpack_require__(132),
        Animation = __webpack_require__(185),
        AnimationState = new AnimationState({
      initialize: function initialize(parent) {
        this.parent = parent, this.animationManager = parent.scene.sys.anims, this.animationManager.on(Events.REMOVE_ANIMATION, this.globalRemove, this), this.textureManager = this.animationManager.textureManager, this.anims = null, this.isPlaying = !1, this.hasStarted = !1, this.currentAnim = null, this.currentFrame = null, this.nextAnim = null, this.nextAnimsQueue = [], this.timeScale = 1, this.frameRate = 0, this.duration = 0, this.msPerFrame = 0, this.skipMissedFrames = !0, this.delay = 0, this.repeat = 0, this.repeatDelay = 0, this.yoyo = !1, this.showOnStart = !1, this.hideOnComplete = !1, this.forward = !0, this.inReverse = !1, this.accumulator = 0, this.nextTick = 0, this.delayCounter = 0, this.repeatCounter = 0, this.pendingRepeat = !1, this._paused = !1, this._wasPlaying = !1, this._pendingStop = 0, this._pendingStopValue;
      },
      chain: function chain(key) {
        var parent = this.parent;
        if (void 0 === key) return this.nextAnimsQueue.length = 0, this.nextAnim = null, parent;
        Array.isArray(key) || (key = [key]);

        for (var i = 0; i < key.length; i++) {
          var anim = key[i];
          null === this.nextAnim ? this.nextAnim = anim : this.nextAnimsQueue.push(anim);
        }

        return this.parent;
      },
      getName: function getName() {
        return this.currentAnim ? this.currentAnim.key : "";
      },
      getFrameName: function getFrameName() {
        return this.currentFrame ? this.currentFrame.textureFrame : "";
      },
      load: function load(frame) {
        this.isPlaying && this.stop();
        var totalFrames,
            startFrame,
            duration = this.animationManager,
            animKey = "string" == typeof frame ? frame : GetFastValue(frame, "key", null),
            anim = (this.exists(animKey) ? this : duration).get(animKey);
        return anim ? (totalFrames = (this.currentAnim = anim).getTotalFrames(), startFrame = GetFastValue(frame, "frameRate", anim.frameRate), duration = GetFastValue(frame, "duration", anim.duration), anim.calculateDuration(this, totalFrames, duration, startFrame), this.delay = GetFastValue(frame, "delay", anim.delay), this.repeat = GetFastValue(frame, "repeat", anim.repeat), this.repeatDelay = GetFastValue(frame, "repeatDelay", anim.repeatDelay), this.yoyo = GetFastValue(frame, "yoyo", anim.yoyo), this.showOnStart = GetFastValue(frame, "showOnStart", anim.showOnStart), this.hideOnComplete = GetFastValue(frame, "hideOnComplete", anim.hideOnComplete), this.skipMissedFrames = GetFastValue(frame, "skipMissedFrames", anim.skipMissedFrames), this.timeScale = GetFastValue(frame, "timeScale", this.timeScale), (startFrame = GetFastValue(frame, "startFrame", 0)) > anim.getTotalFrames() && (startFrame = 0), frame = anim.frames[startFrame], 0 !== startFrame || this.forward || (frame = anim.getLastFrame()), this.currentFrame = frame) : console.warn("Missing animation: " + animKey), this.parent;
      },
      pause: function pause(atFrame) {
        return this._paused || (this._paused = !0, this._wasPlaying = this.isPlaying, this.isPlaying = !1), void 0 !== atFrame && this.setCurrentFrame(atFrame), this.parent;
      },
      resume: function resume(fromFrame) {
        return this._paused && (this._paused = !1, this.isPlaying = this._wasPlaying), void 0 !== fromFrame && this.setCurrentFrame(fromFrame), this.parent;
      },
      playAfterDelay: function playAfterDelay(key, delay) {
        var nextAnim, queue;
        return this.isPlaying ? (nextAnim = this.nextAnim, queue = this.nextAnimsQueue, nextAnim && queue.unshift(nextAnim), this.nextAnim = key, this._pendingStop = 1, this._pendingStopValue = delay) : (this.delayCounter = delay, this.play(key, !0)), this.parent;
      },
      playAfterRepeat: function playAfterRepeat(key, repeatCount) {
        var nextAnim, queue;
        return void 0 === repeatCount && (repeatCount = 1), this.isPlaying ? (nextAnim = this.nextAnim, queue = this.nextAnimsQueue, nextAnim && queue.unshift(nextAnim), -1 !== this.repeatCounter && repeatCount > this.repeatCounter && (repeatCount = this.repeatCounter), this.nextAnim = key, this._pendingStop = 2, this._pendingStopValue = repeatCount) : this.play(key), this.parent;
      },
      play: function play(key, ignoreIfPlaying) {
        var mix = this.currentAnim,
            parent = this.parent,
            animKey = "string" == typeof key ? key : key.key;
        if ((ignoreIfPlaying = void 0 === ignoreIfPlaying ? !1 : ignoreIfPlaying) && this.isPlaying && mix.key === animKey) return parent;

        if (mix && this.isPlaying) {
          mix = this.animationManager.getMix(mix.key, key);
          if (0 < mix) return this.playAfterDelay(key, mix);
        }

        return this.forward = !0, this.inReverse = !1, this._paused = !1, this._wasPlaying = !0, this.startAnimation(key);
      },
      playReverse: function playReverse(key, ignoreIfPlaying) {
        var animKey = "string" == typeof key ? key : key.key;
        return (ignoreIfPlaying = void 0 === ignoreIfPlaying ? !1 : ignoreIfPlaying) && this.isPlaying && this.currentAnim.key === animKey ? this.parent : (this.forward = !1, this.inReverse = !0, this._paused = !1, this._wasPlaying = !0, this.startAnimation(key));
      },
      startAnimation: function startAnimation(gameObject) {
        this.load(gameObject);
        var anim = this.currentAnim,
            gameObject = this.parent;
        return anim && (this.repeatCounter = -1 === this.repeat ? Number.MAX_VALUE : this.repeat, anim.getFirstTick(this), this.isPlaying = !0, this.pendingRepeat = !1, this.hasStarted = !1, this._pendingStop = 0, this._pendingStopValue = 0, this._paused = !1, this.delayCounter += this.delay, 0 === this.delayCounter && this.handleStart()), gameObject;
      },
      handleStart: function handleStart() {
        this.showOnStart && this.parent.setVisible(!0), this.setCurrentFrame(this.currentFrame), this.hasStarted = !0, this.emitEvents(Events.ANIMATION_START);
      },
      handleRepeat: function handleRepeat() {
        this.pendingRepeat = !1, this.emitEvents(Events.ANIMATION_REPEAT);
      },
      handleStop: function handleStop() {
        this._pendingStop = 0, this.isPlaying = !1, this.emitEvents(Events.ANIMATION_STOP);
      },
      handleComplete: function handleComplete() {
        this._pendingStop = 0, this.isPlaying = !1, this.hideOnComplete && this.parent.setVisible(!1), this.emitEvents(Events.ANIMATION_COMPLETE, Events.ANIMATION_COMPLETE_KEY);
      },
      emitEvents: function emitEvents(event, keyEvent) {
        var anim = this.currentAnim,
            frame = this.currentFrame,
            gameObject = this.parent,
            frameKey = frame.textureFrame;
        gameObject.emit(event, anim, frame, gameObject, frameKey), keyEvent && gameObject.emit(keyEvent + anim.key, anim, frame, gameObject, frameKey);
      },
      reverse: function reverse() {
        return this.isPlaying && (this.inReverse = !this.inReverse, this.forward = !this.forward), this.parent;
      },
      getProgress: function getProgress() {
        var p = this.currentFrame;
        if (!p) return 0;
        p = p.progress;
        return this.inReverse && (p *= -1), p;
      },
      setProgress: function setProgress(value) {
        return this.forward || (value = 1 - value), this.setCurrentFrame(this.currentAnim.getFrameByProgress(value)), this.parent;
      },
      setRepeat: function setRepeat(value) {
        return this.repeatCounter = -1 === value ? Number.MAX_VALUE : value, this.parent;
      },
      globalRemove: function globalRemove(key, animation) {
        void 0 === animation && (animation = this.currentAnim), this.isPlaying && animation.key === this.currentAnim.key && (this.stop(), this.setCurrentFrame(this.currentAnim.frames[0]));
      },
      restart: function restart(includeDelay, resetRepeats) {
        void 0 === includeDelay && (includeDelay = !1);
        var anim = this.currentAnim,
            gameObject = this.parent;
        return anim ? ((resetRepeats = void 0 === resetRepeats ? !1 : resetRepeats) && (this.repeatCounter = -1 === this.repeat ? Number.MAX_VALUE : this.repeat), anim.getFirstTick(this), this.emitEvents(Events.ANIMATION_RESTART), this.isPlaying = !0, this.pendingRepeat = !1, this.hasStarted = !includeDelay, this._pendingStop = 0, this._pendingStopValue = 0, this._paused = !1, this.setCurrentFrame(anim.frames[0]), this.parent) : gameObject;
      },
      complete: function complete() {
        var key;
        return this._pendingStop = 0, this.isPlaying = !1, this.currentAnim && this.handleComplete(), this.nextAnim && (key = this.nextAnim, this.nextAnim = 0 < this.nextAnimsQueue.length ? this.nextAnimsQueue.shift() : null, this.play(key)), this.parent;
      },
      stop: function stop() {
        var key;
        return this._pendingStop = 0, this.isPlaying = !1, this.currentAnim && this.handleStop(), this.nextAnim && (key = this.nextAnim, this.nextAnim = this.nextAnimsQueue.shift(), this.play(key)), this.parent;
      },
      stopAfterDelay: function stopAfterDelay(delay) {
        return this._pendingStop = 1, this._pendingStopValue = delay, this.parent;
      },
      stopAfterRepeat: function stopAfterRepeat(repeatCount) {
        return void 0 === repeatCount && (repeatCount = 1), -1 !== this.repeatCounter && repeatCount > this.repeatCounter && (repeatCount = this.repeatCounter), this._pendingStop = 2, this._pendingStopValue = repeatCount, this.parent;
      },
      stopOnFrame: function stopOnFrame(frame) {
        return this._pendingStop = 3, this._pendingStopValue = frame, this.parent;
      },
      getTotalFrames: function getTotalFrames() {
        return this.currentAnim ? this.currentAnim.getTotalFrames() : 0;
      },
      update: function update(time, delta) {
        var anim = this.currentAnim;

        if (this.isPlaying && anim && !anim.paused) {
          if (this.accumulator += delta * this.timeScale, 1 === this._pendingStop && (this._pendingStopValue -= delta, this._pendingStopValue <= 0)) return this.stop();

          if (this.hasStarted) {
            if (this.accumulator >= this.nextTick && (this.forward ? anim.nextFrame(this) : anim.previousFrame(this), this.isPlaying && 0 === this._pendingStop && this.skipMissedFrames && this.accumulator > this.nextTick)) for (var safetyNet = 0; this.forward ? anim.nextFrame(this) : anim.previousFrame(this), safetyNet++, this.isPlaying && this.accumulator > this.nextTick && safetyNet < 60;) {
              ;
            }
          } else this.accumulator >= this.delayCounter && (this.accumulator -= this.delayCounter, this.handleStart());
        }
      },
      setCurrentFrame: function setCurrentFrame(animationFrame) {
        var gameObject = this.parent;
        return this.currentFrame = animationFrame, gameObject.texture = animationFrame.frame.texture, gameObject.frame = animationFrame.frame, gameObject.isCropped && gameObject.frame.updateCropUVs(gameObject._crop, gameObject.flipX, gameObject.flipY), animationFrame.setAlpha && (gameObject.alpha = animationFrame.alpha), gameObject.setSizeToFrame(), gameObject._originComponent && (animationFrame.frame.customPivot ? gameObject.setOrigin(animationFrame.frame.pivotX, animationFrame.frame.pivotY) : gameObject.updateDisplayOrigin()), this.isPlaying && this.hasStarted && (this.emitEvents(Events.ANIMATION_UPDATE), 3 === this._pendingStop && this._pendingStopValue === animationFrame && this.stop()), gameObject;
      },
      nextFrame: function nextFrame() {
        return this.currentAnim && this.currentAnim.nextFrame(this), this.parent;
      },
      previousFrame: function previousFrame() {
        return this.currentAnim && this.currentAnim.previousFrame(this), this.parent;
      },
      get: function get(key) {
        return this.anims ? this.anims.get(key) : null;
      },
      exists: function exists(key) {
        return !!this.anims && this.anims.has(key);
      },
      create: function create(config) {
        var key = config.key,
            anim = !1;
        return key && ((anim = this.get(key)) || (anim = new Animation(this, key, config), this.anims || (this.anims = new CustomMap()), this.anims.set(key, anim))), anim;
      },
      generateFrameNames: function generateFrameNames(key, config) {
        return this.animationManager.generateFrameNames(key, config);
      },
      generateFrameNumbers: function generateFrameNumbers(key, config) {
        return this.animationManager.generateFrameNumbers(key, config);
      },
      remove: function remove(key) {
        var anim = this.get(key);
        return anim && (this.currentAnim === anim && this.stop(), this.anims.delete(key)), anim;
      },
      destroy: function destroy() {
        this.animationManager.off(Events.REMOVE_ANIMATION, this.globalRemove, this), this.anims && this.anims.clear(), this.animationManager = null, this.parent = null, this.nextAnim = null, this.nextAnimsQueue.length = 0, this.currentAnim = null, this.currentFrame = null;
      },
      isPaused: {
        get: function get() {
          return this._paused;
        }
      }
    });

    module.exports = AnimationState;
  }, function (module, exports, __webpack_require__) {
    var Sleeping = {};
    module.exports = Sleeping;

    var Events = __webpack_require__(166);

    Sleeping._motionWakeThreshold = .18, Sleeping._motionSleepThreshold = .08, Sleeping._minBias = .9, Sleeping.update = function (bodies, timeScale) {
      for (var timeFactor = timeScale * timeScale * timeScale, i = 0; i < bodies.length; i++) {
        var minMotion,
            body = bodies[i],
            maxMotion = body.speed * body.speed + body.angularSpeed * body.angularSpeed;
        0 === body.force.x && 0 === body.force.y ? (minMotion = Math.min(body.motion, maxMotion), maxMotion = Math.max(body.motion, maxMotion), body.motion = Sleeping._minBias * minMotion + (1 - Sleeping._minBias) * maxMotion, 0 < body.sleepThreshold && body.motion < Sleeping._motionSleepThreshold * timeFactor ? (body.sleepCounter += 1, body.sleepCounter >= body.sleepThreshold && Sleeping.set(body, !0)) : 0 < body.sleepCounter && --body.sleepCounter) : Sleeping.set(body, !1);
      }
    }, Sleeping.afterCollisions = function (pairs, timeScale) {
      for (var timeFactor = timeScale * timeScale * timeScale, i = 0; i < pairs.length; i++) {
        var bodyA,
            sleepingBody,
            bodyB = pairs[i];
        bodyB.isActive && (bodyA = (sleepingBody = bodyB.collision).bodyA.parent, bodyB = sleepingBody.bodyB.parent, bodyA.isSleeping && bodyB.isSleeping || bodyA.isStatic || bodyB.isStatic || !bodyA.isSleeping && !bodyB.isSleeping || !(sleepingBody = bodyA.isSleeping && !bodyA.isStatic ? bodyA : bodyB).isStatic && (sleepingBody === bodyA ? bodyB : bodyA).motion > Sleeping._motionWakeThreshold * timeFactor && Sleeping.set(sleepingBody, !1));
      }
    }, Sleeping.set = function (body, isSleeping) {
      var wasSleeping = body.isSleeping;
      isSleeping ? (body.isSleeping = !0, body.sleepCounter = body.sleepThreshold, body.positionImpulse.x = 0, body.positionImpulse.y = 0, body.positionPrev.x = body.position.x, body.positionPrev.y = body.position.y, body.anglePrev = body.angle, body.speed = 0, body.angularSpeed = 0, body.motion = 0, wasSleeping || Events.trigger(body, "sleepStart")) : (body.isSleeping = !1, body.sleepCounter = 0, wasSleeping && Events.trigger(body, "sleepEnd"));
    };
  }, function (module, exports, __webpack_require__) {
    var Events = {};
    module.exports = Events;

    var Common = __webpack_require__(32);

    Events.on = function (object, eventNames, callback) {
      for (var name, names = eventNames.split(" "), i = 0; i < names.length; i++) {
        name = names[i], object.events = object.events || {}, object.events[name] = object.events[name] || [], object.events[name].push(callback);
      }

      return callback;
    }, Events.off = function (object, eventNames, callback) {
      if (eventNames) {
        "function" == typeof eventNames && (callback = eventNames, eventNames = Common.keys(object.events).join(" "));

        for (var names = eventNames.split(" "), i = 0; i < names.length; i++) {
          var callbacks = object.events[names[i]],
              newCallbacks = [];
          if (callback && callbacks) for (var j = 0; j < callbacks.length; j++) {
            callbacks[j] !== callback && newCallbacks.push(callbacks[j]);
          }
          object.events[names[i]] = newCallbacks;
        }
      } else object.events = {};
    }, Events.trigger = function (object, eventNames, event) {
      var name,
          callbacks,
          eventClone,
          events = object.events;

      if (events && 0 < Common.keys(events).length) {
        event = event || {};

        for (var names = eventNames.split(" "), i = 0; i < names.length; i++) {
          if (callbacks = events[name = names[i]]) {
            (eventClone = Common.clone(event, !1)).name = name, eventClone.source = object;

            for (var j = 0; j < callbacks.length; j++) {
              callbacks[j].apply(object, [eventClone]);
            }
          }
        }
      }
    };
  }, function (module, exports, __webpack_require__) {
    var DeepCopy = __webpack_require__(175),
        PIPELINE_CONST = __webpack_require__(92),
        SpliceOne = __webpack_require__(74);

    module.exports = {
      defaultPipeline: null,
      pipeline: null,
      hasPostPipeline: !1,
      postPipelines: null,
      pipelineData: null,
      initPipeline: function initPipeline(instance) {
        void 0 === instance && (instance = PIPELINE_CONST.MULTI_PIPELINE);
        var pipelines = this.scene.sys.renderer;
        if (!pipelines) return !1;
        pipelines = pipelines.pipelines;

        if (this.postPipelines = [], this.pipelineData = {}, pipelines) {
          instance = pipelines.get(instance);
          if (instance) return this.defaultPipeline = instance, this.pipeline = instance, !0;
        }

        return !1;
      },
      setPipeline: function setPipeline(instance, pipelineData, copyData) {
        var pipelines = this.scene.sys.renderer;
        if (!pipelines) return this;
        pipelines = pipelines.pipelines;
        return pipelines && ((instance = pipelines.get(instance)) && (this.pipeline = instance), pipelineData && (this.pipelineData = copyData ? DeepCopy(pipelineData) : pipelineData)), this;
      },
      setPostPipeline: function setPostPipeline(pipelines, pipelineData, copyData) {
        var renderer = this.scene.sys.renderer;
        if (!renderer) return this;
        var pipelineManager = renderer.pipelines;

        if (pipelineManager) {
          Array.isArray(pipelines) || (pipelines = [pipelines]);

          for (var i = 0; i < pipelines.length; i++) {
            var instance = pipelineManager.getPostPipeline(pipelines[i], this);
            instance && this.postPipelines.push(instance);
          }

          pipelineData && (this.pipelineData = copyData ? DeepCopy(pipelineData) : pipelineData);
        }

        return this.hasPostPipeline = 0 < this.postPipelines.length, this;
      },
      setPipelineData: function setPipelineData(key, value) {
        var data = this.pipelineData;
        return void 0 === value ? delete data[key] : data[key] = value, this;
      },
      getPostPipeline: function getPostPipeline(pipeline) {
        for (var pipelines = this.postPipelines, results = [], i = 0; i < pipelines.length; i++) {
          var instance = pipelines[i];
          ("string" == typeof pipeline && instance.name === pipeline || instance instanceof pipeline) && results.push(instance);
        }

        return 1 === results.length ? results[0] : results;
      },
      resetPipeline: function resetPipeline(resetPostPipelines, resetData) {
        return void 0 === resetPostPipelines && (resetPostPipelines = !1), void 0 === resetData && (resetData = !1), this.pipeline = this.defaultPipeline, resetPostPipelines && (this.postPipelines = [], this.hasPostPipeline = !1), resetData && (this.pipelineData = {}), null !== this.pipeline;
      },
      resetPostPipeline: function resetPostPipeline(resetData) {
        void 0 === resetData && (resetData = !1);

        for (var pipelines = this.postPipelines, i = 0; i < pipelines.length; i++) {
          pipelines[i].destroy();
        }

        this.postPipelines = [], this.hasPostPipeline = !1, resetData && (this.pipelineData = {});
      },
      removePostPipeline: function removePostPipeline(pipeline) {
        for (var pipelines = this.postPipelines, i = pipelines.length - 1; 0 <= i; i--) {
          var instance = pipelines[i];
          ("string" == typeof pipeline && instance.name === pipeline || "string" != typeof pipeline && instance instanceof pipeline) && (instance.destroy(), SpliceOne(pipelines, i));
        }

        return this.hasPostPipeline = 0 < this.postPipelines.length, this;
      },
      getPipelineName: function getPipelineName() {
        return this.pipeline.name;
      }
    };
  }, function (module, exports) {
    module.exports = {
      DEFAULT: 0,
      LINEAR: 0,
      NEAREST: 1
    };
  }, function (module, exports, __webpack_require__) {
    var Point = __webpack_require__(4);

    module.exports = function (circle, angle, out) {
      return (out = void 0 === out ? new Point() : out).x = circle.x + circle.radius * Math.cos(angle), out.y = circle.y + circle.radius * Math.sin(angle), out;
    };
  }, function (module, exports, __webpack_require__) {
    var Point = __webpack_require__(4);

    module.exports = function (circle, out) {
      void 0 === out && (out = new Point());
      var y = 2 * Math.PI * Math.random(),
          x = Math.random() + Math.random(),
          r = 1 < x ? 2 - x : x,
          x = r * Math.cos(y),
          y = r * Math.sin(y);
      return out.x = circle.x + x * circle.radius, out.y = circle.y + y * circle.radius, out;
    };
  }, function (module, exports, __webpack_require__) {
    var Perimeter = __webpack_require__(130),
        Point = __webpack_require__(4);

    module.exports = function (rectangle, position, out) {
      if (void 0 === out && (out = new Point()), position <= 0 || 1 <= position) return out.x = rectangle.x, out.y = rectangle.y, out;
      var p = Perimeter(rectangle) * position;
      return .5 < position ? (p -= rectangle.width + rectangle.height) <= rectangle.width ? (out.x = rectangle.right - p, out.y = rectangle.bottom) : (out.x = rectangle.x, out.y = rectangle.bottom - (p - rectangle.width)) : p <= rectangle.width ? (out.x = rectangle.x + p, out.y = rectangle.y) : (out.x = rectangle.right, out.y = rectangle.y + (p - rectangle.width)), out;
    };
  }, function (module, exports, __webpack_require__) {
    var Length = __webpack_require__(67),
        Point = __webpack_require__(4);

    module.exports = function (line, quantity, stepRate, out) {
      void 0 === out && (out = []), !quantity && 0 < stepRate && (quantity = Length(line) / stepRate);

      for (var x1 = line.x1, y1 = line.y1, x2 = line.x2, y2 = line.y2, i = 0; i < quantity; i++) {
        var position = i / quantity;
        out.push(new Point(x1 + (x2 - x1) * position, y1 + (y2 - y1) * position));
      }

      return out;
    };
  }, function (module, exports, __webpack_require__) {
    var Point = __webpack_require__(4);

    module.exports = function (line, out) {
      void 0 === out && (out = new Point());
      var t = Math.random();
      return out.x = line.x1 + t * (line.x2 - line.x1), out.y = line.y1 + t * (line.y2 - line.y1), out;
    };
  }, function (module, exports, __webpack_require__) {
    var Point = __webpack_require__(4);

    module.exports = function (rect, out) {
      return (out = void 0 === out ? new Point() : out).x = rect.x + Math.random() * rect.width, out.y = rect.y + Math.random() * rect.height, out;
    };
  }, function (module, exports) {
    function DeepCopy(inObject) {
      var outObject, value, key;
      if ("object" != _typeof(inObject) || null === inObject) return inObject;

      for (key in outObject = Array.isArray(inObject) ? [] : {}, inObject) {
        value = inObject[key], outObject[key] = DeepCopy(value);
      }

      return outObject;
    }

    module.exports = DeepCopy;
  }, function (module, exports) {
    module.exports = function (gameObject) {
      var out = {
        name: gameObject.name,
        type: gameObject.type,
        x: gameObject.x,
        y: gameObject.y,
        depth: gameObject.depth,
        scale: {
          x: gameObject.scaleX,
          y: gameObject.scaleY
        },
        origin: {
          x: gameObject.originX,
          y: gameObject.originY
        },
        flipX: gameObject.flipX,
        flipY: gameObject.flipY,
        rotation: gameObject.rotation,
        alpha: gameObject.alpha,
        visible: gameObject.visible,
        blendMode: gameObject.blendMode,
        textureKey: "",
        frameKey: "",
        data: {}
      };
      return gameObject.texture && (out.textureKey = gameObject.texture.key, out.frameKey = gameObject.frame.name), out;
    };
  }, function (module, exports, __webpack_require__) {
    var Vector2 = __webpack_require__(3);

    module.exports = function (x, y, positionX, positionY, a, b, id, output) {
      void 0 === output && (output = new Vector2());
      var c = Math.sin(a),
          d = Math.cos(a),
          a = d * b,
          b = c * b,
          c = -c * id,
          d = d * id,
          id = 1 / (a * d + c * -b);
      return output.x = d * id * x + -c * id * y + (positionY * c - positionX * d) * id, output.y = a * id * y + -b * id * x + (-positionY * a + positionX * b) * id, output;
    };
  }, function (module, exports) {
    module.exports = function (array, total) {
      void 0 === total && (total = 1);

      for (var element = null, i = 0; i < total; i++) {
        element = array.shift(), array.push(element);
      }

      return element;
    };
  }, function (module, exports) {
    module.exports = function (array, total) {
      void 0 === total && (total = 1);

      for (var element = null, i = 0; i < total; i++) {
        element = array.pop(), array.unshift(element);
      }

      return element;
    };
  }, function (module, exports, __webpack_require__) {
    var Point = __webpack_require__(4);

    module.exports = function (ellipse, out) {
      void 0 === out && (out = new Point());
      var p = Math.random() * Math.PI * 2,
          s = Math.sqrt(Math.random());
      return out.x = ellipse.x + s * Math.cos(p) * ellipse.width / 2, out.y = ellipse.y + s * Math.sin(p) * ellipse.height / 2, out;
    };
  }, function (module, exports, __webpack_require__) {
    var Point = __webpack_require__(4);

    module.exports = function (triangle, out) {
      void 0 === out && (out = new Point());
      var ux = triangle.x2 - triangle.x1,
          uy = triangle.y2 - triangle.y1,
          vx = triangle.x3 - triangle.x1,
          vy = triangle.y3 - triangle.y1,
          r = Math.random(),
          s = Math.random();
      return 1 <= r + s && (r = 1 - r, s = 1 - s), out.x = triangle.x1 + (ux * r + vx * s), out.y = triangle.y1 + (uy * r + vy * s), out;
    };
  }, function (module, exports) {
    module.exports = function (point, x, y, t, distance) {
      t += Math.atan2(point.y - y, point.x - x);
      return point.x = x + distance * Math.cos(t), point.y = y + distance * Math.sin(t), point;
    };
  }, function (module, exports) {
    module.exports = function (x, min, max) {
      return (x = Math.max(0, Math.min(1, (x - min) / (max - min)))) * x * x * (x * (6 * x - 15) + 10);
    };
  }, function (module, exports) {
    module.exports = function (x, min, max) {
      return x <= min ? 0 : max <= x ? 1 : (x = (x - min) / (max - min)) * x * (3 - 2 * x);
    };
  }, function (module, exports, __webpack_require__) {
    var Clamp = __webpack_require__(18),
        Animation = __webpack_require__(0),
        Events = __webpack_require__(132),
        FindClosestInSorted = __webpack_require__(318),
        Frame = __webpack_require__(319),
        GetValue = __webpack_require__(6),
        SortByDigits = __webpack_require__(320),
        Animation = new Animation({
      initialize: function initialize(manager, key, config) {
        this.manager = manager, this.key = key, this.type = "frame", this.frames = this.getFrames(manager.textureManager, GetValue(config, "frames", []), GetValue(config, "defaultTextureKey", null), GetValue(config, "sortFrames", !0)), this.frameRate = GetValue(config, "frameRate", null), this.duration = GetValue(config, "duration", null), this.msPerFrame, this.skipMissedFrames = GetValue(config, "skipMissedFrames", !0), this.delay = GetValue(config, "delay", 0), this.repeat = GetValue(config, "repeat", 0), this.repeatDelay = GetValue(config, "repeatDelay", 0), this.yoyo = GetValue(config, "yoyo", !1), this.showOnStart = GetValue(config, "showOnStart", !1), this.hideOnComplete = GetValue(config, "hideOnComplete", !1), this.paused = !1, this.calculateDuration(this, this.getTotalFrames(), this.duration, this.frameRate), this.manager.on && (this.manager.on(Events.PAUSE_ALL, this.pause, this), this.manager.on(Events.RESUME_ALL, this.resume, this));
      },
      getTotalFrames: function getTotalFrames() {
        return this.frames.length;
      },
      calculateDuration: function calculateDuration(target, totalFrames, duration, frameRate) {
        null === duration && null === frameRate ? (target.frameRate = 24, target.duration = 24 / totalFrames * 1e3) : duration && null === frameRate ? (target.duration = duration, target.frameRate = totalFrames / (duration / 1e3)) : (target.frameRate = frameRate, target.duration = totalFrames / frameRate * 1e3), target.msPerFrame = 1e3 / target.frameRate;
      },
      addFrame: function addFrame(config) {
        return this.addFrameAt(this.frames.length, config);
      },
      addFrameAt: function addFrameAt(post, pre) {
        var newFrames = this.getFrames(this.manager.textureManager, pre);
        return 0 < newFrames.length && (0 === post ? this.frames = newFrames.concat(this.frames) : post === this.frames.length ? this.frames = this.frames.concat(newFrames) : (pre = this.frames.slice(0, post), post = this.frames.slice(post), this.frames = pre.concat(newFrames, post)), this.updateFrameSequence()), this;
      },
      checkFrame: function checkFrame(index) {
        return 0 <= index && index < this.frames.length;
      },
      getFirstTick: function getFirstTick(state) {
        state.accumulator = 0, state.nextTick = state.msPerFrame + state.currentFrame.duration;
      },
      getFrameAt: function getFrameAt(index) {
        return this.frames[index];
      },
      getFrames: function getFrames(textureManager, frames, defaultTextureKey, sortFrames) {
        void 0 === sortFrames && (sortFrames = !0);
        var prev,
            textureKey,
            frameKeys,
            out = [],
            index = 1;
        if ("string" == typeof frames && (textureKey = frames, frameKeys = textureManager.get(textureKey).getFrameNames(), sortFrames && SortByDigits(frameKeys), frames = [], frameKeys.forEach(function (value) {
          frames.push({
            key: textureKey,
            frame: value
          });
        })), !Array.isArray(frames) || 0 === frames.length) return out;

        for (i = 0; i < frames.length; i++) {
          var frame,
              textureFrame,
              animationFrame,
              item = frames[i],
              key = GetValue(item, "key", defaultTextureKey);
          key && (frame = GetValue(item, "frame", 0), textureFrame = textureManager.getFrame(key, frame), (animationFrame = new Frame(key, frame, index, textureFrame)).duration = GetValue(item, "duration", 0), animationFrame.isFirst = !prev, prev && ((prev.nextFrame = animationFrame).prevFrame = prev), out.push(animationFrame), prev = animationFrame, index++);
        }

        if (0 < out.length) {
          animationFrame.isLast = !0, animationFrame.nextFrame = out[0], out[0].prevFrame = animationFrame;

          for (var slice = 1 / (out.length - 1), i = 0; i < out.length; i++) {
            out[i].progress = i * slice;
          }
        }

        return out;
      },
      getNextTick: function getNextTick(state) {
        state.accumulator -= state.nextTick, state.nextTick = state.msPerFrame + state.currentFrame.duration;
      },
      getFrameByProgress: function getFrameByProgress(value) {
        return value = Clamp(value, 0, 1), FindClosestInSorted(value, this.frames, "progress");
      },
      nextFrame: function nextFrame(state) {
        var frame = state.currentFrame;
        frame.isLast ? state.yoyo ? this.handleYoyoFrame(state, !1) : 0 < state.repeatCounter ? state.inReverse && state.forward ? state.forward = !1 : this.repeatAnimation(state) : state.complete() : this.updateAndGetNextTick(state, frame.nextFrame);
      },
      handleYoyoFrame: function handleYoyoFrame(state, frame) {
        if (state.inReverse === !(frame = frame || !1) && 0 < state.repeatCounter) return 0 !== state.repeatDelay && !state.pendingRepeat || (state.forward = frame), void this.repeatAnimation(state);
        state.inReverse === frame || 0 !== state.repeatCounter ? (frame = (state.forward = frame) ? state.currentFrame.nextFrame : state.currentFrame.prevFrame, this.updateAndGetNextTick(state, frame)) : state.complete();
      },
      getLastFrame: function getLastFrame() {
        return this.frames[this.frames.length - 1];
      },
      previousFrame: function previousFrame(state) {
        var frame = state.currentFrame;
        frame.isFirst ? state.yoyo ? this.handleYoyoFrame(state, !0) : 0 < state.repeatCounter ? (state.inReverse && !state.forward || (state.forward = !0), this.repeatAnimation(state)) : state.complete() : this.updateAndGetNextTick(state, frame.prevFrame);
      },
      updateAndGetNextTick: function updateAndGetNextTick(state, frame) {
        state.setCurrentFrame(frame), this.getNextTick(state);
      },
      removeFrame: function removeFrame(index) {
        index = this.frames.indexOf(index);
        return -1 !== index && this.removeFrameAt(index), this;
      },
      removeFrameAt: function removeFrameAt(index) {
        return this.frames.splice(index, 1), this.updateFrameSequence(), this;
      },
      repeatAnimation: function repeatAnimation(state) {
        if (2 === state._pendingStop) {
          if (0 === state._pendingStopValue) return state.stop();
          state._pendingStopValue--;
        }

        0 < state.repeatDelay && !state.pendingRepeat ? (state.pendingRepeat = !0, state.accumulator -= state.nextTick, state.nextTick += state.repeatDelay) : (state.repeatCounter--, state.forward ? state.setCurrentFrame(state.currentFrame.nextFrame) : state.setCurrentFrame(state.currentFrame.prevFrame), state.isPlaying && (this.getNextTick(state), state.handleRepeat()));
      },
      toJSON: function toJSON() {
        var output = {
          key: this.key,
          type: this.type,
          frames: [],
          frameRate: this.frameRate,
          duration: this.duration,
          skipMissedFrames: this.skipMissedFrames,
          delay: this.delay,
          repeat: this.repeat,
          repeatDelay: this.repeatDelay,
          yoyo: this.yoyo,
          showOnStart: this.showOnStart,
          hideOnComplete: this.hideOnComplete
        };
        return this.frames.forEach(function (frame) {
          output.frames.push(frame.toJSON());
        }), output;
      },
      updateFrameSequence: function updateFrameSequence() {
        for (var frame, len = this.frames.length, slice = 1 / (len - 1), i = 0; i < len; i++) {
          (frame = this.frames[i]).index = i + 1, frame.isFirst = !1, frame.isLast = !1, frame.progress = i * slice, 0 === i ? (frame.isFirst = !0, 1 === len ? (frame.isLast = !0, (frame.nextFrame = frame).prevFrame = frame) : (frame.isLast = !1, frame.prevFrame = this.frames[len - 1], frame.nextFrame = this.frames[i + 1])) : i === len - 1 && 1 < len ? (frame.isLast = !0, frame.prevFrame = this.frames[len - 2], frame.nextFrame = this.frames[0]) : 1 < len && (frame.prevFrame = this.frames[i - 1], frame.nextFrame = this.frames[i + 1]);
        }

        return this;
      },
      pause: function pause() {
        return this.paused = !0, this;
      },
      resume: function resume() {
        return this.paused = !1, this;
      },
      destroy: function destroy() {
        this.manager.off && (this.manager.off(Events.PAUSE_ALL, this.pause, this), this.manager.off(Events.RESUME_ALL, this.resume, this)), this.manager.remove(this.key);

        for (var i = 0; i < this.frames.length; i++) {
          this.frames[i].destroy();
        }

        this.frames = [], this.manager = null;
      }
    });

    module.exports = Animation;
  }, function (module, exports) {
    module.exports = function (str, len, pad, dir) {
      void 0 === pad && (pad = " "), void 0 === dir && (dir = 3);
      var padlen;
      if ((len = void 0 === len ? 0 : len) + 1 >= (str = str.toString()).length) switch (dir) {
        case 1:
          str = new Array(len + 1 - str.length).join(pad) + str;
          break;

        case 3:
          var right = Math.ceil((padlen = len - str.length) / 2);
          str = new Array(1 + (padlen - right)).join(pad) + str + new Array(right + 1).join(pad);
          break;

        default:
          str += new Array(len + 1 - str.length).join(pad);
      }
      return str;
    };
  }, function (module, exports, __webpack_require__) {
    var HexStringToColor = __webpack_require__(327),
        IntegerToColor = __webpack_require__(189),
        ObjectToColor = __webpack_require__(331),
        RGBStringToColor = __webpack_require__(332);

    module.exports = function (input) {
      switch (_typeof(input)) {
        case "string":
          return ("rgb" === input.substr(0, 3).toLowerCase() ? RGBStringToColor : HexStringToColor)(input);

        case "number":
          return IntegerToColor(input);

        case "object":
          return ObjectToColor(input);
      }
    };
  }, function (module, exports, __webpack_require__) {
    var GetColor = __webpack_require__(103);

    function ConvertValue(n, min, s, v) {
      min = (n + 6 * min) % 6, min = Math.min(min, 4 - min, 1);
      return Math.round(255 * (v - v * s * Math.max(0, min)));
    }

    module.exports = function (h, s, b, out) {
      var r = ConvertValue(5, h, s = void 0 === s ? 1 : s, b = void 0 === b ? 1 : b),
          g = ConvertValue(3, h, s, b),
          b = ConvertValue(1, h, s, b);
      return out ? out.setTo ? out.setTo(r, g, b, out.alpha, !1) : (out.r = r, out.g = g, out.b = b, out.color = GetColor(r, g, b), out) : {
        r: r,
        g: g,
        b: b,
        color: GetColor(r, g, b)
      };
    };
  }, function (module, exports, __webpack_require__) {
    var Color = __webpack_require__(38),
        IntegerToRGB = __webpack_require__(330);

    module.exports = function (rgb) {
      rgb = IntegerToRGB(rgb);
      return new Color(rgb.r, rgb.g, rgb.b, rgb.a);
    };
  }, function (module, exports) {
    module.exports = function (rect, x, y) {
      return rect.x = x - rect.width / 2, rect.y = y - rect.height / 2, rect;
    };
  }, function (module, exports, __webpack_require__) {
    var OS = __webpack_require__(105),
        Browser = __webpack_require__(136),
        CanvasPool = __webpack_require__(31),
        Features = {
      canvas: !1,
      canvasBitBltShift: null,
      file: !1,
      fileSystem: !1,
      getUserMedia: !0,
      littleEndian: !1,
      localStorage: !1,
      pointerLock: !1,
      support32bit: !1,
      vibration: !1,
      webGL: !1,
      worker: !1
    };

    module.exports = function () {
      if ("function" == typeof importScripts) return Features;
      Features.canvas = !!window.CanvasRenderingContext2D;

      try {
        Features.localStorage = !!localStorage.getItem;
      } catch (error) {
        Features.localStorage = !1;
      }

      Features.file = !!(window.File && window.FileReader && window.FileList && window.Blob), Features.fileSystem = !!window.requestFileSystem;
      var c,
          b,
          isUint8 = !1;
      return Features.webGL = function () {
        if (window.WebGLRenderingContext) try {
          var canvas = CanvasPool.createWebGL(this),
              ctx = canvas.getContext("webgl") || canvas.getContext("experimental-webgl"),
              canvas2D = CanvasPool.create2D(this),
              image = canvas2D.getContext("2d").createImageData(1, 1);
          return isUint8 = image.data instanceof Uint8ClampedArray, CanvasPool.remove(canvas), CanvasPool.remove(canvas2D), !!ctx;
        } catch (e) {
          return !1;
        }
        return !1;
      }(), Features.worker = !!window.Worker, Features.pointerLock = "pointerLockElement" in document || "mozPointerLockElement" in document || "webkitPointerLockElement" in document, navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia, window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL, Features.getUserMedia = Features.getUserMedia && !!navigator.getUserMedia && !!window.URL, Browser.firefox && Browser.firefoxVersion < 21 && (Features.getUserMedia = !1), !OS.iOS && (Browser.ie || Browser.firefox || Browser.chrome) && (Features.canvasBitBltShift = !0), (Browser.safari || Browser.mobileSafari) && (Features.canvasBitBltShift = !1), navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate, navigator.vibrate && (Features.vibration = !0), "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array && "undefined" != typeof Uint32Array && (Features.littleEndian = (c = new ArrayBuffer(4), b = new Uint8Array(c), c = new Uint32Array(c), b[0] = 161, b[1] = 178, b[2] = 195, b[3] = 212, 3569595041 === c[0] || 2712847316 !== c[0] && null)), Features.support32bit = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8ClampedArray && "undefined" != typeof Int32Array && null !== Features.littleEndian && isUint8, Features;
    }();
  }, function (module, exports) {
    var prefix = "";

    function getPrefix(context) {
      for (var vendors = ["i", "webkitI", "msI", "mozI", "oI"], i = 0; i < vendors.length; i++) {
        var s = vendors[i] + "mageSmoothingEnabled";
        if (s in context) return s;
      }

      return null;
    }

    module.exports = {
      disable: function disable(context) {
        return (prefix = "" === prefix ? getPrefix(context) : prefix) && (context[prefix] = !1), context;
      },
      enable: function enable(context) {
        return (prefix = "" === prefix ? getPrefix(context) : prefix) && (context[prefix] = !0), context;
      },
      getPrefix: getPrefix,
      isEnabled: function isEnabled(context) {
        return null !== prefix ? context[prefix] : null;
      }
    };
  }, function (module, exports, PhaserMath) {
    var CONST = PhaserMath(14),
        PhaserMath = PhaserMath(17)(!1, PhaserMath = {
      Angle: PhaserMath(812),
      Distance: PhaserMath(821),
      Easing: PhaserMath(826),
      Fuzzy: PhaserMath(827),
      Interpolation: PhaserMath(830),
      Pow2: PhaserMath(835),
      Snap: PhaserMath(837),
      RandomDataGenerator: PhaserMath(839),
      Average: PhaserMath(840),
      Bernstein: PhaserMath(356),
      Between: PhaserMath(195),
      CatmullRom: PhaserMath(194),
      CeilTo: PhaserMath(841),
      Clamp: PhaserMath(18),
      DegToRad: PhaserMath(36),
      Difference: PhaserMath(842),
      Euler: PhaserMath(843),
      Factorial: PhaserMath(357),
      FloatBetween: PhaserMath(137),
      FloorTo: PhaserMath(844),
      FromPercent: PhaserMath(98),
      GetSpeed: PhaserMath(845),
      IsEven: PhaserMath(846),
      IsEvenStrict: PhaserMath(847),
      Linear: PhaserMath(135),
      MaxAdd: PhaserMath(848),
      Median: PhaserMath(849),
      MinSub: PhaserMath(850),
      Percent: PhaserMath(851),
      RadToDeg: PhaserMath(196),
      RandomXY: PhaserMath(852),
      RandomXYZ: PhaserMath(853),
      RandomXYZW: PhaserMath(854),
      Rotate: PhaserMath(362),
      RotateAround: PhaserMath(308),
      RotateAroundDistance: PhaserMath(182),
      RotateTo: PhaserMath(855),
      RoundAwayFromZero: PhaserMath(363),
      RoundTo: PhaserMath(856),
      SinCosTableGenerator: PhaserMath(857),
      SmootherStep: PhaserMath(183),
      SmoothStep: PhaserMath(184),
      ToXY: PhaserMath(858),
      TransformXY: PhaserMath(177),
      Within: PhaserMath(859),
      Wrap: PhaserMath(68),
      Vector2: PhaserMath(3),
      Vector3: PhaserMath(39),
      Vector4: PhaserMath(140),
      Matrix3: PhaserMath(364),
      Matrix4: PhaserMath(69),
      Quaternion: PhaserMath(365),
      RotateVec3: PhaserMath(860)
    }, CONST);
    module.exports = PhaserMath;
  }, function (module, exports) {
    module.exports = function (t, v1, p1, p2, t2) {
      var v0 = .5 * (p2 - v1),
          v1 = .5 * (t2 - p1),
          t2 = t * t;
      return (2 * p1 - 2 * p2 + v0 + v1) * (t * t2) + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
    };
  }, function (module, exports) {
    module.exports = function (min, max) {
      return Math.floor(Math.random() * (max - min + 1) + min);
    };
  }, function (module, exports, __webpack_require__) {
    var CONST = __webpack_require__(14);

    module.exports = function (radians) {
      return radians * CONST.RAD_TO_DEG;
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      Global: ["game", "anims", "cache", "plugins", "registry", "scale", "sound", "textures", "renderer"],
      CoreScene: ["EventEmitter", "CameraManager", "GameObjectCreator", "GameObjectFactory", "ScenePlugin", "DisplayList", "UpdateList"],
      DefaultScene: ["Clock", "DataManagerPlugin", "InputPlugin", "Loader", "TweenManager", "LightsPlugin"]
    };
  }, function (module, exports, ColorMatrix) {
    ColorMatrix = new (ColorMatrix(0))({
      initialize: function initialize() {
        this._matrix = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], this.alpha = 1, this._dirty = !0, this._data;
      },
      set: function set(value) {
        return this._matrix = value, this._dirty = !0, this;
      },
      reset: function reset() {
        var m = this._matrix;
        return m[0] = 1, m[1] = 0, m[2] = 0, m[3] = 0, m[4] = 0, m[5] = 0, m[6] = 1, m[7] = 0, m[8] = 0, m[9] = 0, m[10] = 0, m[11] = 0, m[12] = 1, m[13] = 0, m[14] = 0, m[15] = 0, m[16] = 0, m[17] = 0, m[18] = 1, m[19] = 0, this._dirty = !0, this;
      },
      getData: function getData() {
        var f32;
        return this._dirty && ((f32 = new Float32Array(this._matrix))[4] /= 255, f32[9] /= 255, f32[14] /= 255, f32[19] /= 255, this._data = f32, this._dirty = !1), this._data;
      },
      brightness: function brightness(b, multiply) {
        b = void 0 === b ? 0 : b;
        return this.multiply([b, 0, 0, 0, 0, 0, b, 0, 0, 0, 0, 0, b, 0, 0, 0, 0, 0, 1, 0], multiply = void 0 === multiply ? !1 : multiply);
      },
      saturate: function saturate(y, multiply) {
        var x = 2 * (y = void 0 === y ? 0 : y) / 3 + 1,
            y = -.5 * (x - 1);
        return this.multiply([x, y, y, 0, 0, y, x, y, 0, 0, y, y, x, 0, 0, 0, 0, 0, 1, 0], multiply = void 0 === multiply ? !1 : multiply);
      },
      desaturate: function desaturate(multiply) {
        return this.saturate(-1, multiply = void 0 === multiply ? !1 : multiply);
      },
      hue: function hue(sin, multiply) {
        void 0 === multiply && (multiply = !1), sin = (sin = void 0 === sin ? 0 : sin) / 180 * Math.PI;
        var cos = Math.cos(sin),
            sin = Math.sin(sin);
        return this.multiply([.213 + .787 * cos + -.213 * sin, .715 + -.715 * cos + -.715 * sin, .072 + -.072 * cos + .928 * sin, 0, 0, .213 + -.213 * cos + .143 * sin, .715 + cos * (1 - .715) + .14 * sin, .072 + -.072 * cos + -.283 * sin, 0, 0, .213 + -.213 * cos + -.787 * sin, .715 + -.715 * cos + .715 * sin, .072 + .928 * cos + .072 * sin, 0, 0, 0, 0, 0, 1, 0], multiply);
      },
      grayscale: function grayscale(value, multiply) {
        return this.saturate(-(value = void 0 === value ? 1 : value), multiply = void 0 === multiply ? !1 : multiply);
      },
      blackWhite: function blackWhite(multiply) {
        return this.multiply([.3, .6, .1, 0, 0, .3, .6, .1, 0, 0, .3, .6, .1, 0, 0, 0, 0, 0, 1, 0], multiply = void 0 === multiply ? !1 : multiply);
      },
      contrast: function contrast(o, multiply) {
        var v = (o = void 0 === o ? 0 : o) + 1,
            o = -.5 * (v - 1);
        return this.multiply([v, 0, 0, 0, o, 0, v, 0, 0, o, 0, 0, v, 0, o, 0, 0, 0, 1, 0], multiply = void 0 === multiply ? !1 : multiply);
      },
      negative: function negative(multiply) {
        return this.multiply([-1, 0, 0, 1, 0, 0, -1, 0, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0], multiply = void 0 === multiply ? !1 : multiply);
      },
      desaturateLuminance: function desaturateLuminance(multiply) {
        return this.multiply([.2764723, .929708, .0938197, 0, -37.1, .2764723, .929708, .0938197, 0, -37.1, .2764723, .929708, .0938197, 0, -37.1, 0, 0, 0, 1, 0], multiply = void 0 === multiply ? !1 : multiply);
      },
      sepia: function sepia(multiply) {
        return this.multiply([.393, .7689999, .18899999, 0, 0, .349, .6859999, .16799999, 0, 0, .272, .5339999, .13099999, 0, 0, 0, 0, 0, 1, 0], multiply = void 0 === multiply ? !1 : multiply);
      },
      night: function night(intensity, multiply) {
        return this.multiply([-2 * (intensity = void 0 === intensity ? .1 : intensity), -intensity, 0, 0, 0, -intensity, 0, intensity, 0, 0, 0, intensity, 2 * intensity, 0, 0, 0, 0, 0, 1, 0], multiply = void 0 === multiply ? !1 : multiply);
      },
      lsd: function lsd(multiply) {
        return this.multiply([2, -.4, .5, 0, 0, -.5, 2, -.4, 0, 0, -.4, -.5, 3, 0, 0, 0, 0, 0, 1, 0], multiply = void 0 === multiply ? !1 : multiply);
      },
      brown: function brown(multiply) {
        return this.multiply([.5997023498159715, .34553243048391263, -.2708298674538042, 0, 47.43192855600873, -.037703249837783157, .8609577587992641, .15059552388459913, 0, -36.96841498319127, .24113635128153335, -.07441037908422492, .44972182064877153, 0, -7.562075277591283, 0, 0, 0, 1, 0], multiply = void 0 === multiply ? !1 : multiply);
      },
      vintagePinhole: function vintagePinhole(multiply) {
        return this.multiply([.6279345635605994, .3202183420819367, -.03965408211312453, 0, 9.651285835294123, .02578397704808868, .6441188644374771, .03259127616149294, 0, 7.462829176470591, .0466055556782719, -.0851232987247891, .5241648018700465, 0, 5.159190588235296, 0, 0, 0, 1, 0], multiply = void 0 === multiply ? !1 : multiply);
      },
      kodachrome: function kodachrome(multiply) {
        return this.multiply([1.1285582396593525, -.3967382283601348, -.03992559172921793, 0, 63.72958762196502, -.16404339962244616, 1.0835251566291304, -.05498805115633132, 0, 24.732407896706203, -.16786010706155763, -.5603416277695248, 1.6014850761964943, 0, 35.62982807460946, 0, 0, 0, 1, 0], multiply = void 0 === multiply ? !1 : multiply);
      },
      technicolor: function technicolor(multiply) {
        return this.multiply([1.9125277891456083, -.8545344976951645, -.09155508482755585, 0, 11.793603434377337, -.3087833385928097, 1.7658908555458428, -.10601743074722245, 0, -70.35205161461398, -.231103377548616, -.7501899197440212, 1.847597816108189, 0, 30.950940869491138, 0, 0, 0, 1, 0], multiply = void 0 === multiply ? !1 : multiply);
      },
      polaroid: function polaroid(multiply) {
        return this.multiply([1.438, -.062, -.062, 0, 0, -.122, 1.378, -.122, 0, 0, -.016, -.016, 1.483, 0, 0, 0, 0, 0, 1, 0], multiply = void 0 === multiply ? !1 : multiply);
      },
      shiftToBGR: function shiftToBGR(multiply) {
        return this.multiply([0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0], multiply = void 0 === multiply ? !1 : multiply);
      },
      multiply: function multiply(a, _multiply) {
        _multiply || this.reset();

        for (var m = this._matrix, c = [], i = 0; i < 20; i++) {
          c[i] = m[i];
        }

        return m[0] = c[0] * a[0] + c[1] * a[5] + c[2] * a[10] + c[3] * a[15], m[1] = c[0] * a[1] + c[1] * a[6] + c[2] * a[11] + c[3] * a[16], m[2] = c[0] * a[2] + c[1] * a[7] + c[2] * a[12] + c[3] * a[17], m[3] = c[0] * a[3] + c[1] * a[8] + c[2] * a[13] + c[3] * a[18], m[4] = c[0] * a[4] + c[1] * a[9] + c[2] * a[14] + c[3] * a[19] + c[4], m[5] = c[5] * a[0] + c[6] * a[5] + c[7] * a[10] + c[8] * a[15], m[6] = c[5] * a[1] + c[6] * a[6] + c[7] * a[11] + c[8] * a[16], m[7] = c[5] * a[2] + c[6] * a[7] + c[7] * a[12] + c[8] * a[17], m[8] = c[5] * a[3] + c[6] * a[8] + c[7] * a[13] + c[8] * a[18], m[9] = c[5] * a[4] + c[6] * a[9] + c[7] * a[14] + c[8] * a[19] + c[9], m[10] = c[10] * a[0] + c[11] * a[5] + c[12] * a[10] + c[13] * a[15], m[11] = c[10] * a[1] + c[11] * a[6] + c[12] * a[11] + c[13] * a[16], m[12] = c[10] * a[2] + c[11] * a[7] + c[12] * a[12] + c[13] * a[17], m[13] = c[10] * a[3] + c[11] * a[8] + c[12] * a[13] + c[13] * a[18], m[14] = c[10] * a[4] + c[11] * a[9] + c[12] * a[14] + c[13] * a[19] + c[14], m[15] = c[15] * a[0] + c[16] * a[5] + c[17] * a[10] + c[18] * a[15], m[16] = c[15] * a[1] + c[16] * a[6] + c[17] * a[11] + c[18] * a[16], m[17] = c[15] * a[2] + c[16] * a[7] + c[17] * a[12] + c[18] * a[17], m[18] = c[15] * a[3] + c[16] * a[8] + c[17] * a[13] + c[18] * a[18], m[19] = c[15] * a[4] + c[16] * a[9] + c[17] * a[14] + c[18] * a[19] + c[19], this._dirty = !0, this;
      }
    });
    module.exports = ColorMatrix;
  }, function (module, exports, __webpack_require__) {
    var Rectangle = __webpack_require__(10),
        MATH_CONST = __webpack_require__(14);

    module.exports = function (points, out) {
      if (void 0 === out && (out = new Rectangle()), 0 === points.length) return out;

      for (var px, py, minX = Number.MAX_VALUE, minY = Number.MAX_VALUE, maxX = MATH_CONST.MIN_SAFE_INTEGER, maxY = MATH_CONST.MIN_SAFE_INTEGER, i = 0; i < points.length; i++) {
        py = points[i], py = Array.isArray(py) ? (px = py[0], py[1]) : (px = py.x, py.y), minX = Math.min(minX, px), minY = Math.min(minY, py), maxX = Math.max(maxX, px), maxY = Math.max(maxY, py);
      }

      return out.x = minX, out.y = minY, out.width = maxX - minX, out.height = maxY - minY, out;
    };
  }, function (module, exports, __webpack_require__) {
    var RGB = __webpack_require__(0),
        NOOP = __webpack_require__(1),
        RGB = new RGB({
      initialize: function initialize(red, green, blue) {
        this._rgb = [0, 0, 0], this.onChangeCallback = NOOP, this.dirty = !1, this.set(red, green, blue);
      },
      set: function set(red, green, blue) {
        return this._rgb = [red = void 0 === red ? 0 : red, green = void 0 === green ? 0 : green, blue = void 0 === blue ? 0 : blue], this.onChange(), this;
      },
      equals: function equals(red, green, blue) {
        var rgb = this._rgb;
        return rgb.r === red && rgb.g === green && rgb.b === blue;
      },
      onChange: function onChange() {
        this.dirty = !0;
        var rgb = this._rgb;
        this.onChangeCallback.call(this, rgb[0], rgb[1], rgb[2]);
      },
      r: {
        get: function get() {
          return this._rgb[0];
        },
        set: function set(value) {
          this._rgb[0] = value, this.onChange();
        }
      },
      g: {
        get: function get() {
          return this._rgb[1];
        },
        set: function set(value) {
          this._rgb[1] = value, this.onChange();
        }
      },
      b: {
        get: function get() {
          return this._rgb[2];
        },
        set: function set(value) {
          this._rgb[2] = value, this.onChange();
        }
      },
      destroy: function destroy() {
        this.onChangeCallback = null;
      }
    });

    module.exports = RGB;
  }, function (module, exports, CONST) {
    CONST = {
      CENTER: CONST(403),
      ORIENTATION: CONST(404),
      SCALE_MODE: CONST(405),
      ZOOM: CONST(406)
    };
    module.exports = CONST;
  }, function (module, exports) {
    module.exports = function (element) {
      element.parentNode && element.parentNode.removeChild(element);
    };
  }, function (module, exports) {
    module.exports = {
      MOUSE_DOWN: 0,
      MOUSE_MOVE: 1,
      MOUSE_UP: 2,
      TOUCH_START: 3,
      TOUCH_MOVE: 4,
      TOUCH_END: 5,
      POINTER_LOCK_CHANGE: 6,
      TOUCH_CANCEL: 7,
      MOUSE_WHEEL: 8
    };
  }, function (module, exports, __webpack_require__) {
    var Systems = __webpack_require__(0),
        CONST = __webpack_require__(144),
        DefaultPlugins = __webpack_require__(197),
        Events = __webpack_require__(20),
        GetPhysicsPlugins = __webpack_require__(419),
        GetScenePlugins = __webpack_require__(420),
        GLOBAL_CONST = __webpack_require__(33),
        NOOP = __webpack_require__(1),
        Settings = __webpack_require__(421),
        Systems = new Systems({
      initialize: function initialize(scene, config) {
        this.scene = scene, this.game, this.renderer, this.config = config, this.settings = Settings.create(config), this.canvas, this.context, this.anims, this.cache, this.plugins, this.registry, this.scale, this.sound, this.textures, this.add, this.cameras, this.displayList, this.events, this.make, this.scenePlugin, this.updateList, this.sceneUpdate = NOOP;
      },
      init: function init(pluginManager) {
        this.settings.status = CONST.INIT, this.sceneUpdate = NOOP, this.game = pluginManager, this.renderer = pluginManager.renderer, this.canvas = pluginManager.canvas, this.context = pluginManager.context;
        pluginManager = pluginManager.plugins;
        (this.plugins = pluginManager).addToScene(this, DefaultPlugins.Global, [DefaultPlugins.CoreScene, GetScenePlugins(this), GetPhysicsPlugins(this)]), this.events.emit(Events.BOOT, this), this.settings.isBooted = !0;
      },
      step: function step(time, delta) {
        var events = this.events;
        events.emit(Events.PRE_UPDATE, time, delta), events.emit(Events.UPDATE, time, delta), this.sceneUpdate.call(this.scene, time, delta), events.emit(Events.POST_UPDATE, time, delta);
      },
      render: function render(renderer) {
        var displayList = this.displayList;
        displayList.depthSort(), this.events.emit(Events.PRE_RENDER, renderer), this.cameras.render(renderer, displayList), this.events.emit(Events.RENDER, renderer);
      },
      queueDepthSort: function queueDepthSort() {
        this.displayList.queueDepthSort();
      },
      depthSort: function depthSort() {
        this.displayList.depthSort();
      },
      pause: function pause(data) {
        var events = this.events,
            settings = this.settings;
        return this.settings.active && (settings.status = CONST.PAUSED, settings.active = !1, events.emit(Events.PAUSE, this, data)), this;
      },
      resume: function resume(data) {
        var events = this.events,
            settings = this.settings;
        return this.settings.active || (settings.status = CONST.RUNNING, settings.active = !0, events.emit(Events.RESUME, this, data)), this;
      },
      sleep: function sleep(data) {
        var events = this.events,
            settings = this.settings;
        return settings.status = CONST.SLEEPING, settings.active = !1, settings.visible = !1, events.emit(Events.SLEEP, this, data), this;
      },
      wake: function wake(data) {
        var events = this.events,
            settings = this.settings;
        return settings.status = CONST.RUNNING, settings.active = !0, settings.visible = !0, events.emit(Events.WAKE, this, data), settings.isTransition && events.emit(Events.TRANSITION_WAKE, settings.transitionFrom, settings.transitionDuration), this;
      },
      getData: function getData() {
        return this.settings.data;
      },
      isSleeping: function isSleeping() {
        return this.settings.status === CONST.SLEEPING;
      },
      isActive: function isActive() {
        return this.settings.status === CONST.RUNNING;
      },
      isPaused: function isPaused() {
        return this.settings.status === CONST.PAUSED;
      },
      isTransitioning: function isTransitioning() {
        return this.settings.isTransition || null !== this.scenePlugin._target;
      },
      isTransitionOut: function isTransitionOut() {
        return null !== this.scenePlugin._target && 0 < this.scenePlugin._duration;
      },
      isTransitionIn: function isTransitionIn() {
        return this.settings.isTransition;
      },
      isVisible: function isVisible() {
        return this.settings.visible;
      },
      setVisible: function setVisible(value) {
        return this.settings.visible = value, this;
      },
      setActive: function setActive(value, data) {
        return value ? this.resume(data) : this.pause(data);
      },
      start: function start(data) {
        var events = this.events,
            settings = this.settings;
        data && (settings.data = data), settings.status = CONST.START, settings.active = !0, settings.visible = !0, events.emit(Events.START, this), events.emit(Events.READY, this, data);
      },
      shutdown: function shutdown(data) {
        var events = this.events,
            settings = this.settings;
        events.off(Events.TRANSITION_INIT), events.off(Events.TRANSITION_START), events.off(Events.TRANSITION_COMPLETE), events.off(Events.TRANSITION_OUT), settings.status = CONST.SHUTDOWN, settings.active = !1, settings.visible = !1, this.renderer === GLOBAL_CONST.WEBGL && this.renderer.resetTextures(!0), events.emit(Events.SHUTDOWN, this, data);
      },
      destroy: function destroy() {
        var events = this.events,
            settings = this.settings;
        settings.status = CONST.DESTROYED, settings.active = !1, settings.visible = !1, events.emit(Events.DESTROY, this), events.removeAllListeners();

        for (var props = ["scene", "game", "anims", "cache", "plugins", "registry", "sound", "textures", "add", "camera", "displayList", "events", "make", "scenePlugin", "updateList"], i = 0; i < props.length; i++) {
          this[props[i]] = null;
        }
      }
    });

    module.exports = Systems;
  }, function (module, exports) {
    module.exports = function (str) {
      return str && str[0].toUpperCase() + str.slice(1);
    };
  }, function (module, exports, __webpack_require__) {
    var CONST = __webpack_require__(33),
        Texture = __webpack_require__(0),
        Frame = __webpack_require__(109),
        TextureSource = __webpack_require__(424),
        Texture = new Texture({
      initialize: function initialize(manager, key, source, width, height) {
        Array.isArray(source) || (source = [source]), this.manager = manager, this.key = key, this.source = [], this.dataSource = [], this.frames = {}, this.customData = {}, this.firstFrame = "__BASE";

        for (var i = this.frameTotal = 0; i < source.length; i++) {
          this.source.push(new TextureSource(this, source[i], width, height));
        }
      },
      add: function add(name, sourceIndex, x, y, width, frame) {
        if (this.has(name)) return null;
        frame = new Frame(this, name, sourceIndex, x, y, width, frame);
        return this.frames[name] = frame, "__BASE" === this.firstFrame && (this.firstFrame = name), this.frameTotal++, frame;
      },
      remove: function remove(name) {
        return !!this.has(name) && (this.get(name).destroy(), delete this.frames[name], !0);
      },
      has: function has(name) {
        return this.frames[name];
      },
      get: function get(name) {
        name = name || this.firstFrame;
        var frame = this.frames[name];
        return frame || (console.warn("Texture.frame missing: " + name), frame = this.frames[this.firstFrame]), frame;
      },
      getTextureSourceIndex: function getTextureSourceIndex(source) {
        for (var i = 0; i < this.source.length; i++) {
          if (this.source[i] === source) return i;
        }

        return -1;
      },
      getFramesFromTextureSource: function getFramesFromTextureSource(sourceIndex, includeBase) {
        void 0 === includeBase && (includeBase = !1);
        var frameName,
            frame,
            out = [];

        for (frameName in this.frames) {
          "__BASE" === frameName && !includeBase || (frame = this.frames[frameName]).sourceIndex === sourceIndex && out.push(frame);
        }

        return out;
      },
      getFrameNames: function getFrameNames(idx) {
        void 0 === idx && (idx = !1);
        var out = Object.keys(this.frames);
        return idx || -1 !== (idx = out.indexOf("__BASE")) && out.splice(idx, 1), out;
      },
      getSourceImage: function getSourceImage(name) {
        null != name && 1 !== this.frameTotal || (name = "__BASE");
        var frame = this.frames[name];
        return frame ? frame.source.image : (console.warn("Texture.frame missing: " + name), this.frames.__BASE.source.image);
      },
      getDataSourceImage: function getDataSourceImage(idx) {
        null != idx && 1 !== this.frameTotal || (idx = "__BASE");
        var frame = this.frames[idx],
            idx = frame ? frame.sourceIndex : (console.warn("Texture.frame missing: " + idx), this.frames.__BASE.sourceIndex);
        return this.dataSource[idx].image;
      },
      setDataSource: function setDataSource(data) {
        Array.isArray(data) || (data = [data]);

        for (var i = 0; i < data.length; i++) {
          var source = this.source[i];
          this.dataSource.push(new TextureSource(this, data[i], source.width, source.height));
        }
      },
      setFilter: function setFilter(filterMode) {
        for (var i = 0; i < this.source.length; i++) {
          this.source[i].setFilter(filterMode);
        }

        for (i = 0; i < this.dataSource.length; i++) {
          this.dataSource[i].setFilter(filterMode);
        }
      },
      destroy: function destroy() {
        for (var frameName, i = 0; i < this.source.length; i++) {
          this.source[i].destroy();
        }

        for (i = 0; i < this.dataSource.length; i++) {
          this.dataSource[i].destroy();
        }

        for (frameName in this.frames) {
          this.frames[frameName].destroy();
        }

        this.source = [], this.dataSource = [], this.frames = {}, this.manager.removeKey(this.key);
        var renderer = this.manager.game.renderer;
        renderer && renderer.type === CONST.WEBGL && renderer.resetTextures(!0), this.manager = null;
      }
    });

    module.exports = Texture;
  }, function (module, exports, __webpack_require__) {
    var SafeRange = __webpack_require__(78);

    module.exports = function (array, property, value, startIndex, endIndex) {
      void 0 === endIndex && (endIndex = array.length);
      var output = [];
      if (SafeRange(array, startIndex = void 0 === startIndex ? 0 : startIndex, endIndex)) for (var i = startIndex; i < endIndex; i++) {
        var child = array[i];
        (!property || void 0 === value && child.hasOwnProperty(property) || property && void 0 !== value && child[property] === value) && output.push(child);
      }
      return output;
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      Matrix: __webpack_require__(1013),
      Add: __webpack_require__(1021),
      AddAt: __webpack_require__(1022),
      BringToTop: __webpack_require__(1023),
      CountAllMatching: __webpack_require__(1024),
      Each: __webpack_require__(1025),
      EachInRange: __webpack_require__(1026),
      FindClosestInSorted: __webpack_require__(318),
      GetAll: __webpack_require__(207),
      GetFirst: __webpack_require__(428),
      GetRandom: __webpack_require__(210),
      MoveDown: __webpack_require__(1027),
      MoveTo: __webpack_require__(1028),
      MoveUp: __webpack_require__(1029),
      MoveAbove: __webpack_require__(1030),
      MoveBelow: __webpack_require__(1031),
      NumberArray: __webpack_require__(322),
      NumberArrayStep: __webpack_require__(1032),
      QuickSelect: __webpack_require__(436),
      Range: __webpack_require__(437),
      Remove: __webpack_require__(93),
      RemoveAt: __webpack_require__(1033),
      RemoveBetween: __webpack_require__(1034),
      RemoveRandomElement: __webpack_require__(1035),
      Replace: __webpack_require__(1036),
      RotateLeft: __webpack_require__(178),
      RotateRight: __webpack_require__(179),
      SafeRange: __webpack_require__(78),
      SendToBack: __webpack_require__(1037),
      SetAll: __webpack_require__(1038),
      Shuffle: __webpack_require__(131),
      SortByDigits: __webpack_require__(320),
      SpliceOne: __webpack_require__(74),
      StableSort: __webpack_require__(79),
      Swap: __webpack_require__(1039)
    };
  }, function (module, exports) {
    module.exports = function (matrix) {
      if (!Array.isArray(matrix) || matrix.length < 2 || !Array.isArray(matrix[0])) return !1;

      for (var size = matrix[0].length, i = 1; i < matrix.length; i++) {
        if (matrix[i].length !== size) return !1;
      }

      return !0;
    };
  }, function (module, exports) {
    module.exports = function (array, startIndex, randomIndex) {
      void 0 === randomIndex && (randomIndex = array.length);
      randomIndex = (startIndex = void 0 === startIndex ? 0 : startIndex) + Math.floor(Math.random() * randomIndex);
      return void 0 === array[randomIndex] ? null : array[randomIndex];
    };
  }, function (module, exports, __webpack_require__) {
    var ProcessQueue = __webpack_require__(0),
        EventEmitter = __webpack_require__(9),
        Events = __webpack_require__(438),
        ProcessQueue = new ProcessQueue({
      Extends: EventEmitter,
      initialize: function initialize() {
        EventEmitter.call(this), this._pending = [], this._active = [], this._destroy = [], this._toProcess = 0, this.checkQueue = !1;
      },
      add: function add(item) {
        return this._pending.push(item), this._toProcess++, item;
      },
      remove: function remove(item) {
        return this._destroy.push(item), this._toProcess++, item;
      },
      removeAll: function removeAll() {
        for (var list = this._active, destroy = this._destroy, i = list.length; i--;) {
          destroy.push(list[i]), this._toProcess++;
        }

        return this;
      },
      update: function update() {
        if (0 === this._toProcess) return this._active;

        for (var list = this._destroy, active = this._active, i = 0; i < list.length; i++) {
          var item = list[i],
              idx = active.indexOf(item);
          -1 !== idx && (active.splice(idx, 1), this.emit(Events.PROCESS_QUEUE_REMOVE, item));
        }

        for (list.length = 0, list = this._pending, i = 0; i < list.length; i++) {
          item = list[i], (!this.checkQueue || this.checkQueue && -1 === active.indexOf(item)) && (active.push(item), this.emit(Events.PROCESS_QUEUE_ADD, item));
        }

        return list.length = 0, this._toProcess = 0, active;
      },
      getActive: function getActive() {
        return this._active;
      },
      length: {
        get: function get() {
          return this._active.length;
        }
      },
      destroy: function destroy() {
        this._toProcess = 0, this._pending = [], this._active = [], this._destroy = [];
      }
    });

    module.exports = ProcessQueue;
  }, function (module, exports) {
    function getValue(node, attribute) {
      return parseInt(node.getAttribute(attribute), 10);
    }

    module.exports = function (xml, frame, xSpacing, ySpacing, texture) {
      void 0 === xSpacing && (xSpacing = 0), void 0 === ySpacing && (ySpacing = 0);
      var textureX = frame.cutX,
          textureY = frame.cutY,
          textureWidth = frame.source.width,
          textureHeight = frame.source.height,
          sourceIndex = frame.sourceIndex,
          data = {},
          info = xml.getElementsByTagName("info")[0],
          common = xml.getElementsByTagName("common")[0];
      data.font = info.getAttribute("face"), data.size = getValue(info, "size"), data.lineHeight = getValue(common, "lineHeight") + ySpacing, data.chars = {};
      var top,
          left,
          letters = xml.getElementsByTagName("char"),
          adjustForTrim = void 0 !== frame && frame.trimmed;
      adjustForTrim && (top = frame.height, left = frame.width);

      for (var i = 0; i < letters.length; i++) {
        var node = letters[i],
            charCode = getValue(node, "id"),
            letter = String.fromCharCode(charCode),
            gx = getValue(node, "x"),
            charFrame = getValue(node, "y"),
            gw = getValue(node, "width"),
            gh = getValue(node, "height");
        adjustForTrim && (gx < left && (left = gx), charFrame < top && (top = charFrame)), adjustForTrim && 0 !== top && 0 !== left && (gx -= frame.x, charFrame -= frame.y);
        var u0 = (textureX + gx) / textureWidth,
            v0 = (textureY + charFrame) / textureHeight,
            u1 = (textureX + gx + gw) / textureWidth,
            v1 = (textureY + charFrame + gh) / textureHeight;
        data.chars[charCode] = {
          x: gx,
          y: charFrame,
          width: gw,
          height: gh,
          centerX: Math.floor(gw / 2),
          centerY: Math.floor(gh / 2),
          xOffset: getValue(node, "xoffset"),
          yOffset: getValue(node, "yoffset"),
          xAdvance: getValue(node, "xadvance") + xSpacing,
          data: {},
          kerning: {},
          u0: u0,
          v0: v0,
          u1: u1,
          v1: v1
        }, !texture || 0 === gw || 0 === gh || (charFrame = texture.add(letter, sourceIndex, gx, charFrame, gw, gh)) && charFrame.setUVs(gw, gh, u0, v0, u1, v1);
      }

      for (var kernings = xml.getElementsByTagName("kerning"), i = 0; i < kernings.length; i++) {
        var amount = kernings[i],
            first = getValue(amount, "first"),
            second = getValue(amount, "second"),
            amount = getValue(amount, "amount");
        data.chars[second].kerning[first] = amount;
      }

      return data;
    };
  }, function (module, exports, __webpack_require__) {
    var Blitter = __webpack_require__(1049),
        Bob = __webpack_require__(440),
        Class = __webpack_require__(0),
        Components = __webpack_require__(11),
        Frame = __webpack_require__(109),
        GameObject = __webpack_require__(15),
        List = __webpack_require__(110),
        Blitter = new Class({
      Extends: GameObject,
      Mixins: [Components.Alpha, Components.BlendMode, Components.Depth, Components.Mask, Components.Pipeline, Components.ScrollFactor, Components.Size, Components.Texture, Components.Transform, Components.Visible, Blitter],
      initialize: function initialize(scene, x, y, texture, frame) {
        GameObject.call(this, scene, "Blitter"), this.setTexture(texture, frame), this.setPosition(x, y), this.initPipeline(), this.children = new List(), this.renderList = [], this.dirty = !1;
      },
      create: function create(x, y, frame, bob, index) {
        void 0 === bob && (bob = !0), void 0 === index && (index = this.children.length), void 0 === frame ? frame = this.frame : frame instanceof Frame || (frame = this.texture.get(frame));
        bob = new Bob(this, x, y, frame, bob);
        return this.children.addAt(bob, index, !1), this.dirty = !0, bob;
      },
      createFromCallback: function createFromCallback(callback, quantity, frame, visible) {
        for (var bobs = this.createMultiple(quantity, frame, visible), i = 0; i < bobs.length; i++) {
          var bob = bobs[i];
          callback.call(this, bob, i);
        }

        return bobs;
      },
      createMultiple: function createMultiple(quantity, frame, visible) {
        void 0 === frame && (frame = this.frame.name), void 0 === visible && (visible = !0), Array.isArray(frame) || (frame = [frame]);

        var bobs = [],
            _this = this;

        return frame.forEach(function (singleFrame) {
          for (var i = 0; i < quantity; i++) {
            bobs.push(_this.create(0, 0, singleFrame, visible));
          }
        }), bobs;
      },
      childCanRender: function childCanRender(child) {
        return child.visible && 0 < child.alpha;
      },
      getRenderList: function getRenderList() {
        return this.dirty && (this.renderList = this.children.list.filter(this.childCanRender, this), this.dirty = !1), this.renderList;
      },
      clear: function clear() {
        this.children.removeAll(), this.dirty = !0;
      },
      preDestroy: function preDestroy() {
        this.children.destroy(), this.renderList = [];
      }
    });

    module.exports = Blitter;
  }, function (module, exports, __webpack_require__) {
    var ArrayUtils = __webpack_require__(208),
        BlendModes = __webpack_require__(35),
        Class = __webpack_require__(0),
        Components = __webpack_require__(11),
        Events = __webpack_require__(75),
        GameObject = __webpack_require__(15),
        Rectangle = __webpack_require__(10),
        Container = __webpack_require__(1052),
        Union = __webpack_require__(441),
        Vector2 = __webpack_require__(3),
        Container = new Class({
      Extends: GameObject,
      Mixins: [Components.AlphaSingle, Components.BlendMode, Components.ComputedSize, Components.Depth, Components.Mask, Components.Pipeline, Components.Transform, Components.Visible, Container],
      initialize: function initialize(scene, x, y, children) {
        GameObject.call(this, scene, "Container"), this.list = [], this.exclusive = !0, this.maxSize = -1, this.position = 0, this.localTransform = new Components.TransformMatrix(), this.tempTransformMatrix = new Components.TransformMatrix(), this._sortKey = "", this._sysEvents = scene.sys.events, this.scrollFactorX = 1, this.scrollFactorY = 1, this.initPipeline(), this.setPosition(x, y), this.clearAlpha(), this.setBlendMode(BlendModes.SKIP_CHECK), children && this.add(children);
      },
      originX: {
        get: function get() {
          return .5;
        }
      },
      originY: {
        get: function get() {
          return .5;
        }
      },
      displayOriginX: {
        get: function get() {
          return .5 * this.width;
        }
      },
      displayOriginY: {
        get: function get() {
          return .5 * this.height;
        }
      },
      setExclusive: function setExclusive(value) {
        return this.exclusive = value = void 0 === value ? !0 : value, this;
      },
      getBounds: function getBounds(output) {
        var transformedPosition;

        if ((output = void 0 === output ? new Rectangle() : output).setTo(this.x, this.y, 0, 0), this.parentContainer && (transformedPosition = this.parentContainer.getBoundsTransformMatrix().transformPoint(this.x, this.y), output.setTo(transformedPosition.x, transformedPosition.y, 0, 0)), 0 < this.list.length) {
          var children = this.list,
              tempRect = new Rectangle(),
              hasSetFirst = !1;
          output.setEmpty();

          for (var i = 0; i < children.length; i++) {
            var entry = children[i];
            entry.getBounds && (entry.getBounds(tempRect), hasSetFirst ? Union(tempRect, output, output) : (output.setTo(tempRect.x, tempRect.y, tempRect.width, tempRect.height), hasSetFirst = !0));
          }
        }

        return output;
      },
      addHandler: function addHandler(gameObject) {
        gameObject.once(Events.DESTROY, this.remove, this), this.exclusive && (gameObject.parentContainer && gameObject.parentContainer.remove(gameObject), gameObject.removeFromDisplayList(), gameObject.parentContainer = this);
      },
      removeHandler: function removeHandler(gameObject) {
        gameObject.off(Events.DESTROY, this.remove), this.exclusive && (gameObject.parentContainer = null, gameObject.addToDisplayList());
      },
      pointToContainer: function pointToContainer(source, output) {
        void 0 === output && (output = new Vector2()), this.parentContainer ? this.parentContainer.pointToContainer(source, output) : output = new Vector2(source.x, source.y);
        var tempMatrix = this.tempTransformMatrix;
        return tempMatrix.applyITRS(this.x, this.y, this.rotation, this.scaleX, this.scaleY), tempMatrix.invert(), tempMatrix.transformPoint(source.x, source.y, output), output;
      },
      getBoundsTransformMatrix: function getBoundsTransformMatrix() {
        return this.getWorldTransformMatrix(this.tempTransformMatrix, this.localTransform);
      },
      add: function add(child) {
        return ArrayUtils.Add(this.list, child, this.maxSize, this.addHandler, this), this;
      },
      addAt: function addAt(child, index) {
        return ArrayUtils.AddAt(this.list, child, index, this.maxSize, this.addHandler, this), this;
      },
      getAt: function getAt(index) {
        return this.list[index];
      },
      getIndex: function getIndex(child) {
        return this.list.indexOf(child);
      },
      sort: function sort(property, handler) {
        return property && ArrayUtils.StableSort(this.list, handler = void 0 === handler ? function (childA, childB) {
          return childA[property] - childB[property];
        } : handler), this;
      },
      getByName: function getByName(name) {
        return ArrayUtils.GetFirst(this.list, "name", name);
      },
      getRandom: function getRandom(startIndex, length) {
        return ArrayUtils.GetRandom(this.list, startIndex, length);
      },
      getFirst: function getFirst(property, value, startIndex, endIndex) {
        return ArrayUtils.GetFirst(this.list, property, value, startIndex, endIndex);
      },
      getAll: function getAll(property, value, startIndex, endIndex) {
        return ArrayUtils.GetAll(this.list, property, value, startIndex, endIndex);
      },
      count: function count(property, value, startIndex, endIndex) {
        return ArrayUtils.CountAllMatching(this.list, property, value, startIndex, endIndex);
      },
      swap: function swap(child1, child2) {
        return ArrayUtils.Swap(this.list, child1, child2), this;
      },
      moveTo: function moveTo(child, index) {
        return ArrayUtils.MoveTo(this.list, child, index), this;
      },
      moveAbove: function moveAbove(child1, child2) {
        return ArrayUtils.MoveAbove(this.list, child1, child2), this;
      },
      moveBelow: function moveBelow(child1, child2) {
        return ArrayUtils.MoveBelow(this.list, child1, child2), this;
      },
      remove: function remove(child, destroyChild) {
        var removed = ArrayUtils.Remove(this.list, child, this.removeHandler, this);

        if (destroyChild && removed) {
          Array.isArray(removed) || (removed = [removed]);

          for (var i = 0; i < removed.length; i++) {
            removed[i].destroy();
          }
        }

        return this;
      },
      removeAt: function removeAt(removed, destroyChild) {
        removed = ArrayUtils.RemoveAt(this.list, removed, this.removeHandler, this);
        return destroyChild && removed && removed.destroy(), this;
      },
      removeBetween: function removeBetween(startIndex, endIndex, destroyChild) {
        var removed = ArrayUtils.RemoveBetween(this.list, startIndex, endIndex, this.removeHandler, this);
        if (destroyChild) for (var i = 0; i < removed.length; i++) {
          removed[i].destroy();
        }
        return this;
      },
      removeAll: function removeAll(destroyChild) {
        var removed = ArrayUtils.RemoveBetween(this.list, 0, this.list.length, this.removeHandler, this);
        if (destroyChild) for (var i = 0; i < removed.length; i++) {
          removed[i].destroy();
        }
        return this;
      },
      bringToTop: function bringToTop(child) {
        return ArrayUtils.BringToTop(this.list, child), this;
      },
      sendToBack: function sendToBack(child) {
        return ArrayUtils.SendToBack(this.list, child), this;
      },
      moveUp: function moveUp(child) {
        return ArrayUtils.MoveUp(this.list, child), this;
      },
      moveDown: function moveDown(child) {
        return ArrayUtils.MoveDown(this.list, child), this;
      },
      reverse: function reverse() {
        return this.list.reverse(), this;
      },
      shuffle: function shuffle() {
        return ArrayUtils.Shuffle(this.list), this;
      },
      replace: function replace(oldChild, newChild, destroyChild) {
        return ArrayUtils.Replace(this.list, oldChild, newChild) && (this.addHandler(newChild), this.removeHandler(oldChild), destroyChild && oldChild.destroy()), this;
      },
      exists: function exists(child) {
        return -1 < this.list.indexOf(child);
      },
      setAll: function setAll(property, value, startIndex, endIndex) {
        return ArrayUtils.SetAll(this.list, property, value, startIndex, endIndex), this;
      },
      each: function each(callback, context) {
        for (var args = [null], temp = this.list.slice(), len = temp.length, i = 2; i < arguments.length; i++) {
          args.push(arguments[i]);
        }

        for (i = 0; i < len; i++) {
          args[0] = temp[i], callback.apply(context, args);
        }

        return this;
      },
      iterate: function iterate(callback, context) {
        for (var args = [null], i = 2; i < arguments.length; i++) {
          args.push(arguments[i]);
        }

        for (i = 0; i < this.list.length; i++) {
          args[0] = this.list[i], callback.apply(context, args);
        }

        return this;
      },
      setScrollFactor: function setScrollFactor(x, y, updateChildren) {
        return void 0 === y && (y = x), void 0 === updateChildren && (updateChildren = !1), this.scrollFactorX = x, this.scrollFactorY = y, updateChildren && (ArrayUtils.SetAll(this.list, "scrollFactorX", x), ArrayUtils.SetAll(this.list, "scrollFactorY", y)), this;
      },
      length: {
        get: function get() {
          return this.list.length;
        }
      },
      first: {
        get: function get() {
          return (this.position = 0) < this.list.length ? this.list[0] : null;
        }
      },
      last: {
        get: function get() {
          return 0 < this.list.length ? (this.position = this.list.length - 1, this.list[this.position]) : null;
        }
      },
      next: {
        get: function get() {
          return this.position < this.list.length ? (this.position++, this.list[this.position]) : null;
        }
      },
      previous: {
        get: function get() {
          return 0 < this.position ? (this.position--, this.list[this.position]) : null;
        }
      },
      preDestroy: function preDestroy() {
        this.removeAll(!!this.exclusive), this.localTransform.destroy(), this.tempTransformMatrix.destroy(), this.list = [];
      }
    });

    module.exports = Container;
  }, function (module, exports, DynamicBitmapText) {
    var BitmapText = DynamicBitmapText(148),
        Class = DynamicBitmapText(0),
        DynamicBitmapText = DynamicBitmapText(1057),
        DynamicBitmapText = new Class({
      Extends: BitmapText,
      Mixins: [DynamicBitmapText],
      initialize: function initialize(scene, x, y, font, text, size, align) {
        BitmapText.call(this, scene, x, y, font, text, size, align), this.type = "DynamicBitmapText", this.scrollX = 0, this.scrollY = 0, this.cropWidth = 0, this.cropHeight = 0, this.displayCallback, this.callbackData = {
          parent: this,
          color: 0,
          tint: {
            topLeft: 0,
            topRight: 0,
            bottomLeft: 0,
            bottomRight: 0
          },
          index: 0,
          charCode: 0,
          x: 0,
          y: 0,
          scale: 0,
          rotation: 0,
          data: 0
        };
      },
      setSize: function setSize(width, height) {
        return this.cropWidth = width, this.cropHeight = height, this;
      },
      setDisplayCallback: function setDisplayCallback(callback) {
        return this.displayCallback = callback, this;
      },
      setScrollX: function setScrollX(value) {
        return this.scrollX = value, this;
      },
      setScrollY: function setScrollY(value) {
        return this.scrollY = value, this;
      }
    });
    module.exports = DynamicBitmapText;
  }, function (module, exports, Render) {
    var BaseCamera = Render(133),
        Class = Render(0),
        Commands = Render(217),
        ComponentsAlpha = Render(303),
        ComponentsBlendMode = Render(304),
        ComponentsDepth = Render(305),
        ComponentsMask = Render(309),
        ComponentsPipeline = Render(167),
        ComponentsScrollFactor = Render(312),
        ComponentsTransform = Render(313),
        ComponentsVisible = Render(314),
        Ellipse = Render(111),
        GameObject = Render(15),
        GetFastValue = Render(2),
        GetValue = Render(6),
        MATH_CONST = Render(14),
        Render = Render(1063),
        Graphics = new Class({
      Extends: GameObject,
      Mixins: [ComponentsAlpha, ComponentsBlendMode, ComponentsDepth, ComponentsMask, ComponentsPipeline, ComponentsTransform, ComponentsVisible, ComponentsScrollFactor, Render],
      initialize: function initialize(scene, options) {
        var x = GetValue(options, "x", 0),
            y = GetValue(options, "y", 0);
        GameObject.call(this, scene, "Graphics"), this.setPosition(x, y), this.initPipeline(), this.displayOriginX = 0, this.displayOriginY = 0, this.commandBuffer = [], this.defaultFillColor = -1, this.defaultFillAlpha = 1, this.defaultStrokeWidth = 1, this.defaultStrokeColor = -1, this.defaultStrokeAlpha = 1, this._lineWidth = 1, this.setDefaultStyles(options);
      },
      setDefaultStyles: function setDefaultStyles(options) {
        return GetValue(options, "lineStyle", null) && (this.defaultStrokeWidth = GetValue(options, "lineStyle.width", 1), this.defaultStrokeColor = GetValue(options, "lineStyle.color", 16777215), this.defaultStrokeAlpha = GetValue(options, "lineStyle.alpha", 1), this.lineStyle(this.defaultStrokeWidth, this.defaultStrokeColor, this.defaultStrokeAlpha)), GetValue(options, "fillStyle", null) && (this.defaultFillColor = GetValue(options, "fillStyle.color", 16777215), this.defaultFillAlpha = GetValue(options, "fillStyle.alpha", 1), this.fillStyle(this.defaultFillColor, this.defaultFillAlpha)), this;
      },
      lineStyle: function lineStyle(lineWidth, color, alpha) {
        return this.commandBuffer.push(Commands.LINE_STYLE, lineWidth, color, alpha = void 0 === alpha ? 1 : alpha), this._lineWidth = lineWidth, this;
      },
      fillStyle: function fillStyle(color, alpha) {
        return this.commandBuffer.push(Commands.FILL_STYLE, color, alpha = void 0 === alpha ? 1 : alpha), this;
      },
      fillGradientStyle: function fillGradientStyle(topLeft, topRight, bottomLeft, bottomRight, alphaTopLeft, alphaTopRight, alphaBottomLeft, alphaBottomRight) {
        return void 0 === alphaTopLeft && (alphaTopLeft = 1), void 0 === alphaTopRight && (alphaTopRight = alphaTopLeft), void 0 === alphaBottomLeft && (alphaBottomLeft = alphaTopLeft), void 0 === alphaBottomRight && (alphaBottomRight = alphaTopLeft), this.commandBuffer.push(Commands.GRADIENT_FILL_STYLE, alphaTopLeft, alphaTopRight, alphaBottomLeft, alphaBottomRight, topLeft, topRight, bottomLeft, bottomRight), this;
      },
      lineGradientStyle: function lineGradientStyle(lineWidth, topLeft, topRight, bottomLeft, bottomRight, alpha) {
        return this.commandBuffer.push(Commands.GRADIENT_LINE_STYLE, lineWidth, alpha = void 0 === alpha ? 1 : alpha, topLeft, topRight, bottomLeft, bottomRight), this;
      },
      beginPath: function beginPath() {
        return this.commandBuffer.push(Commands.BEGIN_PATH), this;
      },
      closePath: function closePath() {
        return this.commandBuffer.push(Commands.CLOSE_PATH), this;
      },
      fillPath: function fillPath() {
        return this.commandBuffer.push(Commands.FILL_PATH), this;
      },
      fill: function fill() {
        return this.commandBuffer.push(Commands.FILL_PATH), this;
      },
      strokePath: function strokePath() {
        return this.commandBuffer.push(Commands.STROKE_PATH), this;
      },
      stroke: function stroke() {
        return this.commandBuffer.push(Commands.STROKE_PATH), this;
      },
      fillCircleShape: function fillCircleShape(circle) {
        return this.fillCircle(circle.x, circle.y, circle.radius);
      },
      strokeCircleShape: function strokeCircleShape(circle) {
        return this.strokeCircle(circle.x, circle.y, circle.radius);
      },
      fillCircle: function fillCircle(x, y, radius) {
        return this.beginPath(), this.arc(x, y, radius, 0, MATH_CONST.PI2), this.fillPath(), this;
      },
      strokeCircle: function strokeCircle(x, y, radius) {
        return this.beginPath(), this.arc(x, y, radius, 0, MATH_CONST.PI2), this.strokePath(), this;
      },
      fillRectShape: function fillRectShape(rect) {
        return this.fillRect(rect.x, rect.y, rect.width, rect.height);
      },
      strokeRectShape: function strokeRectShape(rect) {
        return this.strokeRect(rect.x, rect.y, rect.width, rect.height);
      },
      fillRect: function fillRect(x, y, width, height) {
        return this.commandBuffer.push(Commands.FILL_RECT, x, y, width, height), this;
      },
      strokeRect: function strokeRect(x, y, width, height) {
        var maxx = this._lineWidth / 2,
            minx = x - maxx,
            maxx = x + maxx;
        return this.beginPath(), this.moveTo(x, y), this.lineTo(x, y + height), this.strokePath(), this.beginPath(), this.moveTo(x + width, y), this.lineTo(x + width, y + height), this.strokePath(), this.beginPath(), this.moveTo(minx, y), this.lineTo(maxx + width, y), this.strokePath(), this.beginPath(), this.moveTo(minx, y + height), this.lineTo(maxx + width, y + height), this.strokePath(), this;
      },
      fillRoundedRect: function fillRoundedRect(x, y, width, height, radius) {
        var tl = radius = void 0 === radius ? 20 : radius,
            tr = radius,
            bl = radius,
            br = radius;
        return "number" != typeof radius && (tl = GetFastValue(radius, "tl", 20), tr = GetFastValue(radius, "tr", 20), bl = GetFastValue(radius, "bl", 20), br = GetFastValue(radius, "br", 20)), this.beginPath(), this.moveTo(x + tl, y), this.lineTo(x + width - tr, y), this.arc(x + width - tr, y + tr, tr, -MATH_CONST.TAU, 0), this.lineTo(x + width, y + height - br), this.arc(x + width - br, y + height - br, br, 0, MATH_CONST.TAU), this.lineTo(x + bl, y + height), this.arc(x + bl, y + height - bl, bl, MATH_CONST.TAU, Math.PI), this.lineTo(x, y + tl), this.arc(x + tl, y + tl, tl, -Math.PI, -MATH_CONST.TAU), this.fillPath(), this;
      },
      strokeRoundedRect: function strokeRoundedRect(x, y, width, height, radius) {
        var tl = radius = void 0 === radius ? 20 : radius,
            tr = radius,
            bl = radius,
            br = radius;
        return "number" != typeof radius && (tl = GetFastValue(radius, "tl", 20), tr = GetFastValue(radius, "tr", 20), bl = GetFastValue(radius, "bl", 20), br = GetFastValue(radius, "br", 20)), this.beginPath(), this.moveTo(x + tl, y), this.lineTo(x + width - tr, y), this.moveTo(x + width - tr, y), this.arc(x + width - tr, y + tr, tr, -MATH_CONST.TAU, 0), this.lineTo(x + width, y + height - br), this.moveTo(x + width, y + height - br), this.arc(x + width - br, y + height - br, br, 0, MATH_CONST.TAU), this.lineTo(x + bl, y + height), this.moveTo(x + bl, y + height), this.arc(x + bl, y + height - bl, bl, MATH_CONST.TAU, Math.PI), this.lineTo(x, y + tl), this.moveTo(x, y + tl), this.arc(x + tl, y + tl, tl, -Math.PI, -MATH_CONST.TAU), this.strokePath(), this;
      },
      fillPointShape: function fillPointShape(point, size) {
        return this.fillPoint(point.x, point.y, size);
      },
      fillPoint: function fillPoint(x, y, size) {
        return !size || size < 1 ? size = 1 : (x -= size / 2, y -= size / 2), this.commandBuffer.push(Commands.FILL_RECT, x, y, size, size), this;
      },
      fillTriangleShape: function fillTriangleShape(triangle) {
        return this.fillTriangle(triangle.x1, triangle.y1, triangle.x2, triangle.y2, triangle.x3, triangle.y3);
      },
      strokeTriangleShape: function strokeTriangleShape(triangle) {
        return this.strokeTriangle(triangle.x1, triangle.y1, triangle.x2, triangle.y2, triangle.x3, triangle.y3);
      },
      fillTriangle: function fillTriangle(x0, y0, x1, y1, x2, y2) {
        return this.commandBuffer.push(Commands.FILL_TRIANGLE, x0, y0, x1, y1, x2, y2), this;
      },
      strokeTriangle: function strokeTriangle(x0, y0, x1, y1, x2, y2) {
        return this.commandBuffer.push(Commands.STROKE_TRIANGLE, x0, y0, x1, y1, x2, y2), this;
      },
      strokeLineShape: function strokeLineShape(line) {
        return this.lineBetween(line.x1, line.y1, line.x2, line.y2);
      },
      lineBetween: function lineBetween(x1, y1, x2, y2) {
        return this.beginPath(), this.moveTo(x1, y1), this.lineTo(x2, y2), this.strokePath(), this;
      },
      lineTo: function lineTo(x, y) {
        return this.commandBuffer.push(Commands.LINE_TO, x, y), this;
      },
      moveTo: function moveTo(x, y) {
        return this.commandBuffer.push(Commands.MOVE_TO, x, y), this;
      },
      strokePoints: function strokePoints(points, closeShape, closePath, endIndex) {
        void 0 === closeShape && (closeShape = !1), void 0 === closePath && (closePath = !1), void 0 === endIndex && (endIndex = points.length), this.beginPath(), this.moveTo(points[0].x, points[0].y);

        for (var i = 1; i < endIndex; i++) {
          this.lineTo(points[i].x, points[i].y);
        }

        return closeShape && this.lineTo(points[0].x, points[0].y), closePath && this.closePath(), this.strokePath(), this;
      },
      fillPoints: function fillPoints(points, closeShape, closePath, endIndex) {
        void 0 === closeShape && (closeShape = !1), void 0 === closePath && (closePath = !1), void 0 === endIndex && (endIndex = points.length), this.beginPath(), this.moveTo(points[0].x, points[0].y);

        for (var i = 1; i < endIndex; i++) {
          this.lineTo(points[i].x, points[i].y);
        }

        return closeShape && this.lineTo(points[0].x, points[0].y), closePath && this.closePath(), this.fillPath(), this;
      },
      strokeEllipseShape: function strokeEllipseShape(ellipse, points) {
        points = ellipse.getPoints(points = void 0 === points ? 32 : points);
        return this.strokePoints(points, !0);
      },
      strokeEllipse: function strokeEllipse(x, y, width, height, points) {
        void 0 === points && (points = 32);
        points = new Ellipse(x, y, width, height).getPoints(points);
        return this.strokePoints(points, !0);
      },
      fillEllipseShape: function fillEllipseShape(ellipse, points) {
        points = ellipse.getPoints(points = void 0 === points ? 32 : points);
        return this.fillPoints(points, !0);
      },
      fillEllipse: function fillEllipse(x, y, width, height, points) {
        void 0 === points && (points = 32);
        points = new Ellipse(x, y, width, height).getPoints(points);
        return this.fillPoints(points, !0);
      },
      arc: function arc(x, y, radius, startAngle, endAngle, anticlockwise, overshoot) {
        return this.commandBuffer.push(Commands.ARC, x, y, radius, startAngle, endAngle, anticlockwise = void 0 === anticlockwise ? !1 : anticlockwise, overshoot = void 0 === overshoot ? 0 : overshoot), this;
      },
      slice: function slice(x, y, radius, startAngle, endAngle, anticlockwise, overshoot) {
        return void 0 === anticlockwise && (anticlockwise = !1), void 0 === overshoot && (overshoot = 0), this.commandBuffer.push(Commands.BEGIN_PATH), this.commandBuffer.push(Commands.MOVE_TO, x, y), this.commandBuffer.push(Commands.ARC, x, y, radius, startAngle, endAngle, anticlockwise, overshoot), this.commandBuffer.push(Commands.CLOSE_PATH), this;
      },
      save: function save() {
        return this.commandBuffer.push(Commands.SAVE), this;
      },
      restore: function restore() {
        return this.commandBuffer.push(Commands.RESTORE), this;
      },
      translateCanvas: function translateCanvas(x, y) {
        return this.commandBuffer.push(Commands.TRANSLATE, x, y), this;
      },
      scaleCanvas: function scaleCanvas(x, y) {
        return this.commandBuffer.push(Commands.SCALE, x, y), this;
      },
      rotateCanvas: function rotateCanvas(radians) {
        return this.commandBuffer.push(Commands.ROTATE, radians), this;
      },
      clear: function clear() {
        return this.commandBuffer.length = 0, -1 < this.defaultFillColor && this.fillStyle(this.defaultFillColor, this.defaultFillAlpha), -1 < this.defaultStrokeColor && this.lineStyle(this.defaultStrokeWidth, this.defaultStrokeColor, this.defaultStrokeAlpha), this;
      },
      generateTexture: function generateTexture(key, width, height) {
        var ctx,
            texture,
            src,
            sys = this.scene.sys,
            renderer = sys.game.renderer;
        return void 0 === width && (width = sys.scale.width), void 0 === height && (height = sys.scale.height), Graphics.TargetCamera.setScene(this.scene), Graphics.TargetCamera.setViewport(0, 0, width, height), Graphics.TargetCamera.scrollX = this.x, Graphics.TargetCamera.scrollY = this.y, "string" == typeof key ? sys.textures.exists(key) ? (src = (texture = sys.textures.get(key)).getSourceImage()) instanceof HTMLCanvasElement && (ctx = src.getContext("2d")) : ctx = (texture = sys.textures.createCanvas(key, width, height)).getSourceImage().getContext("2d") : key instanceof HTMLCanvasElement && (ctx = key.getContext("2d")), ctx && (this.renderCanvas(renderer, this, Graphics.TargetCamera, null, ctx, !1), texture && texture.refresh()), this;
      },
      preDestroy: function preDestroy() {
        this.commandBuffer = [];
      }
    });
    Graphics.TargetCamera = new BaseCamera(), module.exports = Graphics;
  }, function (module, exports) {
    module.exports = {
      ARC: 0,
      BEGIN_PATH: 1,
      CLOSE_PATH: 2,
      FILL_RECT: 3,
      LINE_TO: 4,
      MOVE_TO: 5,
      LINE_STYLE: 6,
      FILL_STYLE: 7,
      FILL_PATH: 8,
      STROKE_PATH: 9,
      FILL_TRIANGLE: 10,
      STROKE_TRIANGLE: 11,
      SAVE: 14,
      RESTORE: 15,
      TRANSLATE: 16,
      SCALE: 17,
      ROTATE: 18,
      GRADIENT_FILL_STYLE: 21,
      GRADIENT_LINE_STYLE: 22
    };
  }, function (module, exports, __webpack_require__) {
    var Point = __webpack_require__(4);

    module.exports = function (ellipse, angle, out) {
      void 0 === out && (out = new Point());
      var halfWidth = ellipse.width / 2,
          halfHeight = ellipse.height / 2;
      return out.x = ellipse.x + halfWidth * Math.cos(angle), out.y = ellipse.y + halfHeight * Math.sin(angle), out;
    };
  }, function (module, exports, __webpack_require__) {
    var BlendModes = __webpack_require__(35),
        Class = __webpack_require__(0),
        Components = __webpack_require__(11),
        ComponentsToJSON = __webpack_require__(176),
        DataManager = __webpack_require__(101),
        EventEmitter = __webpack_require__(9),
        GameObjectEvents = __webpack_require__(75),
        List = __webpack_require__(110),
        Layer = __webpack_require__(1071),
        SceneEvents = __webpack_require__(20),
        StableSort = __webpack_require__(79),
        Layer = new Class({
      Extends: List,
      Mixins: [Components.AlphaSingle, Components.BlendMode, Components.Depth, Components.Mask, Components.Pipeline, Components.Visible, EventEmitter, Layer],
      initialize: function initialize(scene, children) {
        List.call(this, scene), EventEmitter.call(this), this.scene = scene, this.displayList = null, this.type = "Layer", this.state = 0, this.parentContainer = null, this.name = "", this.active = !0, this.tabIndex = -1, this.data = null, this.renderFlags = 15, this.cameraFilter = 0, this.input = null, this.body = null, this.ignoreDestroy = !1, this.systems = scene.sys, this.events = scene.sys.events, this.sortChildrenFlag = !1, this.addCallback = this.addChildCallback, this.removeCallback = this.removeChildCallback, this.initPipeline(), this.clearAlpha(), this.setBlendMode(BlendModes.SKIP_CHECK), children && this.add(children), scene.sys.queueDepthSort();
      },
      setActive: function setActive(value) {
        return this.active = value, this;
      },
      setName: function setName(value) {
        return this.name = value, this;
      },
      setState: function setState(value) {
        return this.state = value, this;
      },
      setDataEnabled: function setDataEnabled() {
        return this.data || (this.data = new DataManager(this)), this;
      },
      setData: function setData(key, value) {
        return this.data || (this.data = new DataManager(this)), this.data.set(key, value), this;
      },
      incData: function incData(key, value) {
        return this.data || (this.data = new DataManager(this)), this.data.inc(key, value), this;
      },
      toggleData: function toggleData(key) {
        return this.data || (this.data = new DataManager(this)), this.data.toggle(key), this;
      },
      getData: function getData(key) {
        return this.data || (this.data = new DataManager(this)), this.data.get(key);
      },
      setInteractive: function setInteractive() {
        return this;
      },
      disableInteractive: function disableInteractive() {
        return this;
      },
      removeInteractive: function removeInteractive() {
        return this;
      },
      addedToScene: function addedToScene() {},
      removedFromScene: function removedFromScene() {},
      update: function update() {},
      toJSON: function toJSON() {
        return ComponentsToJSON(this);
      },
      willRender: function willRender(camera) {
        return !(15 !== this.renderFlags || 0 === this.list.length || 0 !== this.cameraFilter && this.cameraFilter & camera.id);
      },
      getIndexList: function getIndexList() {
        for (var child = this, parent = this.parentContainer, indexes = []; parent && (indexes.unshift(parent.getIndex(child)), (child = parent).parentContainer);) {
          parent = parent.parentContainer;
        }

        return indexes.unshift(this.displayList.getIndex(child)), indexes;
      },
      addChildCallback: function addChildCallback(gameObject) {
        gameObject.displayList && gameObject.displayList !== this && gameObject.removeFromDisplayList(), gameObject.displayList || (this.queueDepthSort(), gameObject.displayList = this, gameObject.emit(GameObjectEvents.ADDED_TO_SCENE, gameObject, this.scene), this.events.emit(SceneEvents.ADDED_TO_SCENE, gameObject, this.scene));
      },
      removeChildCallback: function removeChildCallback(gameObject) {
        this.queueDepthSort(), gameObject.displayList = null, gameObject.emit(GameObjectEvents.REMOVED_FROM_SCENE, gameObject, this.scene), this.events.emit(SceneEvents.REMOVED_FROM_SCENE, gameObject, this.scene);
      },
      queueDepthSort: function queueDepthSort() {
        this.sortChildrenFlag = !0;
      },
      depthSort: function depthSort() {
        this.sortChildrenFlag && (StableSort(this.list, this.sortByDepth), this.sortChildrenFlag = !1);
      },
      sortByDepth: function sortByDepth(childA, childB) {
        return childA._depth - childB._depth;
      },
      getChildren: function getChildren() {
        return this.list;
      },
      destroy: function destroy() {
        if (this.scene && !this.ignoreDestroy) {
          this.emit(GameObjectEvents.DESTROY, this);

          for (var i = this.list.length; i--;) {
            this.list[i].destroy();
          }

          this.removeAllListeners(), this.resetPostPipeline(!0), this.displayList && (this.displayList.remove(this, !0), this.displayList.queueDepthSort()), this.data && (this.data.destroy(), this.data = void 0), this.active = !1, this.visible = !1, this.list = void 0, this.scene = void 0, this.displayList = void 0, this.systems = void 0, this.events = void 0;
        }
      }
    });

    module.exports = Layer;
  }, function (module, exports, ParticleEmitterManager) {
    var Class = ParticleEmitterManager(0),
        Components = ParticleEmitterManager(11),
        GameObject = ParticleEmitterManager(15),
        GravityWell = ParticleEmitterManager(450),
        List = ParticleEmitterManager(110),
        ParticleEmitter = ParticleEmitterManager(452),
        ParticleEmitterManager = ParticleEmitterManager(1075),
        ParticleEmitterManager = new Class({
      Extends: GameObject,
      Mixins: [Components.Depth, Components.Mask, Components.Pipeline, Components.Transform, Components.Visible, ParticleEmitterManager],
      initialize: function initialize(scene, texture, frame, emitters) {
        if (GameObject.call(this, scene, "ParticleEmitterManager"), this.blendMode = -1, this.timeScale = 1, this.texture = null, this.frame = null, this.frameNames = [], null === frame || "object" != _typeof(frame) && !Array.isArray(frame) || (emitters = frame, frame = null), this.setTexture(texture, frame), this.initPipeline(), this.emitters = new List(this), this.wells = new List(this), emitters) {
          Array.isArray(emitters) || (emitters = [emitters]);

          for (var i = 0; i < emitters.length; i++) {
            this.createEmitter(emitters[i]);
          }
        }
      },
      addedToScene: function addedToScene() {
        this.scene.sys.updateList.add(this);
      },
      removedFromScene: function removedFromScene() {
        this.scene.sys.updateList.remove(this);
      },
      setTexture: function setTexture(key, frame) {
        return this.texture = this.scene.sys.textures.get(key), this.setFrame(frame);
      },
      setFrame: function setFrame(frames) {
        this.frame = this.texture.get(frames);
        var frames = this.texture.getFramesFromTextureSource(this.frame.sourceIndex),
            names = [];
        return frames.forEach(function (sourceFrame) {
          names.push(sourceFrame.name);
        }), this.frameNames = names, this.defaultFrame = this.frame, this;
      },
      setEmitterFrames: function setEmitterFrames(frames, emitter) {
        Array.isArray(frames) || (frames = [frames]);

        for (var out = emitter.frames, i = out.length = 0; i < frames.length; i++) {
          var frame = frames[i];
          -1 !== this.frameNames.indexOf(frame) && out.push(this.texture.get(frame));
        }

        return 0 < out.length ? emitter.defaultFrame = out[0] : emitter.defaultFrame = this.defaultFrame, this;
      },
      addEmitter: function addEmitter(emitter) {
        return this.emitters.add(emitter);
      },
      createEmitter: function createEmitter(config) {
        return this.addEmitter(new ParticleEmitter(this, config));
      },
      removeEmitter: function removeEmitter(emitter) {
        return this.emitters.remove(emitter, !0);
      },
      addGravityWell: function addGravityWell(well) {
        return this.wells.add(well);
      },
      createGravityWell: function createGravityWell(config) {
        return this.addGravityWell(new GravityWell(config));
      },
      emitParticle: function emitParticle(count, x, y) {
        for (var emitters = this.emitters.list, i = 0; i < emitters.length; i++) {
          var emitter = emitters[i];
          emitter.active && emitter.emitParticle(count, x, y);
        }

        return this;
      },
      emitParticleAt: function emitParticleAt(x, y, count) {
        return this.emitParticle(count, x, y);
      },
      pause: function pause() {
        return this.active = !1, this;
      },
      resume: function resume() {
        return this.active = !0, this;
      },
      getProcessors: function getProcessors() {
        return this.wells.getAll("active", !0);
      },
      preUpdate: function preUpdate(time, delta) {
        delta *= this.timeScale;

        for (var emitters = this.emitters.list, i = 0; i < emitters.length; i++) {
          var emitter = emitters[i];
          emitter.active && emitter.preUpdate(time, delta);
        }
      },
      setAlpha: function setAlpha() {},
      setScrollFactor: function setScrollFactor() {},
      setBlendMode: function setBlendMode() {}
    });
    module.exports = ParticleEmitterManager;
  }, function (module, exports, __webpack_require__) {
    var BlendModes = __webpack_require__(35),
        Camera = __webpack_require__(133),
        CanvasPool = __webpack_require__(31),
        Class = __webpack_require__(0),
        Components = __webpack_require__(11),
        CONST = __webpack_require__(33),
        Frame = __webpack_require__(109),
        GameObject = __webpack_require__(15),
        NOOP = __webpack_require__(1),
        PIPELINE_CONST = __webpack_require__(92),
        RenderTexture = __webpack_require__(1079),
        RenderTarget = __webpack_require__(141),
        Utils = __webpack_require__(12),
        UUID = __webpack_require__(222),
        RenderTexture = new Class({
      Extends: GameObject,
      Mixins: [Components.Alpha, Components.BlendMode, Components.ComputedSize, Components.Crop, Components.Depth, Components.Flip, Components.GetBounds, Components.Mask, Components.Origin, Components.Pipeline, Components.ScrollFactor, Components.Tint, Components.Transform, Components.Visible, RenderTexture],
      initialize: function initialize(scene, x, y, width, height, key, renderer) {
        void 0 === x && (x = 0), void 0 === y && (y = 0), void 0 === width && (width = 32), void 0 === height && (height = 32), GameObject.call(this, scene, "RenderTexture"), this.renderer = scene.sys.renderer, this.textureManager = scene.sys.textures, this.globalTint = 16777215, this.globalAlpha = 1, this.canvas = null, this.dirty = !1, this._crop = this.resetCropObject(), this.texture = null, this.frame = null, this._saved = !1, void 0 === key ? (this.canvas = CanvasPool.create2D(this, width, height), this.texture = scene.sys.textures.addCanvas(UUID(), this.canvas), this.frame = this.texture.get()) : (this.texture = scene.sys.textures.get(key), this.frame = this.texture.get(renderer), this.canvas = this.frame.source.image, this._saved = !0, this.dirty = !0, this.width = this.frame.cutWidth, this.height = this.frame.cutHeight), this.context = this.canvas.getContext("2d"), this._eraseMode = !1, this.camera = new Camera(0, 0, width, height), this.renderTarget = null;
        renderer = this.renderer;
        renderer ? renderer.type === CONST.WEBGL ? (this.drawGameObject = this.batchGameObjectWebGL, this.renderTarget = new RenderTarget(renderer, width, height, 1, 0, !1)) : renderer.type === CONST.CANVAS && (this.drawGameObject = this.batchGameObjectCanvas) : this.drawGameObject = NOOP, this.camera.setScene(scene), this.setPosition(x, y), void 0 === key && this.setSize(width, height), this.setOrigin(0, 0), this.initPipeline(PIPELINE_CONST.SINGLE_PIPELINE);
      },
      setSize: function setSize(width, height) {
        return this.resize(width, height);
      },
      resize: function resize(width, height) {
        void 0 === height && (height = width);
        var baseFrame,
            input = this.frame;
        width !== this.width || height !== this.height ? "__BASE" === input.name && (this.canvas.width = width, this.canvas.height = height, this.texture.width = width, this.texture.height = height, (baseFrame = this.renderTarget) && (baseFrame.resize(width, height), input.glTexture = baseFrame.texture, input.source.isRenderTexture = !0, input.source.isGLTexture = !0, input.source.glTexture = baseFrame.texture), this.camera.setSize(width, height), input.source.width = width, input.source.height = height, input.setSize(width, height), this.width = width, this.height = height) : (baseFrame = this.texture.getSourceImage(), input.cutX + width > baseFrame.width && (width = baseFrame.width - input.cutX), input.cutY + height > baseFrame.height && (height = baseFrame.height - input.cutY), input.setSize(width, height, input.cutX, input.cutY)), this.updateDisplayOrigin();
        input = this.input;
        return input && !input.customHitArea && (input.hitArea.width = width, input.hitArea.height = height), this;
      },
      setGlobalTint: function setGlobalTint(tint) {
        return this.globalTint = tint, this;
      },
      setGlobalAlpha: function setGlobalAlpha(alpha) {
        return this.globalAlpha = alpha, this;
      },
      saveTexture: function saveTexture(key) {
        return this.textureManager.renameTexture(this.texture.key, key), this._saved = !0, this.texture;
      },
      fill: function fill(sx, alpha, x, y, width, height) {
        var frame = this.frame,
            sy = this.camera,
            renderer = this.renderer;
        void 0 === alpha && (alpha = 1), void 0 === x && (x = 0), void 0 === y && (y = 0), void 0 === width && (width = frame.cutWidth), void 0 === height && (height = frame.cutHeight);
        var pipeline,
            r = (sx >> 16 & 255) / 255,
            g = (sx >> 8 & 255) / 255,
            b = (255 & sx) / 255,
            ctx = this.renderTarget;
        return sy.preRender(), ctx ? (ctx.bind(!0), (pipeline = this.pipeline).manager.set(pipeline), sx = ctx.width, sy = ctx.height, sx = renderer.width / sx, sy = renderer.height / sy, pipeline.drawFillRect(x * sx, y * sy, width * sx, height * sy, Utils.getTintFromFloats(b, g, r, 1), alpha), ctx.unbind(!0)) : (ctx = this.context, renderer.setContext(ctx), ctx.fillStyle = "rgba(" + r + "," + g + "," + b + "," + alpha + ")", ctx.fillRect(x + frame.cutX, y + frame.cutY, width, height), renderer.setContext()), this.dirty = !0, this;
      },
      clear: function clear() {
        var ctx;
        return this.dirty && ((ctx = this.renderTarget) ? ctx.clear() : ((ctx = this.context).save(), ctx.setTransform(1, 0, 0, 1, 0, 0), ctx.clearRect(this.frame.cutX, this.frame.cutY, this.frame.cutWidth, this.frame.cutHeight), ctx.restore()), this.dirty = !1), this;
      },
      erase: function erase(entries, x, y) {
        return this._eraseMode = !0, this.draw(entries, x, y, 1, 16777215), this._eraseMode = !1, this;
      },
      draw: function draw(entries, x, y, alpha, tint) {
        return this.beginDraw(), this.batchDraw(entries, x, y, alpha, tint), this.endDraw(), this;
      },
      drawFrame: function drawFrame(key, frame, x, y, alpha, tint) {
        return this.beginDraw(), this.batchDrawFrame(key, frame, x, y, alpha, tint), this.endDraw(), this;
      },
      beginDraw: function beginDraw() {
        var camera = this.camera,
            renderer = this.renderer,
            renderTarget = this.renderTarget;
        return camera.preRender(), renderTarget ? renderer.beginCapture(renderTarget.width, renderTarget.height) : renderer.setContext(this.context), this;
      },
      batchDraw: function batchDraw(entries, x, y, alpha, tint) {
        return void 0 === alpha && (alpha = this.globalAlpha), tint = void 0 === tint ? (this.globalTint >> 16) + (65280 & this.globalTint) + ((255 & this.globalTint) << 16) : (tint >> 16) + (65280 & tint) + ((255 & tint) << 16), Array.isArray(entries) || (entries = [entries]), this.batchList(entries, x, y, alpha, tint), this;
      },
      batchDrawFrame: function batchDrawFrame(key, textureFrame, x, y, alpha, tint) {
        void 0 === x && (x = 0), void 0 === y && (y = 0), void 0 === alpha && (alpha = this.globalAlpha), tint = void 0 === tint ? (this.globalTint >> 16) + (65280 & this.globalTint) + ((255 & this.globalTint) << 16) : (tint >> 16) + (65280 & tint) + ((255 & tint) << 16);
        textureFrame = this.textureManager.getFrame(key, textureFrame);
        return textureFrame && (this.renderTarget ? this.pipeline.batchTextureFrame(textureFrame, x, y, tint, alpha, this.camera.matrix, null) : this.batchTextureFrame(textureFrame, x + this.frame.cutX, y + this.frame.cutY, alpha, tint)), this;
      },
      endDraw: function endDraw(erase) {
        void 0 === erase && (erase = this._eraseMode);
        var canvasTarget,
            renderer = this.renderer,
            renderTarget = this.renderTarget;
        return renderTarget ? (canvasTarget = renderer.endCapture(), renderer.pipelines.setUtility().blitFrame(canvasTarget, renderTarget, 1, !1, !1, erase), renderer.resetScissor(), renderer.resetViewport()) : renderer.setContext(), this.dirty = !0, this;
      },
      batchList: function batchList(children, x, y, alpha, tint) {
        for (var i = 0; i < children.length; i++) {
          var entry = children[i];
          entry && entry !== this && (entry.renderWebGL || entry.renderCanvas ? this.drawGameObject(entry, x, y) : entry.isParent || entry.list ? this.batchGroup(entry.getChildren(), x, y) : "string" == typeof entry ? this.batchTextureFrameKey(entry, null, x, y, alpha, tint) : entry instanceof Frame ? this.batchTextureFrame(entry, x, y, alpha, tint) : Array.isArray(entry) && this.batchList(entry, x, y, alpha, tint));
        }
      },
      batchGroup: function batchGroup(children, x, y) {
        void 0 === x && (x = 0), void 0 === y && (y = 0), x += this.frame.cutX, y += this.frame.cutY;

        for (var i = 0; i < children.length; i++) {
          var tx,
              ty,
              entry = children[i];
          entry.willRender(this.camera) && (tx = entry.x + x, ty = entry.y + y, this.drawGameObject(entry, tx, ty));
        }
      },
      batchGameObjectWebGL: function batchGameObjectWebGL(gameObject, x, y) {
        void 0 === x && (x = gameObject.x), void 0 === y && (y = gameObject.y);
        var prevX = gameObject.x,
            prevY = gameObject.y;
        gameObject.setPosition(x + this.frame.cutX, y + this.frame.cutY), gameObject.renderDirect ? gameObject.renderDirect(this.renderer, gameObject, this.camera) : gameObject.renderWebGL(this.renderer, gameObject, this.camera), gameObject.setPosition(prevX, prevY);
      },
      batchGameObjectCanvas: function batchGameObjectCanvas(gameObject, x, y) {
        void 0 === x && (x = gameObject.x), void 0 === y && (y = gameObject.y);
        var blendMode,
            prevX = gameObject.x,
            prevY = gameObject.y;
        this._eraseMode && (blendMode = gameObject.blendMode, gameObject.blendMode = BlendModes.ERASE), gameObject.setPosition(x + this.frame.cutX, y + this.frame.cutY), gameObject.renderCanvas(this.renderer, gameObject, this.camera, null), gameObject.setPosition(prevX, prevY), this._eraseMode && (gameObject.blendMode = blendMode);
      },
      batchTextureFrameKey: function batchTextureFrameKey(key, textureFrame, x, y, alpha, tint) {
        textureFrame = this.textureManager.getFrame(key, textureFrame);
        textureFrame && this.batchTextureFrame(textureFrame, x, y, alpha, tint);
      },
      batchTextureFrame: function batchTextureFrame(matrix, x, y, alpha, source) {
        var ctx, cd;
        void 0 === x && (x = 0), void 0 === y && (y = 0), x += this.frame.cutX, y += this.frame.cutY, this.renderTarget ? this.pipeline.batchTextureFrame(matrix, x, y, source, alpha, this.camera.matrix, null) : (ctx = this.context, cd = matrix.canvasData, source = matrix.source.image, matrix = this.camera.matrix, ctx.save(), ctx.globalCompositeOperation = this._eraseMode ? "destination-out" : "source-over", ctx.globalAlpha = alpha, matrix.setToContext(ctx), ctx.drawImage(source, cd.x, cd.y, cd.width, cd.height, x, y, cd.width, cd.height), ctx.restore());
      },
      snapshotArea: function snapshotArea(x, y, width, height, callback, type, encoderOptions) {
        return this.renderTarget ? this.renderer.snapshotFramebuffer(this.renderTarget.framebuffer, this.width, this.height, callback, !1, x, y, width, height, type, encoderOptions) : this.renderer.snapshotCanvas(this.canvas, callback, !1, x, y, width, height, type, encoderOptions), this;
      },
      snapshot: function snapshot(callback, type, encoderOptions) {
        return this.renderTarget ? this.renderer.snapshotFramebuffer(this.renderTarget.framebuffer, this.width, this.height, callback, !1, 0, 0, this.width, this.height, type, encoderOptions) : this.renderer.snapshotCanvas(this.canvas, callback, !1, 0, 0, this.width, this.height, type, encoderOptions), this;
      },
      snapshotPixel: function snapshotPixel(x, y, callback) {
        return this.renderTarget ? this.renderer.snapshotFramebuffer(this.renderTarget.framebuffer, this.width, this.height, callback, !0, x, y) : this.renderer.snapshotCanvas(this.canvas, callback, !0, x, y), this;
      },
      preDestroy: function preDestroy() {
        this._saved || (CanvasPool.remove(this.canvas), this.renderTarget && this.renderTarget.destroy(), this.texture.destroy(), this.camera.destroy(), this.canvas = null, this.context = null, this.texture = null);
      }
    });

    module.exports = RenderTexture;
  }, function (module, exports) {
    module.exports = function () {
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
        var r = 16 * Math.random() | 0;
        return ("x" === c ? r : 3 & r | 8).toString(16);
      });
    };
  }, function (module, exports, __webpack_require__) {
    var AnimationState = __webpack_require__(164),
        Class = __webpack_require__(0),
        Components = __webpack_require__(11),
        GameObject = __webpack_require__(15),
        PIPELINE_CONST = __webpack_require__(92),
        Rope = __webpack_require__(1085),
        Vector2 = __webpack_require__(3),
        Rope = new Class({
      Extends: GameObject,
      Mixins: [Components.AlphaSingle, Components.BlendMode, Components.Depth, Components.Flip, Components.Mask, Components.Pipeline, Components.Size, Components.Texture, Components.Transform, Components.Visible, Components.ScrollFactor, Rope],
      initialize: function initialize(scene, x, y, texture, frame, points, horizontal, colors, alphas) {
        void 0 === texture && (texture = "__DEFAULT"), void 0 === points && (points = 2), void 0 === horizontal && (horizontal = !0), GameObject.call(this, scene, "Rope"), this.anims = new AnimationState(this), this.points = points, this.vertices, this.uv, this.colors, this.alphas, this.tintFill = "__DEFAULT" === texture, this.dirty = !1, this.horizontal = horizontal, this._flipX = !1, this._flipY = !1, this._perp = new Vector2(), this.debugCallback = null, this.debugGraphic = null, this.setTexture(texture, frame), this.setPosition(x, y), this.setSizeToFrame(), this.initPipeline(PIPELINE_CONST.ROPE_PIPELINE), Array.isArray(points) && this.resizeArrays(points.length), this.setPoints(points, colors, alphas), this.updateVertices();
      },
      addedToScene: function addedToScene() {
        this.scene.sys.updateList.add(this);
      },
      removedFromScene: function removedFromScene() {
        this.scene.sys.updateList.remove(this);
      },
      preUpdate: function preUpdate(time, delta) {
        var prevFrame = this.anims.currentFrame;
        this.anims.update(time, delta), this.anims.currentFrame !== prevFrame && (this.updateUVs(), this.updateVertices());
      },
      play: function play(key, ignoreIfPlaying, startFrame) {
        return this.anims.play(key, ignoreIfPlaying, startFrame), this;
      },
      setDirty: function setDirty() {
        return this.dirty = !0, this;
      },
      setHorizontal: function setHorizontal(points, colors, alphas) {
        return void 0 === points && (points = this.points.length), this.horizontal ? this : (this.horizontal = !0, this.setPoints(points, colors, alphas));
      },
      setVertical: function setVertical(points, colors, alphas) {
        return void 0 === points && (points = this.points.length), this.horizontal ? (this.horizontal = !1, this.setPoints(points, colors, alphas)) : this;
      },
      setTintFill: function setTintFill(value) {
        return this.tintFill = value = void 0 === value ? !1 : value, this;
      },
      setAlphas: function setAlphas(alphas, bottomAlpha) {
        var total = this.points.length;
        if (total < 1) return this;
        var currentAlphas = this.alphas;
        void 0 === alphas ? alphas = [1] : Array.isArray(alphas) || void 0 !== bottomAlpha || (alphas = [alphas]);
        var index = 0;
        if (void 0 !== bottomAlpha) for (i = 0; i < total; i++) {
          currentAlphas[index = 2 * i] = alphas, currentAlphas[index + 1] = bottomAlpha;
        } else if (alphas.length === total) for (i = 0; i < total; i++) {
          currentAlphas[index = 2 * i] = alphas[i], currentAlphas[index + 1] = alphas[i];
        } else for (var prevAlpha = alphas[0], i = 0; i < total; i++) {
          alphas.length > (index = 2 * i) && (prevAlpha = alphas[index]), currentAlphas[index] = prevAlpha, alphas.length > index + 1 && (prevAlpha = alphas[index + 1]), currentAlphas[index + 1] = prevAlpha;
        }
        return this;
      },
      setColors: function setColors(colors) {
        var total = this.points.length;
        if (total < 1) return this;
        var currentColors = this.colors;
        void 0 === colors ? colors = [16777215] : Array.isArray(colors) || (colors = [colors]);
        var index = 0;
        if (colors.length === total) for (i = 0; i < total; i++) {
          currentColors[index = 2 * i] = colors[i], currentColors[index + 1] = colors[i];
        } else for (var prevColor = colors[0], i = 0; i < total; i++) {
          colors.length > (index = 2 * i) && (prevColor = colors[index]), currentColors[index] = prevColor, colors.length > index + 1 && (prevColor = colors[index + 1]), currentColors[index + 1] = prevColor;
        }
        return this;
      },
      setPoints: function setPoints(points, colors, alphas) {
        if ("number" == typeof (points = void 0 === points ? 2 : points)) {
          var s,
              frameSegment,
              offset,
              segments = points;
          if (segments < 2 && (segments = 2), points = [], this.horizontal) for (offset = -this.frame.halfWidth, frameSegment = this.frame.width / (segments - 1), s = 0; s < segments; s++) {
            points.push({
              x: offset + s * frameSegment,
              y: 0
            });
          } else for (offset = -this.frame.halfHeight, frameSegment = this.frame.height / (segments - 1), s = 0; s < segments; s++) {
            points.push({
              x: 0,
              y: offset + s * frameSegment
            });
          }
        }

        var total = points.length,
            currentTotal = this.points.length;
        return total < 1 ? console.warn("Rope: Not enough points given") : (1 === total && (points.unshift({
          x: 0,
          y: 0
        }), total++), currentTotal !== total && this.resizeArrays(total), this.points = points, this.updateUVs(), null != colors && this.setColors(colors), null != alphas && this.setAlphas(alphas)), this;
      },
      updateUVs: function updateUVs() {
        for (var currentUVs = this.uv, total = this.points.length, u0 = this.frame.u0, v0 = this.frame.v0, u1 = this.frame.u1, v1 = this.frame.v1, partH = (u1 - u0) / (total - 1), partV = (v1 - v0) / (total - 1), i = 0; i < total; i++) {
          var uv0,
              uv1,
              uv2,
              index = 4 * i,
              uv3 = this.horizontal ? (uv2 = uv0 = this._flipX ? u1 - i * partH : u0 + i * partH, this._flipY ? (uv1 = v1, v0) : (uv1 = v0, v1)) : (uv2 = this._flipX ? (uv0 = u0, u1) : (uv0 = u1, u0), uv1 = this._flipY ? v1 - i * partV : v0 + i * partV);
          currentUVs[0 + index] = uv0, currentUVs[1 + index] = uv1, currentUVs[2 + index] = uv2, currentUVs[3 + index] = uv3;
        }

        return this;
      },
      resizeArrays: function resizeArrays(newSize) {
        var colors = this.colors,
            alphas = this.alphas;
        this.vertices = new Float32Array(4 * newSize), this.uv = new Float32Array(4 * newSize);

        for (var colors = new Uint32Array(2 * newSize), alphas = new Float32Array(2 * newSize), i = 0; i < 2 * newSize; i++) {
          colors[i] = 16777215, alphas[i] = 1;
        }

        return this.colors = colors, this.alphas = alphas, this.dirty = !0, this;
      },
      updateVertices: function updateVertices() {
        var perp = this._perp,
            points = this.points,
            vertices = this.vertices,
            total = points.length;

        if (this.dirty = !1, !(total < 1)) {
          for (var lastPoint = points[0], frameSize = this.horizontal ? this.frame.halfHeight : this.frame.halfWidth, i = 0; i < total; i++) {
            var point = points[i],
                index = 4 * i,
                perpLength = i < total - 1 ? points[i + 1] : point;
            perp.x = perpLength.y - lastPoint.y, perp.y = -(perpLength.x - lastPoint.x);
            perpLength = perp.length();
            perp.x /= perpLength, perp.y /= perpLength, perp.x *= frameSize, perp.y *= frameSize, vertices[index] = point.x + perp.x, vertices[1 + index] = point.y + perp.y, vertices[2 + index] = point.x - perp.x, vertices[3 + index] = point.y - perp.y, lastPoint = point;
          }

          return this;
        }
      },
      setDebug: function setDebug(graphic, callback) {
        return this.debugGraphic = graphic, this.debugCallback = graphic || callback ? callback || this.renderDebugVerts : null, this;
      },
      renderDebugVerts: function renderDebugVerts(src, meshLength, verts) {
        var graphic = src.debugGraphic,
            px0 = verts[0],
            py0 = verts[1],
            px1 = verts[2],
            py1 = verts[3];
        graphic.lineBetween(px0, py0, px1, py1);

        for (var i = 4; i < meshLength; i += 4) {
          var x0 = verts[i + 0],
              y0 = verts[i + 1],
              x1 = verts[i + 2],
              y1 = verts[i + 3];
          graphic.lineBetween(px0, py0, x0, y0), graphic.lineBetween(px1, py1, x1, y1), graphic.lineBetween(px1, py1, x0, y0), graphic.lineBetween(x0, y0, x1, y1), px0 = x0, py0 = y0, px1 = x1, py1 = y1;
        }
      },
      preDestroy: function preDestroy() {
        this.anims.destroy(), this.anims = void 0, this.points = null, this.vertices = null, this.uv = null, this.colors = null, this.alphas = null, this.debugCallback = null, this.debugGraphic = null;
      },
      flipX: {
        get: function get() {
          return this._flipX;
        },
        set: function set(value) {
          return this._flipX = value, this.updateUVs();
        }
      },
      flipY: {
        get: function get() {
          return this._flipY;
        },
        set: function set(value) {
          return this._flipY = value, this.updateUVs();
        }
      }
    });

    module.exports = Rope;
  }, function (module, exports, __webpack_require__) {
    var AddToDOM = __webpack_require__(142),
        CanvasPool = __webpack_require__(31),
        Class = __webpack_require__(0),
        Components = __webpack_require__(11),
        GameEvents = __webpack_require__(22),
        GameObject = __webpack_require__(15),
        GetTextSize = __webpack_require__(458),
        GetValue = __webpack_require__(6),
        RemoveFromDOM = __webpack_require__(202),
        Text = __webpack_require__(1088),
        TextStyle = __webpack_require__(459),
        Text = new Class({
      Extends: GameObject,
      Mixins: [Components.Alpha, Components.BlendMode, Components.ComputedSize, Components.Crop, Components.Depth, Components.Flip, Components.GetBounds, Components.Mask, Components.Origin, Components.Pipeline, Components.ScrollFactor, Components.Tint, Components.Transform, Components.Visible, Text],
      initialize: function initialize(scene, x, y, text, style) {
        void 0 === x && (x = 0), void 0 === y && (y = 0), GameObject.call(this, scene, "Text"), this.renderer = scene.sys.renderer, this.setPosition(x, y), this.setOrigin(0, 0), this.initPipeline(), this.canvas = CanvasPool.create(this), this.context = this.canvas.getContext("2d"), this.style = new TextStyle(this, style), this.autoRound = !0, this.splitRegExp = /(?:\r\n|\r|\n)/, this._text = void 0, this.padding = {
          left: 0,
          right: 0,
          top: 0,
          bottom: 0
        }, this.width = 1, this.height = 1, this.lineSpacing = 0, this.dirty = !1, 0 === this.style.resolution && (this.style.resolution = 1), this._crop = this.resetCropObject(), this.texture = scene.sys.textures.addCanvas(null, this.canvas, !0), this.frame = this.texture.get(), this.frame.source.resolution = this.style.resolution, this.renderer && this.renderer.gl && (this.renderer.deleteTexture(this.frame.source.glTexture), this.frame.source.glTexture = null), this.initRTL(), this.setText(text), style && style.padding && this.setPadding(style.padding), style && style.lineSpacing && this.setLineSpacing(style.lineSpacing), scene.sys.game.events.on(GameEvents.CONTEXT_RESTORED, function () {
          this.dirty = !0;
        }, this);
      },
      initRTL: function initRTL() {
        this.style.rtl && (this.canvas.dir = "rtl", this.context.direction = "rtl", this.canvas.style.display = "none", AddToDOM(this.canvas, this.scene.sys.canvas), this.originX = 1);
      },
      runWordWrap: function runWordWrap(text) {
        var style = this.style;

        if (style.wordWrapCallback) {
          var wrappedLines = style.wordWrapCallback.call(style.wordWrapCallbackScope, text, this);
          return wrappedLines = Array.isArray(wrappedLines) ? wrappedLines.join("\n") : wrappedLines;
        }

        return style.wordWrapWidth ? style.wordWrapUseAdvanced ? this.advancedWordWrap(text, this.context, this.style.wordWrapWidth) : this.basicWordWrap(text, this.context, this.style.wordWrapWidth) : text;
      },
      advancedWordWrap: function advancedWordWrap(text, context, wordWrapWidth) {
        for (var output = "", lines = text.replace(/ +/gi, " ").split(this.splitRegExp), linesCount = lines.length, i = 0; i < linesCount; i++) {
          var out = "",
              line = (line = lines[i]).replace(/^ *|\s*$/gi, "");
          if (context.measureText(line).width < wordWrapWidth) output += line + "\n";else {
            for (var currentLineWidth = wordWrapWidth, words = line.split(" "), j = 0; j < words.length; j++) {
              var word = words[j],
                  wordWithSpace = word + " ",
                  wordWidth = context.measureText(wordWithSpace).width;

              if (currentLineWidth < wordWidth) {
                if (0 === j) {
                  for (var newWord = wordWithSpace; newWord.length && (newWord = newWord.slice(0, -1), !((wordWidth = context.measureText(newWord).width) <= currentLineWidth));) {
                    ;
                  }

                  if (!newWord.length) throw new Error("This text's wordWrapWidth setting is less than a single character!");
                  var remainder = word.substr(newWord.length);
                  words[j] = remainder, out += newWord;
                }

                remainder = words[j].length ? j : j + 1, remainder = words.slice(remainder).join(" ").replace(/[ \n]*$/gi, "");
                lines[i + 1] = remainder + " " + (lines[i + 1] || ""), linesCount = lines.length;
                break;
              }

              out += wordWithSpace, currentLineWidth -= wordWidth;
            }

            output += out.replace(/[ \n]*$/gi, "") + "\n";
          }
        }

        return output = output.replace(/[\s|\n]*$/gi, "");
      },
      basicWordWrap: function basicWordWrap(text, context, wordWrapWidth) {
        for (var result = "", lines = text.split(this.splitRegExp), lastLineIndex = lines.length - 1, whiteSpaceWidth = context.measureText(" ").width, i = 0; i <= lastLineIndex; i++) {
          for (var spaceLeft = wordWrapWidth, words = lines[i].split(" "), lastWordIndex = words.length - 1, j = 0; j <= lastWordIndex; j++) {
            var word = words[j],
                wordWidth = context.measureText(word).width,
                wordWidthWithSpace = wordWidth;
            j < lastWordIndex && (wordWidthWithSpace += whiteSpaceWidth), spaceLeft < wordWidthWithSpace && 0 < j && (result += "\n", spaceLeft = wordWrapWidth), result += word, j < lastWordIndex ? (result += " ", spaceLeft -= wordWidthWithSpace) : spaceLeft -= wordWidth;
          }

          i < lastLineIndex && (result += "\n");
        }

        return result;
      },
      getWrappedText: function getWrappedText(text) {
        return void 0 === text && (text = this._text), this.style.syncFont(this.canvas, this.context), this.runWordWrap(text).split(this.splitRegExp);
      },
      setText: function setText(value) {
        return value || 0 === value || (value = ""), (value = Array.isArray(value) ? value.join("\n") : value) !== this._text && (this._text = value.toString(), this.updateText()), this;
      },
      setStyle: function setStyle(style) {
        return this.style.setStyle(style);
      },
      setFont: function setFont(font) {
        return this.style.setFont(font);
      },
      setFontFamily: function setFontFamily(family) {
        return this.style.setFontFamily(family);
      },
      setFontSize: function setFontSize(size) {
        return this.style.setFontSize(size);
      },
      setFontStyle: function setFontStyle(style) {
        return this.style.setFontStyle(style);
      },
      setFixedSize: function setFixedSize(width, height) {
        return this.style.setFixedSize(width, height);
      },
      setBackgroundColor: function setBackgroundColor(color) {
        return this.style.setBackgroundColor(color);
      },
      setFill: function setFill(fillStyle) {
        return this.style.setFill(fillStyle);
      },
      setColor: function setColor(color) {
        return this.style.setColor(color);
      },
      setStroke: function setStroke(color, thickness) {
        return this.style.setStroke(color, thickness);
      },
      setShadow: function setShadow(x, y, color, blur, shadowStroke, shadowFill) {
        return this.style.setShadow(x, y, color, blur, shadowStroke, shadowFill);
      },
      setShadowOffset: function setShadowOffset(x, y) {
        return this.style.setShadowOffset(x, y);
      },
      setShadowColor: function setShadowColor(color) {
        return this.style.setShadowColor(color);
      },
      setShadowBlur: function setShadowBlur(blur) {
        return this.style.setShadowBlur(blur);
      },
      setShadowStroke: function setShadowStroke(enabled) {
        return this.style.setShadowStroke(enabled);
      },
      setShadowFill: function setShadowFill(enabled) {
        return this.style.setShadowFill(enabled);
      },
      setWordWrapWidth: function setWordWrapWidth(width, useAdvancedWrap) {
        return this.style.setWordWrapWidth(width, useAdvancedWrap);
      },
      setWordWrapCallback: function setWordWrapCallback(callback, scope) {
        return this.style.setWordWrapCallback(callback, scope);
      },
      setAlign: function setAlign(align) {
        return this.style.setAlign(align);
      },
      setResolution: function setResolution(value) {
        return this.style.setResolution(value);
      },
      setLineSpacing: function setLineSpacing(value) {
        return this.lineSpacing = value, this.updateText();
      },
      setPadding: function setPadding(left, top, right, bottom) {
        var config, y;
        return "object" == _typeof(left) ? (right = null !== (y = GetValue(config = left, "x", null)) ? left = y : (left = GetValue(config, "left", 0), GetValue(config, "right", left)), bottom = null !== (y = GetValue(config, "y", null)) ? top = y : (top = GetValue(config, "top", 0), GetValue(config, "bottom", top))) : (void 0 === left && (left = 0), void 0 === top && (top = left), void 0 === right && (right = left), void 0 === bottom && (bottom = top)), this.padding.left = left, this.padding.top = top, this.padding.right = right, this.padding.bottom = bottom, this.updateText();
      },
      setMaxLines: function setMaxLines(max) {
        return this.style.setMaxLines(max);
      },
      updateText: function updateText() {
        var input = this.canvas,
            context = this.context,
            style = this.style,
            resolution = style.resolution,
            size = style.metrics;
        style.syncFont(input, context);
        var textWidth,
            h = this._text,
            lines = (h = style.wordWrapWidth || style.wordWrapCallback ? this.runWordWrap(this._text) : h).split(this.splitRegExp),
            textSize = GetTextSize(this, size, lines),
            padding = this.padding;
        0 === style.fixedWidth ? (this.width = textSize.width + padding.left + padding.right, textWidth = textSize.width) : (this.width = style.fixedWidth, (textWidth = this.width - padding.left - padding.right) < textSize.width && (textWidth = textSize.width)), 0 === style.fixedHeight ? this.height = textSize.height + padding.top + padding.bottom : this.height = style.fixedHeight;
        var linePositionX,
            linePositionY,
            w = this.width,
            h = this.height;
        this.updateDisplayOrigin(), w *= resolution, h *= resolution, w = Math.max(w, 1), h = Math.max(h, 1), input.width !== w || input.height !== h ? (input.width = w, input.height = h, this.frame.setSize(w, h), style.syncFont(input, context)) : context.clearRect(0, 0, w, h), context.save(), context.scale(resolution, resolution), style.backgroundColor && (context.fillStyle = style.backgroundColor, context.fillRect(0, 0, w, h)), style.syncStyle(input, context), context.textBaseline = "alphabetic", context.translate(padding.left, padding.top);

        for (var i = 0; i < textSize.lines; i++) {
          if (linePositionX = style.strokeThickness / 2, linePositionY = style.strokeThickness / 2 + i * textSize.lineHeight + size.ascent, 0 < i && (linePositionY += textSize.lineSpacing * i), style.rtl) linePositionX = w - linePositionX;else if ("right" === style.align) linePositionX += textWidth - textSize.lineWidths[i];else if ("center" === style.align) linePositionX += (textWidth - textSize.lineWidths[i]) / 2;else if ("justify" === style.align) if (.85 <= textSize.lineWidths[i] / textSize.width) {
            var extraSpace = textSize.width - textSize.lineWidths[i],
                spaceSize = context.measureText(" ").width,
                trimmedLine = lines[i].trim(),
                array = trimmedLine.split(" ");
            extraSpace += (lines[i].length - trimmedLine.length) * spaceSize;

            for (var extraSpaceCharacters = Math.floor(extraSpace / spaceSize), idx = 0; 0 < extraSpaceCharacters;) {
              array[idx] += " ", idx = (idx + 1) % (array.length - 1 || 1), --extraSpaceCharacters;
            }

            lines[i] = array.join(" ");
          }
          this.autoRound && (linePositionX = Math.round(linePositionX), linePositionY = Math.round(linePositionY)), style.strokeThickness && (this.style.syncShadow(context, style.shadowStroke), context.strokeText(lines[i], linePositionX, linePositionY)), style.color && (this.style.syncShadow(context, style.shadowFill), context.fillText(lines[i], linePositionX, linePositionY));
        }

        context.restore(), this.renderer && this.renderer.gl && (this.frame.source.glTexture = this.renderer.canvasToTexture(input, this.frame.source.glTexture, !0), this.frame.glTexture = this.frame.source.glTexture), this.dirty = !0;
        input = this.input;
        return input && !input.customHitArea && (input.hitArea.width = this.width, input.hitArea.height = this.height), this;
      },
      getTextMetrics: function getTextMetrics() {
        return this.style.getTextMetrics();
      },
      text: {
        get: function get() {
          return this._text;
        },
        set: function set(value) {
          this.setText(value);
        }
      },
      toJSON: function toJSON() {
        var out = Components.ToJSON(this),
            data = {
          autoRound: this.autoRound,
          text: this._text,
          style: this.style.toJSON(),
          padding: {
            left: this.padding.left,
            right: this.padding.right,
            top: this.padding.top,
            bottom: this.padding.bottom
          }
        };
        return out.data = data, out;
      },
      preDestroy: function preDestroy() {
        this.style.rtl && RemoveFromDOM(this.canvas), CanvasPool.remove(this.canvas), this.texture.destroy();
      }
    });

    module.exports = Text;
  }, function (module, exports, __webpack_require__) {
    var CanvasPool = __webpack_require__(31),
        Class = __webpack_require__(0),
        Components = __webpack_require__(11),
        GameEvents = __webpack_require__(22),
        GameObject = __webpack_require__(15),
        GetPowerOfTwo = __webpack_require__(361),
        Smoothing = __webpack_require__(192),
        TileSprite = __webpack_require__(1091),
        Vector2 = __webpack_require__(3),
        TileSprite = new Class({
      Extends: GameObject,
      Mixins: [Components.Alpha, Components.BlendMode, Components.ComputedSize, Components.Crop, Components.Depth, Components.Flip, Components.GetBounds, Components.Mask, Components.Origin, Components.Pipeline, Components.ScrollFactor, Components.Tint, Components.Transform, Components.Visible, TileSprite],
      initialize: function initialize(scene, x, y, width, height, displayFrame, frameKey) {
        var renderer = scene.sys.renderer;
        GameObject.call(this, scene, "TileSprite");
        var displayTexture = scene.sys.textures.get(displayFrame),
            displayFrame = displayTexture.get(frameKey);
        height = width && height ? (width = Math.floor(width), Math.floor(height)) : (width = displayFrame.width, displayFrame.height), this._tilePosition = new Vector2(), this._tileScale = new Vector2(1, 1), this.dirty = !1, this.renderer = renderer, this.canvas = CanvasPool.create(this, width, height), this.context = this.canvas.getContext("2d"), this.displayTexture = displayTexture, this.displayFrame = displayFrame, this._crop = this.resetCropObject(), this.texture = scene.sys.textures.addCanvas(null, this.canvas, !0), this.frame = this.texture.get(), this.potWidth = GetPowerOfTwo(displayFrame.width), this.potHeight = GetPowerOfTwo(displayFrame.height), this.fillCanvas = CanvasPool.create2D(this, this.potWidth, this.potHeight), this.fillContext = this.fillCanvas.getContext("2d"), this.fillPattern = null, this.setPosition(x, y), this.setSize(width, height), this.setFrame(frameKey), this.setOriginFromFrame(), this.initPipeline(), scene.sys.game.events.on(GameEvents.CONTEXT_RESTORED, function (renderer) {
          var gl;
          renderer && (gl = renderer.gl, this.dirty = !0, this.fillPattern = null, this.fillPattern = renderer.createTexture2D(0, gl.LINEAR, gl.LINEAR, gl.REPEAT, gl.REPEAT, gl.RGBA, this.fillCanvas, this.potWidth, this.potHeight));
        }, this);
      },
      setTexture: function setTexture(key, frame) {
        return this.displayTexture = this.scene.sys.textures.get(key), this.setFrame(frame);
      },
      setFrame: function setFrame(newFrame) {
        newFrame = this.displayTexture.get(newFrame);
        return this.potWidth = GetPowerOfTwo(newFrame.width), this.potHeight = GetPowerOfTwo(newFrame.height), this.canvas.width = 0, newFrame.cutWidth && newFrame.cutHeight ? this.renderFlags |= 8 : this.renderFlags &= -9, this.displayFrame = newFrame, this.dirty = !0, this.updateTileTexture(), this;
      },
      setTilePosition: function setTilePosition(x, y) {
        return void 0 !== x && (this.tilePositionX = x), void 0 !== y && (this.tilePositionY = y), this;
      },
      setTileScale: function setTileScale(x, y) {
        return void 0 === x && (x = this.tileScaleX), void 0 === y && (y = x), this.tileScaleX = x, this.tileScaleY = y, this;
      },
      updateTileTexture: function updateTileTexture() {
        if (this.dirty && this.renderer) {
          var frame = this.displayFrame;
          if (frame.source.isRenderTexture || frame.source.isGLTexture) return console.warn("TileSprites can only use Image or Canvas based textures"), void (this.dirty = !1);
          var ctx = this.fillContext,
              canvas = this.fillCanvas,
              fw = this.potWidth,
              fh = this.potHeight;
          this.renderer && this.renderer.gl || (fw = frame.cutWidth, fh = frame.cutHeight), ctx.clearRect(0, 0, fw, fh), canvas.width = fw, canvas.height = fh, ctx.drawImage(frame.source.image, frame.cutX, frame.cutY, frame.cutWidth, frame.cutHeight, 0, 0, fw, fh), this.renderer && this.renderer.gl ? this.fillPattern = this.renderer.canvasToTexture(canvas, this.fillPattern) : this.fillPattern = ctx.createPattern(canvas, "repeat"), this.updateCanvas(), this.dirty = !1;
        }
      },
      updateCanvas: function updateCanvas() {
        var ctx,
            scaleX,
            scaleY,
            positionX,
            positionY = this.canvas;
        positionY.width === this.width && positionY.height === this.height || (positionY.width = this.width, positionY.height = this.height, this.frame.setSize(this.width, this.height), this.updateDisplayOrigin(), this.dirty = !0), !this.dirty || this.renderer && this.renderer.gl || (ctx = this.context, this.scene.sys.game.config.antialias || Smoothing.disable(ctx), scaleX = this._tileScale.x, scaleY = this._tileScale.y, positionX = this._tilePosition.x, positionY = this._tilePosition.y, ctx.clearRect(0, 0, this.width, this.height), ctx.save(), ctx.scale(scaleX, scaleY), ctx.translate(-positionX, -positionY), ctx.fillStyle = this.fillPattern, ctx.fillRect(positionX, positionY, this.width / scaleX, this.height / scaleY), ctx.restore()), this.dirty = !1;
      },
      preDestroy: function preDestroy() {
        this.renderer && this.renderer.gl && this.renderer.deleteTexture(this.fillPattern), CanvasPool.remove(this.canvas), CanvasPool.remove(this.fillCanvas), this.fillPattern = null, this.fillContext = null, this.fillCanvas = null, this.displayTexture = null, this.displayFrame = null, this.texture.destroy(), this.renderer = null;
      },
      tilePositionX: {
        get: function get() {
          return this._tilePosition.x;
        },
        set: function set(value) {
          this._tilePosition.x = value, this.dirty = !0;
        }
      },
      tilePositionY: {
        get: function get() {
          return this._tilePosition.y;
        },
        set: function set(value) {
          this._tilePosition.y = value, this.dirty = !0;
        }
      },
      tileScaleX: {
        get: function get() {
          return this._tileScale.x;
        },
        set: function set(value) {
          this._tileScale.x = value, this.dirty = !0;
        }
      },
      tileScaleY: {
        get: function get() {
          return this._tileScale.y;
        },
        set: function set(value) {
          this._tileScale.y = value, this.dirty = !0;
        }
      }
    });

    module.exports = TileSprite;
  }, function (module, exports, __webpack_require__) {
    var Class = __webpack_require__(0),
        Clamp = __webpack_require__(18),
        Components = __webpack_require__(11),
        Events = __webpack_require__(75),
        GameEvents = __webpack_require__(22),
        InputEvents = __webpack_require__(51),
        GameObject = __webpack_require__(15),
        SoundEvents = __webpack_require__(70),
        UUID = __webpack_require__(222),
        Video = __webpack_require__(1094),
        MATH_CONST = __webpack_require__(14),
        Video = new Class({
      Extends: GameObject,
      Mixins: [Components.Alpha, Components.BlendMode, Components.Depth, Components.Flip, Components.GetBounds, Components.Mask, Components.Origin, Components.Pipeline, Components.ScrollFactor, Components.Size, Components.TextureCrop, Components.Tint, Components.Transform, Components.Visible, Video],
      initialize: function initialize(sound, x, y, game) {
        GameObject.call(this, sound, "Video"), this.video = null, this.videoTexture = null, this.videoTextureSource = null, this.snapshotTexture = null, this.flipY = !1, this._key = UUID(), this.touchLocked = !0, this.playWhenUnlocked = !1, this.retryLimit = 20, this.retry = 0, this.retryInterval = 500, this._retryID = null, this._systemMuted = !1, this._codeMuted = !1, this._systemPaused = !1, this._codePaused = !1, this._callbacks = {
          play: this.playHandler.bind(this),
          error: this.loadErrorHandler.bind(this),
          end: this.completeHandler.bind(this),
          time: this.timeUpdateHandler.bind(this),
          seeking: this.seekingHandler.bind(this),
          seeked: this.seekedHandler.bind(this)
        }, this._crop = this.resetCropObject(), this.markers = {}, this._markerIn = -1, this._markerOut = MATH_CONST.MAX_SAFE_INTEGER, this._lastUpdate = 0, this._cacheKey = "", this._isSeeking = !1, this.removeVideoElementOnDestroy = !1, this.setPosition(x, y), this.initPipeline(), game && this.changeSource(game, !1);
        game = sound.sys.game.events;
        game.on(GameEvents.PAUSE, this.globalPause, this), game.on(GameEvents.RESUME, this.globalResume, this);
        sound = sound.sys.sound;
        sound && sound.on(SoundEvents.GLOBAL_MUTE, this.globalMute, this);
      },
      addedToScene: function addedToScene() {
        this.scene.sys.updateList.add(this);
      },
      removedFromScene: function removedFromScene() {
        this.scene.sys.updateList.remove(this);
      },
      play: function play(playPromise, markerIn, callbacks) {
        if (this.touchLocked && this.playWhenUnlocked || this.isPlaying()) return this;
        var video = this.video;
        if (!video) return console.warn("Video not loaded"), this;
        void 0 === playPromise && (playPromise = video.loop);
        var sound = this.scene.sys.sound;
        sound && sound.mute && this.setMute(!0), isNaN(markerIn) || (this._markerIn = markerIn), !isNaN(callbacks) && markerIn < callbacks && (this._markerOut = callbacks), video.loop = playPromise;
        callbacks = this._callbacks, playPromise = video.play();
        return void 0 !== playPromise ? playPromise.then(this.playPromiseSuccessHandler.bind(this)).catch(this.playPromiseErrorHandler.bind(this)) : (video.addEventListener("playing", callbacks.play, !0), video.readyState < 2 && (this.retry = this.retryLimit, this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval))), video.addEventListener("ended", callbacks.end, !0), video.addEventListener("timeupdate", callbacks.time, !0), video.addEventListener("seeking", callbacks.seeking, !0), video.addEventListener("seeked", callbacks.seeked, !0), this;
      },
      changeSource: function changeSource(key, autoplay, loop, markerIn, markerOut) {
        void 0 === autoplay && (autoplay = !0), this.video && this.stop();
        var newVideo = this.scene.sys.cache.video.get(key);
        return newVideo ? (this.video = newVideo, this._cacheKey = key, this._codePaused = newVideo.paused, this._codeMuted = newVideo.muted, this.videoTexture ? (this.scene.sys.textures.remove(this._key), this.videoTexture = this.scene.sys.textures.create(this._key, newVideo, newVideo.videoWidth, newVideo.videoHeight), this.videoTextureSource = this.videoTexture.source[0], this.videoTexture.add("__BASE", 0, 0, 0, newVideo.videoWidth, newVideo.videoHeight), this.setTexture(this.videoTexture), this.setSizeToFrame(), this.updateDisplayOrigin(), this.emit(Events.VIDEO_CREATED, this, newVideo.videoWidth, newVideo.videoHeight)) : this.updateTexture(), newVideo.currentTime = 0, this._lastUpdate = 0, autoplay && this.play(loop, markerIn, markerOut)) : this.video = null, this;
      },
      addMarker: function addMarker(key, markerIn, markerOut) {
        return !isNaN(markerIn) && 0 <= markerIn && !isNaN(markerOut) && (this.markers[key] = [markerIn, markerOut]), this;
      },
      playMarker: function playMarker(marker, loop) {
        marker = this.markers[marker];
        return marker && this.play(loop, marker[0], marker[1]), this;
      },
      removeMarker: function removeMarker(key) {
        return delete this.markers[key], this;
      },
      snapshot: function snapshot(width, height) {
        return void 0 === width && (width = this.width), void 0 === height && (height = this.height), this.snapshotArea(0, 0, this.width, this.height, width, height);
      },
      snapshotArea: function snapshotArea(x, y, srcWidth, srcHeight, destWidth, destHeight) {
        void 0 === x && (x = 0), void 0 === y && (y = 0), void 0 === srcWidth && (srcWidth = this.width), void 0 === srcHeight && (srcHeight = this.height), void 0 === destWidth && (destWidth = srcWidth), void 0 === destHeight && (destHeight = srcHeight);
        var video = this.video,
            snap = this.snapshotTexture;
        return snap ? snap.setSize(destWidth, destHeight) : (snap = this.scene.sys.textures.createCanvas(UUID(), destWidth, destHeight), this.snapshotTexture = snap), video && snap.context.drawImage(video, x, y, srcWidth, srcHeight, 0, 0, destWidth, destHeight), snap.update();
      },
      saveSnapshotTexture: function saveSnapshotTexture(key) {
        return this.snapshotTexture ? this.scene.sys.textures.renameTexture(this.snapshotTexture.key, key) : this.snapshotTexture = this.scene.sys.textures.createCanvas(key, this.width, this.height), this.snapshotTexture;
      },
      loadURL: function loadURL(url, video, noAudio) {
        void 0 === video && (video = "loadeddata"), void 0 === noAudio && (noAudio = !1), this.video && this.stop(), this.videoTexture && this.scene.sys.textures.remove(this._key);
        video = document.createElement("video");
        return video.controls = !1, noAudio && (video.muted = !0, video.defaultMuted = !0, video.setAttribute("autoplay", "autoplay")), video.setAttribute("playsinline", "playsinline"), video.setAttribute("preload", "auto"), video.addEventListener("error", this._callbacks.error, !0), video.src = url, video.load(), this.video = video, this;
      },
      loadMediaStream: function loadMediaStream(stream, video, noAudio) {
        void 0 === video && (video = "loadeddata"), void 0 === noAudio && (noAudio = !1), this.video && this.stop(), this.videoTexture && this.scene.sys.textures.remove(this._key);
        video = document.createElement("video");
        video.controls = !1, noAudio && (video.muted = !0, video.defaultMuted = !0, video.setAttribute("autoplay", "autoplay")), video.setAttribute("playsinline", "playsinline"), video.setAttribute("preload", "auto"), video.addEventListener("error", this._callbacks.error, !0);

        try {
          video.srcObject = stream;
        } catch (error) {
          video.src = window.URL.createObjectURL(stream);
        }

        return video.load(), this.video = video, this;
      },
      playPromiseSuccessHandler: function playPromiseSuccessHandler() {
        this._codePaused = !1, this.touchLocked = !1, this.emit(Events.VIDEO_PLAY, this), -1 < this._markerIn && (this.video.currentTime = this._markerIn);
      },
      playPromiseErrorHandler: function playPromiseErrorHandler(error) {
        this.scene.sys.input.once(InputEvents.POINTER_DOWN, this.unlockHandler, this), this.touchLocked = !0, this.playWhenUnlocked = !0, this.emit(Events.VIDEO_ERROR, this, error);
      },
      playHandler: function playHandler() {
        this._codePaused = !1, this.touchLocked = !1, this.emit(Events.VIDEO_PLAY, this), this.video.removeEventListener("playing", this._callbacks.play, !0);
      },
      loadErrorHandler: function loadErrorHandler(event) {
        this.stop(), this.emit(Events.VIDEO_ERROR, this, event);
      },
      unlockHandler: function unlockHandler() {
        this.touchLocked = !1, this.playWhenUnlocked = !1, this.emit(Events.VIDEO_UNLOCKED, this), -1 < this._markerIn && (this.video.currentTime = this._markerIn), this.video.play(), this.emit(Events.VIDEO_PLAY, this);
      },
      completeHandler: function completeHandler() {
        this.emit(Events.VIDEO_COMPLETE, this);
      },
      timeUpdateHandler: function timeUpdateHandler() {
        this.video && this.video.currentTime < this._lastUpdate && (this.emit(Events.VIDEO_LOOP, this), this._lastUpdate = 0);
      },
      preUpdate: function preUpdate() {
        var currentTime,
            video = this.video;
        !video || (currentTime = video.currentTime) !== this._lastUpdate && (this._lastUpdate = currentTime, this.updateTexture(), currentTime >= this._markerOut && (video.loop ? (video.currentTime = this._markerIn, this.updateTexture(), this._lastUpdate = currentTime, this.emit(Events.VIDEO_LOOP, this)) : (this.emit(Events.VIDEO_COMPLETE, this), this.stop())));
      },
      checkVideoProgress: function checkVideoProgress() {
        2 <= this.video.readyState ? this.updateTexture() : (this.retry--, 0 < this.retry ? this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval) : this.emit(Events.VIDEO_TIMEOUT, this));
      },
      updateTexture: function updateTexture() {
        var textureSource,
            video = this.video,
            width = video.videoWidth,
            height = video.videoHeight;
        this.videoTexture ? ((textureSource = this.videoTextureSource).source !== video && (textureSource.source = video, textureSource.width = width, textureSource.height = height), textureSource.update()) : (this.videoTexture = this.scene.sys.textures.create(this._key, video, width, height), this.videoTextureSource = this.videoTexture.source[0], this.videoTexture.add("__BASE", 0, 0, 0, width, height), this.setTexture(this.videoTexture), this.setSizeToFrame(), this.updateDisplayOrigin(), this.emit(Events.VIDEO_CREATED, this, width, height));
      },
      getVideoKey: function getVideoKey() {
        return this._cacheKey;
      },
      seekTo: function seekTo(value) {
        var duration = this.video;
        return duration && ((duration = duration.duration) === 1 / 0 || isNaN(duration) || this.setCurrentTime(duration * value)), this;
      },
      getCurrentTime: function getCurrentTime() {
        return this.video ? this.video.currentTime : 0;
      },
      setCurrentTime: function setCurrentTime(value) {
        var op,
            num,
            video = this.video;
        return video && ("string" == typeof value && (op = value[0], num = parseFloat(value.substr(1)), "+" === op ? value = video.currentTime + num : "-" === op && (value = video.currentTime - num)), video.currentTime = value, this._lastUpdate = value), this;
      },
      isSeeking: function isSeeking() {
        return this._isSeeking;
      },
      seekingHandler: function seekingHandler() {
        this._isSeeking = !0, this.emit(Events.VIDEO_SEEKING, this);
      },
      seekedHandler: function seekedHandler() {
        this._isSeeking = !1, this.emit(Events.VIDEO_SEEKED, this), this.video && this.updateTexture();
      },
      getProgress: function getProgress() {
        var duration = this.video;

        if (duration) {
          var now = duration.currentTime,
              duration = duration.duration;
          if (duration !== 1 / 0 && !isNaN(duration)) return now / duration;
        }

        return 0;
      },
      getDuration: function getDuration() {
        return this.video ? this.video.duration : 0;
      },
      setMute: function setMute(value) {
        this._codeMuted = value = void 0 === value ? !0 : value;
        var video = this.video;
        return video && (video.muted = !!this._systemMuted || value), this;
      },
      isMuted: function isMuted() {
        return this._codeMuted;
      },
      globalMute: function globalMute(soundManager, value) {
        this._systemMuted = value;
        var video = this.video;
        video && (video.muted = !!this._codeMuted || value);
      },
      globalPause: function globalPause() {
        this._systemPaused = !0, this.video && this.video.pause();
      },
      globalResume: function globalResume() {
        this._systemPaused = !1, this.video && !this._codePaused && this.video.play();
      },
      setPaused: function setPaused(value) {
        var video = this.video;
        return this._codePaused = value = void 0 === value ? !0 : value, video && (value ? video.paused || video.pause() : video.paused && !this._systemPaused && video.play()), this;
      },
      getVolume: function getVolume() {
        return this.video ? this.video.volume : 1;
      },
      setVolume: function setVolume(value) {
        return void 0 === value && (value = 1), this.video && (this.video.volume = Clamp(value, 0, 1)), this;
      },
      getPlaybackRate: function getPlaybackRate() {
        return this.video ? this.video.playbackRate : 1;
      },
      setPlaybackRate: function setPlaybackRate(rate) {
        return this.video && (this.video.playbackRate = rate), this;
      },
      getLoop: function getLoop() {
        return !!this.video && this.video.loop;
      },
      setLoop: function setLoop(value) {
        return void 0 === value && (value = !0), this.video && (this.video.loop = value), this;
      },
      isPlaying: function isPlaying() {
        return !!this.video && !(this.video.paused || this.video.ended);
      },
      isPaused: function isPaused() {
        return this.video && this.video.paused || this._codePaused || this._systemPaused;
      },
      saveTexture: function saveTexture(key, flipY) {
        return void 0 === flipY && (flipY = !1), this.videoTexture && this.scene.sys.textures.renameTexture(this._key, key), this._key = key, this.flipY = flipY, this.videoTextureSource && this.videoTextureSource.setFlipY(flipY), this.videoTexture;
      },
      stop: function stop() {
        var video = this.video;

        if (video) {
          var callback,
              callbacks = this._callbacks;

          for (callback in callbacks) {
            video.removeEventListener(callback, callbacks[callback], !0);
          }

          video.pause();
        }

        return this._retryID && window.clearTimeout(this._retryID), this.emit(Events.VIDEO_STOP, this), this;
      },
      removeVideoElement: function removeVideoElement() {
        var video = this.video;

        if (video) {
          for (video.parentNode && video.parentNode.removeChild(video); video.hasChildNodes();) {
            video.removeChild(video.firstChild);
          }

          video.removeAttribute("autoplay"), video.removeAttribute("src"), this.video = null;
        }
      },
      preDestroy: function preDestroy() {
        this.stop(), this.removeVideoElementOnDestroy && this.removeVideoElement();
        var sound = this.scene.sys.game.events;
        sound.off(GameEvents.PAUSE, this.globalPause, this), sound.off(GameEvents.RESUME, this.globalResume, this);
        sound = this.scene.sys.sound;
        sound && sound.off(SoundEvents.GLOBAL_MUTE, this.globalMute, this), this._retryID && window.clearTimeout(this._retryID);
      }
    });

    module.exports = Video;
  }, function (module, exports, __webpack_require__) {
    var Polygon = __webpack_require__(0),
        Contains = __webpack_require__(228),
        GetPoints = __webpack_require__(470),
        GEOM_CONST = __webpack_require__(56),
        Polygon = new Polygon({
      initialize: function initialize(points) {
        this.type = GEOM_CONST.POLYGON, this.area = 0, this.points = [], points && this.setTo(points);
      },
      contains: function contains(x, y) {
        return Contains(this, x, y);
      },
      setTo: function setTo(points) {
        if (this.area = 0, this.points = [], "string" == typeof points && (points = points.split(" ")), !Array.isArray(points)) return this;

        for (var p, y0 = Number.MAX_VALUE, i = 0; i < points.length; i++) {
          p = {
            x: 0,
            y: 0
          }, "number" == typeof points[i] || "string" == typeof points[i] ? (p.x = parseFloat(points[i]), p.y = parseFloat(points[i + 1]), i++) : Array.isArray(points[i]) ? (p.x = points[i][0], p.y = points[i][1]) : (p.x = points[i].x, p.y = points[i].y), this.points.push(p), p.y < y0 && (y0 = p.y);
        }

        return this.calculateArea(y0), this;
      },
      calculateArea: function calculateArea() {
        if (this.points.length < 3) return this.area = 0, this.area;

        for (var p1, p2, sum = 0, i = 0; i < this.points.length - 1; i++) {
          p1 = this.points[i], sum += ((p2 = this.points[i + 1]).x - p1.x) * (p1.y + p2.y);
        }

        return p1 = this.points[0], p2 = this.points[this.points.length - 1], sum += (p1.x - p2.x) * (p2.y + p1.y), this.area = .5 * -sum, this.area;
      },
      getPoints: function getPoints(quantity, step, output) {
        return GetPoints(this, quantity, step, output);
      }
    });

    module.exports = Polygon;
  }, function (module, exports) {
    module.exports = function (polygon, x, y) {
      for (var inside = !1, i = -1, j = polygon.points.length - 1; ++i < polygon.points.length; j = i) {
        var ix = polygon.points[i].x,
            iy = polygon.points[i].y,
            jx = polygon.points[j].x,
            jy = polygon.points[j].y;
        (iy <= y && y < jy || jy <= y && y < iy) && x < (jx - ix) * (y - iy) / (jy - iy) + ix && (inside = !inside);
      }

      return inside;
    };
  }, function (module, exports, __webpack_require__) {
    var Class = __webpack_require__(0),
        Components = __webpack_require__(11),
        GameObject = __webpack_require__(15),
        GetFastValue = __webpack_require__(2),
        Extend = __webpack_require__(17),
        SetValue = __webpack_require__(478),
        Shader = __webpack_require__(1176),
        TransformMatrix = __webpack_require__(25),
        Shader = new Class({
      Extends: GameObject,
      Mixins: [Components.ComputedSize, Components.Depth, Components.GetBounds, Components.Mask, Components.Origin, Components.ScrollFactor, Components.Transform, Components.Visible, Shader],
      initialize: function initialize(renderer, key, x, y, width, height, textures, textureData) {
        void 0 === x && (x = 0), void 0 === y && (y = 0), void 0 === width && (width = 128), void 0 === height && (height = 128), GameObject.call(this, renderer, "Shader"), this.blendMode = -1, this.shader;
        renderer = renderer.sys.renderer;
        this.renderer = renderer, this.gl = renderer.gl, this.vertexData = new ArrayBuffer(2 * Float32Array.BYTES_PER_ELEMENT * 6), this.vertexBuffer = renderer.createVertexBuffer(this.vertexData.byteLength, this.gl.STREAM_DRAW), this.program = null, this.bytes = new Uint8Array(this.vertexData), this.vertexViewF32 = new Float32Array(this.vertexData), this._tempMatrix1 = new TransformMatrix(), this._tempMatrix2 = new TransformMatrix(), this._tempMatrix3 = new TransformMatrix(), this.viewMatrix = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]), this.projectionMatrix = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]), this.uniforms = {}, this.pointer = null, this._rendererWidth = renderer.width, this._rendererHeight = renderer.height, this._textureCount = 0, this.framebuffer = null, this.glTexture = null, this.renderToTexture = !1, this.texture = null, this.setPosition(x, y), this.setSize(width, height), this.setOrigin(.5, .5), this.setShader(key, textures, textureData);
      },
      willRender: function willRender(camera) {
        return !!this.renderToTexture || !(GameObject.RENDER_MASK !== this.renderFlags || 0 !== this.cameraFilter && this.cameraFilter & camera.id);
      },
      setRenderToTexture: function setRenderToTexture(key, flipY) {
        var width, height, renderer;
        return void 0 === flipY && (flipY = !1), this.renderToTexture || (width = this.width, height = this.height, renderer = this.renderer, this.glTexture = renderer.createTextureFromSource(null, width, height, 0), this.glTexture.flipY = flipY, this.framebuffer = renderer.createFramebuffer(width, height, this.glTexture, !1), this._rendererWidth = width, this._rendererHeight = height, this.renderToTexture = !0, this.projOrtho(0, this.width, this.height, 0), key && (this.texture = this.scene.sys.textures.addGLTexture(key, this.glTexture, width, height))), this.shader && (renderer.pipelines.clear(), this.load(), this.flush(), renderer.pipelines.rebind()), this;
      },
      setShader: function setShader(defaultUniforms, textures, textureData) {
        if (void 0 === textures && (textures = []), "string" == typeof defaultUniforms) {
          var gl = this.scene.sys.cache.shader;
          if (!gl.has(defaultUniforms)) return console.warn("Shader missing: " + defaultUniforms), this;
          this.shader = gl.get(defaultUniforms);
        } else this.shader = defaultUniforms;

        gl = this.gl, defaultUniforms = this.renderer;
        this.program && gl.deleteProgram(this.program);
        defaultUniforms = defaultUniforms.createProgram(this.shader.vertexSrc, this.shader.fragmentSrc);
        gl.uniformMatrix4fv(gl.getUniformLocation(defaultUniforms, "uViewMatrix"), !1, this.viewMatrix), gl.uniformMatrix4fv(gl.getUniformLocation(defaultUniforms, "uProjectionMatrix"), !1, this.projectionMatrix), gl.uniform2f(gl.getUniformLocation(defaultUniforms, "uResolution"), this.width, this.height), this.program = defaultUniforms;
        defaultUniforms = new Date(), defaultUniforms = {
          resolution: {
            type: "2f",
            value: {
              x: this.width,
              y: this.height
            }
          },
          time: {
            type: "1f",
            value: 0
          },
          mouse: {
            type: "2f",
            value: {
              x: this.width / 2,
              y: this.height / 2
            }
          },
          date: {
            type: "4fv",
            value: [defaultUniforms.getFullYear(), defaultUniforms.getMonth(), defaultUniforms.getDate(), 60 * defaultUniforms.getHours() * 60 + 60 * defaultUniforms.getMinutes() + defaultUniforms.getSeconds()]
          },
          sampleRate: {
            type: "1f",
            value: 44100
          },
          iChannel0: {
            type: "sampler2D",
            value: null,
            textureData: {
              repeat: !0
            }
          },
          iChannel1: {
            type: "sampler2D",
            value: null,
            textureData: {
              repeat: !0
            }
          },
          iChannel2: {
            type: "sampler2D",
            value: null,
            textureData: {
              repeat: !0
            }
          },
          iChannel3: {
            type: "sampler2D",
            value: null,
            textureData: {
              repeat: !0
            }
          }
        };
        this.shader.uniforms ? this.uniforms = Extend(!0, {}, this.shader.uniforms, defaultUniforms) : this.uniforms = defaultUniforms;

        for (var i = 0; i < 4; i++) {
          textures[i] && this.setSampler2D("iChannel" + i, textures[i], i, textureData);
        }

        return this.initUniforms(), this.projOrtho(0, this._rendererWidth, this._rendererHeight, 0), this;
      },
      setPointer: function setPointer(pointer) {
        return this.pointer = pointer, this;
      },
      projOrtho: function projOrtho(left, right, bottom, top) {
        var leftRight = 1 / (left - right),
            program = 1 / (bottom - top),
            gl = this.projectionMatrix;
        gl[0] = -2 * leftRight, gl[5] = -2 * program, gl[10] = -.001, gl[12] = (left + right) * leftRight, gl[13] = (top + bottom) * program, gl[14] = -0;
        program = this.program, gl = this.gl;
        this.renderer.setProgram(program), gl.uniformMatrix4fv(gl.getUniformLocation(program, "uProjectionMatrix"), !1, this.projectionMatrix), this._rendererWidth = right, this._rendererHeight = bottom;
      },
      initUniforms: function initUniforms() {
        var key,
            gl = this.gl,
            map = this.renderer.glFuncMap,
            program = this.program;

        for (key in this._textureCount = 0, this.uniforms) {
          var uniform = this.uniforms[key],
              type = uniform.type,
              data = map[type];
          uniform.uniformLocation = gl.getUniformLocation(program, key), "sampler2D" !== type && (uniform.glMatrix = data.matrix, uniform.glValueLength = data.length, uniform.glFunc = data.func);
        }
      },
      setSampler2DBuffer: function setSampler2DBuffer(uniform, texture, width, height, textureIndex, textureData) {
        void 0 === textureIndex && (textureIndex = 0), void 0 === textureData && (textureData = {});
        uniform = this.uniforms[uniform];
        return uniform.value = texture, textureData.width = width, textureData.height = height, uniform.textureData = textureData, this._textureCount = textureIndex, this.initSampler2D(uniform), this;
      },
      setSampler2D: function setSampler2D(source, textureKey, textureIndex, textureData) {
        void 0 === textureIndex && (textureIndex = 0);
        var uniform = this.scene.sys.textures;

        if (uniform.exists(textureKey)) {
          var frame = uniform.getFrame(textureKey);
          if (frame.glTexture && frame.glTexture.isRenderTexture) return this.setSampler2DBuffer(source, frame.glTexture, frame.width, frame.height, textureIndex, textureData);
          uniform = this.uniforms[source], source = frame.source;
          uniform.textureKey = textureKey, uniform.source = source.image, uniform.value = frame.glTexture, source.isGLTexture && ((textureData = textureData || {}).width = source.width, textureData.height = source.height), textureData && (uniform.textureData = textureData), this._textureCount = textureIndex, this.initSampler2D(uniform);
        }

        return this;
      },
      setUniform: function setUniform(key, value) {
        return SetValue(this.uniforms, key, value), this;
      },
      getUniform: function getUniform(key) {
        return GetFastValue(this.uniforms, key, null);
      },
      setChannel0: function setChannel0(textureKey, textureData) {
        return this.setSampler2D("iChannel0", textureKey, 0, textureData);
      },
      setChannel1: function setChannel1(textureKey, textureData) {
        return this.setSampler2D("iChannel1", textureKey, 1, textureData);
      },
      setChannel2: function setChannel2(textureKey, textureData) {
        return this.setSampler2D("iChannel2", textureKey, 2, textureData);
      },
      setChannel3: function setChannel3(textureKey, textureData) {
        return this.setSampler2D("iChannel3", textureKey, 3, textureData);
      },
      initSampler2D: function initSampler2D(uniform) {
        var gl, magFilter, minFilter, wrapS, wrapT, format, width, height, border;
        uniform.value && ((gl = this.gl).activeTexture(gl.TEXTURE0 + this._textureCount), gl.bindTexture(gl.TEXTURE_2D, uniform.value), (border = uniform.textureData) && !uniform.value.isRenderTexture && (magFilter = gl[GetFastValue(border, "magFilter", "linear").toUpperCase()], minFilter = gl[GetFastValue(border, "minFilter", "linear").toUpperCase()], wrapS = gl[GetFastValue(border, "wrapS", "repeat").toUpperCase()], wrapT = gl[GetFastValue(border, "wrapT", "repeat").toUpperCase()], format = gl[GetFastValue(border, "format", "rgba").toUpperCase()], border.repeat && (wrapS = gl.REPEAT, wrapT = gl.REPEAT), gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, !!border.flipY), border.width ? (width = GetFastValue(border, "width", 512), height = GetFastValue(border, "height", 2), border = GetFastValue(border, "border", 0), gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, border, format, gl.UNSIGNED_BYTE, null)) : gl.texImage2D(gl.TEXTURE_2D, 0, format, gl.RGBA, gl.UNSIGNED_BYTE, uniform.source), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT)), this.renderer.setProgram(this.program), gl.uniform1i(uniform.uniformLocation, this._textureCount), this._textureCount++);
      },
      syncUniforms: function syncUniforms() {
        var uniform,
            length,
            glFunc,
            location,
            value,
            key,
            gl = this.gl,
            uniforms = this.uniforms,
            textureCount = 0;

        for (key in uniforms) {
          glFunc = (uniform = uniforms[key]).glFunc, length = uniform.glValueLength, location = uniform.uniformLocation, null !== (value = uniform.value) && (1 === length ? uniform.glMatrix ? glFunc.call(gl, location, uniform.transpose, value) : glFunc.call(gl, location, value) : 2 === length ? glFunc.call(gl, location, value.x, value.y) : 3 === length ? glFunc.call(gl, location, value.x, value.y, value.z) : 4 === length ? glFunc.call(gl, location, value.x, value.y, value.z, value.w) : "sampler2D" === uniform.type && (gl.activeTexture(gl.TEXTURE0 + textureCount), gl.bindTexture(gl.TEXTURE_2D, value), gl.uniform1i(location, textureCount), textureCount++));
        }
      },
      load: function load(matrix2D) {
        var x,
            y,
            mouse = this.gl,
            px = this.width,
            py = this.height,
            pointer = this.renderer,
            res = this.program,
            vm = this.viewMatrix;
        this.renderToTexture || (x = -this._displayOriginX, y = -this._displayOriginY, vm[0] = matrix2D[0], vm[1] = matrix2D[1], vm[4] = matrix2D[2], vm[5] = matrix2D[3], vm[8] = matrix2D[4], vm[9] = matrix2D[5], vm[12] = vm[0] * x + vm[4] * y, vm[13] = vm[1] * x + vm[5] * y), mouse.useProgram(res), mouse.uniformMatrix4fv(mouse.getUniformLocation(res, "uViewMatrix"), !1, vm), mouse.uniform2f(mouse.getUniformLocation(res, "uResolution"), this.width, this.height);
        mouse = this.uniforms, res = mouse.resolution;
        res.value.x = px, res.value.y = py, mouse.time.value = pointer.game.loop.getDuration();
        pointer = this.pointer;
        pointer && (mouse = mouse.mouse, px = pointer.x / px, py = 1 - pointer.y / py, mouse.value.x = px.toFixed(2), mouse.value.y = py.toFixed(2)), this.syncUniforms();
      },
      flush: function flush() {
        var width = this.width,
            height = this.height,
            vf = this.program,
            gl = this.gl,
            vertexBuffer = this.vertexBuffer,
            renderer = this.renderer,
            vertexSize = 2 * Float32Array.BYTES_PER_ELEMENT;
        this.renderToTexture && (renderer.setFramebuffer(this.framebuffer), gl.clearColor(0, 0, 0, 0), gl.clear(gl.COLOR_BUFFER_BIT)), gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        vf = gl.getAttribLocation(vf, "inPosition");
        -1 !== vf && (gl.enableVertexAttribArray(vf), gl.vertexAttribPointer(vf, 2, gl.FLOAT, !1, vertexSize, 0));
        vf = this.vertexViewF32;
        vf[3] = height, vf[4] = width, vf[5] = height, vf[8] = width, vf[9] = height, vf[10] = width;
        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.bytes.subarray(0, 6 * vertexSize)), gl.drawArrays(gl.TRIANGLES, 0, 6), this.renderToTexture && renderer.setFramebuffer(null, !1);
      },
      setAlpha: function setAlpha() {},
      setBlendMode: function setBlendMode() {},
      preDestroy: function preDestroy() {
        var gl = this.gl;
        gl.deleteProgram(this.program), gl.deleteBuffer(this.vertexBuffer), this.renderToTexture && (this.renderer.deleteFramebuffer(this.framebuffer), this.texture.destroy(), this.framebuffer = null, this.glTexture = null, this.texture = null);
      }
    });

    module.exports = Shader;
  }, function (module, exports, __webpack_require__) {
    var Class = __webpack_require__(0),
        Components = __webpack_require__(11),
        DegToRad = __webpack_require__(36),
        Face = __webpack_require__(116),
        GameObject = __webpack_require__(15),
        GenerateVerts = __webpack_require__(479),
        GenerateObjVerts = __webpack_require__(480),
        GetCalcMatrix = __webpack_require__(19),
        Matrix4 = __webpack_require__(69),
        Mesh = __webpack_require__(1179),
        StableSort = __webpack_require__(79),
        Vector3 = __webpack_require__(39),
        Vertex = __webpack_require__(117),
        Mesh = new Class({
      Extends: GameObject,
      Mixins: [Components.AlphaSingle, Components.BlendMode, Components.Depth, Components.Mask, Components.Pipeline, Components.Size, Components.Texture, Components.Transform, Components.Visible, Components.ScrollFactor, Mesh],
      initialize: function initialize(renderer, x, y, texture, frame, vertices, uvs, indicies, containsZ, normals, colors, alphas) {
        void 0 === x && (x = 0), void 0 === y && (y = 0), void 0 === texture && (texture = "__WHITE"), GameObject.call(this, renderer, "Mesh"), this.faces = [], this.vertices = [], this.tintFill = !1, this.debugCallback = null, this.debugGraphic = null, this.hideCCW = !0, this.modelPosition = new Vector3(), this.modelScale = new Vector3(1, 1, 1), this.modelRotation = new Vector3(), this.dirtyCache = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], this.transformMatrix = new Matrix4(), this.viewPosition = new Vector3(), this.viewMatrix = new Matrix4(), this.projectionMatrix = new Matrix4(), this.totalRendered = 0, this.totalFrame = 0, this.ignoreDirtyCache = !1;
        renderer = renderer.sys.renderer;
        this.setPosition(x, y), this.setTexture(texture, frame), this.setSize(renderer.width, renderer.height), this.initPipeline(), this.setPerspective(renderer.width, renderer.height), vertices && this.addVertices(vertices, uvs, indicies, containsZ, normals, colors, alphas);
      },
      addedToScene: function addedToScene() {
        this.scene.sys.updateList.add(this);
      },
      removedFromScene: function removedFromScene() {
        this.scene.sys.updateList.remove(this);
      },
      panX: function panX(v) {
        return this.viewPosition.addScale(Vector3.LEFT, v), this.dirtyCache[10] = 1, this;
      },
      panY: function panY(v) {
        return this.viewPosition.y += Vector3.DOWN.y * v, this.dirtyCache[10] = 1, this;
      },
      panZ: function panZ(amount) {
        return this.viewPosition.z += amount, this.dirtyCache[10] = 1, this;
      },
      setPerspective: function setPerspective(width, height, fov, near, far) {
        return void 0 === near && (near = .01), void 0 === far && (far = 1e3), this.projectionMatrix.perspective(DegToRad(fov = void 0 === fov ? 45 : fov), width / height, near, far), this.dirtyCache[10] = 1, this.dirtyCache[11] = 0, this;
      },
      setOrtho: function setOrtho(scaleX, scaleY, near, far) {
        return void 0 === scaleX && (scaleX = this.scene.sys.renderer.getAspectRatio()), this.projectionMatrix.ortho(-scaleX, scaleX, -(scaleY = void 0 === scaleY ? 1 : scaleY), scaleY, near = void 0 === near ? -1e3 : near, far = void 0 === far ? 1e3 : far), this.dirtyCache[10] = 1, this.dirtyCache[11] = 1, this;
      },
      clear: function clear() {
        return this.faces.forEach(function (face) {
          face.destroy();
        }), this.faces = [], this.vertices = [], this;
      },
      addVerticesFromObj: function addVerticesFromObj(data, scale, x, y, z, rotateX, rotateY, rotateZ, zIsUp) {
        data = this.scene.sys.cache.obj.get(data);
        return data && GenerateObjVerts(data, this, scale, x, y, z, rotateX, rotateY, rotateZ, zIsUp), this;
      },
      sortByDepth: function sortByDepth(faceA, faceB) {
        return faceA.depth - faceB.depth;
      },
      depthSort: function depthSort() {
        return StableSort(this.faces, this.sortByDepth), this;
      },
      addVertex: function addVertex(x, y, z, u, v, color, vert) {
        vert = new Vertex(x, y, z, u, v, color, vert);
        return this.vertices.push(vert), vert;
      },
      addFace: function addFace(vertex1, vertex2, face) {
        face = new Face(vertex1, vertex2, face);
        return this.faces.push(face), this.dirtyCache[9] = -1, face;
      },
      addVertices: function addVertices(vertices, uvs, indicies, containsZ, normals, colors, result) {
        result = GenerateVerts(vertices, uvs, indicies, containsZ, normals, colors, result);
        return result && (this.faces = this.faces.concat(result.faces), this.vertices = this.vertices.concat(result.vertices)), this.dirtyCache[9] = -1, this;
      },
      getFaceCount: function getFaceCount() {
        return this.faces.length;
      },
      getVertexCount: function getVertexCount() {
        return this.vertices.length;
      },
      getFace: function getFace(index) {
        return this.faces[index];
      },
      getFaceAt: function getFaceAt(x, y, camera) {
        void 0 === camera && (camera = this.scene.sys.cameras.main);

        for (var calcMatrix = GetCalcMatrix(this, camera).calc, faces = this.faces, results = [], i = 0; i < faces.length; i++) {
          var face = faces[i];
          face.contains(x, y, calcMatrix) && results.push(face);
        }

        return StableSort(results, this.sortByDepth);
      },
      setDebug: function setDebug(graphic, callback) {
        return this.debugGraphic = graphic, this.debugCallback = graphic || callback ? callback || this.renderDebug : null, this;
      },
      isDirty: function isDirty() {
        var syCached = this.modelPosition,
            szCached = this.modelRotation,
            fCached = this.modelScale,
            dirtyCache = this.dirtyCache,
            px = syCached.x,
            py = syCached.y,
            pz = syCached.z,
            rx = szCached.x,
            ry = szCached.y,
            rz = szCached.z,
            sx = fCached.x,
            sy = fCached.y,
            sz = fCached.z,
            faces = this.getFaceCount(),
            pxCached = dirtyCache[0],
            pyCached = dirtyCache[1],
            pzCached = dirtyCache[2],
            rxCached = dirtyCache[3],
            ryCached = dirtyCache[4],
            rzCached = dirtyCache[5],
            sxCached = dirtyCache[6],
            syCached = dirtyCache[7],
            szCached = dirtyCache[8],
            fCached = dirtyCache[9];
        return dirtyCache[0] = px, dirtyCache[1] = py, dirtyCache[2] = pz, dirtyCache[3] = rx, dirtyCache[4] = ry, dirtyCache[5] = rz, dirtyCache[6] = sx, dirtyCache[7] = sy, dirtyCache[8] = sz, dirtyCache[9] = faces, pxCached !== px || pyCached !== py || pzCached !== pz || rxCached !== rx || ryCached !== ry || rzCached !== rz || sxCached !== sx || syCached !== sy || szCached !== sz || fCached !== faces;
      },
      preUpdate: function preUpdate() {
        this.totalRendered = this.totalFrame, this.totalFrame = 0;
        var dirty = this.dirtyCache;

        if (this.ignoreDirtyCache || dirty[10] || this.isDirty()) {
          var width = this.width,
              height = this.height,
              viewMatrix = this.viewMatrix,
              viewPosition = this.viewPosition;
          dirty[10] && (viewMatrix.identity(), viewMatrix.translate(viewPosition), viewMatrix.invert(), dirty[10] = 0);
          var transformMatrix = this.transformMatrix;
          transformMatrix.setWorldMatrix(this.modelRotation, this.modelPosition, this.modelScale, this.viewMatrix, this.projectionMatrix);

          for (var z = viewPosition.z, faces = this.faces, i = 0; i < faces.length; i++) {
            faces[i].transformCoordinatesLocal(transformMatrix, width, height, z);
          }

          this.depthSort();
        }
      },
      renderDebug: function renderDebug(src, faces) {
        for (var graphic = src.debugGraphic, i = 0; i < faces.length; i++) {
          var y2 = faces[i],
              x0 = y2.vertex1.tx,
              y0 = y2.vertex1.ty,
              x1 = y2.vertex2.tx,
              y1 = y2.vertex2.ty,
              x2 = y2.vertex3.tx,
              y2 = y2.vertex3.ty;
          graphic.strokeTriangle(x0, y0, x1, y1, x2, y2);
        }
      },
      preDestroy: function preDestroy() {
        this.clear(), this.debugCallback = null, this.debugGraphic = null;
      }
    });

    module.exports = Mesh;
  }, function (module, exports, __webpack_require__) {
    var DistanceBetween = __webpack_require__(50);

    module.exports = function (circleA, circleB) {
      return DistanceBetween(circleA.x, circleA.y, circleB.x, circleB.y) <= circleA.radius + circleB.radius;
    };
  }, function (module, exports, __webpack_require__) {
    var Point = __webpack_require__(4),
        LineToCircle = __webpack_require__(233);

    module.exports = function (oDirY, lambda, out) {
      var lx1, ly1, lDirX, lDirY, oDirX, coefficientB, x, y, root1, root2;
      return void 0 === out && (out = []), LineToCircle(oDirY, lambda) && (lx1 = oDirY.x1, ly1 = oDirY.y1, coefficientB = oDirY.x2, root2 = oDirY.y2, 0 == (lambda = (coefficientB = 2 * ((lDirX = coefficientB - lx1) * (oDirX = lx1 - lambda.x) + (lDirY = root2 - ly1) * (oDirY = ly1 - lambda.y))) * coefficientB - 4 * (root2 = lDirX * lDirX + lDirY * lDirY) * (oDirX * oDirX + oDirY * oDirY - (lambda = lambda.radius) * lambda)) ? (x = lx1 + (root1 = -coefficientB / (2 * root2)) * lDirX, y = ly1 + root1 * lDirY, 0 <= root1 && root1 <= 1 && out.push(new Point(x, y))) : 0 < lambda && (x = lx1 + (root1 = (-coefficientB - Math.sqrt(lambda)) / (2 * root2)) * lDirX, y = ly1 + root1 * lDirY, 0 <= root1 && root1 <= 1 && out.push(new Point(x, y)), x = lx1 + (root2 = (-coefficientB + Math.sqrt(lambda)) / (2 * root2)) * lDirX, y = ly1 + root2 * lDirY, 0 <= root2 && root2 <= 1 && out.push(new Point(x, y)))), out;
    };
  }, function (module, exports, __webpack_require__) {
    var Contains = __webpack_require__(66),
        tmp = new (__webpack_require__(4))();

    module.exports = function (line, circle, nearest) {
      if (void 0 === nearest && (nearest = tmp), Contains(circle, line.x1, line.y1)) return nearest.x = line.x1, nearest.y = line.y1, !0;
      if (Contains(circle, line.x2, line.y2)) return nearest.x = line.x2, nearest.y = line.y2, !0;
      var dx = line.x2 - line.x1,
          dy = line.y2 - line.y1,
          lcx = circle.x - line.x1,
          dp = circle.y - line.y1,
          dLen2 = dx * dx + dy * dy,
          px = dx,
          py = dy;
      return 0 < dLen2 && (px *= dp = (lcx * dx + dp * dy) / dLen2, py *= dp), nearest.x = line.x1 + px, nearest.y = line.y1 + py, px * px + py * py <= dLen2 && 0 <= px * dx + py * dy && Contains(circle, nearest.x, nearest.y);
    };
  }, function (module, exports, __webpack_require__) {
    var Point = __webpack_require__(4),
        LineToLine = __webpack_require__(96),
        LineToRectangle = __webpack_require__(488);

    module.exports = function (line, lineD, out) {
      if (void 0 === out && (out = []), LineToRectangle(line, lineD)) for (var lineA = lineD.getLineA(), lineB = lineD.getLineB(), lineC = lineD.getLineC(), lineD = lineD.getLineD(), output = [new Point(), new Point(), new Point(), new Point()], result = [LineToLine(lineA, line, output[0]), LineToLine(lineB, line, output[1]), LineToLine(lineC, line, output[2]), LineToLine(lineD, line, output[3])], i = 0; i < 4; i++) {
        result[i] && out.push(output[i]);
      }
      return out;
    };
  }, function (module, exports) {
    module.exports = function (triangle, points, returnFirst, out) {
      void 0 === returnFirst && (returnFirst = !1), void 0 === out && (out = []);

      for (var v, dot02, u, v0x = triangle.x3 - triangle.x1, v0y = triangle.y3 - triangle.y1, v1x = triangle.x2 - triangle.x1, v1y = triangle.y2 - triangle.y1, dot00 = v0x * v0x + v0y * v0y, dot01 = v0x * v1x + v0y * v1y, dot11 = v1x * v1x + v1y * v1y, b = dot00 * dot11 - dot01 * dot01, inv = 0 == b ? 0 : 1 / b, x1 = triangle.x1, y1 = triangle.y1, i = 0; i < points.length && (v = (dot00 * (u = v1x * (dot02 = points[i].x - x1) + v1y * (v = points[i].y - y1)) - dot01 * (dot02 = v0x * dot02 + v0y * v)) * inv, !(0 <= (u = (dot11 * dot02 - dot01 * u) * inv) && 0 <= v && u + v < 1 && (out.push({
        x: points[i].x,
        y: points[i].y
      }), returnFirst))); i++) {
        ;
      }

      return out;
    };
  }, function (module, exports) {
    module.exports = function (line, x, y, ty) {
      var c = Math.cos(ty),
          s = Math.sin(ty),
          tx = line.x1 - x,
          ty = line.y1 - y;
      return line.x1 = tx * c - ty * s + x, line.y1 = tx * s + ty * c + y, tx = line.x2 - x, ty = line.y2 - y, line.x2 = tx * c - ty * s + x, line.y2 = tx * s + ty * c + y, line;
    };
  }, function (module, exports) {
    module.exports = function (rect) {
      return 0 === rect.height ? NaN : rect.width / rect.height;
    };
  }, function (module, exports) {
    module.exports = function (triangle, x, y, ty) {
      var c = Math.cos(ty),
          s = Math.sin(ty),
          tx = triangle.x1 - x,
          ty = triangle.y1 - y;
      return triangle.x1 = tx * c - ty * s + x, triangle.y1 = tx * s + ty * c + y, tx = triangle.x2 - x, ty = triangle.y2 - y, triangle.x2 = tx * c - ty * s + x, triangle.y2 = tx * s + ty * c + y, tx = triangle.x3 - x, ty = triangle.y3 - y, triangle.x3 = tx * c - ty * s + x, triangle.y3 = tx * s + ty * c + y, triangle;
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      BUTTON_DOWN: __webpack_require__(1310),
      BUTTON_UP: __webpack_require__(1311),
      CONNECTED: __webpack_require__(1312),
      DISCONNECTED: __webpack_require__(1313),
      GAMEPAD_BUTTON_DOWN: __webpack_require__(1314),
      GAMEPAD_BUTTON_UP: __webpack_require__(1315)
    };
  }, function (module, exports, __webpack_require__) {
    var Extend = __webpack_require__(17),
        XHRSettings = __webpack_require__(156);

    module.exports = function (global, local) {
      var output = void 0 === global ? XHRSettings() : Extend({}, global);
      if (local) for (var setting in local) {
        void 0 !== local[setting] && (output[setting] = local[setting]);
      }
      return output;
    };
  }, function (module, exports, __webpack_require__) {
    var Class = __webpack_require__(0),
        CONST = __webpack_require__(21),
        File = __webpack_require__(23),
        FileTypesManager = __webpack_require__(8),
        GetFastValue = __webpack_require__(2),
        IsPlainObject = __webpack_require__(7),
        ParseXML = __webpack_require__(408),
        XMLFile = new Class({
      Extends: File,
      initialize: function initialize(loader, key, url, fileConfig) {
        var config,
            extension = "xml";
        IsPlainObject(key) && (key = GetFastValue(config = key, "key"), url = GetFastValue(config, "url"), fileConfig = GetFastValue(config, "xhrSettings"), extension = GetFastValue(config, "extension", extension));
        fileConfig = {
          type: "xml",
          cache: loader.cacheManager.xml,
          extension: extension,
          responseType: "text",
          key: key,
          url: url,
          xhrSettings: fileConfig
        };
        File.call(this, loader, fileConfig);
      },
      onProcess: function onProcess() {
        this.state = CONST.FILE_PROCESSING, this.data = ParseXML(this.xhrLoader.responseText), this.data ? this.onProcessComplete() : (console.warn("Invalid XMLFile: " + this.key), this.onProcessError());
      }
    });

    FileTypesManager.register("xml", function (key, url, xhrSettings) {
      if (Array.isArray(key)) for (var i = 0; i < key.length; i++) {
        this.addFile(new XMLFile(this, key[i]));
      } else this.addFile(new XMLFile(this, key, url, xhrSettings));
      return this;
    }), module.exports = XMLFile;
  }, function (module, exports, __webpack_require__) {
    var Class = __webpack_require__(0),
        CONST = __webpack_require__(21),
        File = __webpack_require__(23),
        FileTypesManager = __webpack_require__(8),
        GetFastValue = __webpack_require__(2),
        IsPlainObject = __webpack_require__(7),
        TextFile = new Class({
      Extends: File,
      initialize: function initialize(loader, key, url, xhrSettings) {
        var config,
            type = "text",
            extension = "txt",
            cache = loader.cacheManager.text;
        IsPlainObject(key) && (key = GetFastValue(config = key, "key"), url = GetFastValue(config, "url"), xhrSettings = GetFastValue(config, "xhrSettings"), extension = GetFastValue(config, "extension", extension), type = GetFastValue(config, "type", type), cache = GetFastValue(config, "cache", cache)), File.call(this, loader, {
          type: type,
          cache: cache,
          extension: extension,
          responseType: "text",
          key: key,
          url: url,
          xhrSettings: xhrSettings
        });
      },
      onProcess: function onProcess() {
        this.state = CONST.FILE_PROCESSING, this.data = this.xhrLoader.responseText, this.onProcessComplete();
      }
    });

    FileTypesManager.register("text", function (key, url, xhrSettings) {
      if (Array.isArray(key)) for (var i = 0; i < key.length; i++) {
        this.addFile(new TextFile(this, key[i]));
      } else this.addFile(new TextFile(this, key, url, xhrSettings));
      return this;
    }), module.exports = TextFile;
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      Acceleration: __webpack_require__(1368),
      Angular: __webpack_require__(1369),
      Bounce: __webpack_require__(1370),
      Debug: __webpack_require__(1371),
      Drag: __webpack_require__(1372),
      Enable: __webpack_require__(1373),
      Friction: __webpack_require__(1374),
      Gravity: __webpack_require__(1375),
      Immovable: __webpack_require__(1376),
      Mass: __webpack_require__(1377),
      OverlapCirc: __webpack_require__(523),
      OverlapRect: __webpack_require__(244),
      Pushable: __webpack_require__(1378),
      Size: __webpack_require__(1379),
      Velocity: __webpack_require__(1380)
    };
  }, function (module, exports) {
    module.exports = function (world, x, y, width, height, bodies, includeStatic) {
      void 0 === bodies && (bodies = !0), void 0 === includeStatic && (includeStatic = !1);
      var fakeBody,
          intersects,
          dynamicBodies = [],
          staticBodies = [],
          minMax = world.treeMinMax;
      return minMax.minX = x, minMax.minY = y, minMax.maxX = x + width, minMax.maxY = y + height, includeStatic && (staticBodies = world.staticTree.search(minMax)), bodies && world.useTree ? dynamicBodies = world.tree.search(minMax) : bodies && (bodies = world.bodies, fakeBody = {
        position: {
          x: x,
          y: y
        },
        left: x,
        top: y,
        right: x + width,
        bottom: y + height,
        isCircle: !1
      }, intersects = world.intersects, bodies.iterate(function (target) {
        intersects(target, fakeBody) && dynamicBodies.push(target);
      })), staticBodies.concat(dynamicBodies);
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      COLLIDE: __webpack_require__(1381),
      OVERLAP: __webpack_require__(1382),
      PAUSE: __webpack_require__(1383),
      RESUME: __webpack_require__(1384),
      TILE_COLLIDE: __webpack_require__(1385),
      TILE_OVERLAP: __webpack_require__(1386),
      WORLD_BOUNDS: __webpack_require__(1387),
      WORLD_STEP: __webpack_require__(1388)
    };
  }, function (module, exports, __webpack_require__) {
    var CONST = __webpack_require__(62);

    module.exports = function (body1, body2, overlapOnly, maxOverlap) {
      var overlap = 0,
          maxOverlap = body1.deltaAbsX() + body2.deltaAbsX() + maxOverlap;
      return 0 === body1._dx && 0 === body2._dx ? (body1.embedded = !0, body2.embedded = !0) : body1._dx > body2._dx ? maxOverlap < (overlap = body1.right - body2.x) && !overlapOnly || !1 === body1.checkCollision.right || !1 === body2.checkCollision.left ? overlap = 0 : (body1.touching.none = !1, body1.touching.right = !0, body2.touching.none = !1, body2.touching.left = !0, body2.physicsType !== CONST.STATIC_BODY || overlapOnly || (body1.blocked.none = !1, body1.blocked.right = !0), body1.physicsType !== CONST.STATIC_BODY || overlapOnly || (body2.blocked.none = !1, body2.blocked.left = !0)) : body1._dx < body2._dx && (maxOverlap < -(overlap = body1.x - body2.width - body2.x) && !overlapOnly || !1 === body1.checkCollision.left || !1 === body2.checkCollision.right ? overlap = 0 : (body1.touching.none = !1, body1.touching.left = !0, body2.touching.none = !1, body2.touching.right = !0, body2.physicsType !== CONST.STATIC_BODY || overlapOnly || (body1.blocked.none = !1, body1.blocked.left = !0), body1.physicsType !== CONST.STATIC_BODY || overlapOnly || (body2.blocked.none = !1, body2.blocked.right = !0))), body1.overlapX = overlap, body2.overlapX = overlap;
    };
  }, function (module, exports, __webpack_require__) {
    var CONST = __webpack_require__(62);

    module.exports = function (body1, body2, overlapOnly, maxOverlap) {
      var overlap = 0,
          maxOverlap = body1.deltaAbsY() + body2.deltaAbsY() + maxOverlap;
      return 0 === body1._dy && 0 === body2._dy ? (body1.embedded = !0, body2.embedded = !0) : body1._dy > body2._dy ? maxOverlap < (overlap = body1.bottom - body2.y) && !overlapOnly || !1 === body1.checkCollision.down || !1 === body2.checkCollision.up ? overlap = 0 : (body1.touching.none = !1, body1.touching.down = !0, body2.touching.none = !1, body2.touching.up = !0, body2.physicsType !== CONST.STATIC_BODY || overlapOnly || (body1.blocked.none = !1, body1.blocked.down = !0), body1.physicsType !== CONST.STATIC_BODY || overlapOnly || (body2.blocked.none = !1, body2.blocked.up = !0)) : body1._dy < body2._dy && (maxOverlap < -(overlap = body1.y - body2.bottom) && !overlapOnly || !1 === body1.checkCollision.up || !1 === body2.checkCollision.down ? overlap = 0 : (body1.touching.none = !1, body1.touching.up = !0, body2.touching.none = !1, body2.touching.down = !0, body2.physicsType !== CONST.STATIC_BODY || overlapOnly || (body1.blocked.none = !1, body1.blocked.up = !0), body1.physicsType !== CONST.STATIC_BODY || overlapOnly || (body2.blocked.none = !1, body2.blocked.down = !0))), body1.overlapY = overlap, body2.overlapY = overlap;
    };
  }, function (module, exports) {
    module.exports = function (tileWorldRect, body) {
      return !(body.right <= tileWorldRect.left || body.bottom <= tileWorldRect.top || body.position.x >= tileWorldRect.right || body.position.y >= tileWorldRect.bottom);
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      Bounce: __webpack_require__(1495),
      Collision: __webpack_require__(1496),
      Force: __webpack_require__(1497),
      Friction: __webpack_require__(1498),
      Gravity: __webpack_require__(1499),
      Mass: __webpack_require__(1500),
      Sensor: __webpack_require__(1501),
      SetBody: __webpack_require__(1502),
      Sleep: __webpack_require__(1503),
      Static: __webpack_require__(1520),
      Transform: __webpack_require__(1521),
      Velocity: __webpack_require__(1522)
    };
  }, function (module, exports) {
    var Pair = {};
    (module.exports = Pair).create = function (collision, timestamp) {
      var bodyA = collision.bodyA,
          pair = collision.bodyB,
          pair = {
        id: Pair.id(bodyA, pair),
        bodyA: bodyA,
        bodyB: pair,
        activeContacts: [],
        separation: 0,
        isActive: !0,
        confirmedActive: !0,
        isSensor: bodyA.isSensor || pair.isSensor,
        timeCreated: timestamp,
        timeUpdated: timestamp,
        collision: null,
        inverseMass: 0,
        friction: 0,
        frictionStatic: 0,
        restitution: 0,
        slop: 0
      };
      return Pair.update(pair, collision, timestamp), pair;
    }, Pair.update = function (pair, collision, timestamp) {
      if ((pair.collision = collision).collided) {
        var supports = collision.supports,
            activeContacts = pair.activeContacts,
            parentA = collision.parentA,
            supportCount = collision.parentB;
        pair.inverseMass = parentA.inverseMass + supportCount.inverseMass, pair.friction = Math.min(parentA.friction, supportCount.friction), pair.frictionStatic = Math.max(parentA.frictionStatic, supportCount.frictionStatic), pair.restitution = Math.max(parentA.restitution, supportCount.restitution), pair.slop = Math.max(parentA.slop, supportCount.slop);

        for (var i = 0; i < supports.length; i++) {
          activeContacts[i] = supports[i].contact;
        }

        supportCount = supports.length;
        supportCount < activeContacts.length && (activeContacts.length = supportCount), pair.separation = collision.depth, Pair.setActive(pair, !0, timestamp);
      } else !0 === pair.isActive && Pair.setActive(pair, !1, timestamp);
    }, Pair.setActive = function (pair, isActive, timestamp) {
      isActive ? (pair.isActive = !0, pair.timeUpdated = timestamp) : (pair.isActive = !1, pair.activeContacts.length = 0);
    }, Pair.id = function (bodyA, bodyB) {
      return bodyA.id < bodyB.id ? "A" + bodyA.id + "B" + bodyB.id : "A" + bodyB.id + "B" + bodyA.id;
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      CalculateFacesAt: __webpack_require__(252),
      CalculateFacesWithin: __webpack_require__(63),
      CheckIsoBounds: __webpack_require__(541),
      Copy: __webpack_require__(1420),
      CreateFromTiles: __webpack_require__(1421),
      CullBounds: __webpack_require__(543),
      CullTiles: __webpack_require__(544),
      Fill: __webpack_require__(1422),
      FilterTiles: __webpack_require__(1423),
      FindByIndex: __webpack_require__(1424),
      FindTile: __webpack_require__(1425),
      ForEachTile: __webpack_require__(1426),
      GetCullTilesFunction: __webpack_require__(1427),
      GetTileAt: __webpack_require__(158),
      GetTileAtWorldXY: __webpack_require__(1428),
      GetTilesWithin: __webpack_require__(26),
      GetTilesWithinShape: __webpack_require__(1429),
      GetTilesWithinWorldXY: __webpack_require__(529),
      GetTileToWorldXFunction: __webpack_require__(1430),
      GetTileToWorldXYFunction: __webpack_require__(1431),
      GetTileToWorldYFunction: __webpack_require__(1432),
      GetWorldToTileXFunction: __webpack_require__(1433),
      GetWorldToTileXYFunction: __webpack_require__(1434),
      GetWorldToTileYFunction: __webpack_require__(1435),
      HasTileAt: __webpack_require__(562),
      HasTileAtWorldXY: __webpack_require__(1436),
      HexagonalCullBounds: __webpack_require__(546),
      HexagonalCullTiles: __webpack_require__(545),
      HexagonalTileToWorldXY: __webpack_require__(550),
      HexagonalTileToWorldY: __webpack_require__(554),
      HexagonalWorldToTileXY: __webpack_require__(556),
      HexagonalWorldToTileY: __webpack_require__(560),
      IsInLayerBounds: __webpack_require__(119),
      IsometricCullTiles: __webpack_require__(547),
      IsometricTileToWorldXY: __webpack_require__(551),
      IsometricWorldToTileXY: __webpack_require__(557),
      PutTileAt: __webpack_require__(257),
      PutTileAtWorldXY: __webpack_require__(1437),
      PutTilesAt: __webpack_require__(1438),
      Randomize: __webpack_require__(1439),
      RemoveTileAt: __webpack_require__(563),
      RemoveTileAtWorldXY: __webpack_require__(1440),
      RenderDebug: __webpack_require__(1441),
      ReplaceByIndex: __webpack_require__(542),
      RunCull: __webpack_require__(159),
      SetCollision: __webpack_require__(1442),
      SetCollisionBetween: __webpack_require__(1443),
      SetCollisionByExclusion: __webpack_require__(1444),
      SetCollisionByProperty: __webpack_require__(1445),
      SetCollisionFromCollisionGroup: __webpack_require__(1446),
      SetLayerCollisionIndex: __webpack_require__(160),
      SetTileCollision: __webpack_require__(72),
      SetTileIndexCallback: __webpack_require__(1447),
      SetTileLocationCallback: __webpack_require__(1448),
      Shuffle: __webpack_require__(1449),
      StaggeredCullBounds: __webpack_require__(549),
      StaggeredCullTiles: __webpack_require__(548),
      StaggeredTileToWorldXY: __webpack_require__(552),
      StaggeredTileToWorldY: __webpack_require__(555),
      StaggeredWorldToTileXY: __webpack_require__(558),
      StaggeredWorldToTileY: __webpack_require__(561),
      SwapByIndex: __webpack_require__(1450),
      TileToWorldX: __webpack_require__(253),
      TileToWorldXY: __webpack_require__(553),
      TileToWorldY: __webpack_require__(254),
      WeightedRandomize: __webpack_require__(1451),
      WorldToTileX: __webpack_require__(255),
      WorldToTileXY: __webpack_require__(559),
      WorldToTileY: __webpack_require__(256)
    };
  }, function (module, exports, __webpack_require__) {
    var GetTileAt = __webpack_require__(158);

    module.exports = function (tileX, right, tileCollides) {
      var tile = GetTileAt(tileX, right, !0, tileCollides),
          above = GetTileAt(tileX, right - 1, !0, tileCollides),
          below = GetTileAt(tileX, right + 1, !0, tileCollides),
          left = GetTileAt(tileX - 1, right, !0, tileCollides),
          right = GetTileAt(tileX + 1, right, !0, tileCollides),
          tileCollides = tile && tile.collides;
      return tileCollides && (tile.faceTop = !0, tile.faceBottom = !0, tile.faceLeft = !0, tile.faceRight = !0), above && above.collides && (tileCollides && (tile.faceTop = !1), above.faceBottom = !tileCollides), below && below.collides && (tileCollides && (tile.faceBottom = !1), below.faceTop = !tileCollides), left && left.collides && (tileCollides && (tile.faceLeft = !1), left.faceRight = !tileCollides), right && right.collides && (tileCollides && (tile.faceRight = !1), right.faceLeft = !tileCollides), tile && !tile.collides && tile.resetFaces(), tile;
    };
  }, function (module, exports) {
    module.exports = function (tileX, camera, layerWorldX) {
      var tileWidth = layerWorldX.baseTileWidth,
          tilemapLayer = layerWorldX.tilemapLayer,
          layerWorldX = 0;
      return tilemapLayer && (camera = camera || tilemapLayer.scene.cameras.main, layerWorldX = tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX), tileWidth *= tilemapLayer.scaleX), layerWorldX + tileX * tileWidth;
    };
  }, function (module, exports) {
    module.exports = function (tileY, camera, layerWorldY) {
      var tileHeight = layerWorldY.baseTileHeight,
          tilemapLayer = layerWorldY.tilemapLayer,
          layerWorldY = 0;
      return tilemapLayer && (camera = camera || tilemapLayer.scene.cameras.main, layerWorldY = tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY), tileHeight *= tilemapLayer.scaleY), layerWorldY + tileY * tileHeight;
    };
  }, function (module, exports) {
    module.exports = function (worldX, snapToFloor, camera, tilemapLayer) {
      var tileWidth = tilemapLayer.baseTileWidth,
          tilemapLayer = tilemapLayer.tilemapLayer;
      return tilemapLayer && (camera = camera || tilemapLayer.scene.cameras.main, worldX -= tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX), tileWidth *= tilemapLayer.scaleX), (snapToFloor = void 0 === snapToFloor ? !0 : snapToFloor) ? Math.floor(worldX / tileWidth) : worldX / tileWidth;
    };
  }, function (module, exports) {
    module.exports = function (worldY, snapToFloor, camera, tilemapLayer) {
      var tileHeight = tilemapLayer.baseTileHeight,
          tilemapLayer = tilemapLayer.tilemapLayer;
      return tilemapLayer && (camera = camera || tilemapLayer.scene.cameras.main, worldY -= tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY), tileHeight *= tilemapLayer.scaleY), (snapToFloor = void 0 === snapToFloor ? !0 : snapToFloor) ? Math.floor(worldY / tileHeight) : worldY / tileHeight;
    };
  }, function (module, exports, __webpack_require__) {
    var Tile = __webpack_require__(85),
        IsInLayerBounds = __webpack_require__(119),
        CalculateFacesAt = __webpack_require__(252),
        SetTileCollision = __webpack_require__(72);

    module.exports = function (newTile, tileX, tileY, recalculateFaces, layer) {
      if (void 0 === recalculateFaces && (recalculateFaces = !0), !IsInLayerBounds(tileX, tileY, layer)) return null;
      var oldTileCollides = layer.data[tileY][tileX],
          oldTileCollides = oldTileCollides && oldTileCollides.collides;
      newTile instanceof Tile ? (null === layer.data[tileY][tileX] && (layer.data[tileY][tileX] = new Tile(layer, newTile.index, tileX, tileY, layer.tileWidth, layer.tileHeight)), layer.data[tileY][tileX].copy(newTile)) : (collides = newTile, null === layer.data[tileY][tileX] ? layer.data[tileY][tileX] = new Tile(layer, collides, tileX, tileY, layer.tileWidth, layer.tileHeight) : layer.data[tileY][tileX].index = collides);
      var newTile = layer.data[tileY][tileX],
          collides = -1 !== layer.collideIndexes.indexOf(newTile.index);
      return SetTileCollision(newTile, collides), recalculateFaces && oldTileCollides !== newTile.collides && CalculateFacesAt(tileX, tileY, layer), newTile;
    };
  }, function (module, exports, __webpack_require__) {
    var CONST = __webpack_require__(29);

    module.exports = function (orientation) {
      return "isometric" === (orientation = orientation.toLowerCase()) ? CONST.ISOMETRIC : "staggered" === orientation ? CONST.STAGGERED : "hexagonal" === orientation ? CONST.HEXAGONAL : CONST.ORTHOGONAL;
    };
  }, function (module, exports, __webpack_require__) {
    var Formats = __webpack_require__(40),
        LayerData = __webpack_require__(120),
        MapData = __webpack_require__(121),
        Tile = __webpack_require__(85);

    module.exports = function (height, data, tileWidth, tileHeight, insertNull) {
      for (var layerData = new LayerData({
        tileWidth: tileWidth,
        tileHeight: tileHeight
      }), mapData = new MapData({
        name: height,
        tileWidth: tileWidth,
        tileHeight: tileHeight,
        format: Formats.ARRAY_2D,
        layers: [layerData]
      }), tiles = [], height = data.length, width = 0, y = 0; y < data.length; y++) {
        tiles[y] = [];

        for (var row = data[y], x = 0; x < row.length; x++) {
          var tileIndex = parseInt(row[x], 10);
          isNaN(tileIndex) || -1 === tileIndex ? tiles[y][x] = insertNull ? null : new Tile(layerData, -1, x, y, tileWidth, tileHeight) : tiles[y][x] = new Tile(layerData, tileIndex, x, y, tileWidth, tileHeight);
        }

        0 === width && (width = row.length);
      }

      return mapData.width = layerData.width = width, mapData.height = layerData.height = height, mapData.widthInPixels = layerData.widthInPixels = width * tileWidth, mapData.heightInPixels = layerData.heightInPixels = height * tileHeight, layerData.data = tiles, mapData;
    };
  }, function (module, exports, __webpack_require__) {
    function copyPoints(p) {
      return {
        x: p.x,
        y: p.y
      };
    }

    var Pick = __webpack_require__(571),
        ParseGID = __webpack_require__(261),
        commonObjectProps = ["id", "name", "type", "rotation", "properties", "visible", "x", "y", "width", "height"];

    module.exports = function (tiledObject, offsetX, gidInfo) {
      void 0 === offsetX && (offsetX = 0), void 0 === gidInfo && (gidInfo = 0);
      var parsedObject = Pick(tiledObject, commonObjectProps);
      return parsedObject.x += offsetX, parsedObject.y += gidInfo, tiledObject.gid ? (gidInfo = ParseGID(tiledObject.gid), parsedObject.gid = gidInfo.gid, parsedObject.flippedHorizontal = gidInfo.flippedHorizontal, parsedObject.flippedVertical = gidInfo.flippedVertical, parsedObject.flippedAntiDiagonal = gidInfo.flippedAntiDiagonal) : tiledObject.polyline ? parsedObject.polyline = tiledObject.polyline.map(copyPoints) : tiledObject.polygon ? parsedObject.polygon = tiledObject.polygon.map(copyPoints) : tiledObject.ellipse ? parsedObject.ellipse = tiledObject.ellipse : tiledObject.text ? parsedObject.text = tiledObject.text : tiledObject.point ? parsedObject.point = !0 : parsedObject.rectangle = !0, parsedObject;
    };
  }, function (module, exports) {
    module.exports = function (gid) {
      var flippedHorizontal = Boolean(2147483648 & gid),
          flippedVertical = Boolean(1073741824 & gid),
          flippedAntiDiagonal = Boolean(536870912 & gid);
      gid &= 536870911;
      var rotation = 0,
          flipped = !1;
      return flippedHorizontal && flippedVertical && flippedAntiDiagonal ? (rotation = Math.PI / 2, flipped = !0) : flippedHorizontal && flippedVertical && !flippedAntiDiagonal ? (rotation = Math.PI, flipped = !1) : flippedHorizontal && !flippedVertical && flippedAntiDiagonal ? (rotation = Math.PI / 2, flipped = !1) : !flippedHorizontal || flippedVertical || flippedAntiDiagonal ? !flippedHorizontal && flippedVertical && flippedAntiDiagonal ? (rotation = 3 * Math.PI / 2, flipped = !1) : flippedHorizontal || !flippedVertical || flippedAntiDiagonal ? flippedHorizontal || flippedVertical || !flippedAntiDiagonal ? flippedHorizontal || flippedVertical || flippedAntiDiagonal || (rotation = 0, flipped = !1) : (rotation = 3 * Math.PI / 2, flipped = !0) : (rotation = Math.PI, flipped = !0) : flipped = !(rotation = 0), {
        gid: gid,
        flippedHorizontal: flippedHorizontal,
        flippedVertical: flippedVertical,
        flippedAntiDiagonal: flippedAntiDiagonal,
        rotation: rotation,
        flipped: flipped
      };
    };
  }, function (module, exports, __webpack_require__) {
    var Formats = __webpack_require__(40),
        MapData = __webpack_require__(121),
        Parse = __webpack_require__(564),
        Tilemap = __webpack_require__(580);

    module.exports = function (scene, key, tileWidth, tileHeight, width, height, tilemapData, insertNull) {
      void 0 === tileWidth && (tileWidth = 32), void 0 === tileHeight && (tileHeight = 32), void 0 === width && (width = 10), void 0 === height && (height = 10), void 0 === insertNull && (insertNull = !1);
      var mapData = null;
      return Array.isArray(tilemapData) ? mapData = Parse(void 0 !== key ? key : "map", Formats.ARRAY_2D, tilemapData, tileWidth, tileHeight, insertNull) : void 0 !== key && ((tilemapData = scene.cache.tilemap.get(key)) ? mapData = Parse(key, tilemapData.format, tilemapData.data, tileWidth, tileHeight, insertNull) : console.warn("No map data found for key " + key)), null === mapData && (mapData = new MapData({
        tileWidth: tileWidth,
        tileHeight: tileHeight,
        width: width,
        height: height
      })), new Tilemap(scene, mapData);
    };
  }, function (module, exports, __webpack_require__) {
    var GetValue = __webpack_require__(6);

    module.exports = function (targets) {
      targets = GetValue(targets, "targets", null);
      return null === targets ? targets : ("function" == typeof targets && (targets = targets.call()), Array.isArray(targets) ? targets : [targets]);
    };
  }, function (module, exports) {
    function hasGetActive(def) {
      return !!def.getActive && "function" == typeof def.getActive;
    }

    function hasGetStart(def) {
      return !!def.getStart && "function" == typeof def.getStart;
    }

    function hasGetEnd(def) {
      return !!def.getEnd && "function" == typeof def.getEnd;
    }

    function GetValueOp(fromCallbacks, propertyValue) {
      var callbacks,
          startCallbacks,
          getEnd = function getEnd(target, key, value) {
        return value;
      },
          getStart = function getStart(target, key, value) {
        return value;
      },
          getActive = null,
          hasFrom = _typeof(propertyValue);

      if ("number" == hasFrom) getEnd = function getEnd() {
        return propertyValue;
      };else if ("string" == hasFrom) {
        var hasTo = propertyValue[0],
            num = parseFloat(propertyValue.substr(2));

        switch (hasTo) {
          case "+":
            getEnd = function getEnd(target, key, value) {
              return value + num;
            };

            break;

          case "-":
            getEnd = function getEnd(target, key, value) {
              return value - num;
            };

            break;

          case "*":
            getEnd = function getEnd(target, key, value) {
              return value * num;
            };

            break;

          case "/":
            getEnd = function getEnd(target, key, value) {
              return value / num;
            };

            break;

          default:
            getEnd = function getEnd() {
              return parseFloat(propertyValue);
            };

        }
      } else "function" == hasFrom ? getEnd = propertyValue : "object" == hasFrom && (hasGetStart(startCallbacks = propertyValue) || hasGetEnd(startCallbacks) || hasGetActive(startCallbacks) ? (hasGetActive(propertyValue) && (getActive = propertyValue.getActive), hasGetEnd(propertyValue) && (getEnd = propertyValue.getEnd), hasGetStart(propertyValue) && (getStart = propertyValue.getStart)) : propertyValue.hasOwnProperty("value") ? callbacks = GetValueOp(fromCallbacks, propertyValue.value) : (hasTo = propertyValue.hasOwnProperty("to"), hasFrom = propertyValue.hasOwnProperty("from"), startCallbacks = propertyValue.hasOwnProperty("start"), hasTo && (hasFrom || startCallbacks) && (callbacks = GetValueOp(fromCallbacks, propertyValue.to), startCallbacks && (startCallbacks = GetValueOp(fromCallbacks, propertyValue.start), callbacks.getActive = startCallbacks.getEnd), hasFrom && (fromCallbacks = GetValueOp(fromCallbacks, propertyValue.from), callbacks.getStart = fromCallbacks.getEnd))));
      return callbacks = callbacks || {
        getActive: getActive,
        getEnd: getEnd,
        getStart: getStart
      };
    }

    module.exports = GetValueOp;
  }, function (module, exports) {
    module.exports = {
      targets: null,
      delay: 0,
      duration: 1e3,
      ease: "Power0",
      easeParams: null,
      hold: 0,
      repeat: 0,
      repeatDelay: 0,
      yoyo: !1,
      flipX: !1,
      flipY: !1
    };
  }, function (module, exports, __webpack_require__) {
    var Tween = __webpack_require__(0),
        EventEmitter = __webpack_require__(9),
        Events = __webpack_require__(267),
        GameObjectCreator = __webpack_require__(16),
        GameObjectFactory = __webpack_require__(5),
        TWEEN_CONST = __webpack_require__(100),
        MATH_CONST = __webpack_require__(14),
        Tween = new Tween({
      Extends: EventEmitter,
      initialize: function initialize(parent, data, targets) {
        EventEmitter.call(this), this.parent = parent, this.parentIsTimeline = parent.hasOwnProperty("isTimeline"), this.data = data, this.totalData = data.length, this.targets = targets, this.totalTargets = targets.length, this.useFrames = !1, this.timeScale = 1, this.loop = 0, this.loopDelay = 0, this.loopCounter = 0, this.startDelay = 0, this.hasStarted = !1, this.isSeeking = !1, this.completeDelay = 0, this.countdown = 0, this.offset = 0, this.calculatedOffset = 0, this.state = TWEEN_CONST.PENDING_ADD, this._pausedState = TWEEN_CONST.INIT, this.paused = !1, this.elapsed = 0, this.totalElapsed = 0, this.duration = 0, this.progress = 0, this.totalDuration = 0, this.totalProgress = 0, this.callbacks = {
          onActive: null,
          onComplete: null,
          onLoop: null,
          onRepeat: null,
          onStart: null,
          onStop: null,
          onUpdate: null,
          onYoyo: null
        }, this.callbackScope;
      },
      getValue: function getValue(index) {
        return this.data[index = void 0 === index ? 0 : index].current;
      },
      setTimeScale: function setTimeScale(value) {
        return this.timeScale = value, this;
      },
      getTimeScale: function getTimeScale() {
        return this.timeScale;
      },
      isPlaying: function isPlaying() {
        return this.state === TWEEN_CONST.ACTIVE;
      },
      isPaused: function isPaused() {
        return this.state === TWEEN_CONST.PAUSED;
      },
      hasTarget: function hasTarget(target) {
        return -1 !== this.targets.indexOf(target);
      },
      updateTo: function updateTo(key, value, startToCurrent) {
        void 0 === startToCurrent && (startToCurrent = !1);

        for (var i = 0; i < this.totalData; i++) {
          var tweenData = this.data[i];
          tweenData.key === key && (tweenData.end = value, startToCurrent && (tweenData.start = tweenData.current));
        }

        return this;
      },
      restart: function restart() {
        return this.elapsed = 0, this.progress = 0, this.totalElapsed = 0, this.totalProgress = 0, this.state === TWEEN_CONST.ACTIVE ? this.seek(0) : this.state === TWEEN_CONST.REMOVED ? (this.seek(0), this.parent.makeActive(this), this) : this.state === TWEEN_CONST.PENDING_ADD ? this : this.play();
      },
      calcDuration: function calcDuration() {
        for (var maxDuration = 0, minDelay = MATH_CONST.MAX_SAFE_INTEGER, data = this.data, i = 0; i < this.totalData; i++) {
          var tweenData = data[i];
          tweenData.t1 = tweenData.duration + tweenData.hold, tweenData.yoyo && (tweenData.t1 += tweenData.duration), tweenData.t2 = tweenData.t1 + tweenData.repeatDelay, tweenData.totalDuration = tweenData.delay + tweenData.t1, -1 === tweenData.repeat ? tweenData.totalDuration += 999999999999 * tweenData.t2 : 0 < tweenData.repeat && (tweenData.totalDuration += tweenData.t2 * tweenData.repeat), tweenData.totalDuration > maxDuration && (maxDuration = tweenData.totalDuration), tweenData.delay < minDelay && (minDelay = tweenData.delay);
        }

        this.duration = Math.max(maxDuration, .001), this.loopCounter = -1 === this.loop ? 999999999999 : this.loop, 0 < this.loopCounter ? this.totalDuration = this.duration + this.completeDelay + (this.duration + this.loopDelay) * this.loopCounter : this.totalDuration = this.duration + this.completeDelay, this.startDelay = minDelay;
      },
      init: function init() {
        if (this.paused && !this.parentIsTimeline) return this.state = TWEEN_CONST.PENDING_ADD, this._pausedState = TWEEN_CONST.INIT, !1;

        for (var data = this.data, totalTargets = this.totalTargets, i = 0; i < this.totalData; i++) {
          var tweenData = data[i],
              target = tweenData.target,
              gen = tweenData.gen,
              key = tweenData.key,
              targetIndex = tweenData.index;
          tweenData.delay = gen.delay(target, key, 0, targetIndex, totalTargets, this), tweenData.duration = Math.max(gen.duration(target, key, 0, targetIndex, totalTargets, this), .001), tweenData.hold = gen.hold(target, key, 0, targetIndex, totalTargets, this), tweenData.repeat = gen.repeat(target, key, 0, targetIndex, totalTargets, this), tweenData.repeatDelay = gen.repeatDelay(target, key, 0, targetIndex, totalTargets, this);
        }

        return this.calcDuration(), this.progress = 0, this.totalProgress = 0, this.elapsed = 0, this.totalElapsed = 0, this.state = TWEEN_CONST.INIT, !0;
      },
      makeActive: function makeActive() {
        this.parent.makeActive(this), this.dispatchTweenEvent(Events.TWEEN_ACTIVE, this.callbacks.onActive);
      },
      nextState: function nextState() {
        0 < this.loopCounter ? (this.elapsed = 0, this.progress = 0, this.loopCounter--, this.resetTweenData(!0), 0 < this.loopDelay ? (this.countdown = this.loopDelay, this.state = TWEEN_CONST.LOOP_DELAY) : (this.state = TWEEN_CONST.ACTIVE, this.dispatchTweenEvent(Events.TWEEN_LOOP, this.callbacks.onLoop))) : 0 < this.completeDelay ? (this.state = TWEEN_CONST.COMPLETE_DELAY, this.countdown = this.completeDelay) : (this.state = TWEEN_CONST.PENDING_REMOVE, this.dispatchTweenEvent(Events.TWEEN_COMPLETE, this.callbacks.onComplete));
      },
      pause: function pause() {
        return this.state === TWEEN_CONST.PAUSED || (this.paused = !0, this._pausedState = this.state, this.state = TWEEN_CONST.PAUSED), this;
      },
      play: function play(resetFromTimeline) {
        void 0 === resetFromTimeline && (resetFromTimeline = !1);
        var state = this.state;
        return state !== TWEEN_CONST.INIT || this.parentIsTimeline ? state === TWEEN_CONST.ACTIVE || state === TWEEN_CONST.PENDING_ADD && this._pausedState === TWEEN_CONST.PENDING_ADD || (this.parentIsTimeline || state !== TWEEN_CONST.PENDING_REMOVE && state !== TWEEN_CONST.REMOVED ? this.parentIsTimeline ? (this.resetTweenData(resetFromTimeline), 0 === this.calculatedOffset ? this.state = TWEEN_CONST.ACTIVE : (this.countdown = this.calculatedOffset, this.state = TWEEN_CONST.OFFSET_DELAY)) : (this.paused ? this.paused = !1 : (this.resetTweenData(resetFromTimeline), this.state = TWEEN_CONST.ACTIVE), this.makeActive()) : (this.seek(0), this.parent.makeActive(this))) : (this.resetTweenData(!1), this.state = TWEEN_CONST.ACTIVE), this;
      },
      resetTweenData: function resetTweenData(resetFromLoop) {
        for (var data = this.data, total = this.totalData, totalTargets = this.totalTargets, i = 0; i < total; i++) {
          var tweenData = data[i],
              target = tweenData.target,
              key = tweenData.key,
              targetIndex = tweenData.index;
          tweenData.progress = 0, tweenData.elapsed = 0, tweenData.repeatCounter = -1 === tweenData.repeat ? 999999999999 : tweenData.repeat, resetFromLoop ? (tweenData.start = tweenData.getStartValue(target, key, tweenData.start, targetIndex, totalTargets, this), tweenData.end = tweenData.getEndValue(target, key, tweenData.end, targetIndex, totalTargets, this), tweenData.current = tweenData.start, tweenData.state = TWEEN_CONST.PLAYING_FORWARD) : tweenData.state = TWEEN_CONST.PENDING_RENDER, 0 < tweenData.delay && (tweenData.elapsed = tweenData.delay, tweenData.state = TWEEN_CONST.DELAY), tweenData.getActiveValue && (target[key] = tweenData.getActiveValue(tweenData.target, tweenData.key, tweenData.start));
        }
      },
      resume: function resume() {
        return this.state === TWEEN_CONST.PAUSED ? (this.paused = !1, this.state = this._pausedState) : this.play(), this;
      },
      seek: function seek(toPosition, delta) {
        void 0 === delta && (delta = 16.6), this.state === TWEEN_CONST.REMOVED && this.makeActive(), this.elapsed = 0, this.progress = 0, this.totalElapsed = 0, this.totalProgress = 0;

        for (var data = this.data, totalTargets = this.totalTargets, i = 0; i < this.totalData; i++) {
          var tweenData = data[i],
              target = tweenData.target,
              gen = tweenData.gen,
              key = tweenData.key,
              targetIndex = tweenData.index;
          tweenData.progress = 0, tweenData.elapsed = 0, tweenData.repeatCounter = -1 === tweenData.repeat ? 999999999999 : tweenData.repeat, tweenData.delay = gen.delay(target, key, 0, targetIndex, totalTargets, this), tweenData.duration = Math.max(gen.duration(target, key, 0, targetIndex, totalTargets, this), .001), tweenData.hold = gen.hold(target, key, 0, targetIndex, totalTargets, this), tweenData.repeat = gen.repeat(target, key, 0, targetIndex, totalTargets, this), tweenData.repeatDelay = gen.repeatDelay(target, key, 0, targetIndex, totalTargets, this), tweenData.current = tweenData.start, tweenData.state = TWEEN_CONST.PLAYING_FORWARD, this.updateTweenData(this, tweenData, 0, targetIndex, totalTargets), 0 < tweenData.delay && (tweenData.elapsed = tweenData.delay, tweenData.state = TWEEN_CONST.DELAY);
        }

        this.calcDuration();
        var wasPaused = !1;

        for (this.state === TWEEN_CONST.PAUSED && (wasPaused = !0, this.state = TWEEN_CONST.ACTIVE), this.isSeeking = !0; this.update(0, delta), this.totalProgress < toPosition;) {
          ;
        }

        return this.isSeeking = !1, wasPaused && (this.state = TWEEN_CONST.PAUSED), this;
      },
      setCallback: function setCallback(type, callback, params, scope) {
        return this.callbacks[type] = {
          func: callback,
          scope: scope,
          params: params
        }, this;
      },
      complete: function complete(delay) {
        return (delay = void 0 === delay ? 0 : delay) ? (this.state = TWEEN_CONST.COMPLETE_DELAY, this.countdown = delay) : (this.state = TWEEN_CONST.PENDING_REMOVE, this.dispatchTweenEvent(Events.TWEEN_COMPLETE, this.callbacks.onComplete)), this;
      },
      remove: function remove() {
        return this.parent.remove(this), this;
      },
      stop: function stop(resetTo) {
        return this.state === TWEEN_CONST.ACTIVE && void 0 !== resetTo && this.seek(resetTo), this.state !== TWEEN_CONST.REMOVED && (this.state !== TWEEN_CONST.PAUSED && this.state !== TWEEN_CONST.PENDING_ADD || (this.parentIsTimeline ? (this.parent.manager._destroy.push(this), this.parent.manager._toProcess++) : (this.parent._destroy.push(this), this.parent._toProcess++)), this.dispatchTweenEvent(Events.TWEEN_STOP, this.callbacks.onStop), this.removeAllListeners(), this.state = TWEEN_CONST.PENDING_REMOVE), this;
      },
      update: function update(timestamp, delta) {
        if (this.state === TWEEN_CONST.PAUSED) return !1;

        switch (this.useFrames && (delta = +this.parent.timeScale), delta *= this.timeScale, this.elapsed += delta, this.progress = Math.min(this.elapsed / this.duration, 1), this.totalElapsed += delta, this.totalProgress = Math.min(this.totalElapsed / this.totalDuration, 1), this.state) {
          case TWEEN_CONST.ACTIVE:
            this.hasStarted || this.isSeeking || (this.startDelay -= delta, this.startDelay <= 0 && (this.hasStarted = !0, this.dispatchTweenEvent(Events.TWEEN_START, this.callbacks.onStart)));

            for (var stillRunning = !1, i = 0; i < this.totalData; i++) {
              var tweenData = this.data[i];
              this.updateTweenData(this, tweenData, delta) && (stillRunning = !0);
            }

            stillRunning || this.nextState();
            break;

          case TWEEN_CONST.LOOP_DELAY:
            this.countdown -= delta, this.countdown <= 0 && (this.state = TWEEN_CONST.ACTIVE, this.dispatchTweenEvent(Events.TWEEN_LOOP, this.callbacks.onLoop));
            break;

          case TWEEN_CONST.OFFSET_DELAY:
            this.countdown -= delta, this.countdown <= 0 && (this.state = TWEEN_CONST.ACTIVE);
            break;

          case TWEEN_CONST.COMPLETE_DELAY:
            this.countdown -= delta, this.countdown <= 0 && (this.state = TWEEN_CONST.PENDING_REMOVE, this.dispatchTweenEvent(Events.TWEEN_COMPLETE, this.callbacks.onComplete));
        }

        return this.state === TWEEN_CONST.PENDING_REMOVE;
      },
      dispatchTweenDataEvent: function dispatchTweenDataEvent(event, callback, tweenData) {
        this.isSeeking || (this.emit(event, this, tweenData.key, tweenData.target, tweenData.current, tweenData.previous), callback && (callback.params[1] = tweenData.target, callback.func.apply(callback.scope, callback.params)));
      },
      dispatchTweenEvent: function dispatchTweenEvent(event, callback) {
        this.isSeeking || (this.emit(event, this, this.targets), callback && (callback.params[1] = this.targets, callback.func.apply(callback.scope, callback.params)));
      },
      setStateFromEnd: function setStateFromEnd(tween, tweenData, diff) {
        return tweenData.yoyo ? (tweenData.elapsed = diff, tweenData.progress = diff / tweenData.duration, tweenData.flipX && tweenData.target.toggleFlipX(), tweenData.flipY && tweenData.target.toggleFlipY(), this.dispatchTweenDataEvent(Events.TWEEN_YOYO, tween.callbacks.onYoyo, tweenData), tweenData.start = tweenData.getStartValue(tweenData.target, tweenData.key, tweenData.start, tweenData.index, tween.totalTargets, tween), TWEEN_CONST.PLAYING_BACKWARD) : 0 < tweenData.repeatCounter ? (tweenData.repeatCounter--, tweenData.elapsed = diff, tweenData.progress = diff / tweenData.duration, tweenData.flipX && tweenData.target.toggleFlipX(), tweenData.flipY && tweenData.target.toggleFlipY(), tweenData.start = tweenData.getStartValue(tweenData.target, tweenData.key, tweenData.start, tweenData.index, tween.totalTargets, tween), tweenData.end = tweenData.getEndValue(tweenData.target, tweenData.key, tweenData.start, tweenData.index, tween.totalTargets, tween), 0 < tweenData.repeatDelay ? (tweenData.elapsed = tweenData.repeatDelay - diff, tweenData.current = tweenData.start, tweenData.target[tweenData.key] = tweenData.current, TWEEN_CONST.REPEAT_DELAY) : (this.dispatchTweenDataEvent(Events.TWEEN_REPEAT, tween.callbacks.onRepeat, tweenData), TWEEN_CONST.PLAYING_FORWARD)) : TWEEN_CONST.COMPLETE;
      },
      setStateFromStart: function setStateFromStart(tween, tweenData, diff) {
        return 0 < tweenData.repeatCounter ? (tweenData.repeatCounter--, tweenData.elapsed = diff, tweenData.progress = diff / tweenData.duration, tweenData.flipX && tweenData.target.toggleFlipX(), tweenData.flipY && tweenData.target.toggleFlipY(), tweenData.end = tweenData.getEndValue(tweenData.target, tweenData.key, tweenData.start, tweenData.index, tween.totalTargets, tween), 0 < tweenData.repeatDelay ? (tweenData.elapsed = tweenData.repeatDelay - diff, tweenData.current = tweenData.start, tweenData.target[tweenData.key] = tweenData.current, TWEEN_CONST.REPEAT_DELAY) : (this.dispatchTweenDataEvent(Events.TWEEN_REPEAT, tween.callbacks.onRepeat, tweenData), TWEEN_CONST.PLAYING_FORWARD)) : TWEEN_CONST.COMPLETE;
      },
      updateTweenData: function updateTweenData(tween, tweenData, delta) {
        var target = tweenData.target;

        switch (tweenData.state) {
          case TWEEN_CONST.PLAYING_FORWARD:
          case TWEEN_CONST.PLAYING_BACKWARD:
            if (!target) {
              tweenData.state = TWEEN_CONST.COMPLETE;
              break;
            }

            var elapsed = tweenData.elapsed,
                v = tweenData.duration,
                diff = 0;
            v < (elapsed += delta) && (diff = elapsed - v, elapsed = v);
            var forward = tweenData.state === TWEEN_CONST.PLAYING_FORWARD,
                v = elapsed / v;
            tweenData.elapsed = elapsed, tweenData.progress = v, tweenData.previous = tweenData.current, 1 == v ? forward ? (tweenData.current = tweenData.end, target[tweenData.key] = tweenData.end, 0 < tweenData.hold ? (tweenData.elapsed = tweenData.hold - diff, tweenData.state = TWEEN_CONST.HOLD_DELAY) : tweenData.state = this.setStateFromEnd(tween, tweenData, diff)) : (tweenData.current = tweenData.start, target[tweenData.key] = tweenData.start, tweenData.state = this.setStateFromStart(tween, tweenData, diff)) : (v = forward ? tweenData.ease(v) : tweenData.ease(1 - v), tweenData.current = tweenData.start + (tweenData.end - tweenData.start) * v, target[tweenData.key] = tweenData.current), this.dispatchTweenDataEvent(Events.TWEEN_UPDATE, tween.callbacks.onUpdate, tweenData);
            break;

          case TWEEN_CONST.DELAY:
            tweenData.elapsed -= delta, tweenData.elapsed <= 0 && (tweenData.elapsed = Math.abs(tweenData.elapsed), tweenData.state = TWEEN_CONST.PENDING_RENDER);
            break;

          case TWEEN_CONST.REPEAT_DELAY:
            tweenData.elapsed -= delta, tweenData.elapsed <= 0 && (tweenData.elapsed = Math.abs(tweenData.elapsed), tweenData.state = TWEEN_CONST.PLAYING_FORWARD, this.dispatchTweenDataEvent(Events.TWEEN_REPEAT, tween.callbacks.onRepeat, tweenData));
            break;

          case TWEEN_CONST.HOLD_DELAY:
            tweenData.elapsed -= delta, tweenData.elapsed <= 0 && (tweenData.state = this.setStateFromEnd(tween, tweenData, Math.abs(tweenData.elapsed)));
            break;

          case TWEEN_CONST.PENDING_RENDER:
            target ? (tweenData.start = tweenData.getStartValue(target, tweenData.key, target[tweenData.key], tweenData.index, tween.totalTargets, tween), tweenData.end = tweenData.getEndValue(target, tweenData.key, tweenData.start, tweenData.index, tween.totalTargets, tween), tweenData.current = tweenData.start, target[tweenData.key] = tweenData.start, tweenData.state = TWEEN_CONST.PLAYING_FORWARD) : tweenData.state = TWEEN_CONST.COMPLETE;
        }

        return tweenData.state !== TWEEN_CONST.COMPLETE;
      }
    });

    Tween.TYPES = ["onActive", "onComplete", "onLoop", "onRepeat", "onStart", "onStop", "onUpdate", "onYoyo"], GameObjectFactory.register("tween", function (config) {
      return this.scene.sys.tweens.add(config);
    }), GameObjectCreator.register("tween", function (config) {
      return this.scene.sys.tweens.create(config);
    }), module.exports = Tween;
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      TIMELINE_COMPLETE: __webpack_require__(1466),
      TIMELINE_LOOP: __webpack_require__(1467),
      TIMELINE_PAUSE: __webpack_require__(1468),
      TIMELINE_RESUME: __webpack_require__(1469),
      TIMELINE_START: __webpack_require__(1470),
      TIMELINE_UPDATE: __webpack_require__(1471),
      TWEEN_ACTIVE: __webpack_require__(1472),
      TWEEN_COMPLETE: __webpack_require__(1473),
      TWEEN_LOOP: __webpack_require__(1474),
      TWEEN_REPEAT: __webpack_require__(1475),
      TWEEN_START: __webpack_require__(1476),
      TWEEN_STOP: __webpack_require__(1477),
      TWEEN_UPDATE: __webpack_require__(1478),
      TWEEN_YOYO: __webpack_require__(1479)
    };
  }, function (module, exports) {
    module.exports = function (target, index, key, getEnd, getStart, getActive, ease, delay, duration, yoyo, hold, repeat, repeatDelay, flipX, flipY) {
      return {
        target: target,
        index: index,
        key: key,
        getActiveValue: getActive,
        getEndValue: getEnd,
        getStartValue: getStart,
        ease: ease,
        duration: 0,
        totalDuration: 0,
        delay: 0,
        yoyo: yoyo,
        hold: 0,
        repeat: 0,
        repeatDelay: 0,
        flipX: flipX,
        flipY: flipY,
        progress: 0,
        elapsed: 0,
        repeatCounter: 0,
        start: 0,
        previous: 0,
        current: 0,
        end: 0,
        t1: 0,
        t2: 0,
        gen: {
          delay: delay,
          duration: duration,
          hold: hold,
          repeat: repeat,
          repeatDelay: repeatDelay
        },
        state: 0
      };
    };
  }, function (module, exports, __webpack_require__) {
    var MathWrap = __webpack_require__(68);

    module.exports = function (angle) {
      return MathWrap(angle, -Math.PI, Math.PI);
    };
  }, function (module, exports, __webpack_require__) {
    var Wrap = __webpack_require__(68);

    module.exports = function (angle) {
      return Wrap(angle, -180, 180);
    };
  }, function (module, exports, __webpack_require__) {
    var Axes = {};
    module.exports = Axes;

    var Vector = __webpack_require__(83),
        Common = __webpack_require__(32);

    Axes.fromVertices = function (vertices) {
      for (var axes = {}, i = 0; i < vertices.length; i++) {
        var normal = (i + 1) % vertices.length,
            normal = Vector.normalise({
          x: vertices[normal].y - vertices[i].y,
          y: vertices[i].x - vertices[normal].x
        });
        axes[(0 === normal.y ? 1 / 0 : normal.x / normal.y).toFixed(3).toString()] = normal;
      }

      return Common.values(axes);
    }, Axes.rotate = function (axes, angle) {
      if (0 !== angle) for (var cos = Math.cos(angle), sin = Math.sin(angle), i = 0; i < axes.length; i++) {
        var axis = axes[i],
            xx = axis.x * cos - axis.y * sin;
        axis.y = axis.x * sin + axis.y * cos, axis.x = xx;
      }
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      AFTER_ADD: __webpack_require__(1504),
      AFTER_REMOVE: __webpack_require__(1505),
      AFTER_UPDATE: __webpack_require__(1506),
      BEFORE_ADD: __webpack_require__(1507),
      BEFORE_REMOVE: __webpack_require__(1508),
      BEFORE_UPDATE: __webpack_require__(1509),
      COLLISION_ACTIVE: __webpack_require__(1510),
      COLLISION_END: __webpack_require__(1511),
      COLLISION_START: __webpack_require__(1512),
      DRAG_END: __webpack_require__(1513),
      DRAG: __webpack_require__(1514),
      DRAG_START: __webpack_require__(1515),
      PAUSE: __webpack_require__(1516),
      RESUME: __webpack_require__(1517),
      SLEEP_END: __webpack_require__(1518),
      SLEEP_START: __webpack_require__(1519)
    };
  }, function (module, exports, __webpack_require__) {
    var Detector = {};
    module.exports = Detector;

    var SAT = __webpack_require__(274),
        Pair = __webpack_require__(250),
        Bounds = __webpack_require__(84);

    Detector.collisions = function (broadphasePairs, engine) {
      for (var collisions = [], pairsTable = engine.pairs.table, metrics = engine.metrics, i = 0; i < broadphasePairs.length; i++) {
        var bodyA = broadphasePairs[i][0],
            bodyB = broadphasePairs[i][1];
        if ((!bodyA.isStatic && !bodyA.isSleeping || !bodyB.isStatic && !bodyB.isSleeping) && Detector.canCollide(bodyA.collisionFilter, bodyB.collisionFilter) && (metrics.midphaseTests += 1, Bounds.overlaps(bodyA.bounds, bodyB.bounds))) for (var j = 1 < bodyA.parts.length ? 1 : 0; j < bodyA.parts.length; j++) {
          for (var partA = bodyA.parts[j], k = 1 < bodyB.parts.length ? 1 : 0; k < bodyB.parts.length; k++) {
            var collision,
                partB = bodyB.parts[k];
            (partA === bodyA && partB === bodyB || Bounds.overlaps(partA.bounds, partB.bounds)) && (collision = (collision = pairsTable[Pair.id(partA, partB)]) && collision.isActive ? collision.collision : null, collision = SAT.collides(partA, partB, collision), metrics.narrowphaseTests += 1, collision.reused && (metrics.narrowReuseCount += 1), collision.collided && (collisions.push(collision), metrics.narrowDetections += 1));
          }
        }
      }

      return collisions;
    }, Detector.canCollide = function (filterA, filterB) {
      return filterA.group === filterB.group && 0 !== filterA.group ? 0 < filterA.group : 0 != (filterA.mask & filterB.category) && 0 != (filterB.mask & filterA.category);
    };
  }, function (module, exports, __webpack_require__) {
    var SAT = {};
    module.exports = SAT;

    var Vertices = __webpack_require__(64),
        Vector = __webpack_require__(83);

    SAT.collides = function (verticesA, bodyB, previousCollision) {
      var parentA,
          collision,
          canReusePrevCol = !1;

      if (collision = previousCollision ? (parentA = verticesA.parent, collision = bodyB.parent, collision = parentA.speed * parentA.speed + parentA.angularSpeed * parentA.angularSpeed + collision.speed * collision.speed + collision.angularSpeed * collision.angularSpeed, canReusePrevCol = previousCollision && previousCollision.collided && collision < .2, previousCollision) : {
        collided: !1,
        bodyA: verticesA,
        bodyB: bodyB
      }, previousCollision && canReusePrevCol) {
        var supports = collision.axisBody,
            overlapAB = [supports.axes[previousCollision.axisNumber]],
            supports = SAT._overlapAxes(supports.vertices, (supports === verticesA ? bodyB : verticesA).vertices, overlapAB);

        if (collision.reused = !0, supports.overlap <= 0) return collision.collided = !1, collision;
      } else {
        if ((overlapAB = SAT._overlapAxes(verticesA.vertices, bodyB.vertices, verticesA.axes)).overlap <= 0) return collision.collided = !1, collision;
        if ((verticesB = SAT._overlapAxes(bodyB.vertices, verticesA.vertices, bodyB.axes)).overlap <= 0) return collision.collided = !1, collision;
        overlapAB.overlap < verticesB.overlap ? (supports = overlapAB, collision.axisBody = verticesA) : (supports = verticesB, collision.axisBody = bodyB), collision.axisNumber = supports.axisNumber;
      }

      collision.bodyA = verticesA.id < bodyB.id ? verticesA : bodyB, collision.bodyB = verticesA.id < bodyB.id ? bodyB : verticesA, collision.collided = !0, collision.depth = supports.overlap, collision.parentA = collision.bodyA.parent, collision.parentB = collision.bodyB.parent, verticesA = collision.bodyA, bodyB = collision.bodyB, Vector.dot(supports.axis, Vector.sub(bodyB.position, verticesA.position)) < 0 ? collision.normal = {
        x: supports.axis.x,
        y: supports.axis.y
      } : collision.normal = {
        x: -supports.axis.x,
        y: -supports.axis.y
      }, collision.tangent = Vector.perp(collision.normal), collision.penetration = collision.penetration || {}, collision.penetration.x = collision.normal.x * collision.depth, collision.penetration.y = collision.normal.y * collision.depth;

      var verticesB = SAT._findSupports(verticesA, bodyB, collision.normal),
          supports = [];

      return Vertices.contains(verticesA.vertices, verticesB[0]) && supports.push(verticesB[0]), Vertices.contains(verticesA.vertices, verticesB[1]) && supports.push(verticesB[1]), supports.length < 2 && (verticesA = SAT._findSupports(bodyB, verticesA, Vector.neg(collision.normal)), Vertices.contains(bodyB.vertices, verticesA[0]) && supports.push(verticesA[0]), supports.length < 2 && Vertices.contains(bodyB.vertices, verticesA[1]) && supports.push(verticesA[1])), supports.length < 1 && (supports = [verticesB[0]]), collision.supports = supports, collision;
    }, SAT._overlapAxes = function (verticesA, verticesB, axes) {
      for (var overlap, axis, projectionA = Vector._temp[0], projectionB = Vector._temp[1], result = {
        overlap: Number.MAX_VALUE
      }, i = 0; i < axes.length; i++) {
        if (axis = axes[i], SAT._projectToAxis(projectionA, verticesA, axis), SAT._projectToAxis(projectionB, verticesB, axis), (overlap = Math.min(projectionA.max - projectionB.min, projectionB.max - projectionA.min)) <= 0) return result.overlap = overlap, result;
        overlap < result.overlap && (result.overlap = overlap, result.axis = axis, result.axisNumber = i);
      }

      return result;
    }, SAT._projectToAxis = function (projection, vertices, axis) {
      for (var min = Vector.dot(vertices[0], axis), max = min, i = 1; i < vertices.length; i += 1) {
        var dot = Vector.dot(vertices[i], axis);
        max < dot ? max = dot : dot < min && (min = dot);
      }

      projection.min = min, projection.max = max;
    }, SAT._findSupports = function (vertexB, bodyB, normal) {
      for (var distance, vertexA, nearestDistance = Number.MAX_VALUE, vertexToBody = Vector._temp[0], vertices = bodyB.vertices, bodyAPosition = vertexB.position, i = 0; i < vertices.length; i++) {
        vertex = vertices[i], vertexToBody.x = vertex.x - bodyAPosition.x, vertexToBody.y = vertex.y - bodyAPosition.y, (distance = -Vector.dot(normal, vertexToBody)) < nearestDistance && (nearestDistance = distance, vertexA = vertex);
      }

      var vertex = vertices[0 <= vertexA.index - 1 ? vertexA.index - 1 : vertices.length - 1];
      vertexToBody.x = vertex.x - bodyAPosition.x, vertexToBody.y = vertex.y - bodyAPosition.y;
      nearestDistance = -Vector.dot(normal, vertexToBody), vertexB = vertex;
      return vertex = vertices[(vertexA.index + 1) % vertices.length], vertexToBody.x = vertex.x - bodyAPosition.x, vertexToBody.y = vertex.y - bodyAPosition.y, [vertexA, vertexB = (distance = -Vector.dot(normal, vertexToBody)) < nearestDistance ? vertex : vertexB];
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      AlignTo: __webpack_require__(601),
      Angle: __webpack_require__(602),
      Call: __webpack_require__(603),
      GetFirst: __webpack_require__(604),
      GetLast: __webpack_require__(605),
      GridAlign: __webpack_require__(606),
      IncAlpha: __webpack_require__(678),
      IncX: __webpack_require__(679),
      IncXY: __webpack_require__(680),
      IncY: __webpack_require__(681),
      PlaceOnCircle: __webpack_require__(682),
      PlaceOnEllipse: __webpack_require__(683),
      PlaceOnLine: __webpack_require__(684),
      PlaceOnRectangle: __webpack_require__(685),
      PlaceOnTriangle: __webpack_require__(686),
      PlayAnimation: __webpack_require__(687),
      PropertyValueInc: __webpack_require__(46),
      PropertyValueSet: __webpack_require__(27),
      RandomCircle: __webpack_require__(688),
      RandomEllipse: __webpack_require__(689),
      RandomLine: __webpack_require__(690),
      RandomRectangle: __webpack_require__(691),
      RandomTriangle: __webpack_require__(692),
      Rotate: __webpack_require__(693),
      RotateAround: __webpack_require__(694),
      RotateAroundDistance: __webpack_require__(695),
      ScaleX: __webpack_require__(696),
      ScaleXY: __webpack_require__(697),
      ScaleY: __webpack_require__(698),
      SetAlpha: __webpack_require__(699),
      SetBlendMode: __webpack_require__(700),
      SetDepth: __webpack_require__(701),
      SetHitArea: __webpack_require__(702),
      SetOrigin: __webpack_require__(703),
      SetRotation: __webpack_require__(704),
      SetScale: __webpack_require__(705),
      SetScaleX: __webpack_require__(706),
      SetScaleY: __webpack_require__(707),
      SetScrollFactor: __webpack_require__(708),
      SetScrollFactorX: __webpack_require__(709),
      SetScrollFactorY: __webpack_require__(710),
      SetTint: __webpack_require__(711),
      SetVisible: __webpack_require__(712),
      SetX: __webpack_require__(713),
      SetXY: __webpack_require__(714),
      SetY: __webpack_require__(715),
      ShiftPosition: __webpack_require__(716),
      Shuffle: __webpack_require__(717),
      SmootherStep: __webpack_require__(718),
      SmoothStep: __webpack_require__(719),
      Spread: __webpack_require__(720),
      ToggleVisible: __webpack_require__(721),
      WrapInRectangle: __webpack_require__(722)
    };
  }, function (module, exports, __webpack_require__) {
    var ALIGN_CONST = __webpack_require__(123),
        AlignToMap = [];

    AlignToMap[ALIGN_CONST.BOTTOM_CENTER] = __webpack_require__(277), AlignToMap[ALIGN_CONST.BOTTOM_LEFT] = __webpack_require__(278), AlignToMap[ALIGN_CONST.BOTTOM_RIGHT] = __webpack_require__(279), AlignToMap[ALIGN_CONST.LEFT_BOTTOM] = __webpack_require__(280), AlignToMap[ALIGN_CONST.LEFT_CENTER] = __webpack_require__(281), AlignToMap[ALIGN_CONST.LEFT_TOP] = __webpack_require__(282), AlignToMap[ALIGN_CONST.RIGHT_BOTTOM] = __webpack_require__(283), AlignToMap[ALIGN_CONST.RIGHT_CENTER] = __webpack_require__(284), AlignToMap[ALIGN_CONST.RIGHT_TOP] = __webpack_require__(285), AlignToMap[ALIGN_CONST.TOP_CENTER] = __webpack_require__(286), AlignToMap[ALIGN_CONST.TOP_LEFT] = __webpack_require__(287), AlignToMap[ALIGN_CONST.TOP_RIGHT] = __webpack_require__(288);

    module.exports = function (child, alignTo, position, offsetX, offsetY) {
      return AlignToMap[position](child, alignTo, offsetX, offsetY);
    };
  }, function (module, exports, __webpack_require__) {
    var GetBottom = __webpack_require__(42),
        GetCenterX = __webpack_require__(87),
        SetCenterX = __webpack_require__(88),
        SetTop = __webpack_require__(52);

    module.exports = function (gameObject, alignTo, offsetX, offsetY) {
      return void 0 === offsetX && (offsetX = 0), void 0 === offsetY && (offsetY = 0), SetCenterX(gameObject, GetCenterX(alignTo) + offsetX), SetTop(gameObject, GetBottom(alignTo) + offsetY), gameObject;
    };
  }, function (module, exports, __webpack_require__) {
    var GetBottom = __webpack_require__(42),
        GetLeft = __webpack_require__(43),
        SetLeft = __webpack_require__(53),
        SetTop = __webpack_require__(52);

    module.exports = function (gameObject, alignTo, offsetX, offsetY) {
      return void 0 === offsetX && (offsetX = 0), void 0 === offsetY && (offsetY = 0), SetLeft(gameObject, GetLeft(alignTo) - offsetX), SetTop(gameObject, GetBottom(alignTo) + offsetY), gameObject;
    };
  }, function (module, exports, __webpack_require__) {
    var GetBottom = __webpack_require__(42),
        GetRight = __webpack_require__(44),
        SetRight = __webpack_require__(54),
        SetTop = __webpack_require__(52);

    module.exports = function (gameObject, alignTo, offsetX, offsetY) {
      return void 0 === offsetX && (offsetX = 0), void 0 === offsetY && (offsetY = 0), SetRight(gameObject, GetRight(alignTo) + offsetX), SetTop(gameObject, GetBottom(alignTo) + offsetY), gameObject;
    };
  }, function (module, exports, __webpack_require__) {
    var GetBottom = __webpack_require__(42),
        GetLeft = __webpack_require__(43),
        SetBottom = __webpack_require__(55),
        SetRight = __webpack_require__(54);

    module.exports = function (gameObject, alignTo, offsetX, offsetY) {
      return void 0 === offsetX && (offsetX = 0), void 0 === offsetY && (offsetY = 0), SetRight(gameObject, GetLeft(alignTo) - offsetX), SetBottom(gameObject, GetBottom(alignTo) + offsetY), gameObject;
    };
  }, function (module, exports, __webpack_require__) {
    var GetCenterY = __webpack_require__(89),
        GetLeft = __webpack_require__(43),
        SetCenterY = __webpack_require__(90),
        SetRight = __webpack_require__(54);

    module.exports = function (gameObject, alignTo, offsetX, offsetY) {
      return void 0 === offsetX && (offsetX = 0), void 0 === offsetY && (offsetY = 0), SetRight(gameObject, GetLeft(alignTo) - offsetX), SetCenterY(gameObject, GetCenterY(alignTo) + offsetY), gameObject;
    };
  }, function (module, exports, __webpack_require__) {
    var GetLeft = __webpack_require__(43),
        GetTop = __webpack_require__(45),
        SetRight = __webpack_require__(54),
        SetTop = __webpack_require__(52);

    module.exports = function (gameObject, alignTo, offsetX, offsetY) {
      return void 0 === offsetX && (offsetX = 0), void 0 === offsetY && (offsetY = 0), SetRight(gameObject, GetLeft(alignTo) - offsetX), SetTop(gameObject, GetTop(alignTo) - offsetY), gameObject;
    };
  }, function (module, exports, __webpack_require__) {
    var GetBottom = __webpack_require__(42),
        GetRight = __webpack_require__(44),
        SetBottom = __webpack_require__(55),
        SetLeft = __webpack_require__(53);

    module.exports = function (gameObject, alignTo, offsetX, offsetY) {
      return void 0 === offsetX && (offsetX = 0), void 0 === offsetY && (offsetY = 0), SetLeft(gameObject, GetRight(alignTo) + offsetX), SetBottom(gameObject, GetBottom(alignTo) + offsetY), gameObject;
    };
  }, function (module, exports, __webpack_require__) {
    var GetCenterY = __webpack_require__(89),
        GetRight = __webpack_require__(44),
        SetCenterY = __webpack_require__(90),
        SetLeft = __webpack_require__(53);

    module.exports = function (gameObject, alignTo, offsetX, offsetY) {
      return void 0 === offsetX && (offsetX = 0), void 0 === offsetY && (offsetY = 0), SetLeft(gameObject, GetRight(alignTo) + offsetX), SetCenterY(gameObject, GetCenterY(alignTo) + offsetY), gameObject;
    };
  }, function (module, exports, __webpack_require__) {
    var GetRight = __webpack_require__(44),
        GetTop = __webpack_require__(45),
        SetLeft = __webpack_require__(53),
        SetTop = __webpack_require__(52);

    module.exports = function (gameObject, alignTo, offsetX, offsetY) {
      return void 0 === offsetX && (offsetX = 0), void 0 === offsetY && (offsetY = 0), SetLeft(gameObject, GetRight(alignTo) + offsetX), SetTop(gameObject, GetTop(alignTo) - offsetY), gameObject;
    };
  }, function (module, exports, __webpack_require__) {
    var GetCenterX = __webpack_require__(87),
        GetTop = __webpack_require__(45),
        SetBottom = __webpack_require__(55),
        SetCenterX = __webpack_require__(88);

    module.exports = function (gameObject, alignTo, offsetX, offsetY) {
      return void 0 === offsetX && (offsetX = 0), void 0 === offsetY && (offsetY = 0), SetCenterX(gameObject, GetCenterX(alignTo) + offsetX), SetBottom(gameObject, GetTop(alignTo) - offsetY), gameObject;
    };
  }, function (module, exports, __webpack_require__) {
    var GetLeft = __webpack_require__(43),
        GetTop = __webpack_require__(45),
        SetBottom = __webpack_require__(55),
        SetLeft = __webpack_require__(53);

    module.exports = function (gameObject, alignTo, offsetX, offsetY) {
      return void 0 === offsetX && (offsetX = 0), void 0 === offsetY && (offsetY = 0), SetLeft(gameObject, GetLeft(alignTo) - offsetX), SetBottom(gameObject, GetTop(alignTo) - offsetY), gameObject;
    };
  }, function (module, exports, __webpack_require__) {
    var GetRight = __webpack_require__(44),
        GetTop = __webpack_require__(45),
        SetBottom = __webpack_require__(55),
        SetRight = __webpack_require__(54);

    module.exports = function (gameObject, alignTo, offsetX, offsetY) {
      return void 0 === offsetX && (offsetX = 0), void 0 === offsetY && (offsetY = 0), SetRight(gameObject, GetRight(alignTo) + offsetX), SetBottom(gameObject, GetTop(alignTo) - offsetY), gameObject;
    };
  }, function (module, exports, __webpack_require__) {
    var ALIGN_CONST = __webpack_require__(123),
        AlignInMap = [];

    AlignInMap[ALIGN_CONST.BOTTOM_CENTER] = __webpack_require__(290), AlignInMap[ALIGN_CONST.BOTTOM_LEFT] = __webpack_require__(291), AlignInMap[ALIGN_CONST.BOTTOM_RIGHT] = __webpack_require__(292), AlignInMap[ALIGN_CONST.CENTER] = __webpack_require__(293), AlignInMap[ALIGN_CONST.LEFT_CENTER] = __webpack_require__(295), AlignInMap[ALIGN_CONST.RIGHT_CENTER] = __webpack_require__(296), AlignInMap[ALIGN_CONST.TOP_CENTER] = __webpack_require__(297), AlignInMap[ALIGN_CONST.TOP_LEFT] = __webpack_require__(298), AlignInMap[ALIGN_CONST.TOP_RIGHT] = __webpack_require__(299), AlignInMap[ALIGN_CONST.LEFT_BOTTOM] = AlignInMap[ALIGN_CONST.BOTTOM_LEFT], AlignInMap[ALIGN_CONST.LEFT_TOP] = AlignInMap[ALIGN_CONST.TOP_LEFT], AlignInMap[ALIGN_CONST.RIGHT_BOTTOM] = AlignInMap[ALIGN_CONST.BOTTOM_RIGHT], AlignInMap[ALIGN_CONST.RIGHT_TOP] = AlignInMap[ALIGN_CONST.TOP_RIGHT];

    module.exports = function (child, alignIn, position, offsetX, offsetY) {
      return AlignInMap[position](child, alignIn, offsetX, offsetY);
    };
  }, function (module, exports, __webpack_require__) {
    var GetBottom = __webpack_require__(42),
        GetCenterX = __webpack_require__(87),
        SetBottom = __webpack_require__(55),
        SetCenterX = __webpack_require__(88);

    module.exports = function (gameObject, alignIn, offsetX, offsetY) {
      return void 0 === offsetX && (offsetX = 0), void 0 === offsetY && (offsetY = 0), SetCenterX(gameObject, GetCenterX(alignIn) + offsetX), SetBottom(gameObject, GetBottom(alignIn) + offsetY), gameObject;
    };
  }, function (module, exports, __webpack_require__) {
    var GetBottom = __webpack_require__(42),
        GetLeft = __webpack_require__(43),
        SetBottom = __webpack_require__(55),
        SetLeft = __webpack_require__(53);

    module.exports = function (gameObject, alignIn, offsetX, offsetY) {
      return void 0 === offsetX && (offsetX = 0), void 0 === offsetY && (offsetY = 0), SetLeft(gameObject, GetLeft(alignIn) - offsetX), SetBottom(gameObject, GetBottom(alignIn) + offsetY), gameObject;
    };
  }, function (module, exports, __webpack_require__) {
    var GetBottom = __webpack_require__(42),
        GetRight = __webpack_require__(44),
        SetBottom = __webpack_require__(55),
        SetRight = __webpack_require__(54);

    module.exports = function (gameObject, alignIn, offsetX, offsetY) {
      return void 0 === offsetX && (offsetX = 0), void 0 === offsetY && (offsetY = 0), SetRight(gameObject, GetRight(alignIn) + offsetX), SetBottom(gameObject, GetBottom(alignIn) + offsetY), gameObject;
    };
  }, function (module, exports, __webpack_require__) {
    var CenterOn = __webpack_require__(294),
        GetCenterX = __webpack_require__(87),
        GetCenterY = __webpack_require__(89);

    module.exports = function (gameObject, alignIn, offsetX, offsetY) {
      return void 0 === offsetX && (offsetX = 0), void 0 === offsetY && (offsetY = 0), CenterOn(gameObject, GetCenterX(alignIn) + offsetX, GetCenterY(alignIn) + offsetY), gameObject;
    };
  }, function (module, exports, __webpack_require__) {
    var SetCenterX = __webpack_require__(88),
        SetCenterY = __webpack_require__(90);

    module.exports = function (gameObject, x, y) {
      return SetCenterX(gameObject, x), SetCenterY(gameObject, y);
    };
  }, function (module, exports, __webpack_require__) {
    var GetCenterY = __webpack_require__(89),
        GetLeft = __webpack_require__(43),
        SetCenterY = __webpack_require__(90),
        SetLeft = __webpack_require__(53);

    module.exports = function (gameObject, alignIn, offsetX, offsetY) {
      return void 0 === offsetX && (offsetX = 0), void 0 === offsetY && (offsetY = 0), SetLeft(gameObject, GetLeft(alignIn) - offsetX), SetCenterY(gameObject, GetCenterY(alignIn) + offsetY), gameObject;
    };
  }, function (module, exports, __webpack_require__) {
    var GetCenterY = __webpack_require__(89),
        GetRight = __webpack_require__(44),
        SetCenterY = __webpack_require__(90),
        SetRight = __webpack_require__(54);

    module.exports = function (gameObject, alignIn, offsetX, offsetY) {
      return void 0 === offsetX && (offsetX = 0), void 0 === offsetY && (offsetY = 0), SetRight(gameObject, GetRight(alignIn) + offsetX), SetCenterY(gameObject, GetCenterY(alignIn) + offsetY), gameObject;
    };
  }, function (module, exports, __webpack_require__) {
    var GetCenterX = __webpack_require__(87),
        GetTop = __webpack_require__(45),
        SetCenterX = __webpack_require__(88),
        SetTop = __webpack_require__(52);

    module.exports = function (gameObject, alignIn, offsetX, offsetY) {
      return void 0 === offsetX && (offsetX = 0), void 0 === offsetY && (offsetY = 0), SetCenterX(gameObject, GetCenterX(alignIn) + offsetX), SetTop(gameObject, GetTop(alignIn) - offsetY), gameObject;
    };
  }, function (module, exports, __webpack_require__) {
    var GetLeft = __webpack_require__(43),
        GetTop = __webpack_require__(45),
        SetLeft = __webpack_require__(53),
        SetTop = __webpack_require__(52);

    module.exports = function (gameObject, alignIn, offsetX, offsetY) {
      return void 0 === offsetX && (offsetX = 0), void 0 === offsetY && (offsetY = 0), SetLeft(gameObject, GetLeft(alignIn) - offsetX), SetTop(gameObject, GetTop(alignIn) - offsetY), gameObject;
    };
  }, function (module, exports, __webpack_require__) {
    var GetRight = __webpack_require__(44),
        GetTop = __webpack_require__(45),
        SetRight = __webpack_require__(54),
        SetTop = __webpack_require__(52);

    module.exports = function (gameObject, alignIn, offsetX, offsetY) {
      return void 0 === offsetX && (offsetX = 0), void 0 === offsetY && (offsetY = 0), SetRight(gameObject, GetRight(alignIn) + offsetX), SetTop(gameObject, GetTop(alignIn) - offsetY), gameObject;
    };
  }, function (module, exports, __webpack_require__) {
    var CircumferencePoint = __webpack_require__(169),
        FromPercent = __webpack_require__(98),
        MATH_CONST = __webpack_require__(14),
        Point = __webpack_require__(4);

    module.exports = function (circle, angle, out) {
      void 0 === out && (out = new Point());
      angle = FromPercent(angle, 0, MATH_CONST.PI2);
      return CircumferencePoint(circle, angle, out);
    };
  }, function (module, exports, __webpack_require__) {
    var Circumference = __webpack_require__(302),
        CircumferencePoint = __webpack_require__(169),
        FromPercent = __webpack_require__(98),
        MATH_CONST = __webpack_require__(14);

    module.exports = function (circle, quantity, stepRate, out) {
      void 0 === out && (out = []), !quantity && 0 < stepRate && (quantity = Circumference(circle) / stepRate);

      for (var i = 0; i < quantity; i++) {
        var angle = FromPercent(i / quantity, 0, MATH_CONST.PI2);
        out.push(CircumferencePoint(circle, angle));
      }

      return out;
    };
  }, function (module, exports) {
    module.exports = function (circle) {
      return Math.PI * circle.radius * 2;
    };
  }, function (module, exports, __webpack_require__) {
    var Clamp = __webpack_require__(18);

    module.exports = {
      _alpha: 1,
      clearAlpha: function clearAlpha() {
        return this.setAlpha(1);
      },
      setAlpha: function setAlpha(value) {
        return this.alpha = value = void 0 === value ? 1 : value, this;
      },
      alpha: {
        get: function get() {
          return this._alpha;
        },
        set: function set(v) {
          v = Clamp(v, 0, 1);
          0 === (this._alpha = v) ? this.renderFlags &= -3 : this.renderFlags |= 2;
        }
      }
    };
  }, function (module, exports, BlendMode) {
    var BlendModes = BlendMode(35),
        BlendMode = {
      _blendMode: BlendModes.NORMAL,
      blendMode: {
        get: function get() {
          return this._blendMode;
        },
        set: function set(value) {
          "string" == typeof value && (value = BlendModes[value]), -1 <= (value |= 0) && (this._blendMode = value);
        }
      },
      setBlendMode: function setBlendMode(value) {
        return this.blendMode = value, this;
      }
    };
    module.exports = BlendMode;
  }, function (module, exports) {
    module.exports = {
      _depth: 0,
      depth: {
        get: function get() {
          return this._depth;
        },
        set: function set(value) {
          this.displayList && this.displayList.queueDepthSort(), this._depth = value;
        }
      },
      setDepth: function setDepth(value) {
        return this.depth = value = void 0 === value ? 0 : value, this;
      }
    };
  }, function (module, exports, __webpack_require__) {
    var GetPoint = __webpack_require__(171),
        Perimeter = __webpack_require__(130);

    module.exports = function (rectangle, quantity, stepRate, out) {
      void 0 === out && (out = []), !quantity && 0 < stepRate && (quantity = Perimeter(rectangle) / stepRate);

      for (var i = 0; i < quantity; i++) {
        out.push(GetPoint(rectangle, i / quantity));
      }

      return out;
    };
  }, function (module, exports, __webpack_require__) {
    var Point = __webpack_require__(4);

    module.exports = function (line, position, out) {
      return (out = void 0 === out ? new Point() : out).x = line.x1 + (line.x2 - line.x1) * position, out.y = line.y1 + (line.y2 - line.y1) * position, out;
    };
  }, function (module, exports) {
    module.exports = function (point, x, y, ty) {
      var c = Math.cos(ty),
          s = Math.sin(ty),
          tx = point.x - x,
          ty = point.y - y;
      return point.x = tx * c - ty * s + x, point.y = tx * s + ty * c + y, point;
    };
  }, function (module, exports, __webpack_require__) {
    var BitmapMask = __webpack_require__(310),
        GeometryMask = __webpack_require__(311);

    module.exports = {
      mask: null,
      setMask: function setMask(mask) {
        return this.mask = mask, this;
      },
      clearMask: function clearMask(destroyMask) {
        return (destroyMask = void 0 === destroyMask ? !1 : destroyMask) && this.mask && this.mask.destroy(), this.mask = null, this;
      },
      createBitmapMask: function createBitmapMask(renderable) {
        return void 0 === renderable && (this.texture || this.shader) && (renderable = this), new BitmapMask(this.scene, renderable);
      },
      createGeometryMask: function createGeometryMask(graphics) {
        return void 0 === graphics && "Graphics" === this.type && (graphics = this), new GeometryMask(this.scene, graphics);
      }
    };
  }, function (module, exports, __webpack_require__) {
    var BitmapMask = __webpack_require__(0),
        GameEvents = __webpack_require__(22),
        RenderEvents = __webpack_require__(91),
        BitmapMask = new BitmapMask({
      initialize: function initialize(scene, renderable) {
        var renderer = scene.sys.renderer;
        this.renderer = renderer, this.bitmapMask = renderable, this.maskTexture = null, this.mainTexture = null, this.dirty = !0, this.mainFramebuffer = null, this.maskFramebuffer = null, this.invertAlpha = !1, this.isStencil = !1, this.createMask(), scene.sys.game.events.on(GameEvents.CONTEXT_RESTORED, this.createMask, this), renderer && renderer.on(RenderEvents.RESIZE, this.createMask, this);
      },
      createMask: function createMask() {
        var width,
            height,
            gl,
            wrap,
            filter,
            renderer = this.renderer;
        renderer && renderer.gl && (this.mainTexture && this.clearMask(), width = renderer.width, height = renderer.height, gl = renderer.gl, wrap = 0 == (width & width - 1) && 0 == (height & height - 1) ? gl.REPEAT : gl.CLAMP_TO_EDGE, filter = gl.LINEAR, this.mainTexture = renderer.createTexture2D(0, filter, filter, wrap, wrap, gl.RGBA, null, width, height), this.maskTexture = renderer.createTexture2D(0, filter, filter, wrap, wrap, gl.RGBA, null, width, height), this.mainFramebuffer = renderer.createFramebuffer(width, height, this.mainTexture, !0), this.maskFramebuffer = renderer.createFramebuffer(width, height, this.maskTexture, !0));
      },
      clearMask: function clearMask() {
        var renderer = this.renderer;
        renderer && renderer.gl && this.mainTexture && (renderer.deleteTexture(this.mainTexture), renderer.deleteTexture(this.maskTexture), renderer.deleteFramebuffer(this.mainFramebuffer), renderer.deleteFramebuffer(this.maskFramebuffer), this.mainTexture = null, this.maskTexture = null, this.mainFramebuffer = null, this.maskFramebuffer = null);
      },
      setBitmap: function setBitmap(renderable) {
        this.bitmapMask = renderable;
      },
      preRenderWebGL: function preRenderWebGL(renderer, maskedObject, camera) {
        renderer.pipelines.BITMAPMASK_PIPELINE.beginMask(this, maskedObject, camera);
      },
      postRenderWebGL: function postRenderWebGL(renderer, camera) {
        renderer.pipelines.BITMAPMASK_PIPELINE.endMask(this, camera);
      },
      preRenderCanvas: function preRenderCanvas() {},
      postRenderCanvas: function postRenderCanvas() {},
      destroy: function destroy() {
        this.clearMask(), this.renderer && this.renderer.off(RenderEvents.RESIZE, this.createMask, this), this.bitmapMask = null, this.prevFramebuffer = null, this.renderer = null;
      }
    });

    module.exports = BitmapMask;
  }, function (module, exports, GeometryMask) {
    GeometryMask = new (GeometryMask(0))({
      initialize: function initialize(scene, graphicsGeometry) {
        this.geometryMask = graphicsGeometry, this.invertAlpha = !1, this.isStencil = !0, this.level = 0;
      },
      setShape: function setShape(graphicsGeometry) {
        return this.geometryMask = graphicsGeometry, this;
      },
      setInvertAlpha: function setInvertAlpha(value) {
        return this.invertAlpha = value = void 0 === value ? !0 : value, this;
      },
      preRenderWebGL: function preRenderWebGL(renderer, child, camera) {
        var gl = renderer.gl;
        renderer.flush(), 0 === renderer.maskStack.length && (gl.enable(gl.STENCIL_TEST), gl.clear(gl.STENCIL_BUFFER_BIT), renderer.maskCount = 0), renderer.currentCameraMask.mask !== this && (renderer.currentMask.mask = this), renderer.maskStack.push({
          mask: this,
          camera: camera
        }), this.applyStencil(renderer, camera, !0), renderer.maskCount++;
      },
      applyStencil: function applyStencil(renderer, camera, inc) {
        var gl = renderer.gl,
            geometryMask = this.geometryMask,
            level = renderer.maskCount;
        gl.colorMask(!1, !1, !1, !1), inc ? (gl.stencilFunc(gl.EQUAL, level, 255), gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR)) : (gl.stencilFunc(gl.EQUAL, level + 1, 255), gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR)), geometryMask.renderWebGL(renderer, geometryMask, camera), renderer.flush(), gl.colorMask(!0, !0, !0, !0), gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP), inc ? this.invertAlpha ? gl.stencilFunc(gl.NOTEQUAL, level + 1, 255) : gl.stencilFunc(gl.EQUAL, level + 1, 255) : this.invertAlpha ? gl.stencilFunc(gl.NOTEQUAL, level, 255) : gl.stencilFunc(gl.EQUAL, level, 255);
      },
      postRenderWebGL: function postRenderWebGL(renderer) {
        var prev = renderer.gl;
        renderer.maskStack.pop(), renderer.maskCount--, renderer.flush();
        var current = renderer.currentMask;
        0 === renderer.maskStack.length ? (current.mask = null, prev.disable(prev.STENCIL_TEST)) : ((prev = renderer.maskStack[renderer.maskStack.length - 1]).mask.applyStencil(renderer, prev.camera, !1), renderer.currentCameraMask.mask !== prev.mask ? (current.mask = prev.mask, current.camera = prev.camera) : current.mask = null);
      },
      preRenderCanvas: function preRenderCanvas(renderer, mask, camera) {
        var geometryMask = this.geometryMask;
        renderer.currentContext.save(), geometryMask.renderCanvas(renderer, geometryMask, camera, null, null, !0), renderer.currentContext.clip();
      },
      postRenderCanvas: function postRenderCanvas(renderer) {
        renderer.currentContext.restore();
      },
      destroy: function destroy() {
        this.geometryMask = null;
      }
    });
    module.exports = GeometryMask;
  }, function (module, exports) {
    module.exports = {
      scrollFactorX: 1,
      scrollFactorY: 1,
      setScrollFactor: function setScrollFactor(x, y) {
        return void 0 === y && (y = x), this.scrollFactorX = x, this.scrollFactorY = y, this;
      }
    };
  }, function (module, exports, __webpack_require__) {
    var MATH_CONST = __webpack_require__(14),
        TransformMatrix = __webpack_require__(25),
        TransformXY = __webpack_require__(177),
        WrapAngle = __webpack_require__(269),
        WrapAngleDegrees = __webpack_require__(270),
        Vector2 = __webpack_require__(3);

    module.exports = {
      _scaleX: 1,
      _scaleY: 1,
      _rotation: 0,
      x: 0,
      y: 0,
      z: 0,
      w: 0,
      scale: {
        get: function get() {
          return (this._scaleX + this._scaleY) / 2;
        },
        set: function set(value) {
          this._scaleX = value, 0 === (this._scaleY = value) ? this.renderFlags &= -5 : this.renderFlags |= 4;
        }
      },
      scaleX: {
        get: function get() {
          return this._scaleX;
        },
        set: function set(value) {
          0 === (this._scaleX = value) ? this.renderFlags &= -5 : this.renderFlags |= 4;
        }
      },
      scaleY: {
        get: function get() {
          return this._scaleY;
        },
        set: function set(value) {
          0 === (this._scaleY = value) ? this.renderFlags &= -5 : this.renderFlags |= 4;
        }
      },
      angle: {
        get: function get() {
          return WrapAngleDegrees(this._rotation * MATH_CONST.RAD_TO_DEG);
        },
        set: function set(value) {
          this.rotation = WrapAngleDegrees(value) * MATH_CONST.DEG_TO_RAD;
        }
      },
      rotation: {
        get: function get() {
          return this._rotation;
        },
        set: function set(value) {
          this._rotation = WrapAngle(value);
        }
      },
      setPosition: function setPosition(x, y, z, w) {
        return void 0 === x && (x = 0), void 0 === y && (y = x), void 0 === z && (z = 0), void 0 === w && (w = 0), this.x = x, this.y = y, this.z = z, this.w = w, this;
      },
      copyPosition: function copyPosition(source) {
        return void 0 !== source.x && (this.x = source.x), void 0 !== source.y && (this.y = source.y), void 0 !== source.z && (this.z = source.z), void 0 !== source.w && (this.w = source.w), this;
      },
      setRandomPosition: function setRandomPosition(x, y, width, height) {
        return void 0 === y && (y = 0), void 0 === width && (width = this.scene.sys.scale.width), void 0 === height && (height = this.scene.sys.scale.height), this.x = (x = void 0 === x ? 0 : x) + Math.random() * width, this.y = y + Math.random() * height, this;
      },
      setRotation: function setRotation(radians) {
        return this.rotation = radians = void 0 === radians ? 0 : radians, this;
      },
      setAngle: function setAngle(degrees) {
        return this.angle = degrees = void 0 === degrees ? 0 : degrees, this;
      },
      setScale: function setScale(x, y) {
        return void 0 === x && (x = 1), void 0 === y && (y = x), this.scaleX = x, this.scaleY = y, this;
      },
      setX: function setX(value) {
        return this.x = value = void 0 === value ? 0 : value, this;
      },
      setY: function setY(value) {
        return this.y = value = void 0 === value ? 0 : value, this;
      },
      setZ: function setZ(value) {
        return this.z = value = void 0 === value ? 0 : value, this;
      },
      setW: function setW(value) {
        return this.w = value = void 0 === value ? 0 : value, this;
      },
      getLocalTransformMatrix: function getLocalTransformMatrix(tempMatrix) {
        return (tempMatrix = void 0 === tempMatrix ? new TransformMatrix() : tempMatrix).applyITRS(this.x, this.y, this._rotation, this._scaleX, this._scaleY);
      },
      getWorldTransformMatrix: function getWorldTransformMatrix(tempMatrix, parentMatrix) {
        void 0 === tempMatrix && (tempMatrix = new TransformMatrix()), void 0 === parentMatrix && (parentMatrix = new TransformMatrix());
        var parent = this.parentContainer;
        if (!parent) return this.getLocalTransformMatrix(tempMatrix);

        for (tempMatrix.applyITRS(this.x, this.y, this._rotation, this._scaleX, this._scaleY); parent;) {
          parentMatrix.applyITRS(parent.x, parent.y, parent._rotation, parent._scaleX, parent._scaleY), parentMatrix.multiply(tempMatrix, tempMatrix), parent = parent.parentContainer;
        }

        return tempMatrix;
      },
      getLocalPoint: function getLocalPoint(x, y, point, py) {
        point = point || new Vector2();
        var px = (py = py || this.scene.sys.cameras.main).scrollX,
            py = py.scrollY,
            px = x + px * this.scrollFactorX - px,
            py = y + py * this.scrollFactorY - py;
        return this.parentContainer ? this.getWorldTransformMatrix().applyInverse(px, py, point) : TransformXY(px, py, this.x, this.y, this.rotation, this.scaleX, this.scaleY, point), this._originComponent && (point.x += this._displayOriginX, point.y += this._displayOriginY), point;
      },
      getParentRotation: function getParentRotation() {
        for (var rotation = 0, parent = this.parentContainer; parent;) {
          rotation += parent.rotation, parent = parent.parentContainer;
        }

        return rotation;
      }
    };
  }, function (module, exports) {
    module.exports = {
      _visible: !0,
      visible: {
        get: function get() {
          return this._visible;
        },
        set: function set(value) {
          value ? (this._visible = !0, this.renderFlags |= 1) : (this._visible = !1, this.renderFlags &= -2);
        }
      },
      setVisible: function setVisible(value) {
        return this.visible = value, this;
      }
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      CHANGE_DATA: __webpack_require__(638),
      CHANGE_DATA_KEY: __webpack_require__(639),
      DESTROY: __webpack_require__(640),
      REMOVE_DATA: __webpack_require__(641),
      SET_DATA: __webpack_require__(642)
    };
  }, function (module, exports, __webpack_require__) {
    var Perimeter = __webpack_require__(130),
        Point = __webpack_require__(4);

    module.exports = function (rect, step, quantity, out) {
      if (void 0 === out && (out = []), !step && !quantity) return out;
      step ? quantity = Math.round(Perimeter(rect) / step) : step = Perimeter(rect) / quantity;

      for (var x = rect.x, y = rect.y, face = 0, i = 0; i < quantity; i++) {
        switch (out.push(new Point(x, y)), face) {
          case 0:
            (x += step) >= rect.right && (face = 1, y += x - rect.right, x = rect.right);
            break;

          case 1:
            (y += step) >= rect.bottom && (face = 2, x -= y - rect.bottom, y = rect.bottom);
            break;

          case 2:
            (x -= step) <= rect.left && (face = 3, y -= rect.left - x, x = rect.left);
            break;

          case 3:
            (y -= step) <= rect.top && (face = 0, y = rect.top);
        }
      }

      return out;
    };
  }, function (module, exports) {
    module.exports = function (line, stepRate, results) {
      void 0 === stepRate && (stepRate = 1), void 0 === results && (results = []);
      var x1 = Math.round(line.x1),
          y1 = Math.round(line.y1),
          x2 = Math.round(line.x2),
          y2 = Math.round(line.y2),
          dx = Math.abs(x2 - x1),
          dy = Math.abs(y2 - y1),
          sx = x1 < x2 ? 1 : -1,
          sy = y1 < y2 ? 1 : -1,
          err = dx - dy;
      results.push({
        x: x1,
        y: y1
      });

      for (var i = 1; x1 !== x2 || y1 !== y2;) {
        var e2 = err << 1;
        -dy < e2 && (err -= dy, x1 += sx), e2 < dx && (err += dx, y1 += sy), i % stepRate == 0 && results.push({
          x: x1,
          y: y1
        }), i++;
      }

      return results;
    };
  }, function (module, exports) {
    module.exports = function (value, array, key) {
      if (!array.length) return NaN;
      if (1 === array.length) return array[0];
      var low,
          high,
          i = 1;

      if (key) {
        if (value < array[0][key]) return array[0];

        for (; array[i][key] < value;) {
          i++;
        }
      } else for (; array[i] < value;) {
        i++;
      }

      return i > array.length && (i = array.length), key ? (low = array[i - 1][key], (high = array[i][key]) - value <= value - low ? array[i] : array[i - 1]) : (low = array[i - 1], (high = array[i]) - value <= value - low ? high : low);
    };
  }, function (module, exports, AnimationFrame) {
    AnimationFrame = new (AnimationFrame(0))({
      initialize: function initialize(textureKey, textureFrame, index, frame, isKeyFrame) {
        void 0 === isKeyFrame && (isKeyFrame = !1), this.textureKey = textureKey, this.textureFrame = textureFrame, this.index = index, this.frame = frame, this.isFirst = !1, this.isLast = !1, this.prevFrame = null, this.nextFrame = null, this.duration = 0, this.progress = 0, this.isKeyFrame = isKeyFrame;
      },
      toJSON: function toJSON() {
        return {
          key: this.textureKey,
          frame: this.textureFrame,
          duration: this.duration,
          keyframe: this.isKeyFrame
        };
      },
      destroy: function destroy() {
        this.frame = void 0;
      }
    });
    module.exports = AnimationFrame;
  }, function (module, exports) {
    module.exports = function (array) {
      var re = /\D/g;
      return array.sort(function (a, b) {
        return parseInt(a.replace(re, ""), 10) - parseInt(b.replace(re, ""), 10);
      }), array;
    };
  }, function (module, exports, __webpack_require__) {
    var Animation = __webpack_require__(185),
        AnimationManager = __webpack_require__(0),
        CustomMap = __webpack_require__(102),
        EventEmitter = __webpack_require__(9),
        Events = __webpack_require__(132),
        GameEvents = __webpack_require__(22),
        GetFastValue = __webpack_require__(2),
        GetValue = __webpack_require__(6),
        Pad = __webpack_require__(186),
        NumberArray = __webpack_require__(322),
        AnimationManager = new AnimationManager({
      Extends: EventEmitter,
      initialize: function initialize(game) {
        EventEmitter.call(this), this.game = game, this.textureManager = null, this.globalTimeScale = 1, this.anims = new CustomMap(), this.mixes = new CustomMap(), this.paused = !1, this.name = "AnimationManager", game.events.once(GameEvents.BOOT, this.boot, this);
      },
      boot: function boot() {
        this.textureManager = this.game.textures, this.game.events.once(GameEvents.DESTROY, this.destroy, this);
      },
      addMix: function addMix(keyA, keyB, delay) {
        var mixObj = this.anims,
            mixes = this.mixes,
            keyA = "string" == typeof keyA ? keyA : keyA.key,
            keyB = "string" == typeof keyB ? keyB : keyB.key;
        return mixObj.has(keyA) && mixObj.has(keyB) && ((mixObj = (mixObj = mixes.get(keyA)) || {})[keyB] = delay, mixes.set(keyA, mixObj)), this;
      },
      removeMix: function removeMix(mixObj, keyB) {
        var mixes = this.mixes,
            keyA = "string" == typeof mixObj ? mixObj : mixObj.key,
            mixObj = mixes.get(keyA);
        return mixObj && (keyB ? (keyB = "string" == typeof keyB ? keyB : keyB.key, mixObj.hasOwnProperty(keyB) && delete mixObj[keyB]) : mixes.delete(keyA)), this;
      },
      getMix: function getMix(mixObj, keyB) {
        var mixes = this.mixes,
            mixObj = "string" == typeof mixObj ? mixObj : mixObj.key,
            keyB = "string" == typeof keyB ? keyB : keyB.key,
            mixObj = mixes.get(mixObj);
        return mixObj && mixObj.hasOwnProperty(keyB) ? mixObj[keyB] : 0;
      },
      add: function add(key, animation) {
        return this.anims.has(key) ? console.warn("Animation key exists: " + key) : (animation.key = key, this.anims.set(key, animation), this.emit(Events.ADD_ANIMATION, key, animation)), this;
      },
      exists: function exists(key) {
        return this.anims.has(key);
      },
      createFromAseprite: function createFromAseprite(key, tags) {
        var output = [],
            data = this.game.cache.json.get(key);
        if (!data) return output;

        var _this = this,
            meta = GetValue(data, "meta", null),
            frames = GetValue(data, "frames", null);

        return meta && frames && GetValue(meta, "frameTags", []).forEach(function (result) {
          var animFrames = [],
              name = GetFastValue(result, "name", null),
              totalDuration = GetFastValue(result, "from", 0),
              to = GetFastValue(result, "to", 0),
              result = GetFastValue(result, "direction", "forward");

          if (name && (!tags || -1 < tags.indexOf(name))) {
            for (var tempFrames = [], minDuration = Number.MAX_SAFE_INTEGER, i = totalDuration; i <= to; i++) {
              var frameKey = i.toString(),
                  frameDuration = frames[frameKey];
              frameDuration && ((frameDuration = GetFastValue(frameDuration, "duration", Number.MAX_SAFE_INTEGER)) < minDuration && (minDuration = frameDuration), tempFrames.push({
                frame: frameKey,
                duration: frameDuration
              }));
            }

            tempFrames.forEach(function (entry) {
              animFrames.push({
                key: key,
                frame: entry.frame,
                duration: minDuration - entry.duration
              });
            });
            totalDuration = minDuration * animFrames.length, result = {
              key: name,
              frames: animFrames = "reverse" === result ? animFrames.reverse() : animFrames,
              duration: totalDuration,
              yoyo: "pingpong" === result
            }, result = _this.create(result);
            result && output.push(result);
          }
        }), output;
      },
      create: function create(config) {
        var key = config.key,
            anim = !1;
        return key && ((anim = this.get(key)) || (anim = new Animation(this, key, config), this.anims.set(key, anim), this.emit(Events.ADD_ANIMATION, key, anim))), anim;
      },
      fromJSON: function fromJSON(data, clearCurrentAnimations) {
        (clearCurrentAnimations = void 0 === clearCurrentAnimations ? !1 : clearCurrentAnimations) && this.anims.clear();
        var output = [];

        if ((data = "string" == typeof data ? JSON.parse(data) : data).hasOwnProperty("anims") && Array.isArray(data.anims)) {
          for (var i = 0; i < data.anims.length; i++) {
            output.push(this.create(data.anims[i]));
          }

          data.hasOwnProperty("globalTimeScale") && (this.globalTimeScale = data.globalTimeScale);
        } else data.hasOwnProperty("key") && "frame" === data.type && output.push(this.create(data));

        return output;
      },
      generateFrameNames: function generateFrameNames(key, config) {
        var i,
            prefix = GetValue(config, "prefix", ""),
            start = GetValue(config, "start", 0),
            end = GetValue(config, "end", 0),
            suffix = GetValue(config, "suffix", ""),
            zeroPad = GetValue(config, "zeroPad", 0),
            out = GetValue(config, "outputArray", []),
            frames = GetValue(config, "frames", !1),
            texture = this.textureManager.get(key);
        if (!texture) return out;
        if (config) for (frames = frames || NumberArray(start, end), i = 0; i < frames.length; i++) {
          var frame = prefix + Pad(frames[i], zeroPad, "0", 1) + suffix;
          texture.has(frame) ? out.push({
            key: key,
            frame: frame
          }) : console.warn("generateFrameNames: Frame missing: " + frame + " from texture: " + key);
        } else for (frames = texture.getFrameNames(), i = 0; i < frames.length; i++) {
          out.push({
            key: key,
            frame: frames[i]
          });
        }
        return out;
      },
      generateFrameNumbers: function generateFrameNumbers(key, config) {
        var start = GetValue(config, "start", 0),
            end = GetValue(config, "end", -1),
            first = GetValue(config, "first", !1),
            out = GetValue(config, "outputArray", []),
            frames = GetValue(config, "frames", !1),
            texture = this.textureManager.get(key);
        if (!texture) return out;
        first && texture.has(first) && out.push({
          key: key,
          frame: first
        }), frames || (-1 === end && (end = texture.frameTotal - 2), frames = NumberArray(start, end));

        for (var i = 0; i < frames.length; i++) {
          texture.has(frames[i]) ? out.push({
            key: key,
            frame: frames[i]
          }) : console.warn("generateFrameNumbers: Frame " + i + " missing from texture: " + key);
        }

        return out;
      },
      get: function get(key) {
        return this.anims.get(key);
      },
      pauseAll: function pauseAll() {
        return this.paused || (this.paused = !0, this.emit(Events.PAUSE_ALL)), this;
      },
      play: function play(key, children) {
        Array.isArray(children) || (children = [children]);

        for (var i = 0; i < children.length; i++) {
          children[i].anims.play(key);
        }

        return this;
      },
      staggerPlay: function staggerPlay(key, children, stagger, staggerFirst) {
        void 0 === stagger && (stagger = 0), void 0 === staggerFirst && (staggerFirst = !0);
        var len = (children = !Array.isArray(children) ? [children] : children).length;
        staggerFirst || len--;

        for (var i = 0; i < children.length; i++) {
          var time = stagger < 0 ? Math.abs(stagger) * (len - i) : stagger * i;
          children[i].anims.playAfterDelay(key, time);
        }

        return this;
      },
      remove: function remove(key) {
        var anim = this.get(key);
        return anim && (this.emit(Events.REMOVE_ANIMATION, key, anim), this.anims.delete(key), this.removeMix(key)), anim;
      },
      resumeAll: function resumeAll() {
        return this.paused && (this.paused = !1, this.emit(Events.RESUME_ALL)), this;
      },
      toJSON: function toJSON(key) {
        var output = {
          anims: [],
          globalTimeScale: this.globalTimeScale
        };
        return void 0 !== key && "" !== key ? output.anims.push(this.anims.get(key).toJSON()) : this.anims.each(function (animationKey, animation) {
          output.anims.push(animation.toJSON());
        }), output;
      },
      destroy: function destroy() {
        this.anims.clear(), this.mixes.clear(), this.textureManager = null, this.game = null;
      }
    });

    module.exports = AnimationManager;
  }, function (module, exports) {
    module.exports = function (start, end, prefix, suffix) {
      var i,
          result = [],
          asString = !1;
      if ((prefix || suffix) && (asString = !0, prefix = prefix || "", suffix = suffix || ""), end < start) for (i = start; end <= i; i--) {
        asString ? result.push(prefix + i.toString() + suffix) : result.push(i);
      } else for (i = start; i <= end; i++) {
        asString ? result.push(prefix + i.toString() + suffix) : result.push(i);
      }
      return result;
    };
  }, function (module, exports, __webpack_require__) {
    var BaseCache = __webpack_require__(0),
        CustomMap = __webpack_require__(102),
        EventEmitter = __webpack_require__(9),
        Events = __webpack_require__(324),
        BaseCache = new BaseCache({
      initialize: function initialize() {
        this.entries = new CustomMap(), this.events = new EventEmitter();
      },
      add: function add(key, data) {
        return this.entries.set(key, data), this.events.emit(Events.ADD, this, key, data), this;
      },
      has: function has(key) {
        return this.entries.has(key);
      },
      exists: function exists(key) {
        return this.entries.has(key);
      },
      get: function get(key) {
        return this.entries.get(key);
      },
      remove: function remove(key) {
        var entry = this.get(key);
        return entry && (this.entries.delete(key), this.events.emit(Events.REMOVE, this, key, entry.data)), this;
      },
      getKeys: function getKeys() {
        return this.entries.keys();
      },
      destroy: function destroy() {
        this.entries.clear(), this.events.removeAllListeners(), this.entries = null, this.events = null;
      }
    });

    module.exports = BaseCache;
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      ADD: __webpack_require__(736),
      REMOVE: __webpack_require__(737)
    };
  }, function (module, exports, __webpack_require__) {
    var BaseCache = __webpack_require__(323),
        CacheManager = __webpack_require__(0),
        GameEvents = __webpack_require__(22),
        CacheManager = new CacheManager({
      initialize: function initialize(game) {
        this.game = game, this.binary = new BaseCache(), this.bitmapFont = new BaseCache(), this.json = new BaseCache(), this.physics = new BaseCache(), this.shader = new BaseCache(), this.audio = new BaseCache(), this.video = new BaseCache(), this.text = new BaseCache(), this.html = new BaseCache(), this.obj = new BaseCache(), this.tilemap = new BaseCache(), this.xml = new BaseCache(), this.custom = {}, this.game.events.once(GameEvents.DESTROY, this.destroy, this);
      },
      addCustom: function addCustom(key) {
        return this.custom.hasOwnProperty(key) || (this.custom[key] = new BaseCache()), this.custom[key];
      },
      destroy: function destroy() {
        for (var key, keys = ["binary", "bitmapFont", "json", "physics", "shader", "audio", "video", "text", "html", "obj", "tilemap", "xml"], i = 0; i < keys.length; i++) {
          this[keys[i]].destroy(), this[keys[i]] = null;
        }

        for (key in this.custom) {
          this.custom[key].destroy();
        }

        this.custom = null, this.game = null;
      }
    });

    module.exports = CacheManager;
  }, function (module, exports, __webpack_require__) {
    var BaseCamera = __webpack_require__(133),
        CenterOn = __webpack_require__(190),
        Clamp = __webpack_require__(18),
        Class = __webpack_require__(0),
        Camera = __webpack_require__(11),
        Effects = __webpack_require__(333),
        Events = __webpack_require__(37),
        Linear = __webpack_require__(135),
        Rectangle = __webpack_require__(10),
        Vector2 = __webpack_require__(3),
        Camera = new Class({
      Extends: BaseCamera,
      Mixins: [Camera.Flip, Camera.Tint, Camera.Pipeline],
      initialize: function initialize(x, y, width, height) {
        BaseCamera.call(this, x, y, width, height), this.postPipelines = [], this.pipelineData = {}, this.inputEnabled = !0, this.fadeEffect = new Effects.Fade(this), this.flashEffect = new Effects.Flash(this), this.shakeEffect = new Effects.Shake(this), this.panEffect = new Effects.Pan(this), this.rotateToEffect = new Effects.RotateTo(this), this.zoomEffect = new Effects.Zoom(this), this.lerp = new Vector2(1, 1), this.followOffset = new Vector2(), this.deadzone = null, this._follow = null;
      },
      setDeadzone: function setDeadzone(fx, fy) {
        var originX, originY;
        return void 0 === fx ? this.deadzone = null : (this.deadzone ? (this.deadzone.width = fx, this.deadzone.height = fy) : this.deadzone = new Rectangle(0, 0, fx, fy), this._follow && (originX = this.width / 2, originY = this.height / 2, fx = this._follow.x - this.followOffset.x, fy = this._follow.y - this.followOffset.y, this.midPoint.set(fx, fy), this.scrollX = fx - originX, this.scrollY = fy - originY), CenterOn(this.deadzone, this.midPoint.x, this.midPoint.y)), this;
      },
      fadeIn: function fadeIn(duration, red, green, blue, callback, context) {
        return this.fadeEffect.start(!1, duration, red, green, blue, !0, callback, context);
      },
      fadeOut: function fadeOut(duration, red, green, blue, callback, context) {
        return this.fadeEffect.start(!0, duration, red, green, blue, !0, callback, context);
      },
      fadeFrom: function fadeFrom(duration, red, green, blue, force, callback, context) {
        return this.fadeEffect.start(!1, duration, red, green, blue, force, callback, context);
      },
      fade: function fade(duration, red, green, blue, force, callback, context) {
        return this.fadeEffect.start(!0, duration, red, green, blue, force, callback, context);
      },
      flash: function flash(duration, red, green, blue, force, callback, context) {
        return this.flashEffect.start(duration, red, green, blue, force, callback, context);
      },
      shake: function shake(duration, intensity, force, callback, context) {
        return this.shakeEffect.start(duration, intensity, force, callback, context);
      },
      pan: function pan(x, y, duration, ease, force, callback, context) {
        return this.panEffect.start(x, y, duration, ease, force, callback, context);
      },
      rotateTo: function rotateTo(radians, shortestPath, duration, ease, force, callback, context) {
        return this.rotateToEffect.start(radians, shortestPath, duration, ease, force, callback, context);
      },
      zoomTo: function zoomTo(zoom, duration, ease, force, callback, context) {
        return this.zoomEffect.start(zoom, duration, ease, force, callback, context);
      },
      preRender: function preRender() {
        this.renderList.length = 0;
        var displayWidth = this.width,
            displayHeight = this.height,
            vwx = .5 * displayWidth,
            vwy = .5 * displayHeight,
            zoom = this.zoom,
            matrix = this.matrix,
            originX = displayWidth * this.originX,
            originY = displayHeight * this.originY,
            follow = this._follow,
            deadzone = this.deadzone,
            sx = this.scrollX,
            sy = this.scrollY;
        deadzone && CenterOn(deadzone, this.midPoint.x, this.midPoint.y);
        var fx,
            fy,
            emitFollowEvent = !1;
        follow && !this.panEffect.isRunning && (fx = follow.x - this.followOffset.x, fy = follow.y - this.followOffset.y, deadzone ? (fx < deadzone.x ? sx = Linear(sx, sx - (deadzone.x - fx), this.lerp.x) : fx > deadzone.right && (sx = Linear(sx, sx + (fx - deadzone.right), this.lerp.x)), fy < deadzone.y ? sy = Linear(sy, sy - (deadzone.y - fy), this.lerp.y) : fy > deadzone.bottom && (sy = Linear(sy, sy + (fy - deadzone.bottom), this.lerp.y))) : (sx = Linear(sx, fx - originX, this.lerp.x), sy = Linear(sy, fy - originY, this.lerp.y)), emitFollowEvent = !0), this.useBounds && (sx = this.clampX(sx), sy = this.clampY(sy)), this.roundPixels && (originX = Math.round(originX), originY = Math.round(originY), sx = Math.round(sx), sy = Math.round(sy));
        vwx = (this.scrollX = sx) + vwx, vwy = (this.scrollY = sy) + vwy;
        this.midPoint.set(vwx, vwy);
        displayWidth /= zoom, displayHeight /= zoom, vwx -= displayWidth / 2, vwy -= displayHeight / 2;
        this.roundPixels && (vwx = Math.round(vwx), vwy = Math.round(vwy)), this.worldView.setTo(vwx, vwy, displayWidth, displayHeight), matrix.applyITRS(this.x + originX, this.y + originY, this.rotation, zoom, zoom), matrix.translate(-originX, -originY), this.shakeEffect.preRender(), emitFollowEvent && this.emit(Events.FOLLOW_UPDATE, this, follow);
      },
      setLerp: function setLerp(x, y) {
        return void 0 === x && (x = 1), void 0 === y && (y = x), this.lerp.set(x, y), this;
      },
      setFollowOffset: function setFollowOffset(x, y) {
        return this.followOffset.set(x = void 0 === x ? 0 : x, y = void 0 === y ? 0 : y), this;
      },
      startFollow: function startFollow(target, roundPixels, originX, originY, fx, fy) {
        void 0 === roundPixels && (roundPixels = !1), void 0 === originX && (originX = 1), void 0 === originY && (originY = originX), void 0 === fx && (fx = 0), void 0 === fy && (fy = fx), this._follow = target, this.roundPixels = roundPixels, originX = Clamp(originX, 0, 1), originY = Clamp(originY, 0, 1), this.lerp.set(originX, originY), this.followOffset.set(fx, fy);
        originX = this.width / 2, originY = this.height / 2, fx = target.x - fx, fy = target.y - fy;
        return this.midPoint.set(fx, fy), this.scrollX = fx - originX, this.scrollY = fy - originY, this.useBounds && (this.scrollX = this.clampX(this.scrollX), this.scrollY = this.clampY(this.scrollY)), this;
      },
      stopFollow: function stopFollow() {
        return this._follow = null, this;
      },
      resetFX: function resetFX() {
        return this.rotateToEffect.reset(), this.panEffect.reset(), this.shakeEffect.reset(), this.flashEffect.reset(), this.fadeEffect.reset(), this;
      },
      update: function update(time, delta) {
        this.visible && (this.rotateToEffect.update(time, delta), this.panEffect.update(time, delta), this.zoomEffect.update(time, delta), this.shakeEffect.update(time, delta), this.flashEffect.update(time, delta), this.fadeEffect.update(time, delta));
      },
      destroy: function destroy() {
        this.resetFX(), BaseCamera.prototype.destroy.call(this), this._follow = null, this.deadzone = null;
      }
    });

    module.exports = Camera;
  }, function (module, exports, __webpack_require__) {
    var Color = __webpack_require__(38);

    module.exports = function (g) {
      var color = new Color();
      g = g.replace(/^(?:#|0x)?([a-f\d])([a-f\d])([a-f\d])$/i, function (m, r, g, b) {
        return r + r + g + g + b + b;
      });
      var r,
          b = /^(?:#|0x)?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(g);
      return b && (r = parseInt(b[1], 16), g = parseInt(b[2], 16), b = parseInt(b[3], 16), color.setTo(r, g, b)), color;
    };
  }, function (module, exports) {
    module.exports = function (red, green, blue, alpha) {
      return alpha << 24 | red << 16 | green << 8 | blue;
    };
  }, function (module, exports) {
    module.exports = function (r, g, b, out) {
      void 0 === out && (out = {
        h: 0,
        s: 0,
        v: 0
      }), r /= 255, g /= 255, b /= 255;
      var min = Math.min(r, g, b),
          max = Math.max(r, g, b),
          d = max - min,
          h = 0,
          s = 0 === max ? 0 : d / max,
          v = max;
      return max !== min && (max === r ? h = (g - b) / d + (g < b ? 6 : 0) : max === g ? h = (b - r) / d + 2 : max === b && (h = (r - g) / d + 4), h /= 6), out.hasOwnProperty("_h") ? (out._h = h, out._s = s, out._v = v) : (out.h = h, out.s = s, out.v = v), out;
    };
  }, function (module, exports) {
    module.exports = function (color) {
      return 16777215 < color ? {
        a: color >>> 24,
        r: color >> 16 & 255,
        g: color >> 8 & 255,
        b: 255 & color
      } : {
        a: 255,
        r: color >> 16 & 255,
        g: color >> 8 & 255,
        b: 255 & color
      };
    };
  }, function (module, exports, __webpack_require__) {
    var Color = __webpack_require__(38);

    module.exports = function (input) {
      return new Color(input.r, input.g, input.b, input.a);
    };
  }, function (module, exports, __webpack_require__) {
    var Color = __webpack_require__(38);

    module.exports = function (b) {
      var r,
          g,
          color = new Color(),
          a = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d+(?:\.\d+)?))?\s*\)$/.exec(b.toLowerCase());
      return a && (r = parseInt(a[1], 10), g = parseInt(a[2], 10), b = parseInt(a[3], 10), a = void 0 !== a[4] ? parseFloat(a[4]) : 1, color.setTo(r, g, b, 255 * a)), color;
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      Fade: __webpack_require__(761),
      Flash: __webpack_require__(762),
      Pan: __webpack_require__(763),
      Shake: __webpack_require__(796),
      RotateTo: __webpack_require__(797),
      Zoom: __webpack_require__(798)
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      In: __webpack_require__(764),
      Out: __webpack_require__(765),
      InOut: __webpack_require__(766)
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      In: __webpack_require__(767),
      Out: __webpack_require__(768),
      InOut: __webpack_require__(769)
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      In: __webpack_require__(770),
      Out: __webpack_require__(771),
      InOut: __webpack_require__(772)
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      In: __webpack_require__(773),
      Out: __webpack_require__(774),
      InOut: __webpack_require__(775)
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      In: __webpack_require__(776),
      Out: __webpack_require__(777),
      InOut: __webpack_require__(778)
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      In: __webpack_require__(779),
      Out: __webpack_require__(780),
      InOut: __webpack_require__(781)
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = __webpack_require__(782);
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      In: __webpack_require__(783),
      Out: __webpack_require__(784),
      InOut: __webpack_require__(785)
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      In: __webpack_require__(786),
      Out: __webpack_require__(787),
      InOut: __webpack_require__(788)
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      In: __webpack_require__(789),
      Out: __webpack_require__(790),
      InOut: __webpack_require__(791)
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      In: __webpack_require__(792),
      Out: __webpack_require__(793),
      InOut: __webpack_require__(794)
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = __webpack_require__(795);
  }, function (module, exports, __webpack_require__) {
    var Config = __webpack_require__(0),
        CONST = __webpack_require__(33),
        Device = __webpack_require__(347),
        GetFastValue = __webpack_require__(2),
        GetValue = __webpack_require__(6),
        IsPlainObject = __webpack_require__(7),
        PhaserMath = __webpack_require__(193),
        NOOP = __webpack_require__(1),
        DefaultPlugins = __webpack_require__(197),
        ValueToColor = __webpack_require__(187),
        Config = new Config({
      initialize: function initialize(config) {
        this.width = GetValue(config = void 0 === config ? {} : config, "width", 1024), this.height = GetValue(config, "height", 768), this.zoom = GetValue(config, "zoom", 1), this.parent = GetValue(config, "parent", void 0), this.scaleMode = GetValue(config, "scaleMode", 0), this.expandParent = GetValue(config, "expandParent", !0), this.autoRound = GetValue(config, "autoRound", !1), this.autoCenter = GetValue(config, "autoCenter", 0), this.resizeInterval = GetValue(config, "resizeInterval", 500), this.fullscreenTarget = GetValue(config, "fullscreenTarget", null), this.minWidth = GetValue(config, "minWidth", 0), this.maxWidth = GetValue(config, "maxWidth", 0), this.minHeight = GetValue(config, "minHeight", 0), this.maxHeight = GetValue(config, "maxHeight", 0);
        var plugins = GetValue(config, "scale", null);
        plugins && (this.width = GetValue(plugins, "width", this.width), this.height = GetValue(plugins, "height", this.height), this.zoom = GetValue(plugins, "zoom", this.zoom), this.parent = GetValue(plugins, "parent", this.parent), this.scaleMode = GetValue(plugins, "mode", this.scaleMode), this.expandParent = GetValue(plugins, "expandParent", this.expandParent), this.autoRound = GetValue(plugins, "autoRound", this.autoRound), this.autoCenter = GetValue(plugins, "autoCenter", this.autoCenter), this.resizeInterval = GetValue(plugins, "resizeInterval", this.resizeInterval), this.fullscreenTarget = GetValue(plugins, "fullscreenTarget", this.fullscreenTarget), this.minWidth = GetValue(plugins, "min.width", this.minWidth), this.maxWidth = GetValue(plugins, "max.width", this.maxWidth), this.minHeight = GetValue(plugins, "min.height", this.minHeight), this.maxHeight = GetValue(plugins, "max.height", this.maxHeight)), this.renderType = GetValue(config, "type", CONST.AUTO), this.canvas = GetValue(config, "canvas", null), this.context = GetValue(config, "context", null), this.canvasStyle = GetValue(config, "canvasStyle", null), this.customEnvironment = GetValue(config, "customEnvironment", !1), this.sceneConfig = GetValue(config, "scene", null), this.seed = GetValue(config, "seed", [(Date.now() * Math.random()).toString()]), PhaserMath.RND = new PhaserMath.RandomDataGenerator(this.seed), this.gameTitle = GetValue(config, "title", ""), this.gameURL = GetValue(config, "url", "https://phaser.io"), this.gameVersion = GetValue(config, "version", ""), this.autoFocus = GetValue(config, "autoFocus", !0), this.domCreateContainer = GetValue(config, "dom.createContainer", !1), this.domBehindCanvas = GetValue(config, "dom.behindCanvas", !1), this.domPointerEvents = GetValue(config, "dom.pointerEvents", "none"), this.inputKeyboard = GetValue(config, "input.keyboard", !0), this.inputKeyboardEventTarget = GetValue(config, "input.keyboard.target", window), this.inputKeyboardCapture = GetValue(config, "input.keyboard.capture", []), this.inputMouse = GetValue(config, "input.mouse", !0), this.inputMouseEventTarget = GetValue(config, "input.mouse.target", null), this.inputMousePreventDefaultDown = GetValue(config, "input.mouse.preventDefaultDown", !0), this.inputMousePreventDefaultUp = GetValue(config, "input.mouse.preventDefaultUp", !0), this.inputMousePreventDefaultMove = GetValue(config, "input.mouse.preventDefaultMove", !0), this.inputMousePreventDefaultWheel = GetValue(config, "input.mouse.preventDefaultWheel", !0), this.inputTouch = GetValue(config, "input.touch", Device.input.touch), this.inputTouchEventTarget = GetValue(config, "input.touch.target", null), this.inputTouchCapture = GetValue(config, "input.touch.capture", !0), this.inputActivePointers = GetValue(config, "input.activePointers", 1), this.inputSmoothFactor = GetValue(config, "input.smoothFactor", 0), this.inputWindowEvents = GetValue(config, "input.windowEvents", !0), this.inputGamepad = GetValue(config, "input.gamepad", !1), this.inputGamepadEventTarget = GetValue(config, "input.gamepad.target", window), this.disableContextMenu = GetValue(config, "disableContextMenu", !1), this.audio = GetValue(config, "audio", {}), this.hideBanner = !1 === GetValue(config, "banner", null), this.hidePhaser = GetValue(config, "banner.hidePhaser", !1), this.bannerTextColor = GetValue(config, "banner.text", "#ffffff"), this.bannerBackgroundColor = GetValue(config, "banner.background", ["#ff0000", "#ffff00", "#00ff00", "#00ffff", "#000000"]), "" === this.gameTitle && this.hidePhaser && (this.hideBanner = !0), this.fps = GetValue(config, "fps", null);
        var pngPrefix = GetValue(config, "render", config);
        this.pipeline = GetValue(pngPrefix, "pipeline", null), this.antialias = GetValue(pngPrefix, "antialias", !0), this.antialiasGL = GetValue(pngPrefix, "antialiasGL", !0), this.mipmapFilter = GetValue(pngPrefix, "mipmapFilter", "LINEAR"), this.desynchronized = GetValue(pngPrefix, "desynchronized", !1), this.roundPixels = GetValue(pngPrefix, "roundPixels", !1), this.pixelArt = GetValue(pngPrefix, "pixelArt", 1 !== this.zoom), this.pixelArt && (this.antialias = !1, this.antialiasGL = !1, this.roundPixels = !0), this.transparent = GetValue(pngPrefix, "transparent", !1), this.clearBeforeRender = GetValue(pngPrefix, "clearBeforeRender", !0), this.preserveDrawingBuffer = GetValue(pngPrefix, "preserveDrawingBuffer", !1), this.premultipliedAlpha = GetValue(pngPrefix, "premultipliedAlpha", !0), this.failIfMajorPerformanceCaveat = GetValue(pngPrefix, "failIfMajorPerformanceCaveat", !1), this.powerPreference = GetValue(pngPrefix, "powerPreference", "default"), this.batchSize = GetValue(pngPrefix, "batchSize", 4096), this.maxTextures = GetValue(pngPrefix, "maxTextures", -1), this.maxLights = GetValue(pngPrefix, "maxLights", 10);
        plugins = GetValue(config, "backgroundColor", 0);
        this.backgroundColor = ValueToColor(plugins), this.transparent && (this.backgroundColor = ValueToColor(0), this.backgroundColor.alpha = 0), this.preBoot = GetValue(config, "callbacks.preBoot", NOOP), this.postBoot = GetValue(config, "callbacks.postBoot", NOOP), this.physics = GetValue(config, "physics", {}), this.defaultPhysicsSystem = GetValue(this.physics, "default", !1), this.loaderBaseURL = GetValue(config, "loader.baseURL", ""), this.loaderPath = GetValue(config, "loader.path", "");
        pngPrefix = Device.os.android ? 6 : 32;
        this.loaderMaxParallelDownloads = GetValue(config, "loader.maxParallelDownloads", pngPrefix), this.loaderCrossOrigin = GetValue(config, "loader.crossOrigin", void 0), this.loaderResponseType = GetValue(config, "loader.responseType", ""), this.loaderAsync = GetValue(config, "loader.async", !0), this.loaderUser = GetValue(config, "loader.user", ""), this.loaderPassword = GetValue(config, "loader.password", ""), this.loaderTimeout = GetValue(config, "loader.timeout", 0), this.loaderWithCredentials = GetValue(config, "loader.withCredentials", !1), this.installGlobalPlugins = [], this.installScenePlugins = [];
        plugins = GetValue(config, "plugins", null), pngPrefix = DefaultPlugins.DefaultScene;
        plugins && (Array.isArray(plugins) ? this.defaultPlugins = plugins : IsPlainObject(plugins) && (this.installGlobalPlugins = GetFastValue(plugins, "global", []), this.installScenePlugins = GetFastValue(plugins, "scene", []), Array.isArray(plugins.default) ? pngPrefix = plugins.default : Array.isArray(plugins.defaultMerge) && (pngPrefix = pngPrefix.concat(plugins.defaultMerge)))), this.defaultPlugins = pngPrefix;
        pngPrefix = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAg";
        this.defaultImage = GetValue(config, "images.default", pngPrefix + "AQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg=="), this.missingImage = GetValue(config, "images.missing", pngPrefix + "CAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg=="), this.whiteImage = GetValue(config, "images.white", "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAIAAAAmkwkpAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAABdJREFUeNpi/P//PwMMMDEgAdwcgAADAJZuAwXJYZOzAAAAAElFTkSuQmCC"), window && (window.FORCE_WEBGL ? this.renderType = CONST.WEBGL : window.FORCE_CANVAS && (this.renderType = CONST.CANVAS));
      }
    });

    module.exports = Config;
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      os: __webpack_require__(105),
      browser: __webpack_require__(136),
      features: __webpack_require__(191),
      input: __webpack_require__(808),
      audio: __webpack_require__(809),
      video: __webpack_require__(810),
      fullscreen: __webpack_require__(811),
      canvasFeatures: __webpack_require__(348)
    };
  }, function (module, exports, __webpack_require__) {
    var pngHead,
        pngEnd,
        magenta,
        CanvasPool = __webpack_require__(31),
        CanvasFeatures = {
      supportInverseAlpha: !1,
      supportNewBlendModes: !1
    };

    module.exports = ("function" != typeof importScripts && void 0 !== document && (CanvasFeatures.supportNewBlendModes = (pngHead = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX/", pngEnd = "AAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==", (magenta = new Image()).onload = function () {
      var yellow = new Image();
      yellow.onload = function () {
        var data = CanvasPool.create(yellow, 6, 1).getContext("2d");
        if (data.globalCompositeOperation = "multiply", data.drawImage(magenta, 0, 0), data.drawImage(yellow, 2, 0), !data.getImageData(2, 0, 1, 1)) return !1;
        data = data.getImageData(2, 0, 1, 1).data;
        CanvasPool.remove(yellow), CanvasFeatures.supportNewBlendModes = 255 === data[0] && 0 === data[1] && 0 === data[2];
      }, yellow.src = pngHead + "/wCKxvRF" + pngEnd;
    }, magenta.src = pngHead + "AP804Oa6" + pngEnd, !1), CanvasFeatures.supportInverseAlpha = function () {
      var s2 = CanvasPool.create(this, 2, 1).getContext("2d");
      s2.fillStyle = "rgba(10, 20, 30, 0.5)", s2.fillRect(0, 0, 1, 1);
      var s1 = s2.getImageData(0, 0, 1, 1);
      return null !== s1 && (s2.putImageData(s1, 1, 0), (s2 = s2.getImageData(1, 0, 1, 1)).data[0] === s1.data[0] && s2.data[1] === s1.data[1] && s2.data[2] === s1.data[2] && s2.data[3] === s1.data[3]);
    }()), CanvasFeatures);
  }, function (module, exports) {
    module.exports = function (x1, y1, x2, y2) {
      return Math.atan2(y2 - y1, x2 - x1);
    };
  }, function (module, exports) {
    module.exports = function (point1, point2) {
      return Math.atan2(point2.y - point1.y, point2.x - point1.x);
    };
  }, function (module, exports) {
    module.exports = function (angle) {
      return 0 <= (angle %= 2 * Math.PI) ? angle : angle + 2 * Math.PI;
    };
  }, function (module, exports) {
    module.exports = function (a, dy) {
      var dx = a.x - dy.x,
          dy = a.y - dy.y;
      return Math.sqrt(dx * dx + dy * dy);
    };
  }, function (module, exports) {
    module.exports = function (x1, y1, dx, dy) {
      dx = x1 - dx, dy = y1 - dy;
      return dx * dx + dy * dy;
    };
  }, function (module, exports) {
    module.exports = function (a, b, epsilon) {
      return b - (epsilon = void 0 === epsilon ? 1e-4 : epsilon) < a;
    };
  }, function (module, exports) {
    module.exports = function (a, b, epsilon) {
      return a < b + (epsilon = void 0 === epsilon ? 1e-4 : epsilon);
    };
  }, function (module, exports, __webpack_require__) {
    var Factorial = __webpack_require__(357);

    module.exports = function (n, i) {
      return Factorial(n) / Factorial(i) / Factorial(n - i);
    };
  }, function (module, exports) {
    module.exports = function (value) {
      if (0 === value) return 1;

      for (var res = value; --value;) {
        res *= value;
      }

      return res;
    };
  }, function (module, exports) {
    module.exports = function (t, p0, p1, p2, p3) {
      return (k = 1 - (k = t)) * k * k * p0 + function (t, p) {
        var k = 1 - t;
        return 3 * k * k * t * p;
      }(t, p1) + function (t, p) {
        return 3 * (1 - t) * t * t * p;
      }(t, p2) + function (t, p) {
        return t * t * t * p;
      }(t, p3);
      var k;
    };
  }, function (module, exports) {
    module.exports = function (t, p0, p1, p2) {
      return (k = 1 - (k = t)) * k * p0 + function (t, p) {
        return 2 * (1 - t) * t * p;
      }(t, p1) + function (t, p) {
        return t * t * p;
      }(t, p2);
      var k;
    };
  }, function (module, exports, __webpack_require__) {
    var SmoothStep = __webpack_require__(184);

    module.exports = function (t, min, max) {
      return min + (max - min) * SmoothStep(t, 0, 1);
    };
  }, function (module, exports) {
    module.exports = function (index) {
      index = Math.log(index) / .6931471805599453;
      return 1 << Math.ceil(index);
    };
  }, function (module, exports) {
    module.exports = function (point, angle) {
      var x = point.x,
          y = point.y;
      return point.x = x * Math.cos(angle) - y * Math.sin(angle), point.y = x * Math.sin(angle) + y * Math.cos(angle), point;
    };
  }, function (module, exports) {
    module.exports = function (value) {
      return 0 < value ? Math.ceil(value) : Math.floor(value);
    };
  }, function (module, exports, __webpack_require__) {
    var Matrix3 = new (__webpack_require__(0))({
      initialize: function initialize(m) {
        this.val = new Float32Array(9), m ? this.copy(m) : this.identity();
      },
      clone: function clone() {
        return new Matrix3(this);
      },
      set: function set(src) {
        return this.copy(src);
      },
      copy: function copy(a) {
        var out = this.val,
            a = a.val;
        return out[0] = a[0], out[1] = a[1], out[2] = a[2], out[3] = a[3], out[4] = a[4], out[5] = a[5], out[6] = a[6], out[7] = a[7], out[8] = a[8], this;
      },
      fromMat4: function fromMat4(out) {
        var a = out.val,
            out = this.val;
        return out[0] = a[0], out[1] = a[1], out[2] = a[2], out[3] = a[4], out[4] = a[5], out[5] = a[6], out[6] = a[8], out[7] = a[9], out[8] = a[10], this;
      },
      fromArray: function fromArray(a) {
        var out = this.val;
        return out[0] = a[0], out[1] = a[1], out[2] = a[2], out[3] = a[3], out[4] = a[4], out[5] = a[5], out[6] = a[6], out[7] = a[7], out[8] = a[8], this;
      },
      identity: function identity() {
        var out = this.val;
        return out[0] = 1, out[1] = 0, out[2] = 0, out[3] = 0, out[4] = 1, out[5] = 0, out[6] = 0, out[7] = 0, out[8] = 1, this;
      },
      transpose: function transpose() {
        var a = this.val,
            a01 = a[1],
            a02 = a[2],
            a12 = a[5];
        return a[1] = a[3], a[2] = a[6], a[3] = a01, a[5] = a[7], a[6] = a02, a[7] = a12, this;
      },
      invert: function invert() {
        var a = this.val,
            a00 = a[0],
            a01 = a[1],
            a02 = a[2],
            a10 = a[3],
            a11 = a[4],
            a12 = a[5],
            a20 = a[6],
            a21 = a[7],
            a22 = a[8],
            b01 = a22 * a11 - a12 * a21,
            b11 = -a22 * a10 + a12 * a20,
            b21 = a21 * a10 - a11 * a20,
            det = a00 * b01 + a01 * b11 + a02 * b21;
        return det ? (a[0] = b01 * (det = 1 / det), a[1] = (-a22 * a01 + a02 * a21) * det, a[2] = (a12 * a01 - a02 * a11) * det, a[3] = b11 * det, a[4] = (a22 * a00 - a02 * a20) * det, a[5] = (-a12 * a00 + a02 * a10) * det, a[6] = b21 * det, a[7] = (-a21 * a00 + a01 * a20) * det, a[8] = (a11 * a00 - a01 * a10) * det, this) : null;
      },
      adjoint: function adjoint() {
        var a = this.val,
            a00 = a[0],
            a01 = a[1],
            a02 = a[2],
            a10 = a[3],
            a11 = a[4],
            a12 = a[5],
            a20 = a[6],
            a21 = a[7],
            a22 = a[8];
        return a[0] = a11 * a22 - a12 * a21, a[1] = a02 * a21 - a01 * a22, a[2] = a01 * a12 - a02 * a11, a[3] = a12 * a20 - a10 * a22, a[4] = a00 * a22 - a02 * a20, a[5] = a02 * a10 - a00 * a12, a[6] = a10 * a21 - a11 * a20, a[7] = a01 * a20 - a00 * a21, a[8] = a00 * a11 - a01 * a10, this;
      },
      determinant: function determinant() {
        var a22 = this.val,
            a00 = a22[0],
            a01 = a22[1],
            a02 = a22[2],
            a10 = a22[3],
            a11 = a22[4],
            a12 = a22[5],
            a20 = a22[6],
            a21 = a22[7],
            a22 = a22[8];
        return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
      },
      multiply: function multiply(b21) {
        var a = this.val,
            a00 = a[0],
            a01 = a[1],
            a02 = a[2],
            a10 = a[3],
            a11 = a[4],
            a12 = a[5],
            a20 = a[6],
            a21 = a[7],
            a22 = a[8],
            b22 = b21.val,
            b00 = b22[0],
            b01 = b22[1],
            b02 = b22[2],
            b10 = b22[3],
            b11 = b22[4],
            b12 = b22[5],
            b20 = b22[6],
            b21 = b22[7],
            b22 = b22[8];
        return a[0] = b00 * a00 + b01 * a10 + b02 * a20, a[1] = b00 * a01 + b01 * a11 + b02 * a21, a[2] = b00 * a02 + b01 * a12 + b02 * a22, a[3] = b10 * a00 + b11 * a10 + b12 * a20, a[4] = b10 * a01 + b11 * a11 + b12 * a21, a[5] = b10 * a02 + b11 * a12 + b12 * a22, a[6] = b20 * a00 + b21 * a10 + b22 * a20, a[7] = b20 * a01 + b21 * a11 + b22 * a21, a[8] = b20 * a02 + b21 * a12 + b22 * a22, this;
      },
      translate: function translate(y) {
        var a = this.val,
            x = y.x,
            y = y.y;
        return a[6] = x * a[0] + y * a[3] + a[6], a[7] = x * a[1] + y * a[4] + a[7], a[8] = x * a[2] + y * a[5] + a[8], this;
      },
      rotate: function rotate(c) {
        var a = this.val,
            a00 = a[0],
            a01 = a[1],
            a02 = a[2],
            a10 = a[3],
            a11 = a[4],
            a12 = a[5],
            s = Math.sin(c),
            c = Math.cos(c);
        return a[0] = c * a00 + s * a10, a[1] = c * a01 + s * a11, a[2] = c * a02 + s * a12, a[3] = c * a10 - s * a00, a[4] = c * a11 - s * a01, a[5] = c * a12 - s * a02, this;
      },
      scale: function scale(y) {
        var a = this.val,
            x = y.x,
            y = y.y;
        return a[0] = x * a[0], a[1] = x * a[1], a[2] = x * a[2], a[3] = y * a[3], a[4] = y * a[4], a[5] = y * a[5], this;
      },
      fromQuat: function fromQuat(xz) {
        var yy = xz.x,
            yz = xz.y,
            zz = xz.z,
            wz = xz.w,
            wx = yy + yy,
            wy = yz + yz,
            out = zz + zz,
            xx = yy * wx,
            xy = yy * wy,
            xz = yy * out,
            yy = yz * wy,
            yz = yz * out,
            zz = zz * out,
            wx = wz * wx,
            wy = wz * wy,
            wz = wz * out,
            out = this.val;
        return out[0] = 1 - (yy + zz), out[3] = xy + wz, out[6] = xz - wy, out[1] = xy - wz, out[4] = 1 - (xx + zz), out[7] = yz + wx, out[2] = xz + wy, out[5] = yz - wx, out[8] = 1 - (xx + yy), this;
      },
      normalFromMat4: function normalFromMat4(b07) {
        var b08 = b07.val,
            out = this.val,
            a00 = b08[0],
            a01 = b08[1],
            a02 = b08[2],
            a03 = b08[3],
            a10 = b08[4],
            a11 = b08[5],
            a12 = b08[6],
            a13 = b08[7],
            b09 = b08[8],
            b10 = b08[9],
            b11 = b08[10],
            det = b08[11],
            a30 = b08[12],
            a31 = b08[13],
            a32 = b08[14],
            a33 = b08[15],
            b00 = a00 * a11 - a01 * a10,
            b01 = a00 * a12 - a02 * a10,
            b02 = a00 * a13 - a03 * a10,
            b03 = a01 * a12 - a02 * a11,
            b04 = a01 * a13 - a03 * a11,
            b05 = a02 * a13 - a03 * a12,
            b06 = b09 * a31 - b10 * a30,
            b07 = b09 * a32 - b11 * a30,
            b08 = b09 * a33 - det * a30,
            b09 = b10 * a32 - b11 * a31,
            b10 = b10 * a33 - det * a31,
            b11 = b11 * a33 - det * a32,
            det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
        return det ? (out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * (det = 1 / det), out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det, out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det, out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det, out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det, out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det, out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det, out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det, out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det, this) : null;
      }
    });
    module.exports = Matrix3;
  }, function (module, exports, Vector3) {
    var Quaternion = Vector3(0),
        Matrix3 = Vector3(364),
        NOOP = Vector3(1),
        Vector3 = Vector3(39),
        siNext = new Int8Array([1, 2, 0]),
        tmp = new Float32Array([0, 0, 0]),
        xUnitVec3 = new Vector3(1, 0, 0),
        yUnitVec3 = new Vector3(0, 1, 0),
        tmpvec = new Vector3(),
        tmpMat3 = new Matrix3(),
        Quaternion = new Quaternion({
      initialize: function initialize(x, y, z, w) {
        this.onChangeCallback = NOOP, this.set(x, y, z, w);
      },
      x: {
        get: function get() {
          return this._x;
        },
        set: function set(value) {
          this._x = value, this.onChangeCallback(this);
        }
      },
      y: {
        get: function get() {
          return this._y;
        },
        set: function set(value) {
          this._y = value, this.onChangeCallback(this);
        }
      },
      z: {
        get: function get() {
          return this._z;
        },
        set: function set(value) {
          this._z = value, this.onChangeCallback(this);
        }
      },
      w: {
        get: function get() {
          return this._w;
        },
        set: function set(value) {
          this._w = value, this.onChangeCallback(this);
        }
      },
      copy: function copy(src) {
        return this.set(src);
      },
      set: function set(x, y, z, w, update) {
        return void 0 === update && (update = !0), "object" == _typeof(x) ? (this._x = x.x || 0, this._y = x.y || 0, this._z = x.z || 0, this._w = x.w || 0) : (this._x = x || 0, this._y = y || 0, this._z = z || 0, this._w = w || 0), update && this.onChangeCallback(this), this;
      },
      add: function add(v) {
        return this._x += v.x, this._y += v.y, this._z += v.z, this._w += v.w, this.onChangeCallback(this), this;
      },
      subtract: function subtract(v) {
        return this._x -= v.x, this._y -= v.y, this._z -= v.z, this._w -= v.w, this.onChangeCallback(this), this;
      },
      scale: function scale(_scale3) {
        return this._x *= _scale3, this._y *= _scale3, this._z *= _scale3, this._w *= _scale3, this.onChangeCallback(this), this;
      },
      length: function length() {
        var x = this.x,
            y = this.y,
            z = this.z,
            w = this.w;
        return Math.sqrt(x * x + y * y + z * z + w * w);
      },
      lengthSq: function lengthSq() {
        var x = this.x,
            y = this.y,
            z = this.z,
            w = this.w;
        return x * x + y * y + z * z + w * w;
      },
      normalize: function normalize() {
        var x = this.x,
            y = this.y,
            z = this.z,
            w = this.w,
            len = x * x + y * y + z * z + w * w;
        return 0 < len && (len = 1 / Math.sqrt(len), this._x = x * len, this._y = y * len, this._z = z * len, this._w = w * len), this.onChangeCallback(this), this;
      },
      dot: function dot(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
      },
      lerp: function lerp(v, t) {
        var ax = this.x,
            ay = this.y,
            az = this.z,
            aw = this.w;
        return this.set(ax + (t = void 0 === t ? 0 : t) * (v.x - ax), ay + t * (v.y - ay), az + t * (v.z - az), aw + t * (v.w - aw));
      },
      rotationTo: function rotationTo(a, b) {
        var dot = a.x * b.x + a.y * b.y + a.z * b.z;
        return dot < -.999999 ? (tmpvec.copy(xUnitVec3).cross(a).length() < 1e-6 && tmpvec.copy(yUnitVec3).cross(a), tmpvec.normalize(), this.setAxisAngle(tmpvec, Math.PI)) : .999999 < dot ? this.set(0, 0, 0, 1) : (tmpvec.copy(a).cross(b), this._x = tmpvec.x, this._y = tmpvec.y, this._z = tmpvec.z, this._w = 1 + dot, this.normalize());
      },
      setAxes: function setAxes(view, right, up) {
        var m = tmpMat3.val;
        return m[0] = right.x, m[3] = right.y, m[6] = right.z, m[1] = up.x, m[4] = up.y, m[7] = up.z, m[2] = -view.x, m[5] = -view.y, m[8] = -view.z, this.fromMat3(tmpMat3).normalize();
      },
      identity: function identity() {
        return this.set(0, 0, 0, 1);
      },
      setAxisAngle: function setAxisAngle(axis, rad) {
        rad *= .5;
        var s = Math.sin(rad);
        return this.set(s * axis.x, s * axis.y, s * axis.z, Math.cos(rad));
      },
      multiply: function multiply(bw) {
        var ax = this.x,
            ay = this.y,
            az = this.z,
            aw = this.w,
            bx = bw.x,
            by = bw.y,
            bz = bw.z,
            bw = bw.w;
        return this.set(ax * bw + aw * bx + ay * bz - az * by, ay * bw + aw * by + az * bx - ax * bz, az * bw + aw * bz + ax * by - ay * bx, aw * bw - ax * bx - ay * by - az * bz);
      },
      slerp: function slerp(omega, t) {
        var ax = this.x,
            ay = this.y,
            az = this.z,
            aw = this.w,
            bx = omega.x,
            by = omega.y,
            bz = omega.z,
            bw = omega.w,
            sinom = ax * bx + ay * by + az * bz + aw * bw;
        sinom < 0 && (sinom = -sinom, bx = -bx, by = -by, bz = -bz, bw = -bw);
        var scale0 = 1 - t,
            scale1 = t;
        return 1e-6 < 1 - sinom && (omega = Math.acos(sinom), sinom = Math.sin(omega), scale0 = Math.sin((1 - t) * omega) / sinom, scale1 = Math.sin(t * omega) / sinom), this.set(scale0 * ax + scale1 * bx, scale0 * ay + scale1 * by, scale0 * az + scale1 * bz, scale0 * aw + scale1 * bw);
      },
      invert: function invert() {
        var a0 = this.x,
            a1 = this.y,
            a2 = this.z,
            a3 = this.w,
            invDot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3,
            invDot = invDot ? 1 / invDot : 0;
        return this.set(-a0 * invDot, -a1 * invDot, -a2 * invDot, a3 * invDot);
      },
      conjugate: function conjugate() {
        return this._x = -this.x, this._y = -this.y, this._z = -this.z, this.onChangeCallback(this), this;
      },
      rotateX: function rotateX(bw) {
        bw *= .5;
        var ax = this.x,
            ay = this.y,
            az = this.z,
            aw = this.w,
            bx = Math.sin(bw),
            bw = Math.cos(bw);
        return this.set(ax * bw + aw * bx, ay * bw + az * bx, az * bw - ay * bx, aw * bw - ax * bx);
      },
      rotateY: function rotateY(bw) {
        bw *= .5;
        var ax = this.x,
            ay = this.y,
            az = this.z,
            aw = this.w,
            by = Math.sin(bw),
            bw = Math.cos(bw);
        return this.set(ax * bw - az * by, ay * bw + aw * by, az * bw + ax * by, aw * bw - ay * by);
      },
      rotateZ: function rotateZ(bw) {
        bw *= .5;
        var ax = this.x,
            ay = this.y,
            az = this.z,
            aw = this.w,
            bz = Math.sin(bw),
            bw = Math.cos(bw);
        return this.set(ax * bw + ay * bz, ay * bw - ax * bz, az * bw + aw * bz, aw * bw - az * bz);
      },
      calculateW: function calculateW() {
        var x = this.x,
            y = this.y,
            z = this.z;
        return this.w = -Math.sqrt(1 - x * x - y * y - z * z), this;
      },
      setFromEuler: function setFromEuler(euler, update) {
        var x = euler.x / 2,
            y = euler.y / 2,
            z = euler.z / 2,
            c1 = Math.cos(x),
            c2 = Math.cos(y),
            c3 = Math.cos(z),
            s1 = Math.sin(x),
            s2 = Math.sin(y),
            s3 = Math.sin(z);

        switch (euler.order) {
          case "XYZ":
            this.set(s1 * c2 * c3 + c1 * s2 * s3, c1 * s2 * c3 - s1 * c2 * s3, c1 * c2 * s3 + s1 * s2 * c3, c1 * c2 * c3 - s1 * s2 * s3, update);
            break;

          case "YXZ":
            this.set(s1 * c2 * c3 + c1 * s2 * s3, c1 * s2 * c3 - s1 * c2 * s3, c1 * c2 * s3 - s1 * s2 * c3, c1 * c2 * c3 + s1 * s2 * s3, update);
            break;

          case "ZXY":
            this.set(s1 * c2 * c3 - c1 * s2 * s3, c1 * s2 * c3 + s1 * c2 * s3, c1 * c2 * s3 + s1 * s2 * c3, c1 * c2 * c3 - s1 * s2 * s3, update);
            break;

          case "ZYX":
            this.set(s1 * c2 * c3 - c1 * s2 * s3, c1 * s2 * c3 + s1 * c2 * s3, c1 * c2 * s3 - s1 * s2 * c3, c1 * c2 * c3 + s1 * s2 * s3, update);
            break;

          case "YZX":
            this.set(s1 * c2 * c3 + c1 * s2 * s3, c1 * s2 * c3 + s1 * c2 * s3, c1 * c2 * s3 - s1 * s2 * c3, c1 * c2 * c3 - s1 * s2 * s3, update);
            break;

          case "XZY":
            this.set(s1 * c2 * c3 - c1 * s2 * s3, c1 * s2 * c3 - s1 * c2 * s3, c1 * c2 * s3 + s1 * s2 * c3, c1 * c2 * c3 + s1 * s2 * s3, update);
        }

        return this;
      },
      setFromRotationMatrix: function setFromRotationMatrix(m33) {
        var s,
            trace = m33.val,
            m11 = trace[0],
            m12 = trace[4],
            m13 = trace[8],
            m21 = trace[1],
            m22 = trace[5],
            m23 = trace[9],
            m31 = trace[2],
            m32 = trace[6],
            m33 = trace[10],
            trace = m11 + m22 + m33;
        return 0 < trace ? (s = .5 / Math.sqrt(trace + 1), this.set((m32 - m23) * s, (m13 - m31) * s, (m21 - m12) * s, .25 / s)) : m22 < m11 && m33 < m11 ? (s = 2 * Math.sqrt(1 + m11 - m22 - m33), this.set(.25 * s, (m12 + m21) / s, (m13 + m31) / s, (m32 - m23) / s)) : m33 < m22 ? (s = 2 * Math.sqrt(1 + m22 - m11 - m33), this.set((m12 + m21) / s, .25 * s, (m23 + m32) / s, (m13 - m31) / s)) : (s = 2 * Math.sqrt(1 + m33 - m11 - m22), this.set((m13 + m31) / s, (m23 + m32) / s, .25 * s, (m21 - m12) / s)), this;
      },
      fromMat3: function fromMat3(j) {
        var i,
            fRoot,
            m = j.val,
            k = m[0] + m[4] + m[8];
        return 0 < k ? (fRoot = Math.sqrt(k + 1), this.w = .5 * fRoot, this._x = (m[7] - m[5]) * (fRoot = .5 / fRoot), this._y = (m[2] - m[6]) * fRoot, this._z = (m[3] - m[1]) * fRoot) : (m[4] > m[i = 0] && (i = 1), m[8] > m[3 * i + i] && (i = 2), j = siNext[i], k = siNext[j], fRoot = Math.sqrt(m[3 * i + i] - m[3 * j + j] - m[3 * k + k] + 1), tmp[i] = .5 * fRoot, tmp[j] = (m[3 * j + i] + m[3 * i + j]) * (fRoot = .5 / fRoot), tmp[k] = (m[3 * k + i] + m[3 * i + k]) * fRoot, this._x = tmp[0], this._y = tmp[1], this._z = tmp[2], this._w = (m[3 * k + j] - m[3 * j + k]) * fRoot), this.onChangeCallback(this), this;
      }
    });
    module.exports = Quaternion;
  }, function (module, exports, __webpack_require__) {
    var CanvasInterpolation = __webpack_require__(367),
        CanvasPool = __webpack_require__(31),
        CONST = __webpack_require__(33),
        Features = __webpack_require__(191);

    module.exports = function (game) {
      var config = game.config;
      if ((config.customEnvironment || config.canvas) && config.renderType === CONST.AUTO) throw new Error("Must set explicit renderType in custom environment");
      if (!config.customEnvironment && !config.canvas && config.renderType !== CONST.HEADLESS) if (config.renderType === CONST.CANVAS || config.renderType !== CONST.CANVAS && !Features.webGL) {
        if (!Features.canvas) throw new Error("Cannot create Canvas or WebGL context, aborting.");
        config.renderType = CONST.CANVAS;
      } else config.renderType = CONST.WEBGL;
      config.antialias || CanvasPool.disableSmoothing();
      var WebGLRenderer = game.scale.baseSize,
          CanvasRenderer = WebGLRenderer.width,
          WebGLRenderer = WebGLRenderer.height;
      config.canvas ? (game.canvas = config.canvas, game.canvas.width = CanvasRenderer, game.canvas.height = WebGLRenderer) : game.canvas = CanvasPool.create(game, CanvasRenderer, WebGLRenderer, config.renderType), config.canvasStyle && (game.canvas.style = config.canvasStyle), config.antialias || CanvasInterpolation.setCrisp(game.canvas), config.renderType !== CONST.HEADLESS && (CanvasRenderer = __webpack_require__(368), WebGLRenderer = __webpack_require__(371), config.renderType === CONST.WEBGL ? game.renderer = new WebGLRenderer(game) : (game.renderer = new CanvasRenderer(game), game.context = game.renderer.gameContext));
    };
  }, function (module, exports) {
    module.exports = {
      setCrisp: function setCrisp(canvas) {
        return ["optimizeSpeed", "-moz-crisp-edges", "-o-crisp-edges", "-webkit-optimize-contrast", "optimize-contrast", "crisp-edges", "pixelated"].forEach(function (type) {
          canvas.style["image-rendering"] = type;
        }), canvas.style.msInterpolationMode = "nearest-neighbor", canvas;
      },
      setBicubic: function setBicubic(canvas) {
        return canvas.style["image-rendering"] = "auto", canvas.style.msInterpolationMode = "bicubic", canvas;
      }
    };
  }, function (module, exports, __webpack_require__) {
    var CameraEvents = __webpack_require__(37),
        CanvasSnapshot = __webpack_require__(369),
        CanvasRenderer = __webpack_require__(0),
        CONST = __webpack_require__(33),
        EventEmitter = __webpack_require__(9),
        Events = __webpack_require__(91),
        GetBlendModes = __webpack_require__(370),
        ScaleEvents = __webpack_require__(104),
        TextureEvents = __webpack_require__(106),
        TransformMatrix = __webpack_require__(25),
        CanvasRenderer = new CanvasRenderer({
      Extends: EventEmitter,
      initialize: function initialize(game) {
        EventEmitter.call(this);
        var gameConfig = game.config;
        this.config = {
          clearBeforeRender: gameConfig.clearBeforeRender,
          backgroundColor: gameConfig.backgroundColor,
          antialias: gameConfig.antialias,
          roundPixels: gameConfig.roundPixels
        }, this.game = game, this.type = CONST.CANVAS, this.drawCount = 0, this.width = 0, this.height = 0, this.gameCanvas = game.canvas;
        var contextOptions = {
          alpha: game.config.transparent,
          desynchronized: game.config.desynchronized
        };
        this.gameContext = gameConfig.context || this.gameCanvas.getContext("2d", contextOptions), this.currentContext = this.gameContext, this.antialias = game.config.antialias, this.blendModes = GetBlendModes(), this.snapshotState = {
          x: 0,
          y: 0,
          width: 1,
          height: 1,
          getPixel: !1,
          callback: null,
          type: "image/png",
          encoder: .92
        }, this._tempMatrix1 = new TransformMatrix(), this._tempMatrix2 = new TransformMatrix(), this._tempMatrix3 = new TransformMatrix(), this.isBooted = !1, this.init();
      },
      init: function init() {
        this.game.textures.once(TextureEvents.READY, this.boot, this);
      },
      boot: function boot() {
        var game = this.game,
            baseSize = game.scale.baseSize;
        this.width = baseSize.width, this.height = baseSize.height, this.isBooted = !0, game.scale.on(ScaleEvents.RESIZE, this.onResize, this), this.resize(baseSize.width, baseSize.height);
      },
      onResize: function onResize(gameSize, baseSize) {
        baseSize.width === this.width && baseSize.height === this.height || this.resize(baseSize.width, baseSize.height);
      },
      resize: function resize(width, height) {
        this.width = width, this.height = height, this.emit(Events.RESIZE, width, height);
      },
      resetTransform: function resetTransform() {
        this.currentContext.setTransform(1, 0, 0, 1, 0, 0);
      },
      setBlendMode: function setBlendMode(blendMode) {
        return this.currentContext.globalCompositeOperation = blendMode, this;
      },
      setContext: function setContext(ctx) {
        return this.currentContext = ctx || this.gameContext, this;
      },
      setAlpha: function setAlpha(alpha) {
        return this.currentContext.globalAlpha = alpha, this;
      },
      preRender: function preRender() {
        var ctx = this.gameContext,
            config = this.config,
            width = this.width,
            height = this.height;
        ctx.globalAlpha = 1, ctx.globalCompositeOperation = "source-over", ctx.setTransform(1, 0, 0, 1, 0, 0), config.clearBeforeRender && (ctx.clearRect(0, 0, width, height), config.transparent || (ctx.fillStyle = config.backgroundColor.rgba, ctx.fillRect(0, 0, width, height))), ctx.save(), this.drawCount = 0, this.emit(Events.PRE_RENDER);
      },
      render: function render(scene, children, camera) {
        var childCount = children.length;
        this.emit(Events.RENDER, scene, camera);
        var cx = camera.x,
            cy = camera.y,
            cw = camera.width,
            ch = camera.height,
            ctx = (camera.renderToTexture ? camera : scene.sys).context;
        ctx.save(), this.game.scene.customViewports && (ctx.beginPath(), ctx.rect(cx, cy, cw, ch), ctx.clip()), this.currentContext = ctx;
        var mask = camera.mask;
        mask && mask.preRenderCanvas(this, null, camera._maskCamera), camera.transparent || (ctx.fillStyle = camera.backgroundColor.rgba, ctx.fillRect(cx, cy, cw, ch)), ctx.globalAlpha = camera.alpha, ctx.globalCompositeOperation = "source-over", this.drawCount += childCount, camera.renderToTexture && camera.emit(CameraEvents.PRE_RENDER, camera), camera.matrix.copyToContext(ctx);

        for (var i = 0; i < childCount; i++) {
          var child = children[i];
          child.mask && child.mask.preRenderCanvas(this, child, camera), child.renderCanvas(this, child, camera), child.mask && child.mask.postRenderCanvas(this, child, camera);
        }

        ctx.setTransform(1, 0, 0, 1, 0, 0), ctx.globalCompositeOperation = "source-over", ctx.globalAlpha = 1, camera.flashEffect.postRenderCanvas(ctx), camera.fadeEffect.postRenderCanvas(ctx), camera.dirty = !1, mask && mask.postRenderCanvas(this), ctx.restore(), camera.renderToTexture && (camera.emit(CameraEvents.POST_RENDER, camera), camera.renderToGame && scene.sys.context.drawImage(camera.canvas, cx, cy));
      },
      postRender: function postRender() {
        this.gameContext.restore(), this.emit(Events.POST_RENDER);
        var state = this.snapshotState;
        state.callback && (CanvasSnapshot(this.gameCanvas, state), state.callback = null);
      },
      snapshotCanvas: function snapshotCanvas(canvas, callback, getPixel, x, y, width, height, type, state) {
        void 0 === getPixel && (getPixel = !1), this.snapshotArea(x, y, width, height, callback, type, state);
        state = this.snapshotState;
        return state.getPixel = getPixel, CanvasSnapshot(this.canvas, state), state.callback = null, this;
      },
      snapshot: function snapshot(callback, type, encoderOptions) {
        return this.snapshotArea(0, 0, this.gameCanvas.width, this.gameCanvas.height, callback, type, encoderOptions);
      },
      snapshotArea: function snapshotArea(x, y, width, height, callback, type, encoderOptions) {
        var state = this.snapshotState;
        return state.callback = callback, state.type = type, state.encoder = encoderOptions, state.getPixel = !1, state.x = x, state.y = y, state.width = Math.min(width, this.gameCanvas.width), state.height = Math.min(height, this.gameCanvas.height), this;
      },
      snapshotPixel: function snapshotPixel(x, y, callback) {
        return this.snapshotArea(x, y, 1, 1, callback), this.snapshotState.getPixel = !0, this;
      },
      batchSprite: function batchSprite(sprite, frame, camera, parentTransformMatrix) {
        var ctx,
            camMatrix,
            spriteMatrix,
            frameX,
            frameY,
            frameWidth,
            frameHeight,
            customPivot,
            res,
            displayOriginX,
            displayOriginY,
            x,
            y,
            flipX,
            flipY,
            alpha = camera.alpha * sprite.alpha;
        0 != alpha && (ctx = this.currentContext, camMatrix = this._tempMatrix1, spriteMatrix = this._tempMatrix2, frameX = (flipX = frame.canvasData).x, frameY = flipX.y, frameWidth = frame.cutWidth, frameHeight = frame.cutHeight, customPivot = frame.customPivot, res = frame.source.resolution, displayOriginX = sprite.displayOriginX, displayOriginY = sprite.displayOriginY, x = -displayOriginX + frame.x, y = -displayOriginY + frame.y, sprite.isCropped && ((flipY = sprite._crop).flipX === sprite.flipX && flipY.flipY === sprite.flipY || frame.updateCropUVs(flipY, sprite.flipX, sprite.flipY), frameWidth = flipY.cw, frameHeight = flipY.ch, frameX = flipY.cx, frameY = flipY.cy, x = -displayOriginX + flipY.x, y = -displayOriginY + flipY.y, sprite.flipX && (0 <= x ? x = -(x + frameWidth) : x < 0 && (x = Math.abs(x) - frameWidth)), sprite.flipY && (0 <= y ? y = -(y + frameHeight) : y < 0 && (y = Math.abs(y) - frameHeight))), flipY = flipX = 1, sprite.flipX && (customPivot || (x += -frame.realWidth + 2 * displayOriginX), flipX = -1), sprite.flipY && (customPivot || (y += -frame.realHeight + 2 * displayOriginY), flipY = -1), spriteMatrix.applyITRS(sprite.x, sprite.y, sprite.rotation, sprite.scaleX * flipX, sprite.scaleY * flipY), camMatrix.copyFrom(camera.matrix), parentTransformMatrix ? (camMatrix.multiplyWithOffset(parentTransformMatrix, -camera.scrollX * sprite.scrollFactorX, -camera.scrollY * sprite.scrollFactorY), spriteMatrix.e = sprite.x, spriteMatrix.f = sprite.y) : (spriteMatrix.e -= camera.scrollX * sprite.scrollFactorX, spriteMatrix.f -= camera.scrollY * sprite.scrollFactorY), camMatrix.multiply(spriteMatrix), ctx.save(), camMatrix.setToContext(ctx), ctx.globalCompositeOperation = this.blendModes[sprite.blendMode], ctx.globalAlpha = alpha, ctx.imageSmoothingEnabled = !(!this.antialias || frame.source.scaleMode), sprite.mask && sprite.mask.preRenderCanvas(this, sprite, camera), ctx.drawImage(frame.source.image, frameX, frameY, frameWidth, frameHeight, x, y, frameWidth / res, frameHeight / res), sprite.mask && sprite.mask.postRenderCanvas(this, sprite, camera), ctx.restore());
      },
      destroy: function destroy() {
        this.removeAllListeners(), this.game = null, this.gameCanvas = null, this.gameContext = null;
      }
    });

    module.exports = CanvasRenderer;
  }, function (module, exports, __webpack_require__) {
    var CanvasPool = __webpack_require__(31),
        Color = __webpack_require__(38),
        GetFastValue = __webpack_require__(2);

    module.exports = function (canvas, data) {
      var copyCanvas,
          image1,
          image2,
          callback = GetFastValue(data, "callback"),
          type = GetFastValue(data, "type", "image/png"),
          encoderOptions = GetFastValue(data, "encoder", .92),
          x = Math.abs(Math.round(GetFastValue(data, "x", 0))),
          y = Math.abs(Math.round(GetFastValue(data, "y", 0))),
          width = GetFastValue(data, "width", canvas.width),
          height = GetFastValue(data, "height", canvas.height);
      GetFastValue(data, "getPixel", !1) ? (data = canvas.getContext("2d").getImageData(x, y, 1, 1).data, callback.call(null, new Color(data[0], data[1], data[2], data[3] / 255))) : 0 !== x || 0 !== y || width !== canvas.width || height !== canvas.height ? ((copyCanvas = CanvasPool.createWebGL(this, width, height)).getContext("2d").drawImage(canvas, x, y, width, height, 0, 0, width, height), (image1 = new Image()).onerror = function () {
        callback.call(null), CanvasPool.remove(copyCanvas);
      }, image1.onload = function () {
        callback.call(null, image1), CanvasPool.remove(copyCanvas);
      }, image1.src = copyCanvas.toDataURL(type, encoderOptions)) : ((image2 = new Image()).onerror = function () {
        callback.call(null);
      }, image2.onload = function () {
        callback.call(null, image2);
      }, image2.src = canvas.toDataURL(type, encoderOptions));
    };
  }, function (module, exports, __webpack_require__) {
    var modes = __webpack_require__(35),
        CanvasFeatures = __webpack_require__(348);

    module.exports = function () {
      var output = [],
          useNew = CanvasFeatures.supportNewBlendModes,
          so = "source-over";
      return output[modes.NORMAL] = so, output[modes.ADD] = "lighter", output[modes.MULTIPLY] = useNew ? "multiply" : so, output[modes.SCREEN] = useNew ? "screen" : so, output[modes.OVERLAY] = useNew ? "overlay" : so, output[modes.DARKEN] = useNew ? "darken" : so, output[modes.LIGHTEN] = useNew ? "lighten" : so, output[modes.COLOR_DODGE] = useNew ? "color-dodge" : so, output[modes.COLOR_BURN] = useNew ? "color-burn" : so, output[modes.HARD_LIGHT] = useNew ? "hard-light" : so, output[modes.SOFT_LIGHT] = useNew ? "soft-light" : so, output[modes.DIFFERENCE] = useNew ? "difference" : so, output[modes.EXCLUSION] = useNew ? "exclusion" : so, output[modes.HUE] = useNew ? "hue" : so, output[modes.SATURATION] = useNew ? "saturation" : so, output[modes.COLOR] = useNew ? "color" : so, output[modes.LUMINOSITY] = useNew ? "luminosity" : so, output[modes.ERASE] = "destination-out", output[modes.SOURCE_IN] = "source-in", output[modes.SOURCE_OUT] = "source-out", output[modes.SOURCE_ATOP] = "source-atop", output[modes.DESTINATION_OVER] = "destination-over", output[modes.DESTINATION_IN] = "destination-in", output[modes.DESTINATION_OUT] = "destination-out", output[modes.DESTINATION_ATOP] = "destination-atop", output[modes.LIGHTER] = "lighter", output[modes.COPY] = "copy", output[modes.XOR] = "xor", output;
    };
  }, function (module, exports, __webpack_require__) {
    var ArrayRemove = __webpack_require__(93),
        CameraEvents = __webpack_require__(37),
        WebGLRenderer = __webpack_require__(0),
        CONST = __webpack_require__(33),
        EventEmitter = __webpack_require__(9),
        Events = __webpack_require__(91),
        GameEvents = __webpack_require__(22),
        IsSizePowerOfTwo = __webpack_require__(138),
        Matrix4 = __webpack_require__(69),
        NOOP = __webpack_require__(1),
        PipelineManager = __webpack_require__(372),
        RenderTarget = __webpack_require__(141),
        ScaleEvents = __webpack_require__(104),
        TextureEvents = __webpack_require__(106),
        Utils = __webpack_require__(12),
        WebGLSnapshot = __webpack_require__(383),
        WebGLRenderer = new WebGLRenderer({
      Extends: EventEmitter,
      initialize: function initialize(game) {
        EventEmitter.call(this);
        var gameConfig = game.config,
            contextCreationConfig = {
          alpha: gameConfig.transparent,
          desynchronized: gameConfig.desynchronized,
          depth: !1,
          antialias: gameConfig.antialiasGL,
          premultipliedAlpha: gameConfig.premultipliedAlpha,
          stencil: !0,
          failIfMajorPerformanceCaveat: gameConfig.failIfMajorPerformanceCaveat,
          powerPreference: gameConfig.powerPreference,
          preserveDrawingBuffer: gameConfig.preserveDrawingBuffer
        };
        this.config = {
          clearBeforeRender: gameConfig.clearBeforeRender,
          antialias: gameConfig.antialias,
          backgroundColor: gameConfig.backgroundColor,
          contextCreation: contextCreationConfig,
          roundPixels: gameConfig.roundPixels,
          maxTextures: gameConfig.maxTextures,
          maxTextureSize: gameConfig.maxTextureSize,
          batchSize: gameConfig.batchSize,
          maxLights: gameConfig.maxLights,
          mipmapFilter: gameConfig.mipmapFilter
        }, this.game = game, this.type = CONST.WEBGL, this.pipelines = null, this.width = 0, this.height = 0, this.canvas = game.canvas, this.blendModes = [], this.contextLost = !1, this.snapshotState = {
          x: 0,
          y: 0,
          width: 1,
          height: 1,
          getPixel: !1,
          callback: null,
          type: "image/png",
          encoder: .92,
          isFramebuffer: !1,
          bufferWidth: 0,
          bufferHeight: 0
        }, this.currentActiveTexture = 0, this.startActiveTexture = 0, this.maxTextures = 0, this.textureIndexes, this.tempTextures, this.textureZero, this.normalTexture, this.currentFramebuffer = null, this.fboStack = [], this.currentProgram = null, this.currentBlendMode = 1 / 0, this.currentScissorEnabled = !1, this.currentScissor = null, this.scissorStack = [], this.contextLostHandler = NOOP, this.contextRestoredHandler = NOOP, this.gl = null, this.supportedExtensions = null, this.instancedArraysExtension = null, this.vaoExtension = null, this.extensions = {}, this.glFormats = [], this.compression = {
          ETC1: !1,
          PVRTC: !1,
          S3TC: !1
        }, this.drawingBufferHeight = 0, this.blankTexture = null, this.whiteTexture = null, this.maskCount = 0, this.maskStack = [], this.currentMask = {
          mask: null,
          camera: null
        }, this.currentCameraMask = {
          mask: null,
          camera: null
        }, this.glFuncMap = null, this.currentType = "", this.newType = !1, this.nextTypeMatch = !1, this.finalType = !1, this.mipmapFilter = null, this.textureFlush = 0, this.isTextureClean = !1, this.defaultScissor = [0, 0, 0, 0], this.isBooted = !1, this.renderTarget = null, this.projectionMatrix, this.projectionWidth = 0, this.projectionHeight = 0, this.init(this.config);
      },
      init: function init(config) {
        var game = this.game,
            wkExtString = this.canvas,
            clearColor = config.backgroundColor,
            gl = game.config.context || wkExtString.getContext("webgl", config.contextCreation) || wkExtString.getContext("experimental-webgl", config.contextCreation);
        if (!gl || gl.isContextLost()) throw this.contextLost = !0, new Error("WebGL unsupported");
        this.gl = gl;

        var _this = this;

        this.contextLostHandler = function (event) {
          _this.contextLost = !0, _this.game.events.emit(GameEvents.CONTEXT_LOST, _this), event.preventDefault();
        }, this.contextRestoredHandler = function () {
          _this.contextLost = !1, _this.init(_this.config), _this.game.events.emit(GameEvents.CONTEXT_RESTORED, _this);
        }, wkExtString.addEventListener("webglcontextlost", this.contextLostHandler, !1), wkExtString.addEventListener("webglcontextrestored", this.contextRestoredHandler, !1), game.context = gl;

        for (var i = 0; i <= 27; i++) {
          this.blendModes.push({
            func: [gl.ONE, gl.ONE_MINUS_SRC_ALPHA],
            equation: gl.FUNC_ADD
          });
        }

        this.blendModes[1].func = [gl.ONE, gl.DST_ALPHA], this.blendModes[2].func = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA], this.blendModes[3].func = [gl.ONE, gl.ONE_MINUS_SRC_COLOR], this.blendModes[17] = {
          func: [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA],
          equation: gl.FUNC_REVERSE_SUBTRACT
        }, this.glFormats[0] = gl.BYTE, this.glFormats[1] = gl.SHORT, this.glFormats[2] = gl.UNSIGNED_BYTE, this.glFormats[3] = gl.UNSIGNED_SHORT, this.glFormats[4] = gl.FLOAT, this.glFuncMap = {
          mat2: {
            func: gl.uniformMatrix2fv,
            length: 1,
            matrix: !0
          },
          mat3: {
            func: gl.uniformMatrix3fv,
            length: 1,
            matrix: !0
          },
          mat4: {
            func: gl.uniformMatrix4fv,
            length: 1,
            matrix: !0
          },
          "1f": {
            func: gl.uniform1f,
            length: 1
          },
          "1fv": {
            func: gl.uniform1fv,
            length: 1
          },
          "1i": {
            func: gl.uniform1i,
            length: 1
          },
          "1iv": {
            func: gl.uniform1iv,
            length: 1
          },
          "2f": {
            func: gl.uniform2f,
            length: 2
          },
          "2fv": {
            func: gl.uniform2fv,
            length: 1
          },
          "2i": {
            func: gl.uniform2i,
            length: 2
          },
          "2iv": {
            func: gl.uniform2iv,
            length: 1
          },
          "3f": {
            func: gl.uniform3f,
            length: 3
          },
          "3fv": {
            func: gl.uniform3fv,
            length: 1
          },
          "3i": {
            func: gl.uniform3i,
            length: 3
          },
          "3iv": {
            func: gl.uniform3iv,
            length: 1
          },
          "4f": {
            func: gl.uniform4f,
            length: 4
          },
          "4fv": {
            func: gl.uniform4fv,
            length: 1
          },
          "4i": {
            func: gl.uniform4i,
            length: 4
          },
          "4iv": {
            func: gl.uniform4iv,
            length: 1
          }
        };
        var exts = gl.getSupportedExtensions();
        config.maxTextures && -1 !== config.maxTextures || (config.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS)), config.maxTextureSize || (config.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE));
        var extString = "WEBGL_compressed_texture_",
            wkExtString = "WEBKIT_" + extString;
        this.compression.ETC1 = gl.getExtension(extString + "etc1") || gl.getExtension(wkExtString + "etc1"), this.compression.PVRTC = gl.getExtension(extString + "pvrtc") || gl.getExtension(wkExtString + "pvrtc"), this.compression.S3TC = gl.getExtension(extString + "s3tc") || gl.getExtension(wkExtString + "s3tc"), this.supportedExtensions = exts;
        this.instancedArraysExtension = -1 < exts.indexOf("ANGLE_instanced_arrays") ? gl.getExtension("ANGLE_instanced_arrays") : null;
        this.vaoExtension = -1 < exts.indexOf("OES_vertex_array_object") ? gl.getExtension("OES_vertex_array_object") : null, gl.disable(gl.DEPTH_TEST), gl.disable(gl.CULL_FACE), gl.enable(gl.BLEND), gl.clearColor(clearColor.redGL, clearColor.greenGL, clearColor.blueGL, clearColor.alphaGL), this.mipmapFilter = gl[config.mipmapFilter], this.maxTextures = Utils.checkShaderMax(gl, config.maxTextures), this.textureIndexes = [];
        var tempTextures = this.tempTextures;
        if (Array.isArray(tempTextures)) for (var t = 0; i < this.maxTextures; t++) {
          gl.deleteTexture(tempTextures[t]);
        } else tempTextures = new Array(this.maxTextures);

        for (var index = 0; index < this.maxTextures; index++) {
          var tempTexture = gl.createTexture();
          gl.activeTexture(gl.TEXTURE0 + index), gl.bindTexture(gl.TEXTURE_2D, tempTexture), gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 255, 255])), tempTextures[index] = tempTexture, this.textureIndexes.push(index);
        }

        return this.tempTextures = tempTextures, this.currentActiveTexture = 1, this.startActiveTexture++, gl.activeTexture(gl.TEXTURE1), this.pipelines = new PipelineManager(this), this.setBlendMode(CONST.BlendModes.NORMAL), this.projectionMatrix = new Matrix4().identity(), game.textures.once(TextureEvents.READY, this.boot, this), this;
      },
      boot: function boot() {
        var game = this.game,
            gl = this.pipelines,
            baseSize = game.scale.baseSize;
        this.width = baseSize.width, this.height = baseSize.height, this.isBooted = !0, this.renderTarget = new RenderTarget(this, this.width, this.height, 1, 0, !0, !0), gl.boot(game.config.pipeline), this.blankTexture = game.textures.getFrame("__DEFAULT"), this.whiteTexture = game.textures.getFrame("__WHITE");
        gl = this.gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, null), gl.enable(gl.SCISSOR_TEST), game.scale.on(ScaleEvents.RESIZE, this.onResize, this), this.resize(baseSize.width, baseSize.height);
      },
      onResize: function onResize(gameSize, baseSize) {
        baseSize.width === this.width && baseSize.height === this.height || this.resize(baseSize.width, baseSize.height);
      },
      beginCapture: function beginCapture(width, height) {
        void 0 === width && (width = this.width), void 0 === height && (height = this.height), this.renderTarget.bind(!0, width, height), this.setProjectionMatrix(width, height), this.resetTextures();
      },
      endCapture: function endCapture() {
        return this.renderTarget.unbind(!0), this.resetProjectionMatrix(), this.renderTarget;
      },
      resize: function resize(width, height) {
        var gl = this.gl;
        return this.width = width, this.height = height, this.setProjectionMatrix(width, height), gl.viewport(0, 0, width, height), this.drawingBufferHeight = gl.drawingBufferHeight, gl.scissor(0, gl.drawingBufferHeight - height, width, height), this.defaultScissor[2] = width, this.defaultScissor[3] = height, this.emit(Events.RESIZE, width, height), this;
      },
      getAspectRatio: function getAspectRatio() {
        return this.width / this.height;
      },
      setProjectionMatrix: function setProjectionMatrix(width, height) {
        return width === this.projectionWidth && height === this.projectionHeight || (this.projectionWidth = width, this.projectionHeight = height, this.projectionMatrix.ortho(0, width, height, 0, -1e3, 1e3)), this;
      },
      resetProjectionMatrix: function resetProjectionMatrix() {
        this.projectionWidth = this.width, this.projectionHeight = this.height, this.projectionMatrix.ortho(0, this.width, this.height, 0, -1e3, 1e3);
      },
      hasExtension: function hasExtension(extensionName) {
        return !!this.supportedExtensions && this.supportedExtensions.indexOf(extensionName);
      },
      getExtension: function getExtension(extensionName) {
        return this.hasExtension(extensionName) ? (extensionName in this.extensions || (this.extensions[extensionName] = this.gl.getExtension(extensionName)), this.extensions[extensionName]) : null;
      },
      flush: function flush() {
        this.pipelines.flush();
      },
      pushScissor: function pushScissor(x, y, width, height, drawingBufferHeight) {
        void 0 === drawingBufferHeight && (drawingBufferHeight = this.drawingBufferHeight);
        var scissor = [x, y, width, height];
        return this.scissorStack.push(scissor), this.setScissor(x, y, width, height, drawingBufferHeight), this.currentScissor = scissor;
      },
      setScissor: function setScissor(x, y, width, height, drawingBufferHeight) {
        void 0 === drawingBufferHeight && (drawingBufferHeight = this.drawingBufferHeight);
        var cx,
            cy,
            cw,
            gl = this.gl,
            ch = this.currentScissor,
            setScissor = 0 < width && 0 < height;
        ch && setScissor && (cx = ch[0], cy = ch[1], cw = ch[2], ch = ch[3], setScissor = cx !== x || cy !== y || cw !== width || ch !== height), setScissor && (this.flush(), gl.scissor(x, drawingBufferHeight - y - height, width, height));
      },
      resetScissor: function resetScissor() {
        var gl = this.gl;
        gl.enable(gl.SCISSOR_TEST);
        var x,
            y,
            width,
            height = this.currentScissor;
        height && (x = height[0], y = height[1], width = height[2], height = height[3], 0 < width && 0 < height && gl.scissor(x, this.drawingBufferHeight - y - height, width, height));
      },
      popScissor: function popScissor() {
        var scissor = this.scissorStack;
        scissor.pop();
        scissor = scissor[scissor.length - 1];
        scissor && this.setScissor(scissor[0], scissor[1], scissor[2], scissor[3]), this.currentScissor = scissor;
      },
      hasActiveStencilMask: function hasActiveStencilMask() {
        var mask = this.currentMask.mask,
            camMask = this.currentCameraMask.mask;
        return mask && mask.isStencil || camMask && camMask.isStencil;
      },
      resetViewport: function resetViewport() {
        var gl = this.gl;
        gl.viewport(0, 0, this.width, this.height), this.drawingBufferHeight = gl.drawingBufferHeight;
      },
      setBlendMode: function setBlendMode(blendModeId, force) {
        var gl = this.gl,
            blendMode = this.blendModes[blendModeId];
        return !!((force = void 0 === force ? !1 : force) || blendModeId !== CONST.BlendModes.SKIP_CHECK && this.currentBlendMode !== blendModeId) && (this.flush(), gl.enable(gl.BLEND), gl.blendEquation(blendMode.equation), 2 < blendMode.func.length ? gl.blendFuncSeparate(blendMode.func[0], blendMode.func[1], blendMode.func[2], blendMode.func[3]) : gl.blendFunc(blendMode.func[0], blendMode.func[1]), this.currentBlendMode = blendModeId, !0);
      },
      addBlendMode: function addBlendMode(func, equation) {
        return this.blendModes.push({
          func: func,
          equation: equation
        }) - 1;
      },
      updateBlendMode: function updateBlendMode(index, func, equation) {
        return this.blendModes[index] && (this.blendModes[index].func = func, equation && (this.blendModes[index].equation = equation)), this;
      },
      removeBlendMode: function removeBlendMode(index) {
        return 17 < index && this.blendModes[index] && this.blendModes.splice(index, 1), this;
      },
      setBlankTexture: function setBlankTexture() {
        this.setTexture2D(this.blankTexture.glTexture);
      },
      setTextureSource: function setTextureSource(textureSource) {
        if (this.pipelines.forceZero()) return this.setTextureZero(textureSource.glTexture, !0), 0;
        var gl = this.gl,
            currentActiveTexture = this.currentActiveTexture;
        return textureSource.glIndexCounter < this.startActiveTexture && (textureSource.glIndexCounter = this.startActiveTexture, currentActiveTexture < this.maxTextures ? (textureSource.glIndex = currentActiveTexture, gl.activeTexture(gl.TEXTURE0 + currentActiveTexture), gl.bindTexture(gl.TEXTURE_2D, textureSource.glTexture), this.currentActiveTexture++) : (this.flush(), this.startActiveTexture++, this.textureFlush++, textureSource.glIndexCounter = this.startActiveTexture, textureSource.glIndex = 1, gl.activeTexture(gl.TEXTURE1), gl.bindTexture(gl.TEXTURE_2D, textureSource.glTexture), this.currentActiveTexture = 2)), this.isTextureClean = !1, textureSource.glIndex;
      },
      isNewNormalMap: function isNewNormalMap(texture, normalMap) {
        return this.textureZero !== texture || this.normalTexture !== normalMap;
      },
      setTextureZero: function setTextureZero(texture, gl) {
        this.textureZero !== texture && (gl && this.flush(), (gl = this.gl).activeTexture(gl.TEXTURE0), gl.bindTexture(gl.TEXTURE_2D, texture), this.textureZero = texture);
      },
      clearTextureZero: function clearTextureZero() {
        this.textureZero = null;
      },
      setNormalMap: function setNormalMap(texture) {
        var gl;
        this.normalTexture !== texture && ((gl = this.gl).activeTexture(gl.TEXTURE1), gl.bindTexture(gl.TEXTURE_2D, texture), this.normalTexture = texture, 1 === this.currentActiveTexture && (this.currentActiveTexture = 2));
      },
      clearNormalMap: function clearNormalMap() {
        this.normalTexture = null, this.startActiveTexture++, this.currentActiveTexture = 1, this.textureFlush++;
      },
      unbindTextures: function unbindTextures() {
        for (var gl = this.gl, temp = this.tempTextures, i = 0; i < temp.length; i++) {
          gl.activeTexture(gl.TEXTURE0 + i), gl.bindTexture(gl.TEXTURE_2D, null);
        }

        this.normalTexture = null, this.textureZero = null, this.currentActiveTexture = 1, this.startActiveTexture++, this.textureFlush++;
      },
      resetTextures: function resetTextures(all) {
        if (void 0 === all && (all = !1), !this.isTextureClean) {
          this.flush();
          var gl = this.gl,
              temp = this.tempTextures;

          if (all) {
            for (var i = 0; i < temp.length; i++) {
              gl.activeTexture(gl.TEXTURE0 + i), gl.bindTexture(gl.TEXTURE_2D, temp[i]);
            }

            gl.activeTexture(gl.TEXTURE1), gl.bindTexture(gl.TEXTURE_2D, temp[1]), this.isTextureClean = !0;
          } else gl.activeTexture(gl.TEXTURE0), gl.bindTexture(gl.TEXTURE_2D, temp[0]), gl.activeTexture(gl.TEXTURE1), gl.bindTexture(gl.TEXTURE_2D, temp[1]);

          this.normalTexture = null, this.textureZero = null, this.currentActiveTexture = 1, this.startActiveTexture++, this.textureFlush++;
        }
      },
      setTexture2D: function setTexture2D(texture) {
        if (this.pipelines.forceZero()) return this.setTextureZero(texture, !0), 0;
        var gl = this.gl,
            currentActiveTexture = this.currentActiveTexture;
        return texture.glIndexCounter < this.startActiveTexture && (texture.glIndexCounter = this.startActiveTexture, currentActiveTexture < this.maxTextures ? (texture.glIndex = currentActiveTexture, gl.activeTexture(gl.TEXTURE0 + currentActiveTexture), gl.bindTexture(gl.TEXTURE_2D, texture), this.currentActiveTexture++) : (this.flush(), this.startActiveTexture++, this.textureFlush++, texture.glIndexCounter = this.startActiveTexture, texture.glIndex = 1, gl.activeTexture(gl.TEXTURE1), gl.bindTexture(gl.TEXTURE_2D, texture), this.currentActiveTexture = 2)), this.isTextureClean = !1, texture.glIndex;
      },
      pushFramebuffer: function pushFramebuffer(framebuffer, updateScissor, resetTextures, setViewport) {
        return framebuffer === this.currentFramebuffer ? this : (this.fboStack.push(framebuffer), this.setFramebuffer(framebuffer, updateScissor, resetTextures, setViewport));
      },
      setFramebuffer: function setFramebuffer(framebuffer, updateScissor, resetTextures, setViewport) {
        if (void 0 === updateScissor && (updateScissor = !1), void 0 === resetTextures && (resetTextures = !1), void 0 === setViewport && (setViewport = !0), framebuffer === this.currentFramebuffer) return this;
        var gl = this.gl,
            width = this.width,
            height = this.height;
        return framebuffer && framebuffer.renderTexture && setViewport ? (width = framebuffer.renderTexture.width, height = framebuffer.renderTexture.height) : this.flush(), gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer), setViewport && gl.viewport(0, 0, width, height), updateScissor && (framebuffer ? (this.drawingBufferHeight = height, this.pushScissor(0, 0, width, height)) : (this.drawingBufferHeight = this.height, this.popScissor())), this.currentFramebuffer = framebuffer, resetTextures && this.resetTextures(), this;
      },
      popFramebuffer: function popFramebuffer(updateScissor, resetTextures, setViewport) {
        void 0 === updateScissor && (updateScissor = !1), void 0 === resetTextures && (resetTextures = !1), void 0 === setViewport && (setViewport = !0);
        var framebuffer = this.fboStack;
        framebuffer.pop();
        framebuffer = framebuffer[framebuffer.length - 1] || null;
        return this.setFramebuffer(framebuffer, updateScissor, resetTextures, setViewport), framebuffer;
      },
      setProgram: function setProgram(program) {
        return program !== this.currentProgram && (this.flush(), this.gl.useProgram(program), this.currentProgram = program, !0);
      },
      resetProgram: function resetProgram() {
        return this.gl.useProgram(this.currentProgram), this;
      },
      createTextureFromSource: function createTextureFromSource(source, width, height, scaleMode) {
        var gl = this.gl,
            minFilter = gl.NEAREST,
            magFilter = gl.NEAREST,
            wrap = gl.CLAMP_TO_EDGE;
        width = source ? source.width : width, height = source ? source.height : height;
        var pow = IsSizePowerOfTwo(width, height);
        return pow && (wrap = gl.REPEAT), scaleMode === CONST.ScaleModes.LINEAR && this.config.antialias && (minFilter = pow ? this.mipmapFilter : gl.LINEAR, magFilter = gl.LINEAR), source || "number" != typeof width || "number" != typeof height ? this.createTexture2D(0, minFilter, magFilter, wrap, wrap, gl.RGBA, source) : this.createTexture2D(0, minFilter, magFilter, wrap, wrap, gl.RGBA, null, width, height);
      },
      createTexture2D: function createTexture2D(mipLevel, minFilter, magFilter, wrapT, wrapS, format, pixels, width, height, pma, forceSize, flipY) {
        pma = null == pma || pma, void 0 === forceSize && (forceSize = !1), void 0 === flipY && (flipY = !1);
        var gl = this.gl,
            texture = gl.createTexture();
        gl.activeTexture(gl.TEXTURE0);
        var currentTexture = gl.getParameter(gl.TEXTURE_BINDING_2D);
        return gl.bindTexture(gl.TEXTURE_2D, texture), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT), gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, pma), gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY), null == pixels ? gl.texImage2D(gl.TEXTURE_2D, mipLevel, format, width, height, 0, format, gl.UNSIGNED_BYTE, null) : (forceSize || (width = pixels.width, height = pixels.height), gl.texImage2D(gl.TEXTURE_2D, mipLevel, format, format, gl.UNSIGNED_BYTE, pixels)), IsSizePowerOfTwo(width, height) && gl.generateMipmap(gl.TEXTURE_2D), currentTexture && gl.bindTexture(gl.TEXTURE_2D, currentTexture), texture.isAlphaPremultiplied = pma, texture.isRenderTexture = !1, texture.width = width, texture.height = height, texture.glIndex = 0, texture.glIndexCounter = -1, texture;
      },
      createFramebuffer: function createFramebuffer(width, height, renderTexture, addDepthStencilBuffer) {
        var complete,
            gl = this.gl,
            framebuffer = gl.createFramebuffer();
        if (this.setFramebuffer(framebuffer), addDepthStencilBuffer && (complete = gl.createRenderbuffer(), gl.bindRenderbuffer(gl.RENDERBUFFER, complete), gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height), gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, complete)), renderTexture.isRenderTexture = !0, renderTexture.isAlphaPremultiplied = !1, gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, renderTexture, 0), (complete = gl.checkFramebufferStatus(gl.FRAMEBUFFER)) === gl.FRAMEBUFFER_COMPLETE) return framebuffer.renderTexture = renderTexture, this.setFramebuffer(null), this.resetTextures(), framebuffer;
        throw new Error("Framebuffer status: " + {
          36054: "Incomplete Attachment",
          36055: "Missing Attachment",
          36057: "Incomplete Dimensions",
          36061: "Framebuffer Unsupported"
        }[complete]);
      },
      createProgram: function createProgram(vertexShader, fragmentShader) {
        var gl = this.gl,
            program = gl.createProgram(),
            vs = gl.createShader(gl.VERTEX_SHADER),
            fs = gl.createShader(gl.FRAGMENT_SHADER);
        if (gl.shaderSource(vs, vertexShader), gl.shaderSource(fs, fragmentShader), gl.compileShader(vs), gl.compileShader(fs), !gl.getShaderParameter(vs, gl.COMPILE_STATUS)) throw new Error("Vertex Shader failed:\n" + gl.getShaderInfoLog(vs));
        if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) throw new Error("Fragment Shader failed:\n" + gl.getShaderInfoLog(fs));
        if (gl.attachShader(program, vs), gl.attachShader(program, fs), gl.linkProgram(program), !gl.getProgramParameter(program, gl.LINK_STATUS)) throw new Error("Link Program failed:\n" + gl.getProgramInfoLog(program));
        return gl.useProgram(program), program;
      },
      createVertexBuffer: function createVertexBuffer(initialDataOrSize, bufferUsage) {
        var gl = this.gl,
            vertexBuffer = gl.createBuffer();
        return gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer), gl.bufferData(gl.ARRAY_BUFFER, initialDataOrSize, bufferUsage), gl.bindBuffer(gl.ARRAY_BUFFER, null), vertexBuffer;
      },
      createIndexBuffer: function createIndexBuffer(initialDataOrSize, bufferUsage) {
        var gl = this.gl,
            indexBuffer = gl.createBuffer();
        return gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer), gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, initialDataOrSize, bufferUsage), gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null), indexBuffer;
      },
      deleteTexture: function deleteTexture(texture, reset) {
        return reset && this.resetTextures(!0), texture && this.gl.deleteTexture(texture), this;
      },
      deleteFramebuffer: function deleteFramebuffer(framebuffer) {
        return framebuffer && (this.gl.deleteFramebuffer(framebuffer), ArrayRemove(this.fboStack, framebuffer), this.currentFramebuffer === framebuffer && (this.currentFramebuffer = null)), this;
      },
      deleteProgram: function deleteProgram(program) {
        return program && this.gl.deleteProgram(program), this;
      },
      deleteBuffer: function deleteBuffer(buffer) {
        return this.gl.deleteBuffer(buffer), this;
      },
      preRenderCamera: function preRenderCamera(camera) {
        var cx = camera.x,
            cy = camera.y,
            cw = camera.width,
            ch = camera.height,
            color = camera.backgroundColor;
        camera.emit(CameraEvents.PRE_RENDER, camera), this.pipelines.preBatchCamera(camera), this.pushScissor(cx, cy, cw, ch), camera.mask && (this.currentCameraMask.mask = camera.mask, this.currentCameraMask.camera = camera._maskCamera, camera.mask.preRenderWebGL(this, camera, camera._maskCamera)), 0 < color.alphaGL && this.pipelines.setMulti().drawFillRect(cx, cy, cw, ch, Utils.getTintFromFloats(color.blueGL, color.greenGL, color.redGL, 1), color.alphaGL);
      },
      getCurrentStencilMask: function getCurrentStencilMask() {
        var prev = null,
            stack = this.maskStack,
            cameraMask = this.currentCameraMask;
        return 0 < stack.length ? prev = stack[stack.length - 1] : cameraMask.mask && cameraMask.mask.isStencil && (prev = cameraMask), prev;
      },
      postRenderCamera: function postRenderCamera(camera) {
        var pipeline,
            flashEffect = camera.flashEffect,
            fadeEffect = camera.fadeEffect;
        (flashEffect.isRunning || fadeEffect.isRunning || fadeEffect.isComplete) && (pipeline = this.pipelines.setMulti(), flashEffect.postRenderWebGL(pipeline, Utils.getTintFromFloats), fadeEffect.postRenderWebGL(pipeline, Utils.getTintFromFloats)), camera.dirty = !1, this.popScissor(), camera.mask && (this.currentCameraMask.mask = null, camera.mask.postRenderWebGL(this, camera._maskCamera)), this.pipelines.postBatchCamera(camera), camera.emit(CameraEvents.POST_RENDER, camera);
      },
      preRender: function preRender() {
        var gl, clearColor;
        this.contextLost || ((gl = this.gl).bindFramebuffer(gl.FRAMEBUFFER, null), this.config.clearBeforeRender && (clearColor = this.config.backgroundColor, gl.clearColor(clearColor.redGL, clearColor.greenGL, clearColor.blueGL, clearColor.alphaGL), gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT)), gl.enable(gl.SCISSOR_TEST), this.currentScissor = this.defaultScissor, this.scissorStack.length = 0, this.scissorStack.push(this.currentScissor), this.game.scene.customViewports && gl.scissor(0, this.drawingBufferHeight - this.height, this.width, this.height), this.currentMask.mask = null, this.currentCameraMask.mask = null, this.maskStack.length = 0, this.textureFlush = 0, this.emit(Events.PRE_RENDER));
      },
      render: function render(scene, children, camera) {
        if (!this.contextLost) {
          var childCount = children.length;
          if (this.emit(Events.RENDER, scene, camera), this.preRenderCamera(camera), 0 === childCount) return this.setBlendMode(CONST.BlendModes.NORMAL), void this.postRenderCamera(camera);
          this.currentType = "";

          for (var current = this.currentMask, i = 0; i < childCount; i++) {
            this.finalType = i === childCount - 1;
            var child = children[i],
                type = child.mask;
            (current = this.currentMask).mask && current.mask !== type && current.mask.postRenderWebGL(this, current.camera), type && current.mask !== type && type.preRenderWebGL(this, child, camera), child.blendMode !== this.currentBlendMode && this.setBlendMode(child.blendMode);
            type = child.type;
            type !== this.currentType && (this.newType = !0, this.currentType = type), this.finalType ? this.nextTypeMatch = !1 : this.nextTypeMatch = children[i + 1].type === this.currentType, child.renderWebGL(this, child, camera), this.newType = !1;
          }

          (current = this.currentMask).mask && current.mask.postRenderWebGL(this, current.camera), this.setBlendMode(CONST.BlendModes.NORMAL), this.postRenderCamera(camera);
        }
      },
      postRender: function postRender() {
        var state;
        this.contextLost || (this.flush(), this.emit(Events.POST_RENDER), (state = this.snapshotState).callback && (WebGLSnapshot(this.canvas, state), state.callback = null), 0 < this.textureFlush && (this.startActiveTexture++, this.currentActiveTexture = 1));
      },
      snapshot: function snapshot(callback, type, encoderOptions) {
        return this.snapshotArea(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight, callback, type, encoderOptions);
      },
      snapshotArea: function snapshotArea(x, y, width, height, callback, type, encoderOptions) {
        var state = this.snapshotState;
        return state.callback = callback, state.type = type, state.encoder = encoderOptions, state.getPixel = !1, state.x = x, state.y = y, state.width = Math.min(width, this.gl.drawingBufferWidth), state.height = Math.min(height, this.gl.drawingBufferHeight), this;
      },
      snapshotPixel: function snapshotPixel(x, y, callback) {
        return this.snapshotArea(x, y, 1, 1, callback), this.snapshotState.getPixel = !0, this;
      },
      snapshotFramebuffer: function snapshotFramebuffer(framebuffer, bufferWidth, bufferHeight, callback, getPixel, x, y, width, height, type, state) {
        void 0 === getPixel && (getPixel = !1);
        var currentFramebuffer = this.currentFramebuffer;
        this.snapshotArea(x = void 0 === x ? 0 : x, y = void 0 === y ? 0 : y, width = void 0 === width ? bufferWidth : width, height = void 0 === height ? bufferHeight : height, callback, type, state);
        state = this.snapshotState;
        return state.getPixel = getPixel, state.isFramebuffer = !0, state.bufferWidth = bufferWidth, state.bufferHeight = bufferHeight, this.setFramebuffer(framebuffer), WebGLSnapshot(this.canvas, state), this.setFramebuffer(currentFramebuffer), state.callback = null, state.isFramebuffer = !1, this;
      },
      canvasToTexture: function canvasToTexture(srcCanvas, dstTexture, noRepeat, flipY) {
        return void 0 === noRepeat && (noRepeat = !1), void 0 === flipY && (flipY = !1), dstTexture ? this.updateCanvasTexture(srcCanvas, dstTexture, flipY) : this.createCanvasTexture(srcCanvas, noRepeat, flipY);
      },
      createCanvasTexture: function createCanvasTexture(srcCanvas, noRepeat, flipY) {
        void 0 === noRepeat && (noRepeat = !1), void 0 === flipY && (flipY = !1);
        var gl = this.gl,
            minFilter = gl.NEAREST,
            magFilter = gl.NEAREST,
            width = srcCanvas.width,
            height = srcCanvas.height,
            wrapping = gl.CLAMP_TO_EDGE,
            pow = IsSizePowerOfTwo(width, height);
        return !noRepeat && pow && (wrapping = gl.REPEAT), this.config.antialias && (minFilter = pow ? this.mipmapFilter : gl.LINEAR, magFilter = gl.LINEAR), this.createTexture2D(0, minFilter, magFilter, wrapping, wrapping, gl.RGBA, srcCanvas, width, height, !0, !1, flipY);
      },
      updateCanvasTexture: function updateCanvasTexture(srcCanvas, dstTexture, flipY) {
        void 0 === flipY && (flipY = !1);
        var currentTexture,
            gl = this.gl,
            width = srcCanvas.width,
            height = srcCanvas.height;
        return 0 < width && 0 < height && (gl.activeTexture(gl.TEXTURE0), currentTexture = gl.getParameter(gl.TEXTURE_BINDING_2D), gl.bindTexture(gl.TEXTURE_2D, dstTexture), gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY), gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !0), gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, srcCanvas), dstTexture.width = width, dstTexture.height = height, currentTexture && gl.bindTexture(gl.TEXTURE_2D, currentTexture)), dstTexture;
      },
      createVideoTexture: function createVideoTexture(srcVideo, noRepeat, flipY) {
        void 0 === noRepeat && (noRepeat = !1), void 0 === flipY && (flipY = !1);
        var gl = this.gl,
            minFilter = gl.NEAREST,
            magFilter = gl.NEAREST,
            width = srcVideo.videoWidth,
            height = srcVideo.videoHeight,
            wrapping = gl.CLAMP_TO_EDGE,
            pow = IsSizePowerOfTwo(width, height);
        return !noRepeat && pow && (wrapping = gl.REPEAT), this.config.antialias && (minFilter = pow ? this.mipmapFilter : gl.LINEAR, magFilter = gl.LINEAR), this.createTexture2D(0, minFilter, magFilter, wrapping, wrapping, gl.RGBA, srcVideo, width, height, !0, !0, flipY);
      },
      updateVideoTexture: function updateVideoTexture(srcVideo, dstTexture, flipY) {
        void 0 === flipY && (flipY = !1);
        var currentTexture,
            gl = this.gl,
            width = srcVideo.videoWidth,
            height = srcVideo.videoHeight;
        return 0 < width && 0 < height && (gl.activeTexture(gl.TEXTURE0), currentTexture = gl.getParameter(gl.TEXTURE_BINDING_2D), gl.bindTexture(gl.TEXTURE_2D, dstTexture), gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY), gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, srcVideo), dstTexture.width = width, dstTexture.height = height, currentTexture && gl.bindTexture(gl.TEXTURE_2D, currentTexture)), dstTexture;
      },
      setTextureFilter: function setTextureFilter(texture, currentTexture) {
        var gl = this.gl,
            glFilter = [gl.LINEAR, gl.NEAREST][currentTexture];
        gl.activeTexture(gl.TEXTURE0);
        currentTexture = gl.getParameter(gl.TEXTURE_BINDING_2D);
        return gl.bindTexture(gl.TEXTURE_2D, texture), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, glFilter), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, glFilter), currentTexture && gl.bindTexture(gl.TEXTURE_2D, currentTexture), this;
      },
      getMaxTextureSize: function getMaxTextureSize() {
        return this.config.maxTextureSize;
      },
      destroy: function destroy() {
        this.canvas.removeEventListener("webglcontextlost", this.contextLostHandler, !1), this.canvas.removeEventListener("webglcontextrestored", this.contextRestoredHandler, !1);

        for (var gl = this.gl, temp = this.tempTextures, i = 0; i < temp.length; i++) {
          gl.deleteTexture(temp[i]);
        }

        this.pipelines.destroy(), this.removeAllListeners(), this.fboStack = [], this.maskStack = [], this.extensions = {}, this.textureIndexes = [], this.gl = null, this.game = null, this.canvas = null, this.contextLost = !0, this.currentMask = null, this.currentCameraMask = null;
      }
    });

    module.exports = WebGLRenderer;
  }, function (module, exports, __webpack_require__) {
    var PipelineManager = __webpack_require__(0),
        CONST = __webpack_require__(92),
        CustomMap = __webpack_require__(102),
        BitmapMaskPipeline = __webpack_require__(373),
        GraphicsPipeline = __webpack_require__(376),
        LightPipeline = __webpack_require__(377),
        MultiPipeline = __webpack_require__(108),
        PointLightPipeline = __webpack_require__(378),
        RopePipeline = __webpack_require__(379),
        SinglePipeline = __webpack_require__(380),
        UtilityPipeline = __webpack_require__(381),
        PipelineManager = new PipelineManager({
      initialize: function initialize(renderer) {
        this.game = renderer.game, this.renderer = renderer, this.classes = new CustomMap([[CONST.UTILITY_PIPELINE, UtilityPipeline], [CONST.MULTI_PIPELINE, MultiPipeline], [CONST.BITMAPMASK_PIPELINE, BitmapMaskPipeline], [CONST.SINGLE_PIPELINE, SinglePipeline], [CONST.ROPE_PIPELINE, RopePipeline], [CONST.LIGHT_PIPELINE, LightPipeline], [CONST.POINTLIGHT_PIPELINE, PointLightPipeline], [CONST.GRAPHICS_PIPELINE, GraphicsPipeline]]), this.postPipelineClasses = new CustomMap(), this.pipelines = new CustomMap(), this.current = null, this.previous = null, this.MULTI_PIPELINE = null, this.BITMAPMASK_PIPELINE = null, this.UTILITY_PIPELINE = null, this.fullFrame1, this.fullFrame2, this.halfFrame1, this.halfFrame2;
      },
      boot: function boot(pipelineConfig) {
        var pipelineName,
            _this = this,
            game = this.game;

        if (this.classes.each(function (pipelineName, pipeline) {
          instance = _this.add(pipelineName, new pipeline({
            game: game
          })), pipelineName === CONST.UTILITY_PIPELINE && (_this.UTILITY_PIPELINE = instance, _this.fullFrame1 = instance.fullFrame1, _this.fullFrame2 = instance.fullFrame2, _this.halfFrame1 = instance.halfFrame1, _this.halfFrame2 = instance.halfFrame2);
        }), this.MULTI_PIPELINE = this.get(CONST.MULTI_PIPELINE), this.BITMAPMASK_PIPELINE = this.get(CONST.BITMAPMASK_PIPELINE), pipelineConfig) for (pipelineName in pipelineConfig) {
          var instance,
              pipelineClass = pipelineConfig[pipelineName];
          (instance = new pipelineClass(game)).isPostFX ? this.postPipelineClasses.set(pipelineName, pipelineClass) : this.has(pipelineName) || (this.classes.set(pipelineName, pipelineClass), this.add(pipelineName, instance));
        }
      },
      add: function add(name, pipeline) {
        if (!pipeline.isPostFX) {
          var pipelines = this.pipelines,
              renderer = this.renderer;
          return pipelines.has(name) ? console.warn("Pipeline exists: " + name) : (pipeline.name = name, pipeline.manager = this, pipelines.set(name, pipeline)), pipeline.hasBooted || pipeline.boot(), 0 !== renderer.width && 0 !== renderer.height && pipeline.resize(renderer.width, renderer.height), pipeline;
        }

        console.warn(name + " is a Post Pipeline. Use `addPostPipeline` instead");
      },
      addPostPipeline: function addPostPipeline(name, pipeline) {
        this.postPipelineClasses.has(name) || this.postPipelineClasses.set(name, pipeline);
      },
      flush: function flush() {
        this.current && this.current.flush();
      },
      has: function has(pipeline) {
        var pipelines = this.pipelines;
        return "string" == typeof pipeline ? pipelines.has(pipeline) : !!pipelines.contains(pipeline);
      },
      get: function get(pipeline) {
        var pipelines = this.pipelines;
        return "string" == typeof pipeline ? pipelines.get(pipeline) : pipelines.contains(pipeline) ? pipeline : void 0;
      },
      getPostPipeline: function getPostPipeline(pipeline, gameObject) {
        var pipelineClasses = this.postPipelineClasses;

        if ("string" == typeof pipeline ? newPipeline = pipelineClasses.get(pipeline) : "function" == typeof pipeline ? pipelineClasses.contains(pipeline) && (newPipeline = pipeline) : "object" == _typeof(pipeline) && (newPipeline = pipelineClasses.get(pipeline.name)), newPipeline) {
          var newPipeline = new newPipeline(this.game);
          return gameObject && (newPipeline.gameObject = gameObject), newPipeline;
        }
      },
      remove: function remove(name, removeClass, removePostPipelineClass) {
        void 0 === removeClass && (removeClass = !0), void 0 === removePostPipelineClass && (removePostPipelineClass = !0), this.pipelines.delete(name), removeClass && this.classes.delete(name), removePostPipelineClass && this.postPipelineClasses.delete(name);
      },
      set: function set(pipeline, gameObject, currentShader) {
        if (!pipeline.isPostFX) return this.isCurrent(pipeline, currentShader) || (this.flush(), this.current && this.current.unbind(), (this.current = pipeline).bind(currentShader)), pipeline.updateProjectionMatrix(), pipeline.onBind(gameObject), pipeline;
      },
      preBatch: function preBatch(gameObject) {
        if (gameObject.hasPostPipeline) {
          this.flush();

          for (var pipelines = gameObject.postPipelines, i = pipelines.length - 1; 0 <= i; i--) {
            var pipeline = pipelines[i];
            pipeline.active && pipeline.preBatch(gameObject);
          }
        }
      },
      postBatch: function postBatch(gameObject) {
        if (gameObject.hasPostPipeline) {
          this.flush();

          for (var pipelines = gameObject.postPipelines, i = 0; i < pipelines.length; i++) {
            var pipeline = pipelines[i];
            pipeline.active && pipeline.postBatch(gameObject);
          }
        }
      },
      preBatchCamera: function preBatchCamera(camera) {
        if (camera.hasPostPipeline) {
          this.flush();

          for (var pipelines = camera.postPipelines, i = pipelines.length - 1; 0 <= i; i--) {
            var pipeline = pipelines[i];
            pipeline.active && pipeline.preBatch(camera);
          }
        }
      },
      postBatchCamera: function postBatchCamera(camera) {
        if (camera.hasPostPipeline) {
          this.flush();

          for (var pipelines = camera.postPipelines, i = 0; i < pipelines.length; i++) {
            var pipeline = pipelines[i];
            pipeline.active && pipeline.postBatch(camera);
          }
        }
      },
      isCurrent: function isCurrent(pipeline, currentShader) {
        var renderer = this.renderer,
            current = this.current;
        return current && !currentShader && (currentShader = current.currentShader), !(current !== pipeline || currentShader.program !== renderer.currentProgram);
      },
      copyFrame: function copyFrame(source, target, brightness, clear, clearAlpha) {
        return this.setUtility(this.UTILITY_PIPELINE.copyShader).copyFrame(source, target, brightness, clear, clearAlpha), this;
      },
      copyToGame: function copyToGame(source) {
        return this.setUtility(this.UTILITY_PIPELINE.copyShader).copyToGame(source), this;
      },
      drawFrame: function drawFrame(source, target, clearAlpha, colorMatrix) {
        return this.setUtility(this.UTILITY_PIPELINE.colorMatrixShader).drawFrame(source, target, clearAlpha, colorMatrix), this;
      },
      blendFrames: function blendFrames(source1, source2, target, strength, clearAlpha) {
        return this.setUtility(this.UTILITY_PIPELINE.linearShader).blendFrames(source1, source2, target, strength, clearAlpha), this;
      },
      blendFramesAdditive: function blendFramesAdditive(source1, source2, target, strength, clearAlpha) {
        return this.setUtility(this.UTILITY_PIPELINE.addShader).blendFramesAdditive(source1, source2, target, strength, clearAlpha), this;
      },
      clearFrame: function clearFrame(target, clearAlpha) {
        return this.UTILITY_PIPELINE.clearFrame(target, clearAlpha), this;
      },
      blitFrame: function blitFrame(source, target, brightness, clear, clearAlpha, eraseMode) {
        return this.setUtility(this.UTILITY_PIPELINE.copyShader).blitFrame(source, target, brightness, clear, clearAlpha, eraseMode), this;
      },
      copyFrameRect: function copyFrameRect(source, target, x, y, width, height, clear, clearAlpha) {
        return this.UTILITY_PIPELINE.copyFrameRect(source, target, x, y, width, height, clear, clearAlpha), this;
      },
      forceZero: function forceZero() {
        return this.current && this.current.forceZero;
      },
      setMulti: function setMulti() {
        return this.set(this.MULTI_PIPELINE);
      },
      setUtility: function setUtility(currentShader) {
        return this.UTILITY_PIPELINE.bind(currentShader);
      },
      rebind: function rebind(pipeline) {
        void 0 === pipeline && this.previous && (pipeline = this.previous);
        var renderer = this.renderer,
            gl = renderer.gl;
        gl.disable(gl.DEPTH_TEST), gl.disable(gl.CULL_FACE), renderer.hasActiveStencilMask() ? gl.clear(gl.DEPTH_BUFFER_BIT) : (gl.disable(gl.STENCIL_TEST), gl.clear(gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT)), gl.viewport(0, 0, renderer.width, renderer.height), renderer.currentProgram = null, renderer.setBlendMode(0, !0);
        var key,
            entries = this.pipelines.entries;

        for (key in entries) {
          entries[key].glReset = !0;
        }

        pipeline && (this.current = pipeline).rebind(), renderer.resetTextures();
      },
      clear: function clear() {
        var renderer = this.renderer;
        this.flush(), this.current ? (this.current.unbind(), this.previous = this.current, this.current = null) : this.previous = null, renderer.currentProgram = null, renderer.setBlendMode(0, !0);
      },
      destroy: function destroy() {
        this.flush(), this.classes.clear(), this.postPipelineClasses.clear(), this.pipelines.clear(), this.renderer = null, this.game = null, this.classes = null, this.postPipelineClasses = null, this.pipelines = null, this.current = null, this.previous = null;
      }
    });

    module.exports = PipelineManager;
  }, function (module, exports, __webpack_require__) {
    var BitmapMaskPipeline = __webpack_require__(0),
        GetFastValue = __webpack_require__(2),
        ShaderSourceFS = __webpack_require__(866),
        ShaderSourceVS = __webpack_require__(867),
        WEBGL_CONST = __webpack_require__(107),
        WebGLPipeline = __webpack_require__(58),
        BitmapMaskPipeline = new BitmapMaskPipeline({
      Extends: WebGLPipeline,
      initialize: function initialize(config) {
        config.fragShader = GetFastValue(config, "fragShader", ShaderSourceFS), config.vertShader = GetFastValue(config, "vertShader", ShaderSourceVS), config.batchSize = GetFastValue(config, "batchSize", 1), config.vertices = GetFastValue(config, "vertices", [-1, 1, -1, -7, 7, 1]), config.attributes = GetFastValue(config, "attributes", [{
          name: "inPosition",
          size: 2,
          type: WEBGL_CONST.FLOAT
        }]), WebGLPipeline.call(this, config);
      },
      boot: function boot() {
        WebGLPipeline.prototype.boot.call(this), this.set1i("uMainSampler", 0), this.set1i("uMaskSampler", 1);
      },
      resize: function resize(width, height) {
        WebGLPipeline.prototype.resize.call(this, width, height), this.set2f("uResolution", width, height);
      },
      beginMask: function beginMask(mask, maskedObject, camera) {
        var renderer,
            gl = this.gl;
        mask.bitmapMask && gl && ((renderer = this.renderer).flush(), renderer.pushFramebuffer(mask.mainFramebuffer), gl.disable(gl.STENCIL_TEST), gl.clearColor(0, 0, 0, 0), gl.clear(gl.COLOR_BUFFER_BIT), renderer.currentCameraMask.mask !== mask && (renderer.currentMask.mask = mask, renderer.currentMask.camera = camera));
      },
      endMask: function endMask(mask, prev) {
        var gl = this.gl,
            renderer = this.renderer,
            bitmapMask = mask.bitmapMask;
        bitmapMask && gl && (renderer.flush(), renderer.pushFramebuffer(mask.maskFramebuffer), gl.clearColor(0, 0, 0, 0), gl.clear(gl.COLOR_BUFFER_BIT), renderer.setBlendMode(0, !0), bitmapMask.renderWebGL(renderer, bitmapMask, prev), renderer.flush(), renderer.popFramebuffer(), renderer.popFramebuffer(), (prev = renderer.getCurrentStencilMask()) ? (gl.enable(gl.STENCIL_TEST), prev.mask.applyStencil(renderer, prev.camera, !0)) : renderer.currentMask.mask = null, renderer.pipelines.set(this), gl.activeTexture(gl.TEXTURE1), gl.bindTexture(gl.TEXTURE_2D, mask.maskTexture), gl.activeTexture(gl.TEXTURE0), gl.bindTexture(gl.TEXTURE_2D, mask.mainTexture), this.set1i("uInvertMaskAlpha", mask.invertAlpha), gl.drawArrays(this.topology, 0, 3), renderer.resetTextures());
      }
    });

    module.exports = BitmapMaskPipeline;
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      AFTER_FLUSH: __webpack_require__(868),
      BEFORE_FLUSH: __webpack_require__(869),
      BIND: __webpack_require__(870),
      BOOT: __webpack_require__(871),
      DESTROY: __webpack_require__(872),
      REBIND: __webpack_require__(873),
      RESIZE: __webpack_require__(874)
    };
  }, function (module, exports, __webpack_require__) {
    var WebGLShader = __webpack_require__(0),
        GetFastValue = __webpack_require__(2),
        WEBGL_CONST = __webpack_require__(107),
        WebGLShader = new WebGLShader({
      initialize: function initialize(pipeline, name, vertexShader, fragmentShader, attributes) {
        this.pipeline = pipeline, this.name = name, this.renderer = pipeline.renderer, this.gl = this.renderer.gl, this.program = this.renderer.createProgram(vertexShader, fragmentShader), this.attributes, this.vertexComponentCount = 0, this.vertexSize = 0, this.uniforms = {}, this.createAttributes(attributes), this.createUniforms();
      },
      createAttributes: function createAttributes(attributes) {
        for (var count = 0, offset = 0, result = [], i = this.vertexComponentCount = 0; i < attributes.length; i++) {
          var normalized = attributes[i],
              name = normalized.name,
              size = GetFastValue(normalized, "size", 1),
              typeSize = GetFastValue(normalized, "type", WEBGL_CONST.FLOAT),
              type = typeSize.enum,
              typeSize = typeSize.size,
              normalized = !!normalized.normalized;
          result.push({
            name: name,
            size: size,
            type: type,
            normalized: normalized,
            offset: offset,
            enabled: !1,
            location: -1
          }), 4 === typeSize ? count += size : count++, offset += size * typeSize;
        }

        this.vertexSize = offset, this.vertexComponentCount = count, this.attributes = result;
      },
      bind: function bind(setAttributes, flush) {
        return void 0 === setAttributes && (setAttributes = !1), (flush = void 0 === flush ? !1 : flush) && this.pipeline.flush(), this.renderer.setProgram(this.program), setAttributes && this.setAttribPointers(), this;
      },
      rebind: function rebind() {
        return this.renderer.setProgram(this.program), this.setAttribPointers(!0), this;
      },
      setAttribPointers: function setAttribPointers(reset) {
        void 0 === reset && (reset = !1);

        for (var gl = this.gl, vertexSize = this.vertexSize, attributes = this.attributes, program = this.program, i = 0; i < attributes.length; i++) {
          var attribLocation,
              element = attributes[i],
              size = element.size,
              type = element.type,
              offset = element.offset,
              enabled = element.enabled,
              location = element.location,
              normalized = !!element.normalized;
          reset ? 0 <= (attribLocation = gl.getAttribLocation(program, element.name)) ? (gl.enableVertexAttribArray(attribLocation), gl.vertexAttribPointer(attribLocation, size, type, normalized, vertexSize, offset), element.enabled = !0, element.location = attribLocation) : -1 !== attribLocation && gl.disableVertexAttribArray(attribLocation) : enabled ? gl.vertexAttribPointer(location, size, type, normalized, vertexSize, offset) : !enabled && -1 < location && (gl.disableVertexAttribArray(location), element.location = -1);
        }

        return this;
      },
      createUniforms: function createUniforms() {
        for (var name, location, gl = this.gl, program = this.program, uniforms = this.uniforms, totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS), i = 0; i < totalUniforms; i++) {
          var struct = gl.getActiveUniform(program, i);
          struct && (name = struct.name, null !== (location = gl.getUniformLocation(program, name)) && (uniforms[name] = {
            name: name,
            location: location,
            value1: null,
            value2: null,
            value3: null,
            value4: null
          }), 0 < (struct = name.indexOf("[")) && (name = name.substr(0, struct), uniforms.hasOwnProperty(name) || null !== (location = gl.getUniformLocation(program, name)) && (uniforms[name] = {
            name: name,
            location: location,
            value1: null,
            value2: null,
            value3: null,
            value4: null
          })));
        }

        return this;
      },
      hasUniform: function hasUniform(name) {
        return this.uniforms.hasOwnProperty(name);
      },
      resetUniform: function resetUniform(uniform) {
        uniform = this.uniforms[uniform];
        return uniform && (uniform.value1 = null, uniform.value2 = null, uniform.value3 = null, uniform.value4 = null), this;
      },
      setUniform1: function setUniform1(setter, uniform, value1, skipCheck) {
        uniform = this.uniforms[uniform];
        return uniform && (!skipCheck && uniform.value1 === value1 || (uniform.value1 = value1, this.renderer.setProgram(this.program), setter.call(this.gl, uniform.location, value1), this.pipeline.currentShader = this)), this;
      },
      setUniform2: function setUniform2(setter, uniform, value1, value2, skipCheck) {
        uniform = this.uniforms[uniform];
        return uniform && (!skipCheck && uniform.value1 === value1 && uniform.value2 === value2 || (uniform.value1 = value1, uniform.value2 = value2, this.renderer.setProgram(this.program), setter.call(this.gl, uniform.location, value1, value2), this.pipeline.currentShader = this)), this;
      },
      setUniform3: function setUniform3(setter, uniform, value1, value2, value3, skipCheck) {
        uniform = this.uniforms[uniform];
        return uniform && (!skipCheck && uniform.value1 === value1 && uniform.value2 === value2 && uniform.value3 === value3 || (uniform.value1 = value1, uniform.value2 = value2, uniform.value3 = value3, this.renderer.setProgram(this.program), setter.call(this.gl, uniform.location, value1, value2, value3), this.pipeline.currentShader = this)), this;
      },
      setUniform4: function setUniform4(setter, uniform, value1, value2, value3, value4, skipCheck) {
        uniform = this.uniforms[uniform];
        return uniform && (!skipCheck && uniform.value1 === value1 && uniform.value2 === value2 && uniform.value3 === value3 && uniform.value4 === value4 || (uniform.value1 = value1, uniform.value2 = value2, uniform.value3 = value3, uniform.value4 = value4, this.renderer.setProgram(this.program), setter.call(this.gl, uniform.location, value1, value2, value3, value4), this.pipeline.currentShader = this)), this;
      },
      set1f: function set1f(name, x) {
        return this.setUniform1(this.gl.uniform1f, name, x);
      },
      set2f: function set2f(name, x, y) {
        return this.setUniform2(this.gl.uniform2f, name, x, y);
      },
      set3f: function set3f(name, x, y, z) {
        return this.setUniform3(this.gl.uniform3f, name, x, y, z);
      },
      set4f: function set4f(name, x, y, z, w) {
        return this.setUniform4(this.gl.uniform4f, name, x, y, z, w);
      },
      set1fv: function set1fv(name, arr) {
        return this.setUniform1(this.gl.uniform1fv, name, arr, !0);
      },
      set2fv: function set2fv(name, arr) {
        return this.setUniform1(this.gl.uniform2fv, name, arr, !0);
      },
      set3fv: function set3fv(name, arr) {
        return this.setUniform1(this.gl.uniform3fv, name, arr, !0);
      },
      set4fv: function set4fv(name, arr) {
        return this.setUniform1(this.gl.uniform4fv, name, arr, !0);
      },
      set1iv: function set1iv(name, arr) {
        return this.setUniform1(this.gl.uniform1iv, name, arr, !0);
      },
      set2iv: function set2iv(name, arr) {
        return this.setUniform1(this.gl.uniform2iv, name, arr, !0);
      },
      set3iv: function set3iv(name, arr) {
        return this.setUniform1(this.gl.uniform3iv, name, arr, !0);
      },
      set4iv: function set4iv(name, arr) {
        return this.setUniform1(this.gl.uniform4iv, name, arr, !0);
      },
      set1i: function set1i(name, x) {
        return this.setUniform1(this.gl.uniform1i, name, x);
      },
      set2i: function set2i(name, x, y) {
        return this.setUniform2(this.gl.uniform2i, name, x, y);
      },
      set3i: function set3i(name, x, y, z) {
        return this.setUniform3(this.gl.uniform3i, name, x, y, z);
      },
      set4i: function set4i(name, x, y, z, w) {
        return this.setUniform4(this.gl.uniform4i, name, x, y, z, w);
      },
      setMatrix2fv: function setMatrix2fv(name, transpose, matrix) {
        return this.setUniform2(this.gl.uniformMatrix2fv, name, transpose, matrix, !0);
      },
      setMatrix3fv: function setMatrix3fv(name, transpose, matrix) {
        return this.setUniform2(this.gl.uniformMatrix3fv, name, transpose, matrix, !0);
      },
      setMatrix4fv: function setMatrix4fv(name, transpose, matrix) {
        return this.setUniform2(this.gl.uniformMatrix4fv, name, transpose, matrix, !0);
      },
      destroy: function destroy() {
        this.gl.deleteProgram(this.program), this.pipeline = null, this.renderer = null, this.gl = null, this.program = null, this.attributes = null, this.uniforms = null;
      }
    });

    module.exports = WebGLShader;
  }, function (module, exports, __webpack_require__) {
    var GraphicsPipeline = __webpack_require__(0),
        Earcut = __webpack_require__(59),
        GetFastValue = __webpack_require__(2),
        ShaderSourceFS = __webpack_require__(875),
        ShaderSourceVS = __webpack_require__(876),
        TransformMatrix = __webpack_require__(25),
        WEBGL_CONST = __webpack_require__(107),
        WebGLPipeline = __webpack_require__(58),
        GraphicsPipeline = new GraphicsPipeline({
      Extends: WebGLPipeline,
      initialize: function initialize(config) {
        config.fragShader = GetFastValue(config, "fragShader", ShaderSourceFS), config.vertShader = GetFastValue(config, "vertShader", ShaderSourceVS), config.attributes = GetFastValue(config, "attributes", [{
          name: "inPosition",
          size: 2
        }, {
          name: "inColor",
          size: 4,
          type: WEBGL_CONST.UNSIGNED_BYTE,
          normalized: !0
        }]), WebGLPipeline.call(this, config), this.calcMatrix = new TransformMatrix(), this.tempTriangle = [{
          x: 0,
          y: 0,
          width: 0
        }, {
          x: 0,
          y: 0,
          width: 0
        }, {
          x: 0,
          y: 0,
          width: 0
        }, {
          x: 0,
          y: 0,
          width: 0
        }], this.strokeTint = {
          TL: 0,
          TR: 0,
          BL: 0,
          BR: 0
        }, this.fillTint = {
          TL: 0,
          TR: 0,
          BL: 0,
          BR: 0
        }, this.currentFrame = {
          u0: 0,
          v0: 0,
          u1: 1,
          v1: 1
        }, this.firstQuad = [0, 0, 0, 0, 0], this.prevQuad = [0, 0, 0, 0, 0], this.polygonCache = [];
      },
      batchFillRect: function batchFillRect(y2, tint, y1, x2, x1, y0) {
        this.renderer.pipelines.set(this);
        var calcMatrix = this.calcMatrix;
        y0 && y0.multiply(x1, calcMatrix);
        var y3 = y2 + y1,
            x3 = tint + x2,
            x0 = calcMatrix.getX(y2, tint),
            y0 = calcMatrix.getY(y2, tint),
            x1 = calcMatrix.getX(y2, x3),
            y1 = calcMatrix.getY(y2, x3),
            x2 = calcMatrix.getX(y3, x3),
            y2 = calcMatrix.getY(y3, x3),
            x3 = calcMatrix.getX(y3, tint),
            y3 = calcMatrix.getY(y3, tint),
            tint = this.fillTint;
        this.batchQuad(x0, y0, x1, y1, x2, y2, x3, y3, tint.TL, tint.TR, tint.BL, tint.BR);
      },
      batchFillTriangle: function batchFillTriangle(ty0, tx1, ty1, tx2, ty2, tint, tx0, parentMatrix) {
        this.renderer.pipelines.set(this);
        var calcMatrix = this.calcMatrix;
        parentMatrix && parentMatrix.multiply(tx0, calcMatrix);
        tx0 = calcMatrix.getX(ty0, tx1), ty0 = calcMatrix.getY(ty0, tx1), tx1 = calcMatrix.getX(ty1, tx2), ty1 = calcMatrix.getY(ty1, tx2), tx2 = calcMatrix.getX(ty2, tint), ty2 = calcMatrix.getY(ty2, tint), tint = this.fillTint;
        this.batchTri(tx0, ty0, tx1, ty1, tx2, ty2, tint.TL, tint.TR, tint.BL);
      },
      batchStrokeTriangle: function batchStrokeTriangle(x0, y0, x1, y1, x2, y2, lineWidth, currentMatrix, parentMatrix) {
        var tempTriangle = this.tempTriangle;
        tempTriangle[0].x = x0, tempTriangle[0].y = y0, tempTriangle[0].width = lineWidth, tempTriangle[1].x = x1, tempTriangle[1].y = y1, tempTriangle[1].width = lineWidth, tempTriangle[2].x = x2, tempTriangle[2].y = y2, tempTriangle[2].width = lineWidth, tempTriangle[3].x = x0, tempTriangle[3].y = y0, tempTriangle[3].width = lineWidth, this.batchStrokePath(tempTriangle, lineWidth, !1, currentMatrix, parentMatrix);
      },
      batchFillPath: function batchFillPath(path, currentMatrix, parentMatrix) {
        this.renderer.pipelines.set(this);
        var calcMatrix = this.calcMatrix;
        parentMatrix && parentMatrix.multiply(currentMatrix, calcMatrix);

        for (var point, length = path.length, polygonCache = this.polygonCache, tintTL = this.fillTint.TL, tintTR = this.fillTint.TR, tintBL = this.fillTint.BL, pathIndex = 0; pathIndex < length; ++pathIndex) {
          point = path[pathIndex], polygonCache.push(point.x, point.y);
        }

        for (var polygonIndexArray, length = (polygonIndexArray = Earcut(polygonCache)).length, index = 0; index < length; index += 3) {
          var x2 = 2 * polygonIndexArray[index + 0],
              ty2 = 2 * polygonIndexArray[index + 1],
              tx0 = 2 * polygonIndexArray[index + 2],
              ty0 = polygonCache[0 + x2],
              tx1 = polygonCache[1 + x2],
              ty1 = polygonCache[0 + ty2],
              tx2 = polygonCache[1 + ty2],
              x2 = polygonCache[0 + tx0],
              ty2 = polygonCache[1 + tx0],
              tx0 = calcMatrix.getX(ty0, tx1),
              ty0 = calcMatrix.getY(ty0, tx1),
              tx1 = calcMatrix.getX(ty1, tx2),
              ty1 = calcMatrix.getY(ty1, tx2),
              tx2 = calcMatrix.getX(x2, ty2),
              ty2 = calcMatrix.getY(x2, ty2);
          this.batchTri(tx0, ty0, tx1, ty1, tx2, ty2, tintTL, tintTR, tintBL);
        }

        polygonCache.length = 0;
      },
      batchStrokePath: function batchStrokePath(path, lineWidth, pathOpen, currentMatrix, parentMatrix) {
        this.renderer.pipelines.set(this), this.prevQuad[4] = 0, this.firstQuad[4] = 0;

        for (var pathLength = path.length - 1, pathIndex = 0; pathIndex < pathLength; pathIndex++) {
          var point0 = path[pathIndex],
              point1 = path[pathIndex + 1];
          this.batchLine(point0.x, point0.y, point1.x, point1.y, point0.width / 2, point1.width / 2, lineWidth, pathIndex, !pathOpen && pathIndex === pathLength - 1, currentMatrix, parentMatrix);
        }
      },
      batchLine: function batchLine(brX, blX, prev, tintBL, trY, tlX, first, index, closePath, tintTL, blY) {
        this.renderer.pipelines.set(this);
        var tintTR = this.calcMatrix;
        blY && blY.multiply(tintTL, tintTR);
        var tintBR = prev - brX,
            trX = tintBL - blX,
            tlY = Math.sqrt(tintBR * tintBR + trX * trX),
            brY = trY * (tintBL - blX) / tlY,
            blY = trY * (brX - prev) / tlY,
            tintTL = tlX * (tintBL - blX) / tlY,
            tintBR = tlX * (brX - prev) / tlY,
            trX = prev - tintTL,
            trY = tintBL - tintBR,
            tlX = brX - brY,
            tlY = blX - blY,
            prev = prev + tintTL,
            tintTL = tintBL + tintBR,
            tintBL = brX + brY,
            tintBR = blX + blY,
            brX = tintTR.getX(trX, trY),
            brY = tintTR.getY(trX, trY),
            blX = tintTR.getX(tlX, tlY),
            blY = tintTR.getY(tlX, tlY),
            trX = tintTR.getX(prev, tintTL),
            trY = tintTR.getY(prev, tintTL),
            tlX = tintTR.getX(tintBL, tintBR),
            tlY = tintTR.getY(tintBL, tintBR),
            prev = this.strokeTint,
            tintTL = prev.TL,
            tintTR = prev.TR,
            tintBL = prev.BL,
            tintBR = prev.BR;
        this.batchQuad(tlX, tlY, blX, blY, brX, brY, trX, trY, tintTL, tintTR, tintBL, tintBR), first <= 2 || (prev = this.prevQuad, first = this.firstQuad, 0 < index && prev[4] ? this.batchQuad(tlX, tlY, blX, blY, prev[0], prev[1], prev[2], prev[3], tintTL, tintTR, tintBL, tintBR) : (first[0] = tlX, first[1] = tlY, first[2] = blX, first[3] = blY, first[4] = 1), closePath && first[4] ? this.batchQuad(brX, brY, trX, trY, first[0], first[1], first[2], first[3], tintTL, tintTR, tintBL, tintBR) : (prev[0] = brX, prev[1] = brY, prev[2] = trX, prev[3] = trY, prev[4] = 1));
      },
      batchVert: function batchVert(x, y, tint) {
        var vertexViewF32 = this.vertexViewF32,
            vertexViewU32 = this.vertexViewU32,
            vertexOffset = this.vertexCount * this.currentShader.vertexComponentCount - 1;
        vertexViewF32[++vertexOffset] = x, vertexViewF32[++vertexOffset] = y, vertexViewU32[++vertexOffset] = tint, this.vertexCount++;
      },
      batchQuad: function batchQuad(x0, y0, x1, y1, x2, y2, x3, y3, tintTL, tintTR, tintBL, tintBR) {
        var hasFlushed = !1;
        return this.shouldFlush(6) && (this.flush(), hasFlushed = !0), this.batchVert(x0, y0, tintTL), this.batchVert(x1, y1, tintBL), this.batchVert(x2, y2, tintBR), this.batchVert(x0, y0, tintTL), this.batchVert(x2, y2, tintBR), this.batchVert(x3, y3, tintTR), hasFlushed;
      },
      batchTri: function batchTri(x0, y0, x1, y1, x2, y2, tintTL, tintTR, tintBL) {
        var hasFlushed = !1;
        return this.shouldFlush(3) && (this.flush(), hasFlushed = !0), this.batchVert(x0, y0, tintTL), this.batchVert(x1, y1, tintTR), this.batchVert(x2, y2, tintBL), hasFlushed;
      },
      destroy: function destroy() {
        return WebGLPipeline.prototype.destroy.call(this), this.polygonCache = null, this;
      }
    });

    module.exports = GraphicsPipeline;
  }, function (module, exports, __webpack_require__) {
    var LightPipeline = __webpack_require__(0),
        GetFastValue = __webpack_require__(2),
        LightShaderSourceFS = __webpack_require__(877),
        MultiPipeline = __webpack_require__(108),
        Vec2 = __webpack_require__(3),
        WebGLPipeline = __webpack_require__(58),
        LIGHT_COUNT = 10,
        tempVec2 = new Vec2(),
        LightPipeline = new LightPipeline({
      Extends: MultiPipeline,
      initialize: function initialize(config) {
        LIGHT_COUNT = config.game.renderer.config.maxLights;

        for (var fragShader = GetFastValue(config, "fragShader", LightShaderSourceFS), shaders = [], i = 1; i <= LIGHT_COUNT; i++) {
          shaders.push({
            name: "lights" + i,
            fragShader: fragShader.replace("%LIGHT_COUNT%", i.toString())
          });
        }

        config.shaders = shaders, MultiPipeline.call(this, config), this.inverseRotationMatrix = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]), this.defaultNormalMap, this.lightsActive = !0;
      },
      boot: function boot() {
        WebGLPipeline.prototype.boot.call(this);
        var gl = this.gl,
            tempTexture = gl.createTexture();
        gl.activeTexture(gl.TEXTURE0), gl.bindTexture(gl.TEXTURE_2D, tempTexture), gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([127, 127, 255, 255])), this.defaultNormalMap = {
          glTexture: tempTexture
        };

        for (var i = 0; i < this.shaders.length; i++) {
          this["lightShader" + (i + 1)] = this.shaders[i];
        }
      },
      onRender: function onRender(lightManager, camera) {
        lightManager = lightManager.sys.lights;

        if (this.lightsActive = !1, lightManager && lightManager.active) {
          var i,
              lights = lightManager.getLights(camera),
              lightsCount = lights.length;

          if (0 !== lightsCount) {
            this.lightsActive = !0, this.setShader(this["lightShader" + lightsCount], !0);
            var height = this.renderer.height,
                cameraMatrix = camera.matrix;

            for (this.set1i("uMainSampler", 0), this.set1i("uNormSampler", 1), this.set2f("uResolution", this.width / 2, this.height / 2), this.set4f("uCamera", camera.x, camera.y, camera.rotation, camera.zoom), this.set3f("uAmbientLightColor", lightManager.ambientColor.r, lightManager.ambientColor.g, lightManager.ambientColor.b), i = 0; i < lightsCount; i++) {
              var light = lights[i].light,
                  color = light.color,
                  lightName = "uLights[" + i + "].";
              cameraMatrix.transformPoint(light.x, light.y, tempVec2), this.set2f(lightName + "position", tempVec2.x - camera.scrollX * light.scrollFactorX * camera.zoom, height - (tempVec2.y - camera.scrollY * light.scrollFactorY * camera.zoom)), this.set3f(lightName + "color", color.r, color.g, color.b), this.set1f(lightName + "intensity", light.intensity), this.set1f(lightName + "radius", light.radius);
            }

            this.currentNormalMapRotation = null;
          }
        }
      },
      setNormalMapRotation: function setNormalMapRotation(rotation) {
        var inverseRotationMatrix, c, s;
        rotation === this.currentNormalMapRotation && 0 !== this.vertexCount || (0 < this.vertexCount && this.flush(), inverseRotationMatrix = this.inverseRotationMatrix, rotation ? (s = -rotation, c = Math.cos(s), s = Math.sin(s), inverseRotationMatrix[1] = s, inverseRotationMatrix[3] = -s, inverseRotationMatrix[0] = inverseRotationMatrix[4] = c) : (inverseRotationMatrix[0] = inverseRotationMatrix[4] = 1, inverseRotationMatrix[1] = inverseRotationMatrix[3] = 0), this.setMatrix3fv("uInverseRotationMatrix", !1, inverseRotationMatrix), this.currentNormalMapRotation = rotation);
      },
      setTexture2D: function setTexture2D(texture, rotation) {
        var renderer = this.renderer;
        void 0 === texture && (texture = renderer.tempTextures[0]);
        var normalTexture = this.getNormalMap(rotation);
        renderer.isNewNormalMap(texture, normalTexture) && (this.flush(), renderer.setTextureZero(texture), renderer.setNormalMap(normalTexture));
        rotation = rotation ? rotation.rotation : 0;
        return this.setNormalMapRotation(rotation), this.currentUnit = 0;
      },
      setGameObject: function setGameObject(gameObject, normalTexture) {
        void 0 === normalTexture && (normalTexture = gameObject.frame);
        var renderer = this.renderer,
            texture = normalTexture.glTexture,
            normalTexture = this.getNormalMap(gameObject);
        return renderer.isNewNormalMap() && (this.flush(), renderer.setTextureZero(texture), renderer.setNormalMap(normalTexture)), this.setNormalMapRotation(gameObject.rotation), this.currentUnit = 0;
      },
      getNormalMap: function getNormalMap(gameObject) {
        var normalTexture;
        return gameObject ? gameObject.displayTexture ? normalTexture = gameObject.displayTexture.dataSource[gameObject.displayFrame.sourceIndex] : gameObject.texture ? normalTexture = gameObject.texture.dataSource[gameObject.frame.sourceIndex] : gameObject.tileset && (normalTexture = (Array.isArray(gameObject.tileset) ? gameObject.tileset[0] : gameObject.tileset).image.dataSource[0]) : normalTexture = this.defaultNormalMap, (normalTexture = normalTexture || this.defaultNormalMap).glTexture;
      },
      batchSprite: function batchSprite(gameObject, camera, parentTransformMatrix) {
        this.lightsActive && MultiPipeline.prototype.batchSprite.call(this, gameObject, camera, parentTransformMatrix);
      },
      batchTexture: function batchTexture(gameObject, texture, textureWidth, textureHeight, srcX, srcY, srcWidth, srcHeight, scaleX, scaleY, rotation, flipX, flipY, scrollFactorX, scrollFactorY, displayOriginX, displayOriginY, frameX, frameY, frameWidth, frameHeight, tintTL, tintTR, tintBL, tintBR, tintEffect, uOffset, vOffset, camera, parentTransformMatrix, skipFlip, textureUnit) {
        this.lightsActive && MultiPipeline.prototype.batchTexture.call(this, gameObject, texture, textureWidth, textureHeight, srcX, srcY, srcWidth, srcHeight, scaleX, scaleY, rotation, flipX, flipY, scrollFactorX, scrollFactorY, displayOriginX, displayOriginY, frameX, frameY, frameWidth, frameHeight, tintTL, tintTR, tintBL, tintBR, tintEffect, uOffset, vOffset, camera, parentTransformMatrix, skipFlip, textureUnit);
      },
      batchTextureFrame: function batchTextureFrame(frame, x, y, tint, alpha, transformMatrix, parentTransformMatrix) {
        this.lightsActive && MultiPipeline.prototype.batchTextureFrame.call(this, frame, x, y, tint, alpha, transformMatrix, parentTransformMatrix);
      }
    });

    LightPipeline.LIGHT_COUNT = LIGHT_COUNT, module.exports = LightPipeline;
  }, function (module, exports, __webpack_require__) {
    var PointLightPipeline = __webpack_require__(0),
        GetFastValue = __webpack_require__(2),
        PointLightShaderSourceFS = __webpack_require__(880),
        PointLightShaderSourceVS = __webpack_require__(881),
        WebGLPipeline = __webpack_require__(58),
        PointLightPipeline = new PointLightPipeline({
      Extends: WebGLPipeline,
      initialize: function initialize(config) {
        config.vertShader = GetFastValue(config, "vertShader", PointLightShaderSourceVS), config.fragShader = GetFastValue(config, "fragShader", PointLightShaderSourceFS), config.attributes = GetFastValue(config, "attributes", [{
          name: "inPosition",
          size: 2
        }, {
          name: "inLightPosition",
          size: 2
        }, {
          name: "inLightRadius"
        }, {
          name: "inLightAttenuation"
        }, {
          name: "inLightColor",
          size: 4
        }]), WebGLPipeline.call(this, config);
      },
      onRender: function onRender(scene, camera) {
        this.set2f("uResolution", this.width, this.height), this.set1f("uCameraZoom", camera.zoom);
      },
      batchPointLight: function batchPointLight(a, camera, x0, y0, x1, y1, x2, y2, x3, y3, lightX, lightY) {
        var color = a.color,
            b = a.intensity,
            radius = a.radius,
            attenuation = a.attenuation,
            r = color.r * b,
            g = color.g * b,
            b = color.b * b,
            a = camera.alpha * a.alpha;
        this.shouldFlush(6) && this.flush(), this.batchLightVert(x0, y0, lightX, lightY, radius, attenuation, r, g, b, a), this.batchLightVert(x1, y1, lightX, lightY, radius, attenuation, r, g, b, a), this.batchLightVert(x2, y2, lightX, lightY, radius, attenuation, r, g, b, a), this.batchLightVert(x0, y0, lightX, lightY, radius, attenuation, r, g, b, a), this.batchLightVert(x2, y2, lightX, lightY, radius, attenuation, r, g, b, a), this.batchLightVert(x3, y3, lightX, lightY, radius, attenuation, r, g, b, a);
      },
      batchLightVert: function batchLightVert(x, y, lightX, lightY, radius, attenuation, r, g, b, a) {
        var vertexViewF32 = this.vertexViewF32,
            vertexOffset = this.vertexCount * this.currentShader.vertexComponentCount - 1;
        vertexViewF32[++vertexOffset] = x, vertexViewF32[++vertexOffset] = y, vertexViewF32[++vertexOffset] = lightX, vertexViewF32[++vertexOffset] = lightY, vertexViewF32[++vertexOffset] = radius, vertexViewF32[++vertexOffset] = attenuation, vertexViewF32[++vertexOffset] = r, vertexViewF32[++vertexOffset] = g, vertexViewF32[++vertexOffset] = b, vertexViewF32[++vertexOffset] = a, this.vertexCount++;
      }
    });

    module.exports = PointLightPipeline;
  }, function (module, exports, __webpack_require__) {
    var RopePipeline = __webpack_require__(0),
        GetFastValue = __webpack_require__(2),
        MultiPipeline = __webpack_require__(108),
        RopePipeline = new RopePipeline({
      Extends: MultiPipeline,
      initialize: function initialize(config) {
        config.topology = 5, config.batchSize = GetFastValue(config, "batchSize", 256), MultiPipeline.call(this, config);
      }
    });

    module.exports = RopePipeline;
  }, function (module, exports, __webpack_require__) {
    var SinglePipeline = __webpack_require__(0),
        GetFastValue = __webpack_require__(2),
        MultiPipeline = __webpack_require__(108),
        ShaderSourceFS = __webpack_require__(882),
        ShaderSourceVS = __webpack_require__(883),
        WebGLPipeline = __webpack_require__(58),
        SinglePipeline = new SinglePipeline({
      Extends: MultiPipeline,
      initialize: function initialize(config) {
        config.fragShader = GetFastValue(config, "fragShader", ShaderSourceFS), config.vertShader = GetFastValue(config, "vertShader", ShaderSourceVS), config.forceZero = !0, MultiPipeline.call(this, config);
      },
      boot: function boot() {
        WebGLPipeline.prototype.boot.call(this), this.set1i("uMainSampler", 0);
      }
    });

    module.exports = SinglePipeline;
  }, function (module, exports, __webpack_require__) {
    var AddBlendFS = __webpack_require__(884),
        BlendModes = __webpack_require__(35),
        UtilityPipeline = __webpack_require__(0),
        ColorMatrix = __webpack_require__(198),
        ColorMatrixFS = __webpack_require__(885),
        CopyFS = __webpack_require__(886),
        GetFastValue = __webpack_require__(2),
        LinearBlendFS = __webpack_require__(887),
        QuadVS = __webpack_require__(382),
        WebGLPipeline = __webpack_require__(58),
        UtilityPipeline = new UtilityPipeline({
      Extends: WebGLPipeline,
      initialize: function initialize(config) {
        config.renderTarget = GetFastValue(config, "renderTarget", [{
          scale: 1
        }, {
          scale: 1
        }, {
          scale: .5
        }, {
          scale: .5
        }]), config.vertShader = GetFastValue(config, "vertShader", QuadVS), config.shaders = GetFastValue(config, "shaders", [{
          name: "Copy",
          fragShader: CopyFS
        }, {
          name: "AddBlend",
          fragShader: AddBlendFS
        }, {
          name: "LinearBlend",
          fragShader: LinearBlendFS
        }, {
          name: "ColorMatrix",
          fragShader: ColorMatrixFS
        }]), config.attributes = GetFastValue(config, "attributes", [{
          name: "inPosition",
          size: 2
        }, {
          name: "inTexCoord",
          size: 2
        }]), config.vertices = [-1, -1, 0, 0, -1, 1, 0, 1, 1, 1, 1, 1, -1, -1, 0, 0, 1, 1, 1, 1, 1, -1, 1, 0], config.batchSize = 1, WebGLPipeline.call(this, config), this.colorMatrix = new ColorMatrix(), this.copyShader, this.addShader, this.linearShader, this.colorMatrixShader, this.fullFrame1, this.fullFrame2, this.halfFrame1, this.halfFrame2;
      },
      boot: function boot() {
        WebGLPipeline.prototype.boot.call(this);
        var shaders = this.shaders,
            targets = this.renderTargets;
        this.copyShader = shaders[0], this.addShader = shaders[1], this.linearShader = shaders[2], this.colorMatrixShader = shaders[3], this.fullFrame1 = targets[0], this.fullFrame2 = targets[1], this.halfFrame1 = targets[2], this.halfFrame2 = targets[3];
      },
      copyFrame: function copyFrame(source, target, brightness, clear, clearAlpha) {
        void 0 === brightness && (brightness = 1), void 0 === clear && (clear = !0), void 0 === clearAlpha && (clearAlpha = !0);
        var gl = this.gl;
        this.setShader(this.copyShader), this.set1i("uMainSampler", 0), this.set1f("uBrightness", brightness), gl.activeTexture(gl.TEXTURE0), gl.bindTexture(gl.TEXTURE_2D, source.texture), target ? (gl.viewport(0, 0, target.width, target.height), gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer), gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target.texture, 0)) : gl.viewport(0, 0, source.width, source.height), clear && (clearAlpha ? gl.clearColor(0, 0, 0, 0) : gl.clearColor(0, 0, 0, 1), gl.clear(gl.COLOR_BUFFER_BIT)), gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.STATIC_DRAW), gl.drawArrays(gl.TRIANGLES, 0, 6), gl.bindFramebuffer(gl.FRAMEBUFFER, null), gl.bindTexture(gl.TEXTURE_2D, null);
      },
      blitFrame: function blitFrame(source, target, diff, clear, clearAlpha, eraseMode) {
        void 0 === diff && (diff = 1), void 0 === clear && (clear = !0), void 0 === clearAlpha && (clearAlpha = !0), void 0 === eraseMode && (eraseMode = !1);
        var blendMode,
            gl = this.gl;
        this.setShader(this.copyShader), this.set1i("uMainSampler", 0), this.set1f("uBrightness", diff), gl.activeTexture(gl.TEXTURE0), gl.bindTexture(gl.TEXTURE_2D, source.texture), source.height > target.height ? (gl.viewport(0, 0, source.width, source.height), this.setTargetUVs(source, target)) : (diff = target.height - source.height, gl.viewport(0, diff, source.width, source.height)), gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer), gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target.texture, 0), clear && (clearAlpha ? gl.clearColor(0, 0, 0, 0) : gl.clearColor(0, 0, 0, 1), gl.clear(gl.COLOR_BUFFER_BIT)), eraseMode && (blendMode = this.renderer.currentBlendMode, this.renderer.setBlendMode(BlendModes.ERASE)), gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.STATIC_DRAW), gl.drawArrays(gl.TRIANGLES, 0, 6), eraseMode && this.renderer.setBlendMode(blendMode), gl.bindFramebuffer(gl.FRAMEBUFFER, null), gl.bindTexture(gl.TEXTURE_2D, null), this.resetUVs();
      },
      copyFrameRect: function copyFrameRect(source, target, x, y, width, height, clear, clearAlpha) {
        void 0 === clear && (clear = !0), void 0 === clearAlpha && (clearAlpha = !0);
        var gl = this.gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, source.framebuffer), gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, source.texture, 0), clear && (clearAlpha ? gl.clearColor(0, 0, 0, 0) : gl.clearColor(0, 0, 0, 1), gl.clear(gl.COLOR_BUFFER_BIT)), gl.activeTexture(gl.TEXTURE0), gl.bindTexture(gl.TEXTURE_2D, target.texture), gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, x, y, width, height), gl.bindFramebuffer(gl.FRAMEBUFFER, null), gl.bindTexture(gl.TEXTURE_2D, null);
      },
      copyToGame: function copyToGame(source) {
        var gl = this.gl;
        this.setShader(this.copyShader), this.set1i("uMainSampler", 0), this.set1f("uBrightness", 1), this.renderer.popFramebuffer(), gl.activeTexture(gl.TEXTURE0), gl.bindTexture(gl.TEXTURE_2D, source.texture), gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.STATIC_DRAW), gl.drawArrays(gl.TRIANGLES, 0, 6), this.renderer.resetTextures();
      },
      drawFrame: function drawFrame(source, target, clearAlpha, colorMatrix) {
        void 0 === clearAlpha && (clearAlpha = !0), void 0 === colorMatrix && (colorMatrix = this.colorMatrix);
        var gl = this.gl;
        this.setShader(this.colorMatrixShader), this.set1i("uMainSampler", 0), this.set1fv("uColorMatrix", colorMatrix.getData()), this.set1f("uAlpha", colorMatrix.alpha), gl.activeTexture(gl.TEXTURE0), gl.bindTexture(gl.TEXTURE_2D, source.texture), target ? (gl.viewport(0, 0, target.width, target.height), gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer), gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target.texture, 0)) : gl.viewport(0, 0, source.width, source.height), clearAlpha ? gl.clearColor(0, 0, 0, 0) : gl.clearColor(0, 0, 0, 1), gl.clear(gl.COLOR_BUFFER_BIT), gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.STATIC_DRAW), gl.drawArrays(gl.TRIANGLES, 0, 6), gl.bindFramebuffer(gl.FRAMEBUFFER, null), gl.bindTexture(gl.TEXTURE_2D, null);
      },
      blendFrames: function blendFrames(source1, source2, target, strength, clearAlpha, blendShader) {
        void 0 === strength && (strength = 1), void 0 === clearAlpha && (clearAlpha = !0), void 0 === blendShader && (blendShader = this.linearShader);
        var gl = this.gl;
        this.setShader(blendShader), this.set1i("uMainSampler1", 0), this.set1i("uMainSampler2", 1), this.set1f("uStrength", strength), gl.activeTexture(gl.TEXTURE0), gl.bindTexture(gl.TEXTURE_2D, source1.texture), gl.activeTexture(gl.TEXTURE1), gl.bindTexture(gl.TEXTURE_2D, source2.texture), target ? (gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer), gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target.texture, 0), gl.viewport(0, 0, target.width, target.height)) : gl.viewport(0, 0, source1.width, source1.height), clearAlpha ? gl.clearColor(0, 0, 0, 0) : gl.clearColor(0, 0, 0, 1), gl.clear(gl.COLOR_BUFFER_BIT), gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.STATIC_DRAW), gl.drawArrays(gl.TRIANGLES, 0, 6), gl.bindFramebuffer(gl.FRAMEBUFFER, null), gl.bindTexture(gl.TEXTURE_2D, null);
      },
      blendFramesAdditive: function blendFramesAdditive(source1, source2, target, strength, clearAlpha) {
        this.blendFrames(source1, source2, target, strength, clearAlpha, this.addShader);
      },
      clearFrame: function clearFrame(target, fbo) {
        void 0 === fbo && (fbo = !0);
        var gl = this.gl;
        gl.viewport(0, 0, target.width, target.height), gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer), fbo ? gl.clearColor(0, 0, 0, 0) : gl.clearColor(0, 0, 0, 1), gl.clear(gl.COLOR_BUFFER_BIT);
        fbo = this.renderer.currentFramebuffer;
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
      },
      setUVs: function setUVs(uA, vA, uB, vB, uC, vC, uD, vD) {
        var vertexViewF32 = this.vertexViewF32;
        vertexViewF32[2] = uA, vertexViewF32[3] = vA, vertexViewF32[6] = uB, vertexViewF32[7] = vB, vertexViewF32[10] = uC, vertexViewF32[11] = vC, vertexViewF32[14] = uA, vertexViewF32[15] = vA, vertexViewF32[18] = uC, vertexViewF32[19] = vC, vertexViewF32[22] = uD, vertexViewF32[23] = vD;
      },
      setTargetUVs: function setTargetUVs(diff, target) {
        diff = .5 < (diff = target.height / diff.height) ? .5 - (diff - .5) : .5 - diff + .5;
        this.setUVs(0, diff, 0, 1 + diff, 1, 1 + diff, 1, diff);
      },
      flipX: function flipX() {
        this.setUVs(1, 0, 1, 1, 0, 1, 0, 0);
      },
      flipY: function flipY() {
        this.setUVs(0, 1, 0, 0, 1, 0, 1, 1);
      },
      resetUVs: function resetUVs() {
        this.setUVs(0, 0, 0, 1, 1, 1, 1, 0);
      }
    });

    module.exports = UtilityPipeline;
  }, function (module, exports) {
    module.exports = ["#define SHADER_NAME PHASER_QUAD_VS", "", "precision mediump float;", "", "attribute vec2 inPosition;", "attribute vec2 inTexCoord;", "", "varying vec2 outFragCoord;", "varying vec2 outTexCoord;", "", "void main ()", "{", "    outFragCoord = inPosition.xy * 0.5 + 0.5;", "    outTexCoord = inTexCoord;", "", "    gl_Position = vec4(inPosition, 0, 1);", "}", ""].join("\n");
  }, function (module, exports, __webpack_require__) {
    var CanvasPool = __webpack_require__(31),
        Color = __webpack_require__(38),
        GetFastValue = __webpack_require__(2);

    module.exports = function (bufferHeight, config) {
      var imageData = bufferHeight.getContext("experimental-webgl"),
          callback = GetFastValue(config, "callback"),
          type = GetFastValue(config, "type", "image/png"),
          encoderOptions = GetFastValue(config, "encoder", .92),
          x = GetFastValue(config, "x", 0),
          ctx = GetFastValue(config, "y", 0),
          pixel = GetFastValue(config, "getPixel", !1),
          isFramebuffer = GetFastValue(config, "isFramebuffer", !1),
          bufferWidth = isFramebuffer ? GetFastValue(config, "bufferWidth", 1) : imageData.drawingBufferWidth,
          bufferHeight = isFramebuffer ? GetFastValue(config, "bufferHeight", 1) : imageData.drawingBufferHeight;

      if (pixel) {
        pixel = new Uint8Array(4);
        imageData.readPixels(x, isFramebuffer ? ctx : bufferHeight - ctx, 1, 1, imageData.RGBA, imageData.UNSIGNED_BYTE, pixel), callback.call(null, new Color(pixel[0], pixel[1], pixel[2], pixel[3] / 255));
      } else {
        var width = GetFastValue(config, "width", bufferWidth),
            height = GetFastValue(config, "height", bufferHeight),
            pixels = new Uint8Array(width * height * 4);
        imageData.readPixels(x, bufferHeight - ctx - height, width, height, imageData.RGBA, imageData.UNSIGNED_BYTE, pixels);

        for (var canvas = CanvasPool.createWebGL(this, width, height), ctx = canvas.getContext("2d"), imageData = ctx.getImageData(0, 0, width, height), data = imageData.data, py = 0; py < height; py++) {
          for (var px = 0; px < width; px++) {
            var sourceIndex = 4 * ((height - py - 1) * width + px),
                destIndex = 4 * (py * width + px);
            data[0 + destIndex] = pixels[0 + sourceIndex], data[1 + destIndex] = pixels[1 + sourceIndex], data[2 + destIndex] = pixels[2 + sourceIndex], data[3 + destIndex] = pixels[3 + sourceIndex];
          }
        }

        ctx.putImageData(imageData, 0, 0);
        var image = new Image();
        image.onerror = function () {
          callback.call(null), CanvasPool.remove(canvas);
        }, image.onload = function () {
          callback.call(null, image), CanvasPool.remove(canvas);
        }, image.src = canvas.toDataURL(type, encoderOptions);
      }
    };
  }, function (module, exports, __webpack_require__) {
    var CONST = __webpack_require__(33);

    module.exports = function (game) {
      var renderType,
          audioConfig,
          args,
          lastColor,
          c,
          audioType,
          config = game.config;
      config.hideBanner || (renderType = "WebGL", config.renderType === CONST.CANVAS ? renderType = "Canvas" : config.renderType === CONST.HEADLESS && (renderType = "Headless"), audioConfig = config.audio, audioType = (audioType = game.device.audio).webAudio && !audioConfig.disableWebAudio ? "Web Audio" : audioConfig.noAudio || !audioType.webAudio && !audioType.audioData ? "No Audio" : "HTML5 Audio", game.device.browser.ie ? window.console && console.log("Phaser v" + CONST.VERSION + " / https://phaser.io") : (args = [c = ""], Array.isArray(config.bannerBackgroundColor) ? (config.bannerBackgroundColor.forEach(function (color) {
        c = c.concat("%c "), args.push("background: " + color), lastColor = color;
      }), args[args.length - 1] = "color: " + config.bannerTextColor + "; background: " + lastColor) : (c = c.concat("%c "), args.push("color: " + config.bannerTextColor + "; background: " + config.bannerBackgroundColor)), args.push("background: transparent"), config.gameTitle && (c = c.concat(config.gameTitle), config.gameVersion && (c = c.concat(" v" + config.gameVersion)), config.hidePhaser || (c = c.concat(" / "))), c = (c = !config.hidePhaser ? c.concat("Phaser v" + CONST.VERSION + " (" + renderType + " | " + audioType + ")") : c).concat(" %c " + config.gameURL), args[0] = c, console.log.apply(console, args)));
    };
  }, function (module, exports, __webpack_require__) {
    var TimeStep = __webpack_require__(0),
        GetValue = __webpack_require__(6),
        NOOP = __webpack_require__(1),
        RequestAnimationFrame = __webpack_require__(386),
        TimeStep = new TimeStep({
      initialize: function initialize(game, config) {
        this.game = game, this.raf = new RequestAnimationFrame(), this.started = !1, this.running = !1, this.minFps = GetValue(config, "min", 5), this.targetFps = GetValue(config, "target", 60), this._min = 1e3 / this.minFps, this._target = 1e3 / this.targetFps, this.actualFps = this.targetFps, this.nextFpsUpdate = 0, this.framesThisSecond = 0, this.callback = NOOP, this.forceSetTimeOut = GetValue(config, "forceSetTimeOut", !1), this.time = 0, this.startTime = 0, this.lastTime = 0, this.frame = 0, this.inFocus = !0, this._pauseTime = 0, this._coolDown = 0, this.delta = 0, this.deltaIndex = 0, this.deltaHistory = [], this.deltaSmoothingMax = GetValue(config, "deltaHistory", 10), this.panicMax = GetValue(config, "panicMax", 120), this.rawDelta = 0, this.now = 0, this.smoothStep = GetValue(config, "smoothStep", !0);
      },
      blur: function blur() {
        this.inFocus = !1;
      },
      focus: function focus() {
        this.inFocus = !0, this.resetDelta();
      },
      pause: function pause() {
        this._pauseTime = window.performance.now();
      },
      resume: function resume() {
        this.resetDelta(), this.startTime += this.time - this._pauseTime;
      },
      resetDelta: function resetDelta() {
        var now = window.performance.now();
        this.time = now, this.lastTime = now, this.nextFpsUpdate = now + 1e3;

        for (var i = this.framesThisSecond = 0; i < this.deltaSmoothingMax; i++) {
          this.deltaHistory[i] = Math.min(this._target, this.deltaHistory[i]);
        }

        this.delta = 0, this.deltaIndex = 0, this._coolDown = this.panicMax;
      },
      start: function start(callback) {
        if (this.started) return this;
        this.started = !0, this.running = !0;

        for (var i = 0; i < this.deltaSmoothingMax; i++) {
          this.deltaHistory[i] = this._target;
        }

        this.resetDelta(), this.startTime = window.performance.now(), this.callback = callback, this.raf.start(this.step.bind(this), this.forceSetTimeOut, this._target);
      },
      step: function step() {
        var time = window.performance.now(),
            before = (this.now = time) - this.lastTime;
        this.rawDelta = before = before < 0 ? 0 : before;
        var idx = this.deltaIndex,
            history = this.deltaHistory,
            max = this.deltaSmoothingMax,
            interpolation = before,
            avg = before;

        if (this.smoothStep) {
          (0 < this._coolDown || !this.inFocus) && (this._coolDown--, interpolation = Math.min(interpolation, this._target)), interpolation > this._min && (interpolation = history[idx], interpolation = Math.min(interpolation, this._min)), history[idx] = interpolation, this.deltaIndex++, this.deltaIndex > max && (this.deltaIndex = 0);

          for (var avg = 0, i = 0; i < max; i++) {
            avg += history[i];
          }

          avg /= max;
        }

        this.delta = avg, this.time += this.rawDelta, time > this.nextFpsUpdate && (this.actualFps = .25 * this.framesThisSecond + .75 * this.actualFps, this.nextFpsUpdate = time + 1e3, this.framesThisSecond = 0), this.framesThisSecond++;
        interpolation = avg / this._target;
        this.callback(time, avg, interpolation), this.lastTime = time, this.frame++;
      },
      tick: function tick() {
        this.step();
      },
      sleep: function sleep() {
        this.running && (this.raf.stop(), this.running = !1);
      },
      wake: function wake(seamless) {
        this.running || (seamless && (this.startTime += -this.lastTime + (this.lastTime + window.performance.now())), this.raf.start(this.step.bind(this), this.useRAF), this.running = !0, this.step());
      },
      getDuration: function getDuration() {
        return Math.round(this.lastTime - this.startTime) / 1e3;
      },
      getDurationMS: function getDurationMS() {
        return Math.round(this.lastTime - this.startTime);
      },
      stop: function stop() {
        return this.running = !1, this.started = !1, this.raf.stop(), this;
      },
      destroy: function destroy() {
        this.stop(), this.callback = NOOP, this.raf = null, this.game = null;
      }
    });

    module.exports = TimeStep;
  }, function (module, exports, __webpack_require__) {
    var RequestAnimationFrame = __webpack_require__(0),
        NOOP = __webpack_require__(1),
        RequestAnimationFrame = new RequestAnimationFrame({
      initialize: function initialize() {
        this.isRunning = !1, this.callback = NOOP, this.tick = 0, this.isSetTimeOut = !1, this.timeOutID = null, this.lastTime = 0, this.target = 0;

        var _this = this;

        this.step = function step() {
          var timestamp = window.performance.now();
          _this.lastTime = _this.tick, _this.tick = timestamp, _this.callback(timestamp), _this.timeOutID = window.requestAnimationFrame(step);
        }, this.stepTimeout = function stepTimeout() {
          var d = Date.now(),
              delay = Math.min(Math.max(2 * _this.target + _this.tick - d, 0), _this.target);
          _this.lastTime = _this.tick, _this.tick = d, _this.callback(d), _this.timeOutID = window.setTimeout(stepTimeout, delay);
        };
      },
      start: function start(callback, forceSetTimeOut, targetFPS) {
        this.isRunning || (this.callback = callback, this.isSetTimeOut = forceSetTimeOut, this.target = targetFPS, this.isRunning = !0, this.timeOutID = forceSetTimeOut ? window.setTimeout(this.stepTimeout, 0) : window.requestAnimationFrame(this.step));
      },
      stop: function stop() {
        this.isRunning = !1, this.isSetTimeOut ? clearTimeout(this.timeOutID) : window.cancelAnimationFrame(this.timeOutID);
      },
      destroy: function destroy() {
        this.stop(), this.callback = NOOP;
      }
    });

    module.exports = RequestAnimationFrame;
  }, function (module, exports, __webpack_require__) {
    var Events = __webpack_require__(22);

    module.exports = function (game) {
      var hiddenVar,
          eventEmitter = game.events;
      void 0 !== document.hidden ? hiddenVar = "visibilitychange" : ["webkit", "moz", "ms"].forEach(function (prefix) {
        void 0 !== document[prefix + "Hidden"] && (document.hidden = function () {
          return document[prefix + "Hidden"];
        }, hiddenVar = prefix + "visibilitychange");
      });
      hiddenVar && document.addEventListener(hiddenVar, function (event) {
        document.hidden || "pause" === event.type ? eventEmitter.emit(Events.HIDDEN) : eventEmitter.emit(Events.VISIBLE);
      }, !1), window.onblur = function () {
        eventEmitter.emit(Events.BLUR);
      }, window.onfocus = function () {
        eventEmitter.emit(Events.FOCUS);
      }, window.focus && game.config.autoFocus && window.focus();
    };
  }, function (module, exports, __webpack_require__) {
    var Arne16 = __webpack_require__(389),
        CanvasPool = __webpack_require__(31),
        GetValue = __webpack_require__(6);

    module.exports = function (height) {
      var data = GetValue(height, "data", []),
          canvas = GetValue(height, "canvas", null),
          palette = GetValue(height, "palette", Arne16),
          pixelWidth = GetValue(height, "pixelWidth", 1),
          pixelHeight = GetValue(height, "pixelHeight", pixelWidth),
          resizeCanvas = GetValue(height, "resizeCanvas", !0),
          clearCanvas = GetValue(height, "clearCanvas", !0),
          preRender = GetValue(height, "preRender", null),
          postRender = GetValue(height, "postRender", null),
          width = Math.floor(Math.abs(data[0].length * pixelWidth)),
          height = Math.floor(Math.abs(data.length * pixelHeight));
      canvas || (canvas = CanvasPool.create2D(this, width, height), clearCanvas = resizeCanvas = !1), resizeCanvas && (canvas.width = width, canvas.height = height);
      var ctx = canvas.getContext("2d");
      clearCanvas && ctx.clearRect(0, 0, width, height), preRender && preRender(canvas, ctx);

      for (var y = 0; y < data.length; y++) {
        for (var row = data[y], x = 0; x < row.length; x++) {
          var d = row[x];
          "." !== d && " " !== d && (ctx.fillStyle = palette[d], ctx.fillRect(x * pixelWidth, y * pixelHeight, pixelWidth, pixelHeight));
        }
      }

      return postRender && postRender(canvas, ctx), canvas;
    };
  }, function (module, exports) {
    module.exports = {
      0: "#000",
      1: "#9D9D9D",
      2: "#FFF",
      3: "#BE2633",
      4: "#E06F8B",
      5: "#493C2B",
      6: "#A46422",
      7: "#EB8931",
      8: "#F7E26B",
      9: "#2F484E",
      A: "#44891A",
      B: "#A3CE27",
      C: "#1B2632",
      D: "#005784",
      E: "#31A2F2",
      F: "#B2DCEF"
    };
  }, function (module, exports, __webpack_require__) {
    var Class = __webpack_require__(0),
        CubicBezier = __webpack_require__(358),
        Curve = __webpack_require__(94),
        Vector2 = __webpack_require__(3),
        CubicBezierCurve = new Class({
      Extends: Curve,
      initialize: function initialize(p0, p1, p2, p3) {
        Curve.call(this, "CubicBezierCurve"), Array.isArray(p0) && (p3 = new Vector2(p0[6], p0[7]), p2 = new Vector2(p0[4], p0[5]), p1 = new Vector2(p0[2], p0[3]), p0 = new Vector2(p0[0], p0[1])), this.p0 = p0, this.p1 = p1, this.p2 = p2, this.p3 = p3;
      },
      getStartPoint: function getStartPoint(out) {
        return (out = void 0 === out ? new Vector2() : out).copy(this.p0);
      },
      getResolution: function getResolution(divisions) {
        return divisions;
      },
      getPoint: function getPoint(t, out) {
        void 0 === out && (out = new Vector2());
        var p0 = this.p0,
            p1 = this.p1,
            p2 = this.p2,
            p3 = this.p3;
        return out.set(CubicBezier(t, p0.x, p1.x, p2.x, p3.x), CubicBezier(t, p0.y, p1.y, p2.y, p3.y));
      },
      draw: function draw(graphics, pointsTotal) {
        var points = this.getPoints(pointsTotal = void 0 === pointsTotal ? 32 : pointsTotal);
        graphics.beginPath(), graphics.moveTo(this.p0.x, this.p0.y);

        for (var i = 1; i < points.length; i++) {
          graphics.lineTo(points[i].x, points[i].y);
        }

        return graphics.strokePath(), graphics;
      },
      toJSON: function toJSON() {
        return {
          type: this.type,
          points: [this.p0.x, this.p0.y, this.p1.x, this.p1.y, this.p2.x, this.p2.y, this.p3.x, this.p3.y]
        };
      }
    });

    CubicBezierCurve.fromJSON = function (p2) {
      var p3 = p2.points,
          p0 = new Vector2(p3[0], p3[1]),
          p1 = new Vector2(p3[2], p3[3]),
          p2 = new Vector2(p3[4], p3[5]),
          p3 = new Vector2(p3[6], p3[7]);
      return new CubicBezierCurve(p0, p1, p2, p3);
    }, module.exports = CubicBezierCurve;
  }, function (module, exports, __webpack_require__) {
    var Class = __webpack_require__(0),
        Curve = __webpack_require__(94),
        DegToRad = __webpack_require__(36),
        GetValue = __webpack_require__(6),
        RadToDeg = __webpack_require__(196),
        Vector2 = __webpack_require__(3),
        EllipseCurve = new Class({
      Extends: Curve,
      initialize: function initialize(x, y, xRadius, yRadius, startAngle, endAngle, clockwise, rotation) {
        var config;
        "object" == _typeof(x) ? (x = GetValue(config = x, "x", 0), y = GetValue(config, "y", 0), xRadius = GetValue(config, "xRadius", 0), yRadius = GetValue(config, "yRadius", xRadius), startAngle = GetValue(config, "startAngle", 0), endAngle = GetValue(config, "endAngle", 360), clockwise = GetValue(config, "clockwise", !1), rotation = GetValue(config, "rotation", 0)) : (void 0 === yRadius && (yRadius = xRadius), void 0 === startAngle && (startAngle = 0), void 0 === endAngle && (endAngle = 360), void 0 === clockwise && (clockwise = !1), void 0 === rotation && (rotation = 0)), Curve.call(this, "EllipseCurve"), this.p0 = new Vector2(x, y), this._xRadius = xRadius, this._yRadius = yRadius, this._startAngle = DegToRad(startAngle), this._endAngle = DegToRad(endAngle), this._clockwise = clockwise, this._rotation = DegToRad(rotation);
      },
      getStartPoint: function getStartPoint(out) {
        return void 0 === out && (out = new Vector2()), this.getPoint(0, out);
      },
      getResolution: function getResolution(divisions) {
        return 2 * divisions;
      },
      getPoint: function getPoint(tx, out) {
        void 0 === out && (out = new Vector2());

        for (var twoPi = 2 * Math.PI, deltaAngle = this._endAngle - this._startAngle, sin = Math.abs(deltaAngle) < Number.EPSILON; deltaAngle < 0;) {
          deltaAngle += twoPi;
        }

        for (; twoPi < deltaAngle;) {
          deltaAngle -= twoPi;
        }

        deltaAngle < Number.EPSILON && (deltaAngle = sin ? 0 : twoPi), this._clockwise && !sin && (deltaAngle === twoPi ? deltaAngle = -twoPi : deltaAngle -= twoPi);
        var cos,
            ty = this._startAngle + tx * deltaAngle,
            x = this.p0.x + this._xRadius * Math.cos(ty),
            y = this.p0.y + this._yRadius * Math.sin(ty);
        return 0 !== this._rotation && (cos = Math.cos(this._rotation), sin = Math.sin(this._rotation), x = (tx = x - this.p0.x) * cos - (ty = y - this.p0.y) * sin + this.p0.x, y = tx * sin + ty * cos + this.p0.y), out.set(x, y);
      },
      setXRadius: function setXRadius(value) {
        return this.xRadius = value, this;
      },
      setYRadius: function setYRadius(value) {
        return this.yRadius = value, this;
      },
      setWidth: function setWidth(value) {
        return this.xRadius = value / 2, this;
      },
      setHeight: function setHeight(value) {
        return this.yRadius = value / 2, this;
      },
      setStartAngle: function setStartAngle(value) {
        return this.startAngle = value, this;
      },
      setEndAngle: function setEndAngle(value) {
        return this.endAngle = value, this;
      },
      setClockwise: function setClockwise(value) {
        return this.clockwise = value, this;
      },
      setRotation: function setRotation(value) {
        return this.rotation = value, this;
      },
      x: {
        get: function get() {
          return this.p0.x;
        },
        set: function set(value) {
          this.p0.x = value;
        }
      },
      y: {
        get: function get() {
          return this.p0.y;
        },
        set: function set(value) {
          this.p0.y = value;
        }
      },
      xRadius: {
        get: function get() {
          return this._xRadius;
        },
        set: function set(value) {
          this._xRadius = value;
        }
      },
      yRadius: {
        get: function get() {
          return this._yRadius;
        },
        set: function set(value) {
          this._yRadius = value;
        }
      },
      startAngle: {
        get: function get() {
          return RadToDeg(this._startAngle);
        },
        set: function set(value) {
          this._startAngle = DegToRad(value);
        }
      },
      endAngle: {
        get: function get() {
          return RadToDeg(this._endAngle);
        },
        set: function set(value) {
          this._endAngle = DegToRad(value);
        }
      },
      clockwise: {
        get: function get() {
          return this._clockwise;
        },
        set: function set(value) {
          this._clockwise = value;
        }
      },
      angle: {
        get: function get() {
          return RadToDeg(this._rotation);
        },
        set: function set(value) {
          this._rotation = DegToRad(value);
        }
      },
      rotation: {
        get: function get() {
          return this._rotation;
        },
        set: function set(value) {
          this._rotation = value;
        }
      },
      toJSON: function toJSON() {
        return {
          type: this.type,
          x: this.p0.x,
          y: this.p0.y,
          xRadius: this._xRadius,
          yRadius: this._yRadius,
          startAngle: RadToDeg(this._startAngle),
          endAngle: RadToDeg(this._endAngle),
          clockwise: this._clockwise,
          rotation: RadToDeg(this._rotation)
        };
      }
    });

    EllipseCurve.fromJSON = function (data) {
      return new EllipseCurve(data);
    }, module.exports = EllipseCurve;
  }, function (module, exports, __webpack_require__) {
    var Class = __webpack_require__(0),
        Curve = __webpack_require__(94),
        FromPoints = __webpack_require__(199),
        Rectangle = __webpack_require__(10),
        Vector2 = __webpack_require__(3),
        LineCurve = new Class({
      Extends: Curve,
      initialize: function initialize(p0, p1) {
        Curve.call(this, "LineCurve"), Array.isArray(p0) && (p1 = new Vector2(p0[2], p0[3]), p0 = new Vector2(p0[0], p0[1])), this.p0 = p0, this.p1 = p1, this.arcLengthDivisions = 1;
      },
      getBounds: function getBounds(out) {
        return void 0 === out && (out = new Rectangle()), FromPoints([this.p0, this.p1], out);
      },
      getStartPoint: function getStartPoint(out) {
        return (out = void 0 === out ? new Vector2() : out).copy(this.p0);
      },
      getResolution: function getResolution(divisions) {
        return divisions = void 0 === divisions ? 1 : divisions;
      },
      getPoint: function getPoint(t, out) {
        return void 0 === out && (out = new Vector2()), 1 === t ? out.copy(this.p1) : (out.copy(this.p1).subtract(this.p0).scale(t).add(this.p0), out);
      },
      getPointAt: function getPointAt(u, out) {
        return this.getPoint(u, out);
      },
      getTangent: function getTangent(t, out) {
        return (out = void 0 === out ? new Vector2() : out).copy(this.p1).subtract(this.p0).normalize(), out;
      },
      getUtoTmapping: function getUtoTmapping(u, distance, lineLength) {
        return distance ? (lineLength = (lineLength = this.getLengths(lineLength))[lineLength.length - 1], Math.min(distance, lineLength) / lineLength) : u;
      },
      draw: function draw(graphics) {
        return graphics.lineBetween(this.p0.x, this.p0.y, this.p1.x, this.p1.y), graphics;
      },
      toJSON: function toJSON() {
        return {
          type: this.type,
          points: [this.p0.x, this.p0.y, this.p1.x, this.p1.y]
        };
      }
    });

    LineCurve.fromJSON = function (p0) {
      var p1 = p0.points,
          p0 = new Vector2(p1[0], p1[1]),
          p1 = new Vector2(p1[2], p1[3]);
      return new LineCurve(p0, p1);
    }, module.exports = LineCurve;
  }, function (module, exports, __webpack_require__) {
    var MoveTo = __webpack_require__(0),
        Vector2 = __webpack_require__(3),
        MoveTo = new MoveTo({
      initialize: function initialize(x, y) {
        this.active = !1, this.p0 = new Vector2(x, y);
      },
      getPoint: function getPoint(t, out) {
        return (out = void 0 === out ? new Vector2() : out).copy(this.p0);
      },
      getPointAt: function getPointAt(u, out) {
        return this.getPoint(u, out);
      },
      getResolution: function getResolution() {
        return 1;
      },
      getLength: function getLength() {
        return 0;
      },
      toJSON: function toJSON() {
        return {
          type: "MoveTo",
          points: [this.p0.x, this.p0.y]
        };
      }
    });

    module.exports = MoveTo;
  }, function (module, exports, __webpack_require__) {
    var Class = __webpack_require__(0),
        Curve = __webpack_require__(94),
        QuadraticBezierInterpolation = __webpack_require__(359),
        Vector2 = __webpack_require__(3),
        QuadraticBezier = new Class({
      Extends: Curve,
      initialize: function initialize(p0, p1, p2) {
        Curve.call(this, "QuadraticBezier"), Array.isArray(p0) && (p2 = new Vector2(p0[4], p0[5]), p1 = new Vector2(p0[2], p0[3]), p0 = new Vector2(p0[0], p0[1])), this.p0 = p0, this.p1 = p1, this.p2 = p2;
      },
      getStartPoint: function getStartPoint(out) {
        return (out = void 0 === out ? new Vector2() : out).copy(this.p0);
      },
      getResolution: function getResolution(divisions) {
        return divisions;
      },
      getPoint: function getPoint(t, out) {
        void 0 === out && (out = new Vector2());
        var p0 = this.p0,
            p1 = this.p1,
            p2 = this.p2;
        return out.set(QuadraticBezierInterpolation(t, p0.x, p1.x, p2.x), QuadraticBezierInterpolation(t, p0.y, p1.y, p2.y));
      },
      draw: function draw(graphics, pointsTotal) {
        var points = this.getPoints(pointsTotal = void 0 === pointsTotal ? 32 : pointsTotal);
        graphics.beginPath(), graphics.moveTo(this.p0.x, this.p0.y);

        for (var i = 1; i < points.length; i++) {
          graphics.lineTo(points[i].x, points[i].y);
        }

        return graphics.strokePath(), graphics;
      },
      toJSON: function toJSON() {
        return {
          type: this.type,
          points: [this.p0.x, this.p0.y, this.p1.x, this.p1.y, this.p2.x, this.p2.y]
        };
      }
    });

    QuadraticBezier.fromJSON = function (p1) {
      var p2 = p1.points,
          p0 = new Vector2(p2[0], p2[1]),
          p1 = new Vector2(p2[2], p2[3]),
          p2 = new Vector2(p2[4], p2[5]);
      return new QuadraticBezier(p0, p1, p2);
    }, module.exports = QuadraticBezier;
  }, function (module, exports, __webpack_require__) {
    var CatmullRom = __webpack_require__(194),
        Class = __webpack_require__(0),
        Curve = __webpack_require__(94),
        Vector2 = __webpack_require__(3),
        SplineCurve = new Class({
      Extends: Curve,
      initialize: function initialize(points) {
        void 0 === points && (points = []), Curve.call(this, "SplineCurve"), this.points = [], this.addPoints(points);
      },
      addPoints: function addPoints(points) {
        for (var i = 0; i < points.length; i++) {
          var p = new Vector2();
          "number" == typeof points[i] ? (p.x = points[i], p.y = points[i + 1], i++) : Array.isArray(points[i]) ? (p.x = points[i][0], p.y = points[i][1]) : (p.x = points[i].x, p.y = points[i].y), this.points.push(p);
        }

        return this;
      },
      addPoint: function addPoint(x, vec) {
        vec = new Vector2(x, vec);
        return this.points.push(vec), vec;
      },
      getStartPoint: function getStartPoint(out) {
        return (out = void 0 === out ? new Vector2() : out).copy(this.points[0]);
      },
      getResolution: function getResolution(divisions) {
        return divisions * this.points.length;
      },
      getPoint: function getPoint(p1, out) {
        void 0 === out && (out = new Vector2());
        var points = this.points,
            p2 = (points.length - 1) * p1,
            p3 = Math.floor(p2),
            weight = p2 - p3,
            p0 = points[0 === p3 ? p3 : p3 - 1],
            p1 = points[p3],
            p2 = points[p3 > points.length - 2 ? points.length - 1 : p3 + 1],
            p3 = points[p3 > points.length - 3 ? points.length - 1 : p3 + 2];
        return out.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));
      },
      toJSON: function toJSON() {
        for (var points = [], i = 0; i < this.points.length; i++) {
          points.push(this.points[i].x), points.push(this.points[i].y);
        }

        return {
          type: this.type,
          points: points
        };
      }
    });

    SplineCurve.fromJSON = function (data) {
      return new SplineCurve(data.points);
    }, module.exports = SplineCurve;
  }, function (module, exports, BaseShader) {
    BaseShader = new (BaseShader(0))({
      initialize: function initialize(key, fragmentSrc, vertexSrc, uniforms) {
        fragmentSrc && "" !== fragmentSrc || (fragmentSrc = ["precision mediump float;", "uniform vec2 resolution;", "varying vec2 fragCoord;", "void main () {", "    vec2 uv = fragCoord / resolution.xy;", "    gl_FragColor = vec4(uv.xyx, 1.0);", "}"].join("\n")), vertexSrc && "" !== vertexSrc || (vertexSrc = ["precision mediump float;", "uniform mat4 uProjectionMatrix;", "uniform mat4 uViewMatrix;", "uniform vec2 uResolution;", "attribute vec2 inPosition;", "varying vec2 fragCoord;", "varying vec2 outTexCoord;", "void main () {", "   gl_Position = uProjectionMatrix * uViewMatrix * vec4(inPosition, 1.0, 1.0);", "   fragCoord = vec2(inPosition.x, uResolution.y - inPosition.y);", "   outTexCoord = vec2(inPosition.x / uResolution.x, fragCoord.y / uResolution.y);", "}"].join("\n")), void 0 === uniforms && (uniforms = null), this.key = key, this.fragmentSrc = fragmentSrc, this.vertexSrc = vertexSrc, this.uniforms = uniforms;
      }
    });
    module.exports = BaseShader;
  }, function (module, exports, __webpack_require__) {
    var Color = __webpack_require__(38);

    Color.ColorSpectrum = __webpack_require__(909), Color.ColorToRGBA = __webpack_require__(910), Color.ComponentToHex = __webpack_require__(398), Color.GetColor = __webpack_require__(103), Color.GetColor32 = __webpack_require__(328), Color.HexStringToColor = __webpack_require__(327), Color.HSLToColor = __webpack_require__(911), Color.HSVColorWheel = __webpack_require__(912), Color.HSVToRGB = __webpack_require__(188), Color.HueToComponent = __webpack_require__(399), Color.IntegerToColor = __webpack_require__(189), Color.IntegerToRGB = __webpack_require__(330), Color.Interpolate = __webpack_require__(913), Color.ObjectToColor = __webpack_require__(331), Color.RandomRGB = __webpack_require__(914), Color.RGBStringToColor = __webpack_require__(332), Color.RGBToHSV = __webpack_require__(329), Color.RGBToString = __webpack_require__(915), Color.ValueToColor = __webpack_require__(187), module.exports = Color;
  }, function (module, exports) {
    module.exports = function (hex) {
      hex = hex.toString(16);
      return 1 === hex.length ? "0" + hex : hex;
    };
  }, function (module, exports) {
    module.exports = function (p, q, t) {
      return t < 0 && (t += 1), 1 < t && --t, t < 1 / 6 ? p + 6 * (q - p) * t : t < .5 ? q : t < 2 / 3 ? p + (q - p) * (2 / 3 - t) * 6 : p;
    };
  }, function (module, exports, __webpack_require__) {
    var OS = __webpack_require__(105);

    module.exports = function (callback) {
      var _check;

      "complete" !== document.readyState && "interactive" !== document.readyState ? (_check = function check() {
        document.removeEventListener("deviceready", _check, !0), document.removeEventListener("DOMContentLoaded", _check, !0), window.removeEventListener("load", _check, !0), callback();
      }, document.body ? OS.cordova ? document.addEventListener("deviceready", _check, !1) : (document.addEventListener("DOMContentLoaded", _check, !0), window.addEventListener("load", _check, !0)) : window.setTimeout(_check, 20)) : callback();
    };
  }, function (module, exports) {
    module.exports = function (ruler) {
      if (!ruler) return window.innerHeight;
      var axis = Math.abs(window.orientation),
          size = {
        w: 0,
        h: 0
      },
          ruler = document.createElement("div");
      return ruler.setAttribute("style", "position: fixed; height: 100vh; width: 0; top: 0"), document.documentElement.appendChild(ruler), size.w = 90 === axis ? ruler.offsetHeight : window.innerWidth, size.h = 90 === axis ? window.innerWidth : ruler.offsetHeight, document.documentElement.removeChild(ruler), ruler = null, 90 !== Math.abs(window.orientation) ? size.h : size.w;
    };
  }, function (module, exports, __webpack_require__) {
    var CONST = __webpack_require__(201);

    module.exports = function (width, height) {
      var orientation = window.screen,
          orientation = !!orientation && (orientation.orientation || orientation.mozOrientation || orientation.msOrientation);
      return orientation && "string" == typeof orientation.type ? orientation.type : "string" == typeof orientation ? orientation : "number" == typeof window.orientation ? 0 === window.orientation || 180 === window.orientation ? CONST.ORIENTATION.PORTRAIT : CONST.ORIENTATION.LANDSCAPE : window.matchMedia ? window.matchMedia("(orientation: portrait)").matches ? CONST.ORIENTATION.PORTRAIT : window.matchMedia("(orientation: landscape)").matches ? CONST.ORIENTATION.LANDSCAPE : void 0 : width < height ? CONST.ORIENTATION.PORTRAIT : CONST.ORIENTATION.LANDSCAPE;
    };
  }, function (module, exports) {
    module.exports = {
      NO_CENTER: 0,
      CENTER_BOTH: 1,
      CENTER_HORIZONTALLY: 2,
      CENTER_VERTICALLY: 3
    };
  }, function (module, exports) {
    module.exports = {
      LANDSCAPE: "landscape-primary",
      PORTRAIT: "portrait-primary"
    };
  }, function (module, exports) {
    module.exports = {
      NONE: 0,
      WIDTH_CONTROLS_HEIGHT: 1,
      HEIGHT_CONTROLS_WIDTH: 2,
      FIT: 3,
      ENVELOP: 4,
      RESIZE: 5
    };
  }, function (module, exports) {
    module.exports = {
      NO_ZOOM: 1,
      ZOOM_2X: 2,
      ZOOM_4X: 4,
      MAX_ZOOM: -1
    };
  }, function (module, exports) {
    module.exports = function (element) {
      var target;
      return "" !== element && ("string" == typeof element ? target = document.getElementById(element) : element && 1 === element.nodeType && (target = element)), target = target || document.body;
    };
  }, function (module, exports) {
    module.exports = function (data) {
      var xml = "";

      try {
        window.DOMParser ? xml = new DOMParser().parseFromString(data, "text/xml") : (xml = new ActiveXObject("Microsoft.XMLDOM")).loadXML(data);
      } catch (e) {
        xml = null;
      }

      return xml && xml.documentElement && !xml.getElementsByTagName("parsererror").length ? xml : null;
    };
  }, function (module, exports, __webpack_require__) {
    var InputManager = __webpack_require__(0),
        CONST = __webpack_require__(203),
        EventEmitter = __webpack_require__(9),
        Events = __webpack_require__(51),
        GameEvents = __webpack_require__(22),
        Keyboard = __webpack_require__(410),
        Mouse = __webpack_require__(411),
        Pointer = __webpack_require__(412),
        Touch = __webpack_require__(413),
        TransformMatrix = __webpack_require__(25),
        TransformXY = __webpack_require__(177),
        InputManager = new InputManager({
      initialize: function initialize(game, config) {
        this.game = game, this.scaleManager, this.canvas, this.config = config, this.enabled = !0, this.events = new EventEmitter(), this.isOver = !0, this.defaultCursor = "", this.keyboard = config.inputKeyboard ? new Keyboard(this) : null, this.mouse = config.inputMouse ? new Mouse(this) : null, this.touch = config.inputTouch ? new Touch(this) : null, this.pointers = [], this.pointersTotal = config.inputActivePointers, config.inputTouch && 1 === this.pointersTotal && (this.pointersTotal = 2);

        for (var i = 0; i <= this.pointersTotal; i++) {
          var pointer = new Pointer(this, i);
          pointer.smoothFactor = config.inputSmoothFactor, this.pointers.push(pointer);
        }

        this.mousePointer = config.inputMouse ? this.pointers[0] : null, this.activePointer = this.pointers[0], this.globalTopOnly = !0, this.time = 0, this._tempPoint = {
          x: 0,
          y: 0
        }, this._tempHitTest = [], this._tempMatrix = new TransformMatrix(), this._tempMatrix2 = new TransformMatrix(), this._tempSkip = !1, this.mousePointerContainer = [this.mousePointer], game.events.once(GameEvents.BOOT, this.boot, this);
      },
      boot: function boot() {
        this.canvas = this.game.canvas, this.scaleManager = this.game.scale, this.events.emit(Events.MANAGER_BOOT), this.game.events.on(GameEvents.PRE_RENDER, this.preRender, this), this.game.events.once(GameEvents.DESTROY, this.destroy, this);
      },
      setCanvasOver: function setCanvasOver(event) {
        this.isOver = !0, this.events.emit(Events.GAME_OVER, event);
      },
      setCanvasOut: function setCanvasOut(event) {
        this.isOver = !1, this.events.emit(Events.GAME_OUT, event);
      },
      preRender: function preRender() {
        var time = this.game.loop.now,
            delta = this.game.loop.delta,
            scenes = this.game.scene.getScenes(!0, !0);
        this.time = time, this.events.emit(Events.MANAGER_UPDATE);

        for (var i = 0; i < scenes.length; i++) {
          var scene = scenes[i];
          if (scene.sys.input && scene.sys.input.updatePoll(time, delta) && this.globalTopOnly) return;
        }
      },
      setDefaultCursor: function setDefaultCursor(cursor) {
        this.defaultCursor = cursor, this.canvas.style.cursor !== cursor && (this.canvas.style.cursor = cursor);
      },
      setCursor: function setCursor(interactiveObject) {
        interactiveObject.cursor && (this.canvas.style.cursor = interactiveObject.cursor);
      },
      resetCursor: function resetCursor(interactiveObject) {
        interactiveObject.cursor && this.canvas && (this.canvas.style.cursor = this.defaultCursor);
      },
      addPointer: function addPointer(quantity) {
        var output = [];
        10 < this.pointersTotal + (quantity = void 0 === quantity ? 1 : quantity) && (quantity = 10 - this.pointersTotal);

        for (var i = 0; i < quantity; i++) {
          var pointer = this.pointers.length,
              pointer = new Pointer(this, pointer);
          pointer.smoothFactor = this.config.inputSmoothFactor, this.pointers.push(pointer), this.pointersTotal++, output.push(pointer);
        }

        return output;
      },
      updateInputPlugins: function updateInputPlugins(type, pointers) {
        var scenes = this.game.scene.getScenes(!0, !0);
        this._tempSkip = !1;

        for (var i = 0; i < scenes.length; i++) {
          var scene = scenes[i];
          if (scene.sys.input) if (scene.sys.input.update(type, pointers) && this.globalTopOnly || this._tempSkip) return;
        }
      },
      onTouchStart: function onTouchStart(event) {
        for (var pointers = this.pointers, changed = [], c = 0; c < event.changedTouches.length; c++) {
          for (var changedTouch = event.changedTouches[c], i = 1; i < this.pointersTotal; i++) {
            var pointer = pointers[i];

            if (!pointer.active) {
              pointer.touchstart(changedTouch, event), this.activePointer = pointer, changed.push(pointer);
              break;
            }
          }
        }

        this.updateInputPlugins(CONST.TOUCH_START, changed);
      },
      onTouchMove: function onTouchMove(event) {
        for (var pointers = this.pointers, changed = [], c = 0; c < event.changedTouches.length; c++) {
          for (var changedTouch = event.changedTouches[c], i = 1; i < this.pointersTotal; i++) {
            var pointer = pointers[i];

            if (pointer.active && pointer.identifier === changedTouch.identifier) {
              pointer.touchmove(changedTouch, event), this.activePointer = pointer, changed.push(pointer);
              break;
            }
          }
        }

        this.updateInputPlugins(CONST.TOUCH_MOVE, changed);
      },
      onTouchEnd: function onTouchEnd(event) {
        for (var pointers = this.pointers, changed = [], c = 0; c < event.changedTouches.length; c++) {
          for (var changedTouch = event.changedTouches[c], i = 1; i < this.pointersTotal; i++) {
            var pointer = pointers[i];

            if (pointer.active && pointer.identifier === changedTouch.identifier) {
              pointer.touchend(changedTouch, event), changed.push(pointer);
              break;
            }
          }
        }

        this.updateInputPlugins(CONST.TOUCH_END, changed);
      },
      onTouchCancel: function onTouchCancel(event) {
        for (var pointers = this.pointers, changed = [], c = 0; c < event.changedTouches.length; c++) {
          for (var changedTouch = event.changedTouches[c], i = 1; i < this.pointersTotal; i++) {
            var pointer = pointers[i];

            if (pointer.active && pointer.identifier === changedTouch.identifier) {
              pointer.touchcancel(changedTouch, event), changed.push(pointer);
              break;
            }
          }
        }

        this.updateInputPlugins(CONST.TOUCH_CANCEL, changed);
      },
      onMouseDown: function onMouseDown(event) {
        var mousePointer = this.mousePointer;
        mousePointer.down(event), mousePointer.updateMotion(), this.activePointer = mousePointer, this.updateInputPlugins(CONST.MOUSE_DOWN, this.mousePointerContainer);
      },
      onMouseMove: function onMouseMove(event) {
        var mousePointer = this.mousePointer;
        mousePointer.move(event), mousePointer.updateMotion(), this.activePointer = mousePointer, this.updateInputPlugins(CONST.MOUSE_MOVE, this.mousePointerContainer);
      },
      onMouseUp: function onMouseUp(event) {
        var mousePointer = this.mousePointer;
        mousePointer.up(event), mousePointer.updateMotion(), this.activePointer = mousePointer, this.updateInputPlugins(CONST.MOUSE_UP, this.mousePointerContainer);
      },
      onMouseWheel: function onMouseWheel(event) {
        var mousePointer = this.mousePointer;
        mousePointer.wheel(event), this.activePointer = mousePointer, this.updateInputPlugins(CONST.MOUSE_WHEEL, this.mousePointerContainer);
      },
      onPointerLockChange: function onPointerLockChange(event) {
        var isLocked = this.mouse.locked;
        this.mousePointer.locked = isLocked, this.events.emit(Events.POINTERLOCK_CHANGE, event, isLocked);
      },
      inputCandidate: function inputCandidate(gameObject, camera) {
        var input = gameObject.input;
        if (!input || !input.enabled || !input.alwaysEnabled && !gameObject.willRender(camera)) return !1;
        var visible = !0,
            parent = gameObject.parentContainer;
        if (parent) do {
          if (!parent.willRender(camera)) {
            visible = !1;
            break;
          }
        } while (parent = parent.parentContainer);
        return visible;
      },
      hitTest: function hitTest(pointer, gameObjects, camera, output) {
        void 0 === output && (output = this._tempHitTest);
        var tempPoint = this._tempPoint,
            csx = camera.scrollX,
            csy = camera.scrollY;
        output.length = 0;
        var x = pointer.x,
            y = pointer.y;
        camera.getWorldPoint(x, y, tempPoint), pointer.worldX = tempPoint.x, pointer.worldY = tempPoint.y;

        for (var point = {
          x: 0,
          y: 0
        }, matrix = this._tempMatrix, parentMatrix = this._tempMatrix2, i = 0; i < gameObjects.length; i++) {
          var px,
              py,
              gameObject = gameObjects[i];
          this.inputCandidate(gameObject, camera) && (px = tempPoint.x + csx * gameObject.scrollFactorX - csx, py = tempPoint.y + csy * gameObject.scrollFactorY - csy, gameObject.parentContainer ? (gameObject.getWorldTransformMatrix(matrix, parentMatrix), matrix.applyInverse(px, py, point)) : TransformXY(px, py, gameObject.x, gameObject.y, gameObject.rotation, gameObject.scaleX, gameObject.scaleY, point), this.pointWithinHitArea(gameObject, point.x, point.y) && output.push(gameObject));
        }

        return output;
      },
      pointWithinHitArea: function pointWithinHitArea(gameObject, x, y) {
        x += gameObject.displayOriginX, y += gameObject.displayOriginY;
        var input = gameObject.input;
        return !(!input || !input.hitAreaCallback(input.hitArea, x, y, gameObject)) && (input.localX = x, input.localY = y, !0);
      },
      pointWithinInteractiveObject: function pointWithinInteractiveObject(object, x, y) {
        return !!object.hitArea && (x += object.gameObject.displayOriginX, y += object.gameObject.displayOriginY, object.localX = x, object.localY = y, object.hitAreaCallback(object.hitArea, x, y, object));
      },
      transformPointer: function transformPointer(a, x, y, wasMove) {
        var p0 = a.position,
            p1 = a.prevPosition;
        p1.x = p0.x, p1.y = p0.y;
        x = this.scaleManager.transformX(x), y = this.scaleManager.transformY(y), a = a.smoothFactor;
        wasMove && 0 !== a ? (p0.x = x * a + p1.x * (1 - a), p0.y = y * a + p1.y * (1 - a)) : (p0.x = x, p0.y = y);
      },
      destroy: function destroy() {
        this.events.removeAllListeners(), this.game.events.off(GameEvents.PRE_RENDER), this.keyboard && this.keyboard.destroy(), this.mouse && this.mouse.destroy(), this.touch && this.touch.destroy();

        for (var i = 0; i < this.pointers.length; i++) {
          this.pointers[i].destroy();
        }

        this.pointers = [], this._tempHitTest = [], this._tempMatrix.destroy(), this.canvas = null, this.game = null;
      }
    });

    module.exports = InputManager;
  }, function (module, exports, __webpack_require__) {
    var ArrayRemove = __webpack_require__(93),
        KeyboardManager = __webpack_require__(0),
        GameEvents = __webpack_require__(22),
        InputEvents = __webpack_require__(51),
        KeyCodes = __webpack_require__(143),
        NOOP = __webpack_require__(1),
        KeyboardManager = new KeyboardManager({
      initialize: function initialize(inputManager) {
        this.manager = inputManager, this.queue = [], this.preventDefault = !0, this.captures = [], this.enabled = !1, this.target, this.onKeyDown = NOOP, this.onKeyUp = NOOP, inputManager.events.once(InputEvents.MANAGER_BOOT, this.boot, this);
      },
      boot: function boot() {
        var config = this.manager.config;
        this.enabled = config.inputKeyboard, this.target = config.inputKeyboardEventTarget, this.addCapture(config.inputKeyboardCapture), !this.target && window && (this.target = window), this.enabled && this.target && this.startListeners(), this.manager.game.events.on(GameEvents.POST_STEP, this.postUpdate, this);
      },
      startListeners: function startListeners() {
        var _this = this;

        this.onKeyDown = function (event) {
          var modified;
          !event.defaultPrevented && _this.enabled && _this.manager && (_this.queue.push(event), _this.manager.events.emit(InputEvents.MANAGER_PROCESS), modified = event.altKey || event.ctrlKey || event.shiftKey || event.metaKey, _this.preventDefault && !modified && -1 < _this.captures.indexOf(event.keyCode) && event.preventDefault());
        }, this.onKeyUp = function (event) {
          var modified;
          !event.defaultPrevented && _this.enabled && _this.manager && (_this.queue.push(event), _this.manager.events.emit(InputEvents.MANAGER_PROCESS), modified = event.altKey || event.ctrlKey || event.shiftKey || event.metaKey, _this.preventDefault && !modified && -1 < _this.captures.indexOf(event.keyCode) && event.preventDefault());
        };
        var target = this.target;
        target && (target.addEventListener("keydown", this.onKeyDown, !1), target.addEventListener("keyup", this.onKeyUp, !1), this.enabled = !0);
      },
      stopListeners: function stopListeners() {
        var target = this.target;
        target.removeEventListener("keydown", this.onKeyDown, !1), target.removeEventListener("keyup", this.onKeyUp, !1), this.enabled = !1;
      },
      postUpdate: function postUpdate() {
        this.queue = [];
      },
      addCapture: function addCapture(keycode) {
        "string" == typeof keycode && (keycode = keycode.split(",")), Array.isArray(keycode) || (keycode = [keycode]);

        for (var captures = this.captures, i = 0; i < keycode.length; i++) {
          var code = keycode[i];
          "string" == typeof code && (code = KeyCodes[code.trim().toUpperCase()]), -1 === captures.indexOf(code) && captures.push(code);
        }

        this.preventDefault = 0 < captures.length;
      },
      removeCapture: function removeCapture(keycode) {
        "string" == typeof keycode && (keycode = keycode.split(",")), Array.isArray(keycode) || (keycode = [keycode]);

        for (var captures = this.captures, i = 0; i < keycode.length; i++) {
          var code = keycode[i];
          "string" == typeof code && (code = KeyCodes[code.toUpperCase()]), ArrayRemove(captures, code);
        }

        this.preventDefault = 0 < captures.length;
      },
      clearCaptures: function clearCaptures() {
        this.captures = [], this.preventDefault = !1;
      },
      destroy: function destroy() {
        this.stopListeners(), this.clearCaptures(), this.queue = [], this.manager.game.events.off(GameEvents.POST_RENDER, this.postUpdate, this), this.target = null, this.enabled = !1, this.manager = null;
      }
    });

    module.exports = KeyboardManager;
  }, function (module, exports, __webpack_require__) {
    var MouseManager = __webpack_require__(0),
        Features = __webpack_require__(191),
        InputEvents = __webpack_require__(51),
        NOOP = __webpack_require__(1),
        MouseManager = new MouseManager({
      initialize: function initialize(inputManager) {
        this.manager = inputManager, this.preventDefaultDown = !0, this.preventDefaultUp = !0, this.preventDefaultMove = !0, this.preventDefaultWheel = !1, this.enabled = !1, this.target, this.locked = !1, this.onMouseMove = NOOP, this.onMouseDown = NOOP, this.onMouseUp = NOOP, this.onMouseDownWindow = NOOP, this.onMouseUpWindow = NOOP, this.onMouseOver = NOOP, this.onMouseOut = NOOP, this.onMouseWheel = NOOP, this.pointerLockChange = NOOP, this.isTop = !0, inputManager.events.once(InputEvents.MANAGER_BOOT, this.boot, this);
      },
      boot: function boot() {
        var config = this.manager.config;
        this.enabled = config.inputMouse, this.target = config.inputMouseEventTarget, this.passive = config.inputMousePassive, this.preventDefaultDown = config.inputMousePreventDefaultDown, this.preventDefaultUp = config.inputMousePreventDefaultUp, this.preventDefaultMove = config.inputMousePreventDefaultMove, this.preventDefaultWheel = config.inputMousePreventDefaultWheel, this.target ? "string" == typeof this.target && (this.target = document.getElementById(this.target)) : this.target = this.manager.game.canvas, config.disableContextMenu && this.disableContextMenu(), this.enabled && this.target && this.startListeners();
      },
      disableContextMenu: function disableContextMenu() {
        return document.body.addEventListener("contextmenu", function (event) {
          return event.preventDefault(), !1;
        }), this;
      },
      requestPointerLock: function requestPointerLock() {
        var element;
        Features.pointerLock && ((element = this.target).requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock, element.requestPointerLock());
      },
      releasePointerLock: function releasePointerLock() {
        Features.pointerLock && (document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock, document.exitPointerLock());
      },
      startListeners: function startListeners() {
        var target = this.target;

        if (target) {
          var _this = this,
              manager = this.manager,
              canvas = manager.canvas,
              autoFocus = window && window.focus && manager.game.config.autoFocus;

          this.onMouseMove = function (event) {
            !event.defaultPrevented && _this.enabled && manager && manager.enabled && (manager.onMouseMove(event), _this.preventDefaultMove && event.preventDefault());
          }, this.onMouseDown = function (event) {
            autoFocus && window.focus(), !event.defaultPrevented && _this.enabled && manager && manager.enabled && (manager.onMouseDown(event), _this.preventDefaultDown && event.target === canvas && event.preventDefault());
          }, this.onMouseDownWindow = function (event) {
            !event.defaultPrevented && _this.enabled && manager && manager.enabled && event.target !== canvas && manager.onMouseDown(event);
          }, this.onMouseUp = function (event) {
            !event.defaultPrevented && _this.enabled && manager && manager.enabled && (manager.onMouseUp(event), _this.preventDefaultUp && event.target === canvas && event.preventDefault());
          }, this.onMouseUpWindow = function (event) {
            !event.defaultPrevented && _this.enabled && manager && manager.enabled && event.target !== canvas && manager.onMouseUp(event);
          }, this.onMouseOver = function (event) {
            !event.defaultPrevented && _this.enabled && manager && manager.enabled && manager.setCanvasOver(event);
          }, this.onMouseOut = function (event) {
            !event.defaultPrevented && _this.enabled && manager && manager.enabled && manager.setCanvasOut(event);
          }, this.onMouseWheel = function (event) {
            !event.defaultPrevented && _this.enabled && manager && manager.enabled && manager.onMouseWheel(event), _this.preventDefaultWheel && event.target === canvas && event.preventDefault();
          };
          var passive = {
            passive: !0
          };
          if (target.addEventListener("mousemove", this.onMouseMove), target.addEventListener("mousedown", this.onMouseDown), target.addEventListener("mouseup", this.onMouseUp), target.addEventListener("mouseover", this.onMouseOver, passive), target.addEventListener("mouseout", this.onMouseOut, passive), this.preventDefaultWheel ? target.addEventListener("wheel", this.onMouseWheel, {
            passive: !1
          }) : target.addEventListener("wheel", this.onMouseWheel, passive), window && manager.game.config.inputWindowEvents) try {
            window.top.addEventListener("mousedown", this.onMouseDownWindow, passive), window.top.addEventListener("mouseup", this.onMouseUpWindow, passive);
          } catch (exception) {
            window.addEventListener("mousedown", this.onMouseDownWindow, passive), window.addEventListener("mouseup", this.onMouseUpWindow, passive), this.isTop = !1;
          }
          Features.pointerLock && (this.pointerLockChange = function (event) {
            var element = _this.target;
            _this.locked = document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element, manager.onPointerLockChange(event);
          }, document.addEventListener("pointerlockchange", this.pointerLockChange, !0), document.addEventListener("mozpointerlockchange", this.pointerLockChange, !0), document.addEventListener("webkitpointerlockchange", this.pointerLockChange, !0)), this.enabled = !0;
        }
      },
      stopListeners: function stopListeners() {
        var target = this.target;
        target.removeEventListener("mousemove", this.onMouseMove), target.removeEventListener("mousedown", this.onMouseDown), target.removeEventListener("mouseup", this.onMouseUp), target.removeEventListener("mouseover", this.onMouseOver), target.removeEventListener("mouseout", this.onMouseOut), window && ((target = this.isTop ? window.top : window).removeEventListener("mousedown", this.onMouseDownWindow), target.removeEventListener("mouseup", this.onMouseUpWindow)), Features.pointerLock && (document.removeEventListener("pointerlockchange", this.pointerLockChange, !0), document.removeEventListener("mozpointerlockchange", this.pointerLockChange, !0), document.removeEventListener("webkitpointerlockchange", this.pointerLockChange, !0));
      },
      destroy: function destroy() {
        this.stopListeners(), this.target = null, this.enabled = !1, this.manager = null;
      }
    });

    module.exports = MouseManager;
  }, function (module, exports, __webpack_require__) {
    var Angle = __webpack_require__(349),
        Pointer = __webpack_require__(0),
        Distance = __webpack_require__(50),
        FuzzyEqual = __webpack_require__(124),
        SmoothStepInterpolation = __webpack_require__(360),
        Vector2 = __webpack_require__(3),
        OS = __webpack_require__(105),
        Pointer = new Pointer({
      initialize: function initialize(manager, id) {
        this.manager = manager, this.id = id, this.event, this.downElement, this.upElement, this.camera = null, this.button = 0, this.buttons = 0, this.position = new Vector2(), this.prevPosition = new Vector2(), this.midPoint = new Vector2(-1, -1), this.velocity = new Vector2(), this.angle = 0, this.distance = 0, this.smoothFactor = 0, this.motionFactor = .2, this.worldX = 0, this.worldY = 0, this.moveTime = 0, this.downX = 0, this.downY = 0, this.downTime = 0, this.upX = 0, this.upY = 0, this.upTime = 0, this.primaryDown = !1, this.isDown = !1, this.wasTouch = !1, this.wasCanceled = !1, this.movementX = 0, this.movementY = 0, this.identifier = 0, this.pointerId = null, this.active = 0 === id, this.locked = !1, this.deltaX = 0, this.deltaY = 0, this.deltaZ = 0;
      },
      updateWorldPoint: function updateWorldPoint(temp) {
        temp = temp.getWorldPoint(this.x, this.y);
        return this.worldX = temp.x, this.worldY = temp.y, this;
      },
      positionToCamera: function positionToCamera(camera, output) {
        return camera.getWorldPoint(this.x, this.y, output);
      },
      updateMotion: function updateMotion() {
        var vx,
            vy,
            cx = this.position.x,
            cy = this.position.y,
            dx = this.midPoint.x,
            dy = this.midPoint.y;
        cx === dx && cy === dy || (vx = SmoothStepInterpolation(this.motionFactor, dx, cx), vy = SmoothStepInterpolation(this.motionFactor, dy, cy), FuzzyEqual(vx, cx, .1) && (vx = cx), FuzzyEqual(vy, cy, .1) && (vy = cy), this.midPoint.set(vx, vy), this.velocity.set(dx = cx - vx, dy = cy - vy), this.angle = Angle(vx, vy, cx, cy), this.distance = Math.sqrt(dx * dx + dy * dy));
      },
      up: function up(event) {
        "buttons" in event && (this.buttons = event.buttons), this.event = event, this.button = event.button, this.upElement = event.target, this.manager.transformPointer(this, event.pageX, event.pageY, !1), 0 === event.button && (this.primaryDown = !1, this.upX = this.x, this.upY = this.y), 0 === this.buttons && (this.isDown = !1, this.upTime = event.timeStamp, this.wasTouch = !1);
      },
      down: function down(event) {
        "buttons" in event && (this.buttons = event.buttons), this.event = event, this.button = event.button, this.downElement = event.target, this.manager.transformPointer(this, event.pageX, event.pageY, !1), 0 === event.button && (this.primaryDown = !0, this.downX = this.x, this.downY = this.y), OS.macOS && event.ctrlKey && (this.buttons = 2, this.primaryDown = !1), this.isDown || (this.isDown = !0, this.downTime = event.timeStamp), this.wasTouch = !1;
      },
      move: function move(event) {
        "buttons" in event && (this.buttons = event.buttons), this.event = event, this.manager.transformPointer(this, event.pageX, event.pageY, !0), this.locked && (this.movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0, this.movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0), this.moveTime = event.timeStamp, this.wasTouch = !1;
      },
      wheel: function wheel(event) {
        "buttons" in event && (this.buttons = event.buttons), this.event = event, this.manager.transformPointer(this, event.pageX, event.pageY, !1), this.deltaX = event.deltaX, this.deltaY = event.deltaY, this.deltaZ = event.deltaZ, this.wasTouch = !1;
      },
      touchstart: function touchstart(touch, event) {
        touch.pointerId && (this.pointerId = touch.pointerId), this.identifier = touch.identifier, this.target = touch.target, this.active = !0, this.buttons = 1, this.event = event, this.downElement = touch.target, this.manager.transformPointer(this, touch.pageX, touch.pageY, !1), this.primaryDown = !0, this.downX = this.x, this.downY = this.y, this.downTime = event.timeStamp, this.isDown = !0, this.wasTouch = !0, this.wasCanceled = !1, this.updateMotion();
      },
      touchmove: function touchmove(touch, event) {
        this.event = event, this.manager.transformPointer(this, touch.pageX, touch.pageY, !0), this.moveTime = event.timeStamp, this.wasTouch = !0, this.updateMotion();
      },
      touchend: function touchend(touch, event) {
        this.buttons = 0, this.event = event, this.upElement = touch.target, this.manager.transformPointer(this, touch.pageX, touch.pageY, !1), this.primaryDown = !1, this.upX = this.x, this.upY = this.y, this.upTime = event.timeStamp, this.isDown = !1, this.wasTouch = !0, this.wasCanceled = !1, this.active = !1, this.updateMotion();
      },
      touchcancel: function touchcancel(touch, event) {
        this.buttons = 0, this.event = event, this.upElement = touch.target, this.manager.transformPointer(this, touch.pageX, touch.pageY, !1), this.primaryDown = !1, this.upX = this.x, this.upY = this.y, this.upTime = event.timeStamp, this.isDown = !1, this.wasTouch = !0, this.wasCanceled = !0, this.active = !1;
      },
      noButtonDown: function noButtonDown() {
        return 0 === this.buttons;
      },
      leftButtonDown: function leftButtonDown() {
        return !!(1 & this.buttons);
      },
      rightButtonDown: function rightButtonDown() {
        return !!(2 & this.buttons);
      },
      middleButtonDown: function middleButtonDown() {
        return !!(4 & this.buttons);
      },
      backButtonDown: function backButtonDown() {
        return !!(8 & this.buttons);
      },
      forwardButtonDown: function forwardButtonDown() {
        return !!(16 & this.buttons);
      },
      leftButtonReleased: function leftButtonReleased() {
        return 0 === this.button && !this.isDown;
      },
      rightButtonReleased: function rightButtonReleased() {
        return 2 === this.button && !this.isDown;
      },
      middleButtonReleased: function middleButtonReleased() {
        return 1 === this.button && !this.isDown;
      },
      backButtonReleased: function backButtonReleased() {
        return 3 === this.button && !this.isDown;
      },
      forwardButtonReleased: function forwardButtonReleased() {
        return 4 === this.button && !this.isDown;
      },
      getDistance: function getDistance() {
        return this.isDown ? Distance(this.downX, this.downY, this.x, this.y) : Distance(this.downX, this.downY, this.upX, this.upY);
      },
      getDistanceX: function getDistanceX() {
        return this.isDown ? Math.abs(this.downX - this.x) : Math.abs(this.downX - this.upX);
      },
      getDistanceY: function getDistanceY() {
        return this.isDown ? Math.abs(this.downY - this.y) : Math.abs(this.downY - this.upY);
      },
      getDuration: function getDuration() {
        return this.isDown ? this.manager.time - this.downTime : this.upTime - this.downTime;
      },
      getAngle: function getAngle() {
        return this.isDown ? Angle(this.downX, this.downY, this.x, this.y) : Angle(this.downX, this.downY, this.upX, this.upY);
      },
      getInterpolatedPosition: function getInterpolatedPosition(steps, out) {
        void 0 === steps && (steps = 10), void 0 === out && (out = []);

        for (var prevX = this.prevPosition.x, prevY = this.prevPosition.y, curX = this.position.x, curY = this.position.y, i = 0; i < steps; i++) {
          var t = 1 / steps * i;
          out[i] = {
            x: SmoothStepInterpolation(t, prevX, curX),
            y: SmoothStepInterpolation(t, prevY, curY)
          };
        }

        return out;
      },
      destroy: function destroy() {
        this.camera = null, this.manager = null, this.position = null;
      },
      x: {
        get: function get() {
          return this.position.x;
        },
        set: function set(value) {
          this.position.x = value;
        }
      },
      y: {
        get: function get() {
          return this.position.y;
        },
        set: function set(value) {
          this.position.y = value;
        }
      },
      time: {
        get: function get() {
          return this.event ? this.event.timeStamp : 0;
        }
      }
    });

    module.exports = Pointer;
  }, function (module, exports, __webpack_require__) {
    var TouchManager = __webpack_require__(0),
        InputEvents = __webpack_require__(51),
        NOOP = __webpack_require__(1),
        TouchManager = new TouchManager({
      initialize: function initialize(inputManager) {
        this.manager = inputManager, this.capture = !0, this.enabled = !1, this.target, this.onTouchStart = NOOP, this.onTouchStartWindow = NOOP, this.onTouchMove = NOOP, this.onTouchEnd = NOOP, this.onTouchEndWindow = NOOP, this.onTouchCancel = NOOP, this.onTouchCancelWindow = NOOP, this.onTouchOver = NOOP, this.onTouchOut = NOOP, inputManager.events.once(InputEvents.MANAGER_BOOT, this.boot, this);
      },
      boot: function boot() {
        var config = this.manager.config;
        this.enabled = config.inputTouch, this.target = config.inputTouchEventTarget, this.capture = config.inputTouchCapture, this.target || (this.target = this.manager.game.canvas), config.disableContextMenu && this.disableContextMenu(), this.enabled && this.target && this.startListeners();
      },
      disableContextMenu: function disableContextMenu() {
        return document.body.addEventListener("contextmenu", function (event) {
          return event.preventDefault(), !1;
        }), this;
      },
      startListeners: function startListeners() {
        var _this = this,
            canvas = this.manager.canvas,
            autoFocus = window && window.focus && this.manager.game.config.autoFocus;

        this.onTouchStart = function (event) {
          autoFocus && window.focus(), !event.defaultPrevented && _this.enabled && _this.manager && _this.manager.enabled && (_this.manager.onTouchStart(event), _this.capture && event.cancelable && event.target === canvas && event.preventDefault());
        }, this.onTouchStartWindow = function (event) {
          !event.defaultPrevented && _this.enabled && _this.manager && _this.manager.enabled && event.target !== canvas && _this.manager.onTouchStart(event);
        }, this.onTouchMove = function (event) {
          !event.defaultPrevented && _this.enabled && _this.manager && _this.manager.enabled && (_this.manager.onTouchMove(event), _this.capture && event.cancelable && event.preventDefault());
        }, this.onTouchEnd = function (event) {
          !event.defaultPrevented && _this.enabled && _this.manager && _this.manager.enabled && (_this.manager.onTouchEnd(event), _this.capture && event.cancelable && event.target === canvas && event.preventDefault());
        }, this.onTouchEndWindow = function (event) {
          !event.defaultPrevented && _this.enabled && _this.manager && _this.manager.enabled && event.target !== canvas && _this.manager.onTouchEnd(event);
        }, this.onTouchCancel = function (event) {
          !event.defaultPrevented && _this.enabled && _this.manager && _this.manager.enabled && (_this.manager.onTouchCancel(event), _this.capture && event.preventDefault());
        }, this.onTouchCancelWindow = function (event) {
          !event.defaultPrevented && _this.enabled && _this.manager && _this.manager.enabled && _this.manager.onTouchCancel(event);
        }, this.onTouchOver = function (event) {
          !event.defaultPrevented && _this.enabled && _this.manager && _this.manager.enabled && _this.manager.setCanvasOver(event);
        }, this.onTouchOut = function (event) {
          !event.defaultPrevented && _this.enabled && _this.manager && _this.manager.enabled && _this.manager.setCanvasOut(event);
        };
        var passive,
            nonPassive,
            target = this.target;
        target && (nonPassive = {
          passive: !(passive = {
            passive: !0
          })
        }, target.addEventListener("touchstart", this.onTouchStart, this.capture ? nonPassive : passive), target.addEventListener("touchmove", this.onTouchMove, this.capture ? nonPassive : passive), target.addEventListener("touchend", this.onTouchEnd, this.capture ? nonPassive : passive), target.addEventListener("touchcancel", this.onTouchCancel, this.capture ? nonPassive : passive), target.addEventListener("touchover", this.onTouchOver, this.capture ? nonPassive : passive), target.addEventListener("touchout", this.onTouchOut, this.capture ? nonPassive : passive), window && this.manager.game.config.inputWindowEvents && (window.addEventListener("touchstart", this.onTouchStartWindow, nonPassive), window.addEventListener("touchend", this.onTouchEndWindow, nonPassive), window.addEventListener("touchcancel", this.onTouchCancelWindow, nonPassive)), this.enabled = !0);
      },
      stopListeners: function stopListeners() {
        var target = this.target;
        target.removeEventListener("touchstart", this.onTouchStart), target.removeEventListener("touchmove", this.onTouchMove), target.removeEventListener("touchend", this.onTouchEnd), target.removeEventListener("touchcancel", this.onTouchCancel), target.removeEventListener("touchover", this.onTouchOver), target.removeEventListener("touchout", this.onTouchOut), window && (window.removeEventListener("touchstart", this.onTouchStartWindow), window.removeEventListener("touchend", this.onTouchEndWindow));
      },
      destroy: function destroy() {
        this.stopListeners(), this.target = null, this.enabled = !1, this.manager = null;
      }
    });

    module.exports = TouchManager;
  }, function (module, exports, __webpack_require__) {
    var PluginManager = __webpack_require__(0),
        GameEvents = __webpack_require__(22),
        EventEmitter = __webpack_require__(9),
        FileTypesManager = __webpack_require__(8),
        GameObjectCreator = __webpack_require__(16),
        GameObjectFactory = __webpack_require__(5),
        GetFastValue = __webpack_require__(2),
        PluginCache = __webpack_require__(24),
        Remove = __webpack_require__(93),
        PluginManager = new PluginManager({
      Extends: EventEmitter,
      initialize: function initialize(game) {
        EventEmitter.call(this), this.game = game, this.plugins = [], this.scenePlugins = [], this._pendingGlobal = [], this._pendingScene = [], game.isBooted ? this.boot() : game.events.once(GameEvents.BOOT, this.boot, this);
      },
      boot: function boot() {
        for (var entry, key, plugin, start, mapping, data, config = this.game.config, list = (list = config.installGlobalPlugins).concat(this._pendingGlobal), i = 0; i < list.length; i++) {
          entry = list[i], key = GetFastValue(entry, "key", null), plugin = GetFastValue(entry, "plugin", null), start = GetFastValue(entry, "start", !1), mapping = GetFastValue(entry, "mapping", null), data = GetFastValue(entry, "data", null), key && (plugin ? this.install(key, plugin, start, mapping, data) : console.warn("Missing `plugin` for key: " + key));
        }

        for (list = (list = config.installScenePlugins).concat(this._pendingScene), i = 0; i < list.length; i++) {
          entry = list[i], key = GetFastValue(entry, "key", null), plugin = GetFastValue(entry, "plugin", null), mapping = GetFastValue(entry, "mapping", null), key && (plugin ? this.installScenePlugin(key, plugin, mapping) : console.warn("Missing `plugin` for key: " + key));
        }

        this._pendingGlobal = [], this._pendingScene = [], this.game.events.once(GameEvents.DESTROY, this.destroy, this);
      },
      addToScene: function addToScene(sys, globalPlugins, scenePlugins) {
        for (var pluginList, game = this.game, scene = sys.scene, map = sys.settings.map, isBooted = sys.settings.isBooted, i = 0; i < globalPlugins.length; i++) {
          game[pluginKey = globalPlugins[i]] ? (sys[pluginKey] = game[pluginKey], map.hasOwnProperty(pluginKey) && (scene[map[pluginKey]] = sys[pluginKey])) : "game" === pluginKey && map.hasOwnProperty(pluginKey) && (scene[map[pluginKey]] = game);
        }

        for (var s = 0; s < scenePlugins.length; s++) {
          for (pluginList = scenePlugins[s], i = 0; i < pluginList.length; i++) {
            var source,
                mapKey,
                plugin,
                pluginKey = pluginList[i];
            PluginCache.hasCore(pluginKey) && (mapKey = (source = PluginCache.getCore(pluginKey)).mapping, plugin = new source.plugin(scene, this, mapKey), sys[mapKey] = plugin, source.custom ? scene[mapKey] = plugin : map.hasOwnProperty(mapKey) && (scene[map[mapKey]] = plugin), isBooted && plugin.boot());
          }
        }

        for (pluginList = this.plugins, i = 0; i < pluginList.length; i++) {
          var entry = pluginList[i];
          entry.mapping && (scene[entry.mapping] = entry.plugin);
        }
      },
      getDefaultScenePlugins: function getDefaultScenePlugins() {
        return this.game.config.defaultPlugins.concat(this.scenePlugins);
      },
      installScenePlugin: function installScenePlugin(key, instance, mapping, addToScene, fromLoader) {
        if (void 0 === fromLoader && (fromLoader = !1), "function" == typeof instance) {
          if (PluginCache.hasCore(key)) {
            if (!fromLoader && PluginCache.hasCore(key)) return void console.warn("Scene Plugin key in use: " + key);
          } else PluginCache.register(key, instance, mapping, !0), this.scenePlugins.push(key);

          addToScene && (instance = new instance(addToScene, this, key), addToScene.sys[key] = instance, mapping && "" !== mapping && (addToScene[mapping] = instance), instance.boot());
        } else console.warn("Invalid Scene Plugin: " + key);
      },
      install: function install(key, plugin, start, mapping, data) {
        if (void 0 === start && (start = !1), void 0 === mapping && (mapping = null), void 0 === data && (data = null), "function" != typeof plugin) return console.warn("Invalid Plugin: " + key), null;
        if (PluginCache.hasCustom(key)) return console.warn("Plugin key in use: " + key), null;

        if (null !== mapping && (start = !0), this.game.isBooted) {
          if (PluginCache.registerCustom(key, plugin, mapping, data), start) return this.start(key);
        } else this._pendingGlobal.push({
          key: key,
          plugin: plugin,
          start: start,
          mapping: mapping,
          data: data
        });

        return null;
      },
      getIndex: function getIndex(key) {
        for (var list = this.plugins, i = 0; i < list.length; i++) {
          if (list[i].key === key) return i;
        }

        return -1;
      },
      getEntry: function getEntry(idx) {
        idx = this.getIndex(idx);
        if (-1 !== idx) return this.plugins[idx];
      },
      isActive: function isActive(entry) {
        entry = this.getEntry(entry);
        return entry && entry.active;
      },
      start: function start(key, runAs) {
        var entry = this.getEntry(runAs = void 0 === runAs ? key : runAs);
        return entry && !entry.active ? (entry.active = !0, entry.plugin.start()) : entry = entry || this.createEntry(key, runAs), entry ? entry.plugin : null;
      },
      createEntry: function createEntry(entry, instance) {
        var entry = PluginCache.getCustom(entry);
        return entry && (entry = {
          key: instance,
          plugin: instance = new entry.plugin(this),
          active: !0,
          mapping: entry.mapping,
          data: entry.data
        }, this.plugins.push(entry), instance.init(entry.data), instance.start()), entry;
      },
      stop: function stop(entry) {
        entry = this.getEntry(entry);
        return entry && entry.active && (entry.active = !1, entry.plugin.stop()), this;
      },
      get: function get(key, autoStart) {
        void 0 === autoStart && (autoStart = !0);
        var entry = this.getEntry(key);
        if (entry) return entry.plugin;
        var plugin = this.getClass(key);
        return plugin && autoStart ? (entry = this.createEntry(key, key)) ? entry.plugin : null : plugin || null;
      },
      getClass: function getClass(key) {
        return PluginCache.getCustomClass(key);
      },
      removeGlobalPlugin: function removeGlobalPlugin(key) {
        var entry = this.getEntry(key);
        entry && Remove(this.plugins, entry), PluginCache.removeCustom(key);
      },
      removeScenePlugin: function removeScenePlugin(key) {
        Remove(this.scenePlugins, key), PluginCache.remove(key);
      },
      registerGameObject: function registerGameObject(key, factoryCallback, creatorCallback) {
        return factoryCallback && GameObjectFactory.register(key, factoryCallback), creatorCallback && GameObjectCreator.register(key, creatorCallback), this;
      },
      removeGameObject: function removeGameObject(key, removeFromFactory, removeFromCreator) {
        return void 0 === removeFromCreator && (removeFromCreator = !0), (removeFromFactory = void 0 === removeFromFactory ? !0 : removeFromFactory) && GameObjectFactory.remove(key), removeFromCreator && GameObjectCreator.remove(key), this;
      },
      registerFileType: function registerFileType(key, callback, addToScene) {
        FileTypesManager.register(key, callback), addToScene && addToScene.sys.load && (addToScene.sys.load[key] = callback);
      },
      destroy: function destroy() {
        for (var i = 0; i < this.plugins.length; i++) {
          this.plugins[i].plugin.destroy();
        }

        PluginCache.destroyCustomPlugins(), this.game.noReturn && PluginCache.destroyCorePlugins(), this.game = null, this.plugins = [], this.scenePlugins = [];
      }
    });

    module.exports = PluginManager;
  }, function (module, exports, __webpack_require__) {
    var CONST = __webpack_require__(201),
        ScaleManager = __webpack_require__(0),
        EventEmitter = __webpack_require__(9),
        Events = __webpack_require__(104),
        GameEvents = __webpack_require__(22),
        GetInnerHeight = __webpack_require__(401),
        GetTarget = __webpack_require__(407),
        GetScreenOrientation = __webpack_require__(402),
        NOOP = __webpack_require__(1),
        Rectangle = __webpack_require__(10),
        Size = __webpack_require__(416),
        SnapFloor = __webpack_require__(76),
        Vector2 = __webpack_require__(3),
        ScaleManager = new ScaleManager({
      Extends: EventEmitter,
      initialize: function initialize(game) {
        EventEmitter.call(this), this.game = game, this.canvas, this.canvasBounds = new Rectangle(), this.parent = null, this.parentIsWindow = !1, this.parentSize = new Size(), this.gameSize = new Size(), this.baseSize = new Size(), this.displaySize = new Size(), this.scaleMode = CONST.SCALE_MODE.NONE, this.zoom = 1, this._resetZoom = !1, this.displayScale = new Vector2(1, 1), this.autoRound = !1, this.autoCenter = CONST.CENTER.NO_CENTER, this.orientation = CONST.ORIENTATION.LANDSCAPE, this.fullscreen, this.fullscreenTarget = null, this._createdFullscreenTarget = !1, this.dirty = !1, this.resizeInterval = 500, this._lastCheck = 0, this._checkOrientation = !1, this.listeners = {
          orientationChange: NOOP,
          windowResize: NOOP,
          fullScreenChange: NOOP,
          fullScreenError: NOOP
        };
      },
      preBoot: function preBoot() {
        this.parseConfig(this.game.config), this.game.events.once(GameEvents.BOOT, this.boot, this);
      },
      boot: function boot() {
        var game = this.game;
        this.canvas = game.canvas, this.fullscreen = game.device.fullscreen, this.scaleMode !== CONST.SCALE_MODE.RESIZE && this.displaySize.setAspectMode(this.scaleMode), this.scaleMode === CONST.SCALE_MODE.NONE ? this.resize(this.width, this.height) : (this.getParentBounds(), 0 < this.parentSize.width && 0 < this.parentSize.height && this.displaySize.setParent(this.parentSize), this.refresh()), game.events.on(GameEvents.PRE_STEP, this.step, this), game.events.once(GameEvents.READY, this.refresh, this), game.events.once(GameEvents.DESTROY, this.destroy, this), this.startListeners();
      },
      parseConfig: function parseConfig(config) {
        this.getParent(config), this.getParentBounds();
        var parentHeight,
            parentScaleY,
            width = config.width,
            height = config.height,
            scaleMode = config.scaleMode,
            zoom = config.zoom,
            autoRound = config.autoRound;
        "string" == typeof width && (0 === (parentHeight = this.parentSize.width) && (parentHeight = window.innerWidth), parentScaleY = parseInt(width, 10) / 100, width = Math.floor(parentHeight * parentScaleY)), "string" == typeof height && (0 === (parentHeight = this.parentSize.height) && (parentHeight = window.innerHeight), parentScaleY = parseInt(height, 10) / 100, height = Math.floor(parentHeight * parentScaleY)), this.scaleMode = scaleMode, this.autoRound = autoRound, this.autoCenter = config.autoCenter, this.resizeInterval = config.resizeInterval, autoRound && (width = Math.floor(width), height = Math.floor(height)), this.gameSize.setSize(width, height), zoom === CONST.ZOOM.MAX_ZOOM && (zoom = this.getMaxZoom()), 1 !== (this.zoom = zoom) && (this._resetZoom = !0), this.baseSize.setSize(width, height), autoRound && (this.baseSize.width = Math.floor(this.baseSize.width), this.baseSize.height = Math.floor(this.baseSize.height)), 0 < config.minWidth && this.displaySize.setMin(config.minWidth * zoom, config.minHeight * zoom), 0 < config.maxWidth && this.displaySize.setMax(config.maxWidth * zoom, config.maxHeight * zoom), this.displaySize.setSize(width, height), this.orientation = GetScreenOrientation(width, height);
      },
      getParent: function getParent(config) {
        var DOMRect = config.parent;
        null !== DOMRect && (this.parent = GetTarget(DOMRect), this.parentIsWindow = this.parent === document.body, config.expandParent && config.scaleMode !== CONST.SCALE_MODE.NONE && (DOMRect = this.parent.getBoundingClientRect(), !this.parentIsWindow && 0 !== DOMRect.height || (document.documentElement.style.height = "100%", document.body.style.height = "100%", DOMRect = this.parent.getBoundingClientRect(), this.parentIsWindow || 0 !== DOMRect.height || (this.parent.style.overflow = "hidden", this.parent.style.width = "100%", this.parent.style.height = "100%"))), config.fullscreenTarget && !this.fullscreenTarget && (this.fullscreenTarget = GetTarget(config.fullscreenTarget)));
      },
      getParentBounds: function getParentBounds() {
        if (!this.parent) return !1;
        var parentSize = this.parentSize,
            newHeight = this.parent.getBoundingClientRect();
        this.parentIsWindow && this.game.device.os.iOS && (newHeight.height = GetInnerHeight(!0));
        var newWidth = newHeight.width,
            newHeight = newHeight.height;
        return (parentSize.width !== newWidth || parentSize.height !== newHeight) && (parentSize.setSize(newWidth, newHeight), !0);
      },
      lockOrientation: function lockOrientation(orientation) {
        var lock = screen.lockOrientation || screen.mozLockOrientation || screen.msLockOrientation;
        return !!lock && lock.call(screen, orientation);
      },
      setParentSize: function setParentSize(width, height) {
        return this.parentSize.setSize(width, height), this.refresh();
      },
      setGameSize: function setGameSize(width, height) {
        var autoRound = this.autoRound;
        autoRound && (width = Math.floor(width), height = Math.floor(height));
        var previousWidth = this.width,
            previousHeight = this.height;
        return this.gameSize.resize(width, height), this.baseSize.resize(width, height), autoRound && (this.baseSize.width = Math.floor(this.baseSize.width), this.baseSize.height = Math.floor(this.baseSize.height)), this.displaySize.setAspectRatio(width / height), this.canvas.width = this.baseSize.width, this.canvas.height = this.baseSize.height, this.refresh(previousWidth, previousHeight);
      },
      resize: function resize(width, height) {
        var styleHeight = this.zoom,
            autoRound = this.autoRound;
        autoRound && (width = Math.floor(width), height = Math.floor(height));
        var previousWidth = this.width,
            previousHeight = this.height;
        this.gameSize.resize(width, height), this.baseSize.resize(width, height), autoRound && (this.baseSize.width = Math.floor(this.baseSize.width), this.baseSize.height = Math.floor(this.baseSize.height)), this.displaySize.setSize(width * styleHeight, height * styleHeight), this.canvas.width = this.baseSize.width, this.canvas.height = this.baseSize.height;
        var style = this.canvas.style,
            styleWidth = width * styleHeight,
            styleHeight = height * styleHeight;
        return autoRound && (styleWidth = Math.floor(styleWidth), styleHeight = Math.floor(styleHeight)), styleWidth === width && styleHeight === height || (style.width = styleWidth + "px", style.height = styleHeight + "px"), this.refresh(previousWidth, previousHeight);
      },
      setZoom: function setZoom(value) {
        return this.zoom = value, this._resetZoom = !0, this.refresh();
      },
      setMaxZoom: function setMaxZoom() {
        return this.zoom = this.getMaxZoom(), this._resetZoom = !0, this.refresh();
      },
      refresh: function refresh(previousWidth, previousHeight) {
        void 0 === previousWidth && (previousWidth = this.width), void 0 === previousHeight && (previousHeight = this.height), this.updateScale(), this.updateBounds(), this.updateOrientation(), this.displayScale.set(this.baseSize.width / this.canvasBounds.width, this.baseSize.height / this.canvasBounds.height);
        var canvasStyle,
            domStyle = this.game.domContainer;
        return domStyle && (this.baseSize.setCSS(domStyle), canvasStyle = this.canvas.style, (domStyle = domStyle.style).transform = "scale(" + this.displaySize.width / this.baseSize.width + "," + this.displaySize.height / this.baseSize.height + ")", domStyle.marginLeft = canvasStyle.marginLeft, domStyle.marginTop = canvasStyle.marginTop), this.emit(Events.RESIZE, this.gameSize, this.baseSize, this.displaySize, previousWidth, previousHeight), this;
      },
      updateOrientation: function updateOrientation() {
        var newOrientation;
        this._checkOrientation && (this._checkOrientation = !1, (newOrientation = GetScreenOrientation(this.width, this.height)) !== this.orientation && (this.orientation = newOrientation, this.emit(Events.ORIENTATION_CHANGE, newOrientation)));
      },
      updateScale: function updateScale() {
        var styleWidth,
            styleHeight,
            style = this.canvas.style,
            width = this.gameSize.width,
            height = this.gameSize.height,
            zoom = this.zoom,
            autoRound = this.autoRound;
        this.scaleMode === CONST.SCALE_MODE.NONE ? (this.displaySize.setSize(width * zoom, height * zoom), styleWidth = this.displaySize.width, styleHeight = this.displaySize.height, autoRound && (styleWidth = Math.floor(styleWidth), styleHeight = Math.floor(styleHeight)), this._resetZoom && (style.width = styleWidth + "px", style.height = styleHeight + "px", this._resetZoom = !1)) : this.scaleMode === CONST.SCALE_MODE.RESIZE ? (this.displaySize.setSize(this.parentSize.width, this.parentSize.height), this.gameSize.setSize(this.displaySize.width, this.displaySize.height), this.baseSize.setSize(this.displaySize.width, this.displaySize.height), styleWidth = this.displaySize.width, styleHeight = this.displaySize.height, autoRound && (styleWidth = Math.floor(styleWidth), styleHeight = Math.floor(styleHeight)), this.canvas.width = styleWidth, this.canvas.height = styleHeight) : (this.displaySize.setSize(this.parentSize.width, this.parentSize.height), styleWidth = this.displaySize.width, styleHeight = this.displaySize.height, autoRound && (styleWidth = Math.floor(styleWidth), styleHeight = Math.floor(styleHeight)), style.width = styleWidth + "px", style.height = styleHeight + "px"), this.getParentBounds(), this.updateCenter();
      },
      getMaxZoom: function getMaxZoom() {
        var zoomH = SnapFloor(this.parentSize.width, this.gameSize.width, 0, !0),
            zoomV = SnapFloor(this.parentSize.height, this.gameSize.height, 0, !0);
        return Math.max(Math.min(zoomH, zoomV), 1);
      },
      updateCenter: function updateCenter() {
        var style,
            offsetX,
            offsetY,
            autoCenter = this.autoCenter;
        autoCenter !== CONST.CENTER.NO_CENTER && (style = (offsetX = this.canvas).style, offsetX = (offsetY = offsetX.getBoundingClientRect()).width, offsetY = offsetY.height, offsetX = Math.floor((this.parentSize.width - offsetX) / 2), offsetY = Math.floor((this.parentSize.height - offsetY) / 2), autoCenter === CONST.CENTER.CENTER_HORIZONTALLY ? offsetY = 0 : autoCenter === CONST.CENTER.CENTER_VERTICALLY && (offsetX = 0), style.marginLeft = offsetX + "px", style.marginTop = offsetY + "px");
      },
      updateBounds: function updateBounds() {
        var bounds = this.canvasBounds,
            clientRect = this.canvas.getBoundingClientRect();
        bounds.x = clientRect.left + (window.pageXOffset || 0) - (document.documentElement.clientLeft || 0), bounds.y = clientRect.top + (window.pageYOffset || 0) - (document.documentElement.clientTop || 0), bounds.width = clientRect.width, bounds.height = clientRect.height;
      },
      transformX: function transformX(pageX) {
        return (pageX - this.canvasBounds.left) * this.displayScale.x;
      },
      transformY: function transformY(pageY) {
        return (pageY - this.canvasBounds.top) * this.displayScale.y;
      },
      startFullscreen: function startFullscreen(fullscreenOptions) {
        void 0 === fullscreenOptions && (fullscreenOptions = {
          navigationUI: "hide"
        });
        var fsTarget,
            fullscreen = this.fullscreen;
        fullscreen.available ? fullscreen.active || (fsTarget = this.getFullscreenTarget(), fullscreen.keyboard ? fsTarget[fullscreen.request](Element.ALLOW_KEYBOARD_INPUT) : fsTarget[fullscreen.request](fullscreenOptions)) : this.emit(Events.FULLSCREEN_UNSUPPORTED);
      },
      fullscreenSuccessHandler: function fullscreenSuccessHandler() {
        this.getParentBounds(), this.refresh(), this.emit(Events.ENTER_FULLSCREEN);
      },
      fullscreenErrorHandler: function fullscreenErrorHandler(error) {
        this.removeFullscreenTarget(), this.emit(Events.FULLSCREEN_FAILED, error);
      },
      getFullscreenTarget: function getFullscreenTarget() {
        var fsTarget;
        return this.fullscreenTarget || ((fsTarget = document.createElement("div")).style.margin = "0", fsTarget.style.padding = "0", fsTarget.style.width = "100%", fsTarget.style.height = "100%", this.fullscreenTarget = fsTarget, this._createdFullscreenTarget = !0), this._createdFullscreenTarget && (this.canvas.parentNode.insertBefore(this.fullscreenTarget, this.canvas), this.fullscreenTarget.appendChild(this.canvas)), this.fullscreenTarget;
      },
      removeFullscreenTarget: function removeFullscreenTarget() {
        var fsTarget, parent;
        !this._createdFullscreenTarget || (fsTarget = this.fullscreenTarget) && fsTarget.parentNode && ((parent = fsTarget.parentNode).insertBefore(this.canvas, fsTarget), parent.removeChild(fsTarget));
      },
      stopFullscreen: function stopFullscreen() {
        var fullscreen = this.fullscreen;
        if (!fullscreen.available) return this.emit(Events.FULLSCREEN_UNSUPPORTED), !1;
        fullscreen.active && document[fullscreen.cancel](), this.removeFullscreenTarget(), this.getParentBounds(), this.emit(Events.LEAVE_FULLSCREEN), this.refresh();
      },
      toggleFullscreen: function toggleFullscreen(fullscreenOptions) {
        this.fullscreen.active ? this.stopFullscreen() : this.startFullscreen(fullscreenOptions);
      },
      startListeners: function startListeners() {
        var _this = this,
            listeners = this.listeners;

        listeners.orientationChange = function () {
          _this.updateBounds(), _this._checkOrientation = !0, _this.dirty = !0;
        }, listeners.windowResize = function () {
          _this.updateBounds(), _this.dirty = !0;
        }, window.addEventListener("orientationchange", listeners.orientationChange, !1), window.addEventListener("resize", listeners.windowResize, !1), this.fullscreen.available && (listeners.fullScreenChange = function (event) {
          return _this.onFullScreenChange(event);
        }, listeners.fullScreenError = function (event) {
          return _this.onFullScreenError(event);
        }, ["webkit", "moz", ""].forEach(function (prefix) {
          document.addEventListener(prefix + "fullscreenchange", listeners.fullScreenChange, !1), document.addEventListener(prefix + "fullscreenerror", listeners.fullScreenError, !1);
        }), document.addEventListener("MSFullscreenChange", listeners.fullScreenChange, !1), document.addEventListener("MSFullscreenError", listeners.fullScreenError, !1));
      },
      onFullScreenChange: function onFullScreenChange() {
        document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement || document.mozFullScreenElement ? this.fullscreenSuccessHandler() : this.stopFullscreen();
      },
      onFullScreenError: function onFullScreenError() {
        this.removeFullscreenTarget();
      },
      step: function step(time, delta) {
        this.parent && (this._lastCheck += delta, (this.dirty || this._lastCheck > this.resizeInterval) && (this.getParentBounds() && this.refresh(), this.dirty = !1, this._lastCheck = 0));
      },
      stopListeners: function stopListeners() {
        var listeners = this.listeners;
        window.removeEventListener("orientationchange", listeners.orientationChange, !1), window.removeEventListener("resize", listeners.windowResize, !1);
        ["webkit", "moz", ""].forEach(function (prefix) {
          document.removeEventListener(prefix + "fullscreenchange", listeners.fullScreenChange, !1), document.removeEventListener(prefix + "fullscreenerror", listeners.fullScreenError, !1);
        }), document.removeEventListener("MSFullscreenChange", listeners.fullScreenChange, !1), document.removeEventListener("MSFullscreenError", listeners.fullScreenError, !1);
      },
      destroy: function destroy() {
        this.removeAllListeners(), this.stopListeners(), this.game = null, this.canvas = null, this.canvasBounds = null, this.parent = null, this.fullscreenTarget = null, this.parentSize.destroy(), this.gameSize.destroy(), this.baseSize.destroy(), this.displaySize.destroy();
      },
      isFullscreen: {
        get: function get() {
          return this.fullscreen.active;
        }
      },
      width: {
        get: function get() {
          return this.gameSize.width;
        }
      },
      height: {
        get: function get() {
          return this.gameSize.height;
        }
      },
      isPortrait: {
        get: function get() {
          return this.orientation === CONST.ORIENTATION.PORTRAIT;
        }
      },
      isLandscape: {
        get: function get() {
          return this.orientation === CONST.ORIENTATION.LANDSCAPE;
        }
      },
      isGamePortrait: {
        get: function get() {
          return this.height > this.width;
        }
      },
      isGameLandscape: {
        get: function get() {
          return this.width > this.height;
        }
      }
    });

    module.exports = ScaleManager;
  }, function (module, exports, __webpack_require__) {
    var Clamp = __webpack_require__(18),
        Class = __webpack_require__(0),
        SnapFloor = __webpack_require__(76),
        Vector2 = __webpack_require__(3),
        Size = new Class({
      initialize: function initialize(width, height, aspectMode, parent) {
        void 0 === width && (width = 0), void 0 === height && (height = width), void 0 === aspectMode && (aspectMode = 0), void 0 === parent && (parent = null), this._width = width, this._height = height, this._parent = parent, this.aspectMode = aspectMode, this.aspectRatio = 0 === height ? 1 : width / height, this.minWidth = 0, this.minHeight = 0, this.maxWidth = Number.MAX_VALUE, this.maxHeight = Number.MAX_VALUE, this.snapTo = new Vector2();
      },
      setAspectMode: function setAspectMode(value) {
        return this.aspectMode = value = void 0 === value ? 0 : value, this.setSize(this._width, this._height);
      },
      setSnap: function setSnap(snapWidth, snapHeight) {
        return void 0 === snapWidth && (snapWidth = 0), void 0 === snapHeight && (snapHeight = snapWidth), this.snapTo.set(snapWidth, snapHeight), this.setSize(this._width, this._height);
      },
      setParent: function setParent(parent) {
        return this._parent = parent, this.setSize(this._width, this._height);
      },
      setMin: function setMin(width, height) {
        return void 0 === width && (width = 0), void 0 === height && (height = width), this.minWidth = Clamp(width, 0, this.maxWidth), this.minHeight = Clamp(height, 0, this.maxHeight), this.setSize(this._width, this._height);
      },
      setMax: function setMax(width, height) {
        return void 0 === width && (width = Number.MAX_VALUE), void 0 === height && (height = width), this.maxWidth = Clamp(width, this.minWidth, Number.MAX_VALUE), this.maxHeight = Clamp(height, this.minHeight, Number.MAX_VALUE), this.setSize(this._width, this._height);
      },
      setSize: function setSize(width, height) {
        switch (void 0 === width && (width = 0), void 0 === height && (height = width), this.aspectMode) {
          case Size.NONE:
            this._width = this.getNewWidth(SnapFloor(width, this.snapTo.x)), this._height = this.getNewHeight(SnapFloor(height, this.snapTo.y)), this.aspectRatio = 0 === this._height ? 1 : this._width / this._height;
            break;

          case Size.WIDTH_CONTROLS_HEIGHT:
            this._width = this.getNewWidth(SnapFloor(width, this.snapTo.x)), this._height = this.getNewHeight(this._width * (1 / this.aspectRatio), !1);
            break;

          case Size.HEIGHT_CONTROLS_WIDTH:
            this._height = this.getNewHeight(SnapFloor(height, this.snapTo.y)), this._width = this.getNewWidth(this._height * this.aspectRatio, !1);
            break;

          case Size.FIT:
            this.constrain(width, height, !0);
            break;

          case Size.ENVELOP:
            this.constrain(width, height, !1);
        }

        return this;
      },
      setAspectRatio: function setAspectRatio(ratio) {
        return this.aspectRatio = ratio, this.setSize(this._width, this._height);
      },
      resize: function resize(width, height) {
        return this._width = this.getNewWidth(SnapFloor(width, this.snapTo.x)), this._height = this.getNewHeight(SnapFloor(height, this.snapTo.y)), this.aspectRatio = 0 === this._height ? 1 : this._width / this._height, this;
      },
      getNewWidth: function getNewWidth(value, checkParent) {
        return void 0 === checkParent && (checkParent = !0), value = Clamp(value, this.minWidth, this.maxWidth), value = checkParent && this._parent && value > this._parent.width ? Math.max(this.minWidth, this._parent.width) : value;
      },
      getNewHeight: function getNewHeight(value, checkParent) {
        return void 0 === checkParent && (checkParent = !0), value = Clamp(value, this.minHeight, this.maxHeight), value = checkParent && this._parent && value > this._parent.height ? Math.max(this.minHeight, this._parent.height) : value;
      },
      constrain: function constrain(width, height, fit) {
        void 0 === width && (width = 0), void 0 === height && (height = width), void 0 === fit && (fit = !0), width = this.getNewWidth(width), height = this.getNewHeight(height);
        var snap = this.snapTo,
            newRatio = 0 === height ? 1 : width / height;
        return fit && this.aspectRatio > newRatio || !fit && this.aspectRatio < newRatio ? (height = (width = SnapFloor(width, snap.x)) / this.aspectRatio, 0 < snap.y && (width = (height = SnapFloor(height, snap.y)) * this.aspectRatio)) : (fit && this.aspectRatio < newRatio || !fit && this.aspectRatio > newRatio) && (width = (height = SnapFloor(height, snap.y)) * this.aspectRatio, 0 < snap.x && (height = (width = SnapFloor(width, snap.x)) * (1 / this.aspectRatio))), this._width = width, this._height = height, this;
      },
      fitTo: function fitTo(width, height) {
        return this.constrain(width, height, !0);
      },
      envelop: function envelop(width, height) {
        return this.constrain(width, height, !1);
      },
      setWidth: function setWidth(value) {
        return this.setSize(value, this._height);
      },
      setHeight: function setHeight(value) {
        return this.setSize(this._width, value);
      },
      toString: function toString() {
        return "[{ Size (width=" + this._width + " height=" + this._height + " aspectRatio=" + this.aspectRatio + " aspectMode=" + this.aspectMode + ") }]";
      },
      setCSS: function setCSS(element) {
        element && element.style && (element.style.width = this._width + "px", element.style.height = this._height + "px");
      },
      copy: function copy(destination) {
        return destination.setAspectMode(this.aspectMode), destination.aspectRatio = this.aspectRatio, destination.setSize(this.width, this.height);
      },
      destroy: function destroy() {
        this._parent = null, this.snapTo = null;
      },
      width: {
        get: function get() {
          return this._width;
        },
        set: function set(value) {
          this.setSize(value, this._height);
        }
      },
      height: {
        get: function get() {
          return this._height;
        },
        set: function set(value) {
          this.setSize(this._width, value);
        }
      }
    });

    Size.NONE = 0, Size.WIDTH_CONTROLS_HEIGHT = 1, Size.HEIGHT_CONTROLS_WIDTH = 2, Size.FIT = 3, Size.ENVELOP = 4, module.exports = Size;
  }, function (module, exports, __webpack_require__) {
    var SceneManager = __webpack_require__(0),
        CONST = __webpack_require__(144),
        Events = __webpack_require__(20),
        GameEvents = __webpack_require__(22),
        GetValue = __webpack_require__(6),
        LoaderEvents = __webpack_require__(95),
        NOOP = __webpack_require__(1),
        Scene = __webpack_require__(418),
        Systems = __webpack_require__(204),
        SceneManager = new SceneManager({
      initialize: function initialize(game, sceneConfig) {
        if (this.game = game, this.keys = {}, this.scenes = [], this._pending = [], this._start = [], this._queue = [], this._data = {}, this.isProcessing = !1, this.isBooted = !1, this.customViewports = 0, sceneConfig) {
          Array.isArray(sceneConfig) || (sceneConfig = [sceneConfig]);

          for (var i = 0; i < sceneConfig.length; i++) {
            this._pending.push({
              key: "default",
              scene: sceneConfig[i],
              autoStart: 0 === i,
              data: {}
            });
          }
        }

        game.events.once(GameEvents.READY, this.bootQueue, this);
      },
      bootQueue: function bootQueue() {
        if (!this.isBooted) {
          for (var i = 0; i < this._pending.length; i++) {
            var newScene,
                entry,
                sceneConfig,
                key = (entry = this._pending[i]).key;
            (sceneConfig = entry.scene) instanceof Scene ? newScene = this.createSceneFromInstance(key, sceneConfig) : "object" == _typeof(sceneConfig) ? newScene = this.createSceneFromObject(key, sceneConfig) : "function" == typeof sceneConfig && (newScene = this.createSceneFromFunction(key, sceneConfig)), key = newScene.sys.settings.key, this.keys[key] = newScene, this.scenes.push(newScene), this._data[key] && (newScene.sys.settings.data = this._data[key].data, this._data[key].autoStart && (entry.autoStart = !0)), (entry.autoStart || newScene.sys.settings.active) && this._start.push(key);
          }

          for (this._pending.length = 0, this._data = {}, this.isBooted = !0, i = 0; i < this._start.length; i++) {
            entry = this._start[i], this.start(entry);
          }

          this._start.length = 0;
        }
      },
      processQueue: function processQueue() {
        var i,
            entry,
            pendingLength = this._pending.length,
            queueLength = this._queue.length;

        if (0 !== pendingLength || 0 !== queueLength) {
          if (pendingLength) {
            for (i = 0; i < pendingLength; i++) {
              entry = this._pending[i], this.add(entry.key, entry.scene, entry.autoStart, entry.data);
            }

            for (i = 0; i < this._start.length; i++) {
              entry = this._start[i], this.start(entry);
            }

            return this._start.length = 0, void (this._pending.length = 0);
          }

          for (i = 0; i < this._queue.length; i++) {
            this[(entry = this._queue[i]).op](entry.keyA, entry.keyB);
          }

          this._queue.length = 0;
        }
      },
      add: function add(key, sceneConfig, autoStart, data) {
        return void 0 === autoStart && (autoStart = !1), void 0 === data && (data = {}), this.isProcessing || !this.isBooted ? (this._pending.push({
          key: key,
          scene: sceneConfig,
          autoStart: autoStart,
          data: data
        }), this.isBooted || (this._data[key] = {
          data: data
        }), null) : (key = this.getKey(key, sceneConfig), sceneConfig instanceof Scene ? newScene = this.createSceneFromInstance(key, sceneConfig) : "object" == _typeof(sceneConfig) ? (sceneConfig.key = key, newScene = this.createSceneFromObject(key, sceneConfig)) : "function" == typeof sceneConfig && (newScene = this.createSceneFromFunction(key, sceneConfig)), newScene.sys.settings.data = data, key = newScene.sys.settings.key, this.keys[key] = newScene, this.scenes.push(newScene), (autoStart || newScene.sys.settings.active) && (this._pending.length ? this._start.push(key) : this.start(key)), newScene);
        var newScene;
      },
      remove: function remove(sceneKey) {
        if (this.isProcessing) this._queue.push({
          op: "remove",
          keyA: sceneKey,
          keyB: null
        });else {
          var sceneToRemove = this.getScene(sceneKey);
          if (!sceneToRemove || sceneToRemove.sys.isTransitioning()) return this;
          var index = this.scenes.indexOf(sceneToRemove),
              sceneKey = sceneToRemove.sys.settings.key;
          -1 < index && (delete this.keys[sceneKey], this.scenes.splice(index, 1), -1 < this._start.indexOf(sceneKey) && (index = this._start.indexOf(sceneKey), this._start.splice(index, 1)), sceneToRemove.sys.destroy());
        }
        return this;
      },
      bootScene: function bootScene(scene) {
        var loader,
            sys = scene.sys,
            settings = sys.settings;
        sys.sceneUpdate = NOOP, scene.init && (scene.init.call(scene, settings.data), settings.status = CONST.INIT, settings.isTransition && sys.events.emit(Events.TRANSITION_INIT, settings.transitionFrom, settings.transitionDuration)), sys.load && (loader = sys.load).reset(), loader && scene.preload ? (scene.preload.call(scene), 0 === loader.list.size ? this.create(scene) : (settings.status = CONST.LOADING, loader.once(LoaderEvents.COMPLETE, this.loadComplete, this), loader.start())) : this.create(scene);
      },
      loadComplete: function loadComplete(loader) {
        this.create(loader.scene);
      },
      payloadComplete: function payloadComplete(loader) {
        this.bootScene(loader.scene);
      },
      update: function update(time, delta) {
        this.processQueue(), this.isProcessing = !0;

        for (var i = this.scenes.length - 1; 0 <= i; i--) {
          var sys = this.scenes[i].sys;
          sys.settings.status > CONST.START && sys.settings.status <= CONST.RUNNING && sys.step(time, delta);
        }
      },
      render: function render(renderer) {
        for (var i = 0; i < this.scenes.length; i++) {
          var sys = this.scenes[i].sys;
          sys.settings.visible && sys.settings.status >= CONST.LOADING && sys.settings.status < CONST.SLEEPING && sys.render(renderer);
        }

        this.isProcessing = !1;
      },
      create: function create(scene) {
        var sys = scene.sys,
            settings = sys.settings;
        scene.create && (settings.status = CONST.CREATING, scene.create.call(scene, settings.data), settings.status === CONST.DESTROYED) || (settings.isTransition && sys.events.emit(Events.TRANSITION_START, settings.transitionFrom, settings.transitionDuration), scene.update && (sys.sceneUpdate = scene.update), settings.status = CONST.RUNNING, sys.events.emit(Events.CREATE, scene));
      },
      createSceneFromFunction: function createSceneFromFunction(key, configKey) {
        var newScene = new configKey();

        if (newScene instanceof Scene) {
          configKey = newScene.sys.settings.key;
          if (this.keys.hasOwnProperty(key = "" !== configKey ? configKey : key)) throw new Error("Cannot add a Scene with duplicate key: " + key);
          return this.createSceneFromInstance(key, newScene);
        }

        return newScene.sys = new Systems(newScene), newScene.sys.settings.key = key, newScene.sys.init(this.game), newScene;
      },
      createSceneFromInstance: function createSceneFromInstance(key, newScene) {
        return "" === newScene.sys.settings.key && (newScene.sys.settings.key = key), newScene.sys.init(this.game), newScene;
      },
      createSceneFromObject: function createSceneFromObject(key, sceneConfig) {
        var newScene = new Scene(sceneConfig),
            configKey = newScene.sys.settings.key;
        "" !== configKey ? key = configKey : newScene.sys.settings.key = key, newScene.sys.init(this.game);

        for (var value, defaults = ["init", "preload", "create", "update", "render"], i = 0; i < defaults.length; i++) {
          var sceneCallback = GetValue(sceneConfig, defaults[i], null);
          sceneCallback && (newScene[defaults[i]] = sceneCallback);
        }

        if (sceneConfig.hasOwnProperty("extend")) for (var propertyKey in sceneConfig.extend) {
          sceneConfig.extend.hasOwnProperty(propertyKey) && (value = sceneConfig.extend[propertyKey], "data" === propertyKey && newScene.hasOwnProperty("data") && "object" == _typeof(value) ? newScene.data.merge(value) : "sys" !== propertyKey && (newScene[propertyKey] = value));
        }
        return newScene;
      },
      getKey: function getKey(key, sceneConfig) {
        if (key = key || "default", "function" == typeof sceneConfig) return key;
        if (sceneConfig instanceof Scene ? key = sceneConfig.sys.settings.key : "object" == _typeof(sceneConfig) && sceneConfig.hasOwnProperty("key") && (key = sceneConfig.key), this.keys.hasOwnProperty(key)) throw new Error("Cannot add a Scene with duplicate key: " + key);
        return key;
      },
      getScenes: function getScenes(isActive, inReverse) {
        void 0 === isActive && (isActive = !0), void 0 === inReverse && (inReverse = !1);

        for (var out = [], scenes = this.scenes, i = 0; i < scenes.length; i++) {
          var scene = scenes[i];
          !scene || isActive && !scene.sys.isActive() || out.push(scene);
        }

        return inReverse ? out.reverse() : out;
      },
      getScene: function getScene(key) {
        if ("string" == typeof key) {
          if (this.keys[key]) return this.keys[key];
        } else for (var i = 0; i < this.scenes.length; i++) {
          if (key === this.scenes[i]) return key;
        }

        return null;
      },
      isActive: function isActive(scene) {
        scene = this.getScene(scene);
        return scene ? scene.sys.isActive() : null;
      },
      isPaused: function isPaused(scene) {
        scene = this.getScene(scene);
        return scene ? scene.sys.isPaused() : null;
      },
      isVisible: function isVisible(scene) {
        scene = this.getScene(scene);
        return scene ? scene.sys.isVisible() : null;
      },
      isSleeping: function isSleeping(scene) {
        scene = this.getScene(scene);
        return scene ? scene.sys.isSleeping() : null;
      },
      pause: function pause(scene, data) {
        scene = this.getScene(scene);
        return scene && scene.sys.pause(data), this;
      },
      resume: function resume(scene, data) {
        scene = this.getScene(scene);
        return scene && scene.sys.resume(data), this;
      },
      sleep: function sleep(scene, data) {
        scene = this.getScene(scene);
        return scene && !scene.sys.isTransitioning() && scene.sys.sleep(data), this;
      },
      wake: function wake(scene, data) {
        scene = this.getScene(scene);
        return scene && scene.sys.wake(data), this;
      },
      run: function run(key, data) {
        var scene = this.getScene(key);

        if (!scene) {
          for (var i = 0; i < this._pending.length; i++) {
            if (this._pending[i].key === key) {
              this.queueOp("start", key, data);
              break;
            }
          }

          return this;
        }

        scene.sys.isSleeping() ? scene.sys.wake(data) : scene.sys.isPaused() ? scene.sys.resume(data) : this.start(key, data);
      },
      start: function start(sys, data) {
        if (!this.isBooted) return this._data[sys] = {
          autoStart: !0,
          data: data
        }, this;
        var scene = this.getScene(sys);

        if (scene) {
          var loader,
              sys = scene.sys;
          if (sys.isActive() || sys.isPaused()) sys.shutdown(), sys.sceneUpdate = NOOP, sys.start(data);else if (sys.sceneUpdate = NOOP, sys.start(data), (loader = sys.load ? sys.load : loader) && sys.settings.hasOwnProperty("pack") && (loader.reset(), loader.addPack({
            payload: sys.settings.pack
          }))) return sys.settings.status = CONST.LOADING, loader.once(LoaderEvents.COMPLETE, this.payloadComplete, this), loader.start(), this;
          this.bootScene(scene);
        }

        return this;
      },
      stop: function stop(scene, data) {
        scene = this.getScene(scene);
        return scene && !scene.sys.isTransitioning() && scene.sys.shutdown(data), this;
      },
      switch: function _switch(from, to) {
        var sceneA = this.getScene(from),
            sceneB = this.getScene(to);
        return sceneA && sceneB && sceneA !== sceneB && (this.sleep(from), this.isSleeping(to) ? this.wake(to) : this.start(to)), this;
      },
      getAt: function getAt(index) {
        return this.scenes[index];
      },
      getIndex: function getIndex(scene) {
        scene = this.getScene(scene);
        return this.scenes.indexOf(scene);
      },
      bringToTop: function bringToTop(scene) {
        var index;
        return this.isProcessing ? this._queue.push({
          op: "bringToTop",
          keyA: scene,
          keyB: null
        }) : -1 !== (index = this.getIndex(scene)) && index < this.scenes.length && (scene = this.getScene(scene), this.scenes.splice(index, 1), this.scenes.push(scene)), this;
      },
      sendToBack: function sendToBack(scene) {
        var index;
        return this.isProcessing ? this._queue.push({
          op: "sendToBack",
          keyA: scene,
          keyB: null
        }) : -1 !== (index = this.getIndex(scene)) && 0 < index && (scene = this.getScene(scene), this.scenes.splice(index, 1), this.scenes.unshift(scene)), this;
      },
      moveDown: function moveDown(sceneB) {
        var indexA, indexB, sceneA;
        return this.isProcessing ? this._queue.push({
          op: "moveDown",
          keyA: sceneB,
          keyB: null
        }) : 0 < (indexA = this.getIndex(sceneB)) && (indexB = indexA - 1, sceneA = this.getScene(sceneB), sceneB = this.getAt(indexB), this.scenes[indexA] = sceneB, this.scenes[indexB] = sceneA), this;
      },
      moveUp: function moveUp(sceneB) {
        var indexA, indexB, sceneA;
        return this.isProcessing ? this._queue.push({
          op: "moveUp",
          keyA: sceneB,
          keyB: null
        }) : (indexA = this.getIndex(sceneB)) < this.scenes.length - 1 && (indexB = indexA + 1, sceneA = this.getScene(sceneB), sceneB = this.getAt(indexB), this.scenes[indexA] = sceneB, this.scenes[indexB] = sceneA), this;
      },
      moveAbove: function moveAbove(indexB, tempScene) {
        return indexB === tempScene || (this.isProcessing ? this._queue.push({
          op: "moveAbove",
          keyA: indexB,
          keyB: tempScene
        }) : (indexA = this.getIndex(indexB), indexB = this.getIndex(tempScene), -1 !== indexA && -1 !== indexB && (tempScene = this.getAt(indexB), this.scenes.splice(indexB, 1), this.scenes.splice(indexA + 1, 0, tempScene)))), this;
        var indexA;
      },
      moveBelow: function moveBelow(indexB, tempScene) {
        return indexB === tempScene || (this.isProcessing ? this._queue.push({
          op: "moveBelow",
          keyA: indexB,
          keyB: tempScene
        }) : (indexA = this.getIndex(indexB), indexB = this.getIndex(tempScene), -1 !== indexA && -1 !== indexB && (tempScene = this.getAt(indexB), this.scenes.splice(indexB, 1), 0 === indexA ? this.scenes.unshift(tempScene) : this.scenes.splice(indexA, 0, tempScene)))), this;
        var indexA;
      },
      queueOp: function queueOp(op, keyA, keyB) {
        return this._queue.push({
          op: op,
          keyA: keyA,
          keyB: keyB
        }), this;
      },
      swapPosition: function swapPosition(indexB, tempScene) {
        return indexB === tempScene || (this.isProcessing ? this._queue.push({
          op: "swapPosition",
          keyA: indexB,
          keyB: tempScene
        }) : (indexA = this.getIndex(indexB)) !== (indexB = this.getIndex(tempScene)) && -1 !== indexA && -1 !== indexB && (tempScene = this.getAt(indexA), this.scenes[indexA] = this.scenes[indexB], this.scenes[indexB] = tempScene)), this;
        var indexA;
      },
      dump: function dump() {
        for (var out = [], map = ["pending", "init", "start", "loading", "creating", "running", "paused", "sleeping", "shutdown", "destroyed"], i = 0; i < this.scenes.length; i++) {
          var sys = this.scenes[i].sys,
              key = !sys.settings.visible || sys.settings.status !== CONST.RUNNING && sys.settings.status !== CONST.PAUSED ? "[-] " : "[*] ";
          key += sys.settings.key + " (" + map[sys.settings.status] + ")", out.push(key);
        }

        console.log(out.join("\n"));
      },
      destroy: function destroy() {
        for (var i = 0; i < this.scenes.length; i++) {
          this.scenes[i].sys.destroy();
        }

        this.update = NOOP, this.scenes = [], this._pending = [], this._start = [], this._queue = [], this.game = null;
      }
    });

    module.exports = SceneManager;
  }, function (module, exports, __webpack_require__) {
    var Scene = __webpack_require__(0),
        Systems = __webpack_require__(204),
        Scene = new Scene({
      initialize: function initialize(config) {
        this.sys = new Systems(this, config), this.game, this.anims, this.cache, this.registry, this.sound, this.textures, this.events, this.cameras, this.add, this.make, this.scene, this.children, this.lights, this.data, this.input, this.load, this.time, this.tweens, this.physics, this.matter, this.scale, this.plugins, this.renderer;
      },
      update: function update() {}
    });

    module.exports = Scene;
  }, function (module, exports, __webpack_require__) {
    var GetFastValue = __webpack_require__(2),
        UppercaseFirst = __webpack_require__(205);

    module.exports = function (sceneSystems) {
      var defaultSystem = sceneSystems.game.config.defaultPhysicsSystem,
          sceneSystems = GetFastValue(sceneSystems.settings, "physics", !1);

      if (defaultSystem || sceneSystems) {
        var output = [];
        if (defaultSystem && output.push(UppercaseFirst(defaultSystem + "Physics")), sceneSystems) for (var key in sceneSystems) {
          key = UppercaseFirst(key.concat("Physics")), -1 === output.indexOf(key) && output.push(key);
        }
        return output;
      }
    };
  }, function (module, exports, __webpack_require__) {
    var GetFastValue = __webpack_require__(2);

    module.exports = function (scenePlugins) {
      var defaultPlugins = scenePlugins.plugins.getDefaultScenePlugins(),
          scenePlugins = GetFastValue(scenePlugins.settings, "plugins", !1);
      return Array.isArray(scenePlugins) ? scenePlugins : defaultPlugins || [];
    };
  }, function (module, exports, __webpack_require__) {
    var CONST = __webpack_require__(144),
        GetValue = __webpack_require__(6),
        Merge = __webpack_require__(127),
        InjectionMap = __webpack_require__(978);

    module.exports = {
      create: function create(config) {
        return "string" == typeof config ? config = {
          key: config
        } : void 0 === config && (config = {}), {
          status: CONST.PENDING,
          key: GetValue(config, "key", ""),
          active: GetValue(config, "active", !1),
          visible: GetValue(config, "visible", !0),
          isBooted: !1,
          isTransition: !1,
          transitionFrom: null,
          transitionDuration: 0,
          transitionAllowInput: !0,
          data: {},
          pack: GetValue(config, "pack", !1),
          cameras: GetValue(config, "cameras", null),
          map: GetValue(config, "map", Merge(InjectionMap, GetValue(config, "mapAdd", {}))),
          physics: GetValue(config, "physics", {}),
          loader: GetValue(config, "loader", {}),
          plugins: GetValue(config, "plugins", !1),
          input: GetValue(config, "input", {})
        };
      }
    };
  }, function (module, exports, __webpack_require__) {
    var CanvasPool = __webpack_require__(31),
        CanvasTexture = __webpack_require__(423),
        TextureManager = __webpack_require__(0),
        Color = __webpack_require__(38),
        CONST = __webpack_require__(33),
        EventEmitter = __webpack_require__(9),
        Events = __webpack_require__(106),
        GameEvents = __webpack_require__(22),
        GenerateTexture = __webpack_require__(388),
        GetValue = __webpack_require__(6),
        Parser = __webpack_require__(425),
        Texture = __webpack_require__(206),
        TextureManager = new TextureManager({
      Extends: EventEmitter,
      initialize: function initialize(game) {
        EventEmitter.call(this), this.game = game, this.name = "TextureManager", this.list = {}, this._tempCanvas = CanvasPool.create2D(this, 1, 1), this._tempContext = this._tempCanvas.getContext("2d"), this._pending = 0, game.events.once(GameEvents.BOOT, this.boot, this);
      },
      boot: function boot() {
        this._pending = 3, this.on(Events.LOAD, this.updatePending, this), this.on(Events.ERROR, this.updatePending, this);
        var config = this.game.config;
        this.addBase64("__DEFAULT", config.defaultImage), this.addBase64("__MISSING", config.missingImage), this.addBase64("__WHITE", config.whiteImage), this.game.events.once(GameEvents.DESTROY, this.destroy, this);
      },
      updatePending: function updatePending() {
        this._pending--, 0 === this._pending && (this.off(Events.LOAD), this.off(Events.ERROR), this.emit(Events.READY));
      },
      checkKey: function checkKey(key) {
        return !this.exists(key) || (console.error("Texture key already in use: " + key), !1);
      },
      remove: function remove(key) {
        if ("string" == typeof key) {
          if (!this.exists(key)) return console.warn("No texture found matching key: " + key), this;
          key = this.get(key);
        }

        return this.list.hasOwnProperty(key.key) && (key.destroy(), this.emit(Events.REMOVE, key.key)), this;
      },
      removeKey: function removeKey(key) {
        return this.list.hasOwnProperty(key) && delete this.list[key], this;
      },
      addBase64: function addBase64(key, data) {
        var _this, image;

        return this.checkKey(key) && (_this = this, (image = new Image()).onerror = function () {
          _this.emit(Events.ERROR, key);
        }, image.onload = function () {
          var texture = _this.create(key, image);

          Parser.Image(texture, 0), _this.emit(Events.ADD, key, texture), _this.emit(Events.LOAD, key, texture);
        }, image.src = data), this;
      },
      getBase64: function getBase64(cd, canvas, type, encoderOptions) {
        void 0 === type && (type = "image/png"), void 0 === encoderOptions && (encoderOptions = .92);
        var data = "",
            textureFrame = this.getFrame(cd, canvas);
        return textureFrame && (textureFrame.source.isRenderTexture || textureFrame.source.isGLTexture) ? console.warn("Cannot getBase64 from WebGL Texture") : textureFrame && (cd = textureFrame.canvasData, (canvas = CanvasPool.create2D(this, cd.width, cd.height)).getContext("2d").drawImage(textureFrame.source.image, cd.x, cd.y, cd.width, cd.height, 0, 0, cd.width, cd.height), data = canvas.toDataURL(type, encoderOptions), CanvasPool.remove(canvas)), data;
      },
      addImage: function addImage(key, source, dataSource) {
        var texture = null;
        return this.checkKey(key) && (texture = this.create(key, source), Parser.Image(texture, 0), dataSource && texture.setDataSource(dataSource), this.emit(Events.ADD, key, texture)), texture;
      },
      addGLTexture: function addGLTexture(key, glTexture, width, height) {
        var texture = null;
        return this.checkKey(key) && (void 0 === width && (width = glTexture.width), void 0 === height && (height = glTexture.height), (texture = this.create(key, glTexture, width, height)).add("__BASE", 0, 0, 0, width, height), this.emit(Events.ADD, key, texture)), texture;
      },
      addRenderTexture: function addRenderTexture(key, renderTexture) {
        var texture = null;
        return this.checkKey(key) && ((texture = this.create(key, renderTexture)).add("__BASE", 0, 0, 0, renderTexture.width, renderTexture.height), this.emit(Events.ADD, key, texture)), texture;
      },
      generate: function generate(key, config) {
        if (this.checkKey(key)) {
          var canvas = CanvasPool.create(this, 1, 1);
          return config.canvas = canvas, GenerateTexture(config), this.addCanvas(key, canvas);
        }

        return null;
      },
      createCanvas: function createCanvas(key, width, canvas) {
        if (void 0 === width && (width = 256), void 0 === canvas && (canvas = 256), this.checkKey(key)) {
          canvas = CanvasPool.create(this, width, canvas, CONST.CANVAS, !0);
          return this.addCanvas(key, canvas);
        }

        return null;
      },
      addCanvas: function addCanvas(key, source, skipCache) {
        var texture = null;
        return (skipCache = void 0 === skipCache ? !1 : skipCache) ? texture = new CanvasTexture(this, key, source, source.width, source.height) : this.checkKey(key) && (texture = new CanvasTexture(this, key, source, source.width, source.height), this.list[key] = texture, this.emit(Events.ADD, key, texture)), texture;
      },
      addAtlas: function addAtlas(key, source, data, dataSource) {
        return Array.isArray(data.textures) || Array.isArray(data.frames) ? this.addAtlasJSONArray(key, source, data, dataSource) : this.addAtlasJSONHash(key, source, data, dataSource);
      },
      addAtlasJSONArray: function addAtlasJSONArray(key, source, data, dataSource) {
        var texture = null;

        if (this.checkKey(key)) {
          if (texture = this.create(key, source), Array.isArray(data)) for (var singleAtlasFile = 1 === data.length, i = 0; i < texture.source.length; i++) {
            var atlasData = singleAtlasFile ? data[0] : data[i];
            Parser.JSONArray(texture, i, atlasData);
          } else Parser.JSONArray(texture, 0, data);
          dataSource && texture.setDataSource(dataSource), this.emit(Events.ADD, key, texture);
        }

        return texture;
      },
      addAtlasJSONHash: function addAtlasJSONHash(key, source, data, dataSource) {
        var texture = null;

        if (this.checkKey(key)) {
          if (texture = this.create(key, source), Array.isArray(data)) for (var i = 0; i < data.length; i++) {
            Parser.JSONHash(texture, i, data[i]);
          } else Parser.JSONHash(texture, 0, data);
          dataSource && texture.setDataSource(dataSource), this.emit(Events.ADD, key, texture);
        }

        return texture;
      },
      addAtlasXML: function addAtlasXML(key, source, data, dataSource) {
        var texture = null;
        return this.checkKey(key) && (texture = this.create(key, source), Parser.AtlasXML(texture, 0, data), dataSource && texture.setDataSource(dataSource), this.emit(Events.ADD, key, texture)), texture;
      },
      addUnityAtlas: function addUnityAtlas(key, source, data, dataSource) {
        var texture = null;
        return this.checkKey(key) && (texture = this.create(key, source), Parser.UnityYAML(texture, 0, data), dataSource && texture.setDataSource(dataSource), this.emit(Events.ADD, key, texture)), texture;
      },
      addSpriteSheet: function addSpriteSheet(key, height, config) {
        var width,
            texture = null;
        return this.checkKey(key) && (width = (texture = this.create(key, height)).source[0].width, height = texture.source[0].height, Parser.SpriteSheet(texture, 0, 0, 0, width, height, config), this.emit(Events.ADD, key, texture)), texture;
      },
      addSpriteSheetFromAtlas: function addSpriteSheetFromAtlas(key, config) {
        if (!this.checkKey(key)) return null;
        var sheet = GetValue(config, "atlas", null),
            texture = GetValue(config, "frame", null);

        if (sheet && texture) {
          sheet = this.get(sheet).get(texture);

          if (sheet) {
            texture = this.create(key, sheet.source.image);
            return sheet.trimmed ? Parser.SpriteSheetFromAtlas(texture, sheet, config) : Parser.SpriteSheet(texture, 0, sheet.cutX, sheet.cutY, sheet.cutWidth, sheet.cutHeight, config), this.emit(Events.ADD, key, texture), texture;
          }
        }
      },
      create: function create(key, source, width, height) {
        var texture = null;
        return this.checkKey(key) && (texture = new Texture(this, key, source, width, height), this.list[key] = texture), texture;
      },
      exists: function exists(key) {
        return this.list.hasOwnProperty(key);
      },
      get: function get(key) {
        return this.list[key = void 0 === key ? "__DEFAULT" : key] || (key instanceof Texture ? key : this.list.__MISSING);
      },
      cloneFrame: function cloneFrame(key, frame) {
        if (this.list[key]) return this.list[key].get(frame).clone();
      },
      getFrame: function getFrame(key, frame) {
        if (this.list[key]) return this.list[key].get(frame);
      },
      getTextureKeys: function getTextureKeys() {
        var key,
            output = [];

        for (key in this.list) {
          "__DEFAULT" !== key && "__MISSING" !== key && output.push(key);
        }

        return output;
      },
      getPixel: function getPixel(x, y, textureFrame, rgb) {
        textureFrame = this.getFrame(textureFrame, rgb);

        if (textureFrame) {
          x -= textureFrame.x, y -= textureFrame.y;
          rgb = textureFrame.data.cut;

          if (x += rgb.x, y += rgb.y, x >= rgb.x && x < rgb.r && y >= rgb.y && y < rgb.b) {
            rgb = this._tempContext;
            rgb.clearRect(0, 0, 1, 1), rgb.drawImage(textureFrame.source.image, x, y, 1, 1, 0, 0, 1, 1);
            rgb = rgb.getImageData(0, 0, 1, 1);
            return new Color(rgb.data[0], rgb.data[1], rgb.data[2], rgb.data[3]);
          }
        }

        return null;
      },
      getPixelAlpha: function getPixelAlpha(x, y, textureFrame, ctx) {
        textureFrame = this.getFrame(textureFrame, ctx);

        if (textureFrame) {
          x -= textureFrame.x, y -= textureFrame.y;
          ctx = textureFrame.data.cut;

          if (x += ctx.x, y += ctx.y, x >= ctx.x && x < ctx.r && y >= ctx.y && y < ctx.b) {
            ctx = this._tempContext;
            return ctx.clearRect(0, 0, 1, 1), ctx.drawImage(textureFrame.source.image, x, y, 1, 1, 0, 0, 1, 1), ctx.getImageData(0, 0, 1, 1).data[3];
          }
        }

        return null;
      },
      setTexture: function setTexture(gameObject, key, frame) {
        return this.list[key] && (gameObject.texture = this.list[key], gameObject.frame = gameObject.texture.get(frame)), gameObject;
      },
      renameTexture: function renameTexture(currentKey, newKey) {
        var texture = this.get(currentKey);
        return !(!texture || currentKey === newKey) && (texture.key = newKey, this.list[newKey] = texture, delete this.list[currentKey], !0);
      },
      each: function each(callback, scope) {
        for (var texture, args = [null], i = 1; i < arguments.length; i++) {
          args.push(arguments[i]);
        }

        for (texture in this.list) {
          args[0] = this.list[texture], callback.apply(scope, args);
        }
      },
      destroy: function destroy() {
        for (var texture in this.list) {
          this.list[texture].destroy();
        }

        this.list = {}, this.game = null, CanvasPool.remove(this._tempCanvas);
      }
    });

    module.exports = TextureManager;
  }, function (module, exports, __webpack_require__) {
    var CanvasTexture = __webpack_require__(0),
        Clamp = __webpack_require__(18),
        Color = __webpack_require__(38),
        CONST = __webpack_require__(33),
        IsSizePowerOfTwo = __webpack_require__(138),
        Texture = __webpack_require__(206),
        CanvasTexture = new CanvasTexture({
      Extends: Texture,
      initialize: function initialize(manager, key, source, width, height) {
        Texture.call(this, manager, key, source, width, height), this.add("__BASE", 0, 0, 0, width, height), this._source = this.frames.__BASE.source, this.canvas = this._source.image, this.context = this.canvas.getContext("2d"), this.width = width, this.height = height, this.imageData = this.context.getImageData(0, 0, width, height), this.data = null, this.imageData && (this.data = this.imageData.data), this.pixels = null, this.buffer, this.data && (this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer, this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length), this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data);
      },
      update: function update() {
        return this.imageData = this.context.getImageData(0, 0, this.width, this.height), this.data = this.imageData.data, this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer, this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length), this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data, this.manager.game.config.renderType === CONST.WEBGL && this.refresh(), this;
      },
      draw: function draw(x, y, source) {
        return this.context.drawImage(source, x, y), this.update();
      },
      drawFrame: function drawFrame(height, res, x, y) {
        void 0 === x && (x = 0), void 0 === y && (y = 0);
        var textureFrame = this.manager.getFrame(height, res);

        if (textureFrame) {
          var cd = textureFrame.canvasData,
              width = textureFrame.cutWidth,
              height = textureFrame.cutHeight,
              res = textureFrame.source.resolution;
          return this.context.drawImage(textureFrame.source.image, cd.x, cd.y, width, height, x, y, width / res, height / res), this.update();
        }

        return this;
      },
      setPixel: function setPixel(x, y, red, green, blue, alpha) {
        var imageData;
        return void 0 === alpha && (alpha = 255), x = Math.abs(Math.floor(x)), y = Math.abs(Math.floor(y)), -1 < this.getIndex(x, y) && ((imageData = this.context.getImageData(x, y, 1, 1)).data[0] = red, imageData.data[1] = green, imageData.data[2] = blue, imageData.data[3] = alpha, this.context.putImageData(imageData, x, y)), this;
      },
      putData: function putData(imageData, x, y, dirtyX, dirtyY, dirtyWidth, dirtyHeight) {
        return void 0 === dirtyWidth && (dirtyWidth = imageData.width), void 0 === dirtyHeight && (dirtyHeight = imageData.height), this.context.putImageData(imageData, x, y, dirtyX = void 0 === dirtyX ? 0 : dirtyX, dirtyY = void 0 === dirtyY ? 0 : dirtyY, dirtyWidth, dirtyHeight), this;
      },
      getData: function getData(x, y, width, height) {
        return x = Clamp(Math.floor(x), 0, this.width - 1), y = Clamp(Math.floor(y), 0, this.height - 1), width = Clamp(width, 1, this.width - x), height = Clamp(height, 1, this.height - y), this.context.getImageData(x, y, width, height);
      },
      getPixel: function getPixel(g, b, out) {
        out = out || new Color();
        var data,
            r,
            a = this.getIndex(g, b);
        return -1 < a && (r = (data = this.data)[a + 0], g = data[a + 1], b = data[a + 2], a = data[a + 3], out.setTo(r, g, b, a)), out;
      },
      getPixels: function getPixels(x, y, top, height) {
        void 0 === x && (x = 0), void 0 === y && (y = 0), void 0 === top && (top = this.width), void 0 === height && (height = top), x = Math.abs(Math.round(x)), y = Math.abs(Math.round(y));

        for (var left = Clamp(x, 0, this.width), right = Clamp(x + top, 0, this.width), top = Clamp(y, 0, this.height), bottom = Clamp(y + height, 0, this.height), pixel = new Color(), out = [], py = top; py < bottom; py++) {
          for (var row = [], px = left; px < right; px++) {
            pixel = this.getPixel(px, py, pixel), row.push({
              x: px,
              y: py,
              color: pixel.color,
              alpha: pixel.alphaGL
            });
          }

          out.push(row);
        }

        return out;
      },
      getIndex: function getIndex(x, y) {
        return x = Math.abs(Math.round(x)), y = Math.abs(Math.round(y)), x < this.width && y < this.height ? 4 * (x + y * this.width) : -1;
      },
      refresh: function refresh() {
        return this._source.update(), this;
      },
      getCanvas: function getCanvas() {
        return this.canvas;
      },
      getContext: function getContext() {
        return this.context;
      },
      clear: function clear(x, y, width, height) {
        return void 0 === width && (width = this.width), void 0 === height && (height = this.height), this.context.clearRect(x = void 0 === x ? 0 : x, y = void 0 === y ? 0 : y, width, height), this.update();
      },
      setSize: function setSize(width, height) {
        return void 0 === height && (height = width), width === this.width && height === this.height || (this.canvas.width = width, this.canvas.height = height, this._source.width = width, this._source.height = height, this._source.isPowerOf2 = IsSizePowerOfTwo(width, height), this.frames.__BASE.setSize(width, height, 0, 0), this.width = width, this.height = height, this.refresh()), this;
      },
      destroy: function destroy() {
        Texture.prototype.destroy.call(this), this._source = null, this.canvas = null, this.context = null, this.imageData = null, this.data = null, this.pixels = null, this.buffer = null;
      }
    });

    module.exports = CanvasTexture;
  }, function (module, exports, __webpack_require__) {
    var CanvasPool = __webpack_require__(31),
        TextureSource = __webpack_require__(0),
        IsSizePowerOfTwo = __webpack_require__(138),
        ScaleModes = __webpack_require__(168),
        TextureSource = new TextureSource({
      initialize: function initialize(texture, source, width, height, flipY) {
        void 0 === flipY && (flipY = !1);
        var game = texture.manager.game;
        this.renderer = game.renderer, this.texture = texture, this.source = source, this.image = source, this.compressionAlgorithm = null, this.resolution = 1, this.width = width || source.naturalWidth || source.videoWidth || source.width || 0, this.height = height || source.naturalHeight || source.videoHeight || source.height || 0, this.scaleMode = ScaleModes.DEFAULT, this.isCanvas = source instanceof HTMLCanvasElement, this.isVideo = window.hasOwnProperty("HTMLVideoElement") && source instanceof HTMLVideoElement, this.isRenderTexture = "RenderTexture" === source.type, this.isGLTexture = window.hasOwnProperty("WebGLTexture") && source instanceof WebGLTexture, this.isPowerOf2 = IsSizePowerOfTwo(this.width, this.height), this.glTexture = null, this.glIndex = 0, this.glIndexCounter = -1, this.flipY = flipY, this.init(game);
      },
      init: function init(game) {
        var renderer = this.renderer;
        renderer && (renderer.gl ? this.isCanvas ? this.glTexture = renderer.createCanvasTexture(this.image, !1, this.flipY) : this.isVideo ? this.glTexture = renderer.createVideoTexture(this.image, !1, this.flipY) : this.isRenderTexture ? (this.image = this.source.canvas, this.glTexture = renderer.createTextureFromSource(null, this.width, this.height, this.scaleMode)) : this.isGLTexture ? this.glTexture = this.source : this.glTexture = renderer.createTextureFromSource(this.image, this.width, this.height, this.scaleMode) : this.isRenderTexture && (this.image = this.source.canvas)), game.config.antialias || this.setFilter(1);
      },
      setFilter: function setFilter(filterMode) {
        this.renderer.gl && this.renderer.setTextureFilter(this.glTexture, filterMode), this.scaleMode = filterMode;
      },
      setFlipY: function setFlipY(value) {
        return this.flipY = value = void 0 === value ? !0 : value, this;
      },
      update: function update() {
        var gl = this.renderer.gl;
        gl && this.isCanvas ? this.glTexture = this.renderer.updateCanvasTexture(this.image, this.glTexture, this.flipY) : gl && this.isVideo && (this.glTexture = this.renderer.updateVideoTexture(this.image, this.glTexture, this.flipY));
      },
      destroy: function destroy() {
        this.glTexture && this.renderer.deleteTexture(this.glTexture, !0), this.isCanvas && CanvasPool.remove(this.image), this.renderer = null, this.texture = null, this.source = null, this.image = null, this.glTexture = null;
      }
    });

    module.exports = TextureSource;
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      AtlasXML: __webpack_require__(979),
      Canvas: __webpack_require__(980),
      Image: __webpack_require__(981),
      JSONArray: __webpack_require__(982),
      JSONHash: __webpack_require__(983),
      SpriteSheet: __webpack_require__(984),
      SpriteSheetFromAtlas: __webpack_require__(985),
      UnityYAML: __webpack_require__(986)
    };
  }, function (module, exports, __webpack_require__) {
    var HTML5AudioSoundManager = __webpack_require__(427),
        NoAudioSoundManager = __webpack_require__(430),
        WebAudioSoundManager = __webpack_require__(432);

    module.exports = {
      create: function create(game) {
        var audioConfig = game.config.audio,
            deviceAudio = game.device.audio;
        return new (audioConfig.noAudio || !deviceAudio.webAudio && !deviceAudio.audioData ? NoAudioSoundManager : deviceAudio.webAudio && !audioConfig.disableWebAudio ? WebAudioSoundManager : HTML5AudioSoundManager)(game);
      }
    };
  }, function (module, exports, __webpack_require__) {
    var BaseSoundManager = __webpack_require__(145),
        HTML5AudioSoundManager = __webpack_require__(0),
        Events = __webpack_require__(70),
        HTML5AudioSound = __webpack_require__(429),
        HTML5AudioSoundManager = new HTML5AudioSoundManager({
      Extends: BaseSoundManager,
      initialize: function initialize(game) {
        this.override = !0, this.audioPlayDelay = .1, this.loopEndOffset = .05, this.onBlurPausedSounds = [], this.locked = "ontouchstart" in window, this.lockedActionsQueue = this.locked ? [] : null, this._mute = !1, this._volume = 1, BaseSoundManager.call(this, game);
      },
      add: function add(key, sound) {
        sound = new HTML5AudioSound(this, key, sound);
        return this.sounds.push(sound), sound;
      },
      unlock: function unlock() {
        this.locked = !1;

        var moved,
            detectMove,
            _unlock,
            _this = this;

        this.game.cache.audio.entries.each(function (key, tags) {
          for (var i = 0; i < tags.length; i++) {
            if ("true" === tags[i].dataset.locked) return !(_this.locked = !0);
          }

          return !0;
        }), this.locked && (moved = !1, detectMove = function detectMove() {
          moved = !0;
        }, _unlock = function unlock() {
          var lockedTags, lastTag;
          moved ? moved = !1 : (document.body.removeEventListener("touchmove", detectMove), document.body.removeEventListener("touchend", _unlock), lockedTags = [], _this.game.cache.audio.entries.each(function (key, tags) {
            for (var i = 0; i < tags.length; i++) {
              var tag = tags[i];
              "true" === tag.dataset.locked && lockedTags.push(tag);
            }

            return !0;
          }), 0 !== lockedTags.length && ((lastTag = lockedTags[lockedTags.length - 1]).oncanplaythrough = function () {
            lastTag.oncanplaythrough = null, lockedTags.forEach(function (tag) {
              tag.dataset.locked = "false";
            }), _this.unlocked = !0;
          }, lockedTags.forEach(function (tag) {
            tag.load();
          })));
        }, this.once(Events.UNLOCKED, function () {
          for (this.forEachActiveSound(function (sound) {
            null === sound.currentMarker && 0 === sound.duration && (sound.duration = sound.tags[0].duration), sound.totalDuration = sound.tags[0].duration;
          }); this.lockedActionsQueue.length;) {
            var lockedAction = this.lockedActionsQueue.shift();
            lockedAction.sound[lockedAction.prop].apply ? lockedAction.sound[lockedAction.prop].apply(lockedAction.sound, lockedAction.value || []) : lockedAction.sound[lockedAction.prop] = lockedAction.value;
          }
        }, this), document.body.addEventListener("touchmove", detectMove, !1), document.body.addEventListener("touchend", _unlock, !1));
      },
      onBlur: function onBlur() {
        this.forEachActiveSound(function (sound) {
          sound.isPlaying && (this.onBlurPausedSounds.push(sound), sound.onBlur());
        });
      },
      onFocus: function onFocus() {
        this.onBlurPausedSounds.forEach(function (sound) {
          sound.onFocus();
        }), this.onBlurPausedSounds.length = 0;
      },
      destroy: function destroy() {
        BaseSoundManager.prototype.destroy.call(this), this.onBlurPausedSounds.length = 0, this.onBlurPausedSounds = null;
      },
      isLocked: function isLocked(sound, prop, value) {
        return "true" === sound.tags[0].dataset.locked && (this.lockedActionsQueue.push({
          sound: sound,
          prop: prop,
          value: value
        }), !0);
      },
      setMute: function setMute(value) {
        return this.mute = value, this;
      },
      mute: {
        get: function get() {
          return this._mute;
        },
        set: function set(value) {
          this._mute = value, this.forEachActiveSound(function (sound) {
            sound.updateMute();
          }), this.emit(Events.GLOBAL_MUTE, this, value);
        }
      },
      setVolume: function setVolume(value) {
        return this.volume = value, this;
      },
      volume: {
        get: function get() {
          return this._volume;
        },
        set: function set(value) {
          this._volume = value, this.forEachActiveSound(function (sound) {
            sound.updateVolume();
          }), this.emit(Events.GLOBAL_VOLUME, this, value);
        }
      }
    });

    module.exports = HTML5AudioSoundManager;
  }, function (module, exports, __webpack_require__) {
    var SafeRange = __webpack_require__(78);

    module.exports = function (array, property, value, startIndex, endIndex) {
      if (void 0 === endIndex && (endIndex = array.length), SafeRange(array, startIndex = void 0 === startIndex ? 0 : startIndex, endIndex)) for (var i = startIndex; i < endIndex; i++) {
        var child = array[i];
        if (!property || void 0 === value && child.hasOwnProperty(property) || property && void 0 !== value && child[property] === value) return child;
      }
      return null;
    };
  }, function (module, exports, __webpack_require__) {
    var BaseSound = __webpack_require__(146),
        HTML5AudioSound = __webpack_require__(0),
        Events = __webpack_require__(70),
        Clamp = __webpack_require__(18),
        HTML5AudioSound = new HTML5AudioSound({
      Extends: BaseSound,
      initialize: function initialize(manager, key, config) {
        if (void 0 === config && (config = {}), this.tags = manager.game.cache.audio.get(key), !this.tags) throw new Error('There is no audio asset with key "' + key + '" in the audio cache');
        this.audio = null, this.startTime = 0, this.previousTime = 0, this.duration = this.tags[0].duration, this.totalDuration = this.tags[0].duration, BaseSound.call(this, manager, key, config);
      },
      play: function play(markerName, config) {
        return !this.manager.isLocked(this, "play", [markerName, config]) && !!BaseSound.prototype.play.call(this, markerName, config) && !!this.pickAndPlayAudioTag() && (this.emit(Events.PLAY, this), !0);
      },
      pause: function pause() {
        return !this.manager.isLocked(this, "pause") && !(0 < this.startTime) && !!BaseSound.prototype.pause.call(this) && (this.currentConfig.seek = this.audio.currentTime - (this.currentMarker ? this.currentMarker.start : 0), this.stopAndReleaseAudioTag(), this.emit(Events.PAUSE, this), !0);
      },
      resume: function resume() {
        return !this.manager.isLocked(this, "resume") && !(0 < this.startTime) && !!BaseSound.prototype.resume.call(this) && !!this.pickAndPlayAudioTag() && (this.emit(Events.RESUME, this), !0);
      },
      stop: function stop() {
        return !this.manager.isLocked(this, "stop") && !!BaseSound.prototype.stop.call(this) && (this.stopAndReleaseAudioTag(), this.emit(Events.STOP, this), !0);
      },
      pickAndPlayAudioTag: function pickAndPlayAudioTag() {
        if (!this.pickAudioTag()) return this.reset(), !1;
        var offset = this.currentConfig.seek,
            delay = this.currentConfig.delay,
            offset = (this.currentMarker ? this.currentMarker.start : 0) + offset;
        return this.previousTime = offset, this.audio.currentTime = offset, this.applyConfig(), 0 === delay ? (this.startTime = 0, this.audio.paused && this.playCatchPromise()) : (this.startTime = window.performance.now() + 1e3 * delay, this.audio.paused || this.audio.pause()), this.resetConfig(), !0;
      },
      pickAudioTag: function pickAudioTag() {
        if (this.audio) return !0;

        for (var i = 0; i < this.tags.length; i++) {
          var audio = this.tags[i];
          if ("false" === audio.dataset.used) return audio.dataset.used = "true", this.audio = audio, !0;
        }

        if (!this.manager.override) return !1;
        var otherSounds = [];
        this.manager.forEachActiveSound(function (sound) {
          sound.key === this.key && sound.audio && otherSounds.push(sound);
        }, this), otherSounds.sort(function (a1, a2) {
          return a1.loop === a2.loop ? a2.seek / a2.duration - a1.seek / a1.duration : a1.loop ? 1 : -1;
        });
        var selectedSound = otherSounds[0];
        return this.audio = selectedSound.audio, selectedSound.reset(), selectedSound.audio = null, selectedSound.startTime = 0, !(selectedSound.previousTime = 0);
      },
      playCatchPromise: function playCatchPromise() {
        var playPromise = this.audio.play();
        playPromise && playPromise.catch(function (reason) {
          console.warn(reason);
        });
      },
      stopAndReleaseAudioTag: function stopAndReleaseAudioTag() {
        this.startTime = 0, this.previousTime = 0, this.audio && (this.audio.pause(), this.audio.dataset.used = "false", this.audio = null);
      },
      reset: function reset() {
        BaseSound.prototype.stop.call(this);
      },
      onBlur: function onBlur() {
        this.isPlaying = !1, this.isPaused = !0, this.currentConfig.seek = this.audio.currentTime - (this.currentMarker ? this.currentMarker.start : 0), this.currentConfig.delay = Math.max(0, (this.startTime - window.performance.now()) / 1e3), this.stopAndReleaseAudioTag();
      },
      onFocus: function onFocus() {
        this.isPlaying = !0, this.isPaused = !1, this.pickAndPlayAudioTag();
      },
      update: function update(currentTime) {
        if (this.isPlaying) if (0 < this.startTime) this.startTime < currentTime - this.manager.audioPlayDelay && (this.audio.currentTime += Math.max(0, currentTime - this.startTime) / 1e3, this.startTime = 0, this.previousTime = this.audio.currentTime, this.playCatchPromise());else {
          var startTime = this.currentMarker ? this.currentMarker.start : 0,
              endTime = startTime + this.duration,
              currentTime = this.audio.currentTime;
          if (this.currentConfig.loop) currentTime >= endTime - this.manager.loopEndOffset ? (this.audio.currentTime = startTime + Math.max(0, currentTime - endTime), currentTime = this.audio.currentTime) : currentTime < startTime && (this.audio.currentTime += startTime, currentTime = this.audio.currentTime), currentTime < this.previousTime && this.emit(Events.LOOPED, this);else if (endTime <= currentTime) return this.reset(), this.stopAndReleaseAudioTag(), void this.emit(Events.COMPLETE, this);
          this.previousTime = currentTime;
        }
      },
      destroy: function destroy() {
        BaseSound.prototype.destroy.call(this), this.tags = null, this.audio && this.stopAndReleaseAudioTag();
      },
      updateMute: function updateMute() {
        this.audio && (this.audio.muted = this.currentConfig.mute || this.manager.mute);
      },
      updateVolume: function updateVolume() {
        this.audio && (this.audio.volume = Clamp(this.currentConfig.volume * this.manager.volume, 0, 1));
      },
      calculateRate: function calculateRate() {
        BaseSound.prototype.calculateRate.call(this), this.audio && (this.audio.playbackRate = this.totalRate);
      },
      mute: {
        get: function get() {
          return this.currentConfig.mute;
        },
        set: function set(value) {
          this.currentConfig.mute = value, this.manager.isLocked(this, "mute", value) || (this.updateMute(), this.emit(Events.MUTE, this, value));
        }
      },
      setMute: function setMute(value) {
        return this.mute = value, this;
      },
      volume: {
        get: function get() {
          return this.currentConfig.volume;
        },
        set: function set(value) {
          this.currentConfig.volume = value, this.manager.isLocked(this, "volume", value) || (this.updateVolume(), this.emit(Events.VOLUME, this, value));
        }
      },
      setVolume: function setVolume(value) {
        return this.volume = value, this;
      },
      rate: {
        get: function get() {
          return this.currentConfig.rate;
        },
        set: function set(value) {
          this.currentConfig.rate = value, this.manager.isLocked(this, Events.RATE, value) || (this.calculateRate(), this.emit(Events.RATE, this, value));
        }
      },
      setRate: function setRate(value) {
        return this.rate = value, this;
      },
      detune: {
        get: function get() {
          return this.currentConfig.detune;
        },
        set: function set(value) {
          this.currentConfig.detune = value, this.manager.isLocked(this, Events.DETUNE, value) || (this.calculateRate(), this.emit(Events.DETUNE, this, value));
        }
      },
      setDetune: function setDetune(value) {
        return this.detune = value, this;
      },
      seek: {
        get: function get() {
          return this.isPlaying ? this.audio.currentTime - (this.currentMarker ? this.currentMarker.start : 0) : this.isPaused ? this.currentConfig.seek : 0;
        },
        set: function set(value) {
          this.manager.isLocked(this, "seek", value) || 0 < this.startTime || (this.isPlaying || this.isPaused) && (value = Math.min(Math.max(0, value), this.duration), this.isPlaying ? (this.previousTime = value, this.audio.currentTime = value) : this.isPaused && (this.currentConfig.seek = value), this.emit(Events.SEEK, this, value));
        }
      },
      setSeek: function setSeek(value) {
        return this.seek = value, this;
      },
      loop: {
        get: function get() {
          return this.currentConfig.loop;
        },
        set: function set(value) {
          this.currentConfig.loop = value, this.manager.isLocked(this, "loop", value) || (this.audio && (this.audio.loop = value), this.emit(Events.LOOP, this, value));
        }
      },
      setLoop: function setLoop(value) {
        return this.loop = value, this;
      },
      pan: {
        get: function get() {
          return this.currentConfig.pan;
        },
        set: function set(value) {
          this.currentConfig.pan = value, this.emit(Events.PAN, this, value);
        }
      },
      setPan: function setPan(value) {
        return this.pan = value, this;
      }
    });

    module.exports = HTML5AudioSound;
  }, function (module, exports, NoAudioSoundManager) {
    var BaseSoundManager = NoAudioSoundManager(145),
        Class = NoAudioSoundManager(0),
        EventEmitter = NoAudioSoundManager(9),
        NoAudioSound = NoAudioSoundManager(431),
        NoAudioSoundManager = NoAudioSoundManager(1),
        NoAudioSoundManager = new Class({
      Extends: EventEmitter,
      initialize: function initialize(game) {
        EventEmitter.call(this), this.game = game, this.sounds = [], this.mute = !1, this.volume = 1, this.rate = 1, this.detune = 0, this.pauseOnBlur = !0, this.locked = !1;
      },
      add: function add(key, sound) {
        sound = new NoAudioSound(this, key, sound);
        return this.sounds.push(sound), sound;
      },
      addAudioSprite: function addAudioSprite(key, sound) {
        sound = this.add(key, sound);
        return sound.spritemap = {}, sound;
      },
      play: function play(key, extra) {
        return !1;
      },
      playAudioSprite: function playAudioSprite(key, spriteName, config) {
        return !1;
      },
      remove: function remove(sound) {
        return BaseSoundManager.prototype.remove.call(this, sound);
      },
      removeByKey: function removeByKey(key) {
        return BaseSoundManager.prototype.removeByKey.call(this, key);
      },
      pauseAll: NoAudioSoundManager,
      resumeAll: NoAudioSoundManager,
      stopAll: NoAudioSoundManager,
      update: NoAudioSoundManager,
      setRate: NoAudioSoundManager,
      setDetune: NoAudioSoundManager,
      setMute: NoAudioSoundManager,
      setVolume: NoAudioSoundManager,
      forEachActiveSound: function forEachActiveSound(callbackfn, scope) {
        BaseSoundManager.prototype.forEachActiveSound.call(this, callbackfn, scope);
      },
      destroy: function destroy() {
        BaseSoundManager.prototype.destroy.call(this);
      }
    });
    module.exports = NoAudioSoundManager;
  }, function (module, exports, __webpack_require__) {
    function returnFalse() {
      return !1;
    }

    function returnThis() {
      return this;
    }

    var BaseSound = __webpack_require__(146),
        NoAudioSound = __webpack_require__(0),
        EventEmitter = __webpack_require__(9),
        Extend = __webpack_require__(17),
        NoAudioSound = new NoAudioSound({
      Extends: EventEmitter,
      initialize: function initialize(manager, key, config) {
        void 0 === config && (config = {}), EventEmitter.call(this), this.manager = manager, this.key = key, this.isPlaying = !1, this.isPaused = !1, this.totalRate = 1, this.duration = 0, this.totalDuration = 0, this.config = Extend({
          mute: !1,
          volume: 1,
          rate: 1,
          detune: 0,
          seek: 0,
          loop: !1,
          delay: 0,
          pan: 0
        }, config), this.currentConfig = this.config, this.mute = !1, this.volume = 1, this.rate = 1, this.detune = 0, this.seek = 0, this.loop = !1, this.pan = 0, this.markers = {}, this.currentMarker = null, this.pendingRemove = !1;
      },
      addMarker: returnFalse,
      updateMarker: returnFalse,
      removeMarker: function removeMarker() {
        return null;
      },
      play: returnFalse,
      pause: returnFalse,
      resume: returnFalse,
      stop: returnFalse,
      destroy: function destroy() {
        BaseSound.prototype.destroy.call(this);
      },
      setMute: returnThis,
      setVolume: returnThis,
      setRate: returnThis,
      setDetune: returnThis,
      setSeek: returnThis,
      setLoop: returnThis,
      setPan: returnThis
    });

    module.exports = NoAudioSound;
  }, function (module, exports, __webpack_require__) {
    var Base64ToArrayBuffer = __webpack_require__(433),
        BaseSoundManager = __webpack_require__(145),
        WebAudioSoundManager = __webpack_require__(0),
        Events = __webpack_require__(70),
        GameEvents = __webpack_require__(22),
        WebAudioSound = __webpack_require__(434),
        WebAudioSoundManager = new WebAudioSoundManager({
      Extends: BaseSoundManager,
      initialize: function initialize(game) {
        this.context = this.createAudioContext(game), this.masterMuteNode = this.context.createGain(), this.masterVolumeNode = this.context.createGain(), this.masterMuteNode.connect(this.masterVolumeNode), this.masterVolumeNode.connect(this.context.destination), this.destination = this.masterMuteNode, this.locked = "suspended" === this.context.state && ("ontouchstart" in window || "onclick" in window), BaseSoundManager.call(this, game), this.locked && game.isBooted ? this.unlock() : game.events.once(GameEvents.BOOT, this.unlock, this);
      },
      createAudioContext: function createAudioContext(audioConfig) {
        audioConfig = audioConfig.config.audio;
        return audioConfig.context ? (audioConfig.context.resume(), audioConfig.context) : window.hasOwnProperty("AudioContext") ? new AudioContext() : window.hasOwnProperty("webkitAudioContext") ? new window.webkitAudioContext() : void 0;
      },
      setAudioContext: function setAudioContext(context) {
        return this.context && this.context.close(), this.masterMuteNode && this.masterMuteNode.disconnect(), this.masterVolumeNode && this.masterVolumeNode.disconnect(), this.context = context, this.masterMuteNode = context.createGain(), this.masterVolumeNode = context.createGain(), this.masterMuteNode.connect(this.masterVolumeNode), this.masterVolumeNode.connect(context.destination), this.destination = this.masterMuteNode, this;
      },
      add: function add(key, sound) {
        sound = new WebAudioSound(this, key, sound);
        return this.sounds.push(sound), sound;
      },
      decodeAudio: function decodeAudio(audioKey, audioData) {
        for (var audioFiles = Array.isArray(audioKey) ? audioKey : [{
          key: audioKey,
          data: audioData
        }], cache = this.game.cache.audio, remaining = audioFiles.length, i = 0; i < audioFiles.length; i++) {
          var success = audioFiles[i],
              failure = success.key,
              data = success.data;
          "string" == typeof data && (data = Base64ToArrayBuffer(data));
          success = function (key, audioBuffer) {
            cache.add(key, audioBuffer), this.emit(Events.DECODED, key), 0 === --remaining && this.emit(Events.DECODED_ALL);
          }.bind(this, failure), failure = function (key, error) {
            console.error("Error decoding audio: " + key + " - ", error ? error.message : ""), 0 === --remaining && this.emit(Events.DECODED_ALL);
          }.bind(this, failure);
          this.context.decodeAudioData(data, success, failure);
        }
      },
      unlock: function unlock() {
        function unlockHandler() {
          var bodyRemove;
          _this.context && body && (bodyRemove = body.removeEventListener, _this.context.resume().then(function () {
            bodyRemove("touchstart", unlockHandler), bodyRemove("touchend", unlockHandler), bodyRemove("click", unlockHandler), bodyRemove("keydown", unlockHandler), _this.unlocked = !0;
          }, function () {
            bodyRemove("touchstart", unlockHandler), bodyRemove("touchend", unlockHandler), bodyRemove("click", unlockHandler), bodyRemove("keydown", unlockHandler);
          }));
        }

        var _this = this,
            body = document.body;

        body && (body.addEventListener("touchstart", unlockHandler, !1), body.addEventListener("touchend", unlockHandler, !1), body.addEventListener("click", unlockHandler, !1), body.addEventListener("keydown", unlockHandler, !1));
      },
      onBlur: function onBlur() {
        this.locked || this.context.suspend();
      },
      onFocus: function onFocus() {
        var context = this.context;
        "suspended" !== context.state && "interrupted" !== context.state || this.locked || context.resume();
      },
      update: function update(time, context) {
        BaseSoundManager.prototype.update.call(this, time, context);
        context = this.context;
        context && "interrupted" === context.state && context.resume();
      },
      destroy: function destroy() {
        var _this;

        this.destination = null, this.masterVolumeNode.disconnect(), this.masterVolumeNode = null, this.masterMuteNode.disconnect(), this.masterMuteNode = null, this.game.config.audio.context ? this.context.suspend() : (_this = this).context.close().then(function () {
          _this.context = null;
        }), BaseSoundManager.prototype.destroy.call(this);
      },
      setMute: function setMute(value) {
        return this.mute = value, this;
      },
      mute: {
        get: function get() {
          return 0 === this.masterMuteNode.gain.value;
        },
        set: function set(value) {
          this.masterMuteNode.gain.setValueAtTime(value ? 0 : 1, 0), this.emit(Events.GLOBAL_MUTE, this, value);
        }
      },
      setVolume: function setVolume(value) {
        return this.volume = value, this;
      },
      volume: {
        get: function get() {
          return this.masterVolumeNode.gain.value;
        },
        set: function set(value) {
          this.masterVolumeNode.gain.setValueAtTime(value, 0), this.emit(Events.GLOBAL_VOLUME, this, value);
        }
      }
    });

    module.exports = WebAudioSoundManager;
  }, function (module, exports) {
    for (var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", lookup = new Uint8Array(256), i = 0; i < chars.length; i++) {
      lookup[chars.charCodeAt(i)] = i;
    }

    module.exports = function (base64) {
      var encoded1,
          encoded2,
          encoded3,
          encoded4,
          len = (base64 = base64.substr(base64.indexOf(",") + 1)).length,
          arrayBuffer = .75 * len,
          p = 0;
      "=" === base64[len - 1] && (arrayBuffer--, "=" === base64[len - 2] && arrayBuffer--);

      for (var arrayBuffer = new ArrayBuffer(arrayBuffer), bytes = new Uint8Array(arrayBuffer), i = 0; i < len; i += 4) {
        encoded1 = lookup[base64.charCodeAt(i)], encoded2 = lookup[base64.charCodeAt(i + 1)], encoded3 = lookup[base64.charCodeAt(i + 2)], encoded4 = lookup[base64.charCodeAt(i + 3)], bytes[p++] = encoded1 << 2 | encoded2 >> 4, bytes[p++] = (15 & encoded2) << 4 | encoded3 >> 2, bytes[p++] = (3 & encoded3) << 6 | 63 & encoded4;
      }

      return arrayBuffer;
    };
  }, function (module, exports, __webpack_require__) {
    var BaseSound = __webpack_require__(146),
        WebAudioSound = __webpack_require__(0),
        Events = __webpack_require__(70),
        WebAudioSound = new WebAudioSound({
      Extends: BaseSound,
      initialize: function initialize(manager, key, config) {
        if (void 0 === config && (config = {}), this.audioBuffer = manager.game.cache.audio.get(key), !this.audioBuffer) throw new Error('Audio key "' + key + '" missing from cache');
        this.source = null, this.loopSource = null, this.muteNode = manager.context.createGain(), this.volumeNode = manager.context.createGain(), this.pannerNode = null, this.playTime = 0, this.startTime = 0, this.loopTime = 0, this.rateUpdates = [], this.hasEnded = !1, this.hasLooped = !1, this.muteNode.connect(this.volumeNode), manager.context.createStereoPanner ? (this.pannerNode = manager.context.createStereoPanner(), this.volumeNode.connect(this.pannerNode), this.pannerNode.connect(manager.destination)) : this.volumeNode.connect(manager.destination), this.duration = this.audioBuffer.duration, this.totalDuration = this.audioBuffer.duration, BaseSound.call(this, manager, key, config);
      },
      play: function play(markerName, config) {
        return !!BaseSound.prototype.play.call(this, markerName, config) && (this.stopAndRemoveBufferSource(), this.createAndStartBufferSource(), this.emit(Events.PLAY, this), !0);
      },
      pause: function pause() {
        return !(this.manager.context.currentTime < this.startTime) && !!BaseSound.prototype.pause.call(this) && (this.currentConfig.seek = this.getCurrentTime(), this.stopAndRemoveBufferSource(), this.emit(Events.PAUSE, this), !0);
      },
      resume: function resume() {
        return !(this.manager.context.currentTime < this.startTime) && !!BaseSound.prototype.resume.call(this) && (this.createAndStartBufferSource(), this.emit(Events.RESUME, this), !0);
      },
      stop: function stop() {
        return !!BaseSound.prototype.stop.call(this) && (this.stopAndRemoveBufferSource(), this.emit(Events.STOP, this), !0);
      },
      createAndStartBufferSource: function createAndStartBufferSource() {
        var seek = this.currentConfig.seek,
            duration = this.currentConfig.delay,
            when = this.manager.context.currentTime + duration,
            offset = (this.currentMarker ? this.currentMarker.start : 0) + seek,
            duration = this.duration - seek;
        this.playTime = when - seek, this.startTime = when, this.source = this.createBufferSource(), this.applyConfig(), this.source.start(Math.max(0, when), Math.max(0, offset), Math.max(0, duration)), this.resetConfig();
      },
      createAndStartLoopBufferSource: function createAndStartLoopBufferSource() {
        var when = this.getLoopTime(),
            offset = this.currentMarker ? this.currentMarker.start : 0,
            duration = this.duration;
        this.loopTime = when, this.loopSource = this.createBufferSource(), this.loopSource.playbackRate.setValueAtTime(this.totalRate, 0), this.loopSource.start(Math.max(0, when), Math.max(0, offset), Math.max(0, duration));
      },
      createBufferSource: function createBufferSource() {
        var _this = this,
            source = this.manager.context.createBufferSource();

        return source.buffer = this.audioBuffer, source.connect(this.muteNode), source.onended = function (ev) {
          ev.target === _this.source && (_this.currentConfig.loop ? _this.hasLooped = !0 : _this.hasEnded = !0);
        }, source;
      },
      stopAndRemoveBufferSource: function stopAndRemoveBufferSource() {
        this.source && (this.source.stop(), this.source.disconnect(), this.source = null), this.playTime = 0, this.startTime = 0, this.stopAndRemoveLoopBufferSource();
      },
      stopAndRemoveLoopBufferSource: function stopAndRemoveLoopBufferSource() {
        this.loopSource && (this.loopSource.stop(), this.loopSource.disconnect(), this.loopSource = null), this.loopTime = 0;
      },
      applyConfig: function applyConfig() {
        this.rateUpdates.length = 0, this.rateUpdates.push({
          time: 0,
          rate: 1
        }), BaseSound.prototype.applyConfig.call(this);
      },
      update: function update() {
        this.hasEnded ? (this.hasEnded = !1, BaseSound.prototype.stop.call(this), this.stopAndRemoveBufferSource(), this.emit(Events.COMPLETE, this)) : this.hasLooped && (this.hasLooped = !1, this.source = this.loopSource, this.loopSource = null, this.playTime = this.startTime = this.loopTime, this.rateUpdates.length = 0, this.rateUpdates.push({
          time: 0,
          rate: this.totalRate
        }), this.createAndStartLoopBufferSource(), this.emit(Events.LOOPED, this));
      },
      destroy: function destroy() {
        BaseSound.prototype.destroy.call(this), this.audioBuffer = null, this.stopAndRemoveBufferSource(), this.muteNode.disconnect(), this.muteNode = null, this.volumeNode.disconnect(), this.volumeNode = null, this.pannerNode && (this.pannerNode.disconnect(), this.pannerNode = null), this.rateUpdates.length = 0, this.rateUpdates = null;
      },
      calculateRate: function calculateRate() {
        BaseSound.prototype.calculateRate.call(this);
        var now = this.manager.context.currentTime;
        this.source && "number" == typeof this.totalRate && this.source.playbackRate.setValueAtTime(this.totalRate, now), this.isPlaying && (this.rateUpdates.push({
          time: Math.max(this.startTime, now) - this.playTime,
          rate: this.totalRate
        }), this.loopSource && (this.stopAndRemoveLoopBufferSource(), this.createAndStartLoopBufferSource()));
      },
      getCurrentTime: function getCurrentTime() {
        for (var currentTime = 0, i = 0; i < this.rateUpdates.length; i++) {
          currentTime += ((i < this.rateUpdates.length - 1 ? this.rateUpdates[i + 1].time : this.manager.context.currentTime - this.playTime) - this.rateUpdates[i].time) * this.rateUpdates[i].rate;
        }

        return currentTime;
      },
      getLoopTime: function getLoopTime() {
        for (var lastRateUpdateCurrentTime = 0, i = 0; i < this.rateUpdates.length - 1; i++) {
          lastRateUpdateCurrentTime += (this.rateUpdates[i + 1].time - this.rateUpdates[i].time) * this.rateUpdates[i].rate;
        }

        var lastRateUpdate = this.rateUpdates[this.rateUpdates.length - 1];
        return this.playTime + lastRateUpdate.time + (this.duration - lastRateUpdateCurrentTime) / lastRateUpdate.rate;
      },
      rate: {
        get: function get() {
          return this.currentConfig.rate;
        },
        set: function set(value) {
          this.currentConfig.rate = value, this.calculateRate(), this.emit(Events.RATE, this, value);
        }
      },
      setRate: function setRate(value) {
        return this.rate = value, this;
      },
      detune: {
        get: function get() {
          return this.currentConfig.detune;
        },
        set: function set(value) {
          this.currentConfig.detune = value, this.calculateRate(), this.emit(Events.DETUNE, this, value);
        }
      },
      setDetune: function setDetune(value) {
        return this.detune = value, this;
      },
      mute: {
        get: function get() {
          return 0 === this.muteNode.gain.value;
        },
        set: function set(value) {
          this.currentConfig.mute = value, this.muteNode.gain.setValueAtTime(value ? 0 : 1, 0), this.emit(Events.MUTE, this, value);
        }
      },
      setMute: function setMute(value) {
        return this.mute = value, this;
      },
      volume: {
        get: function get() {
          return this.volumeNode.gain.value;
        },
        set: function set(value) {
          this.currentConfig.volume = value, this.volumeNode.gain.setValueAtTime(value, 0), this.emit(Events.VOLUME, this, value);
        }
      },
      setVolume: function setVolume(value) {
        return this.volume = value, this;
      },
      seek: {
        get: function get() {
          return this.isPlaying ? this.manager.context.currentTime < this.startTime ? this.startTime - this.playTime : this.getCurrentTime() : this.isPaused ? this.currentConfig.seek : 0;
        },
        set: function set(value) {
          this.manager.context.currentTime < this.startTime || (this.isPlaying || this.isPaused) && (value = Math.min(Math.max(0, value), this.duration), this.currentConfig.seek = value, this.isPlaying && (this.stopAndRemoveBufferSource(), this.createAndStartBufferSource()), this.emit(Events.SEEK, this, value));
        }
      },
      setSeek: function setSeek(value) {
        return this.seek = value, this;
      },
      loop: {
        get: function get() {
          return this.currentConfig.loop;
        },
        set: function set(value) {
          this.currentConfig.loop = value, this.isPlaying && (this.stopAndRemoveLoopBufferSource(), value && this.createAndStartLoopBufferSource()), this.emit(Events.LOOP, this, value);
        }
      },
      setLoop: function setLoop(value) {
        return this.loop = value, this;
      },
      pan: {
        get: function get() {
          return this.pannerNode ? this.pannerNode.pan.value : 0;
        },
        set: function set(value) {
          this.currentConfig.pan = value, this.pannerNode && this.pannerNode.pan.setValueAtTime(value, this.manager.context.currentTime), this.emit(Events.PAN, this, value);
        }
      },
      setPan: function setPan(value) {
        return this.pan = value, this;
      }
    });

    module.exports = WebAudioSound;
  }, function (module, exports) {
    module.exports = function (array) {
      for (var sourceRowCount = array.length, sourceColCount = array[0].length, result = new Array(sourceColCount), i = 0; i < sourceColCount; i++) {
        result[i] = new Array(sourceRowCount);

        for (var j = sourceRowCount - 1; -1 < j; j--) {
          result[i][j] = array[j][i];
        }
      }

      return result;
    };
  }, function (module, exports) {
    function swap(arr, i, j) {
      var tmp = arr[i];
      arr[i] = arr[j], arr[j] = tmp;
    }

    function defaultCompare(a, b) {
      return a < b ? -1 : b < a ? 1 : 0;
    }

    function QuickSelect(arr, k, left, right, compare) {
      for (void 0 === left && (left = 0), void 0 === right && (right = arr.length - 1), void 0 === compare && (compare = defaultCompare); left < right;) {
        var n, m, s, newLeft, newRight;
        600 < right - left && (n = right - left + 1, m = k - left + 1, newLeft = Math.log(n), s = .5 * Math.exp(2 * newLeft / 3), newRight = .5 * Math.sqrt(newLeft * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1), newLeft = Math.max(left, Math.floor(k - m * s / n + newRight)), newRight = Math.min(right, Math.floor(k + (n - m) * s / n + newRight)), QuickSelect(arr, k, newLeft, newRight, compare));
        var t = arr[k],
            i = left,
            j = right;

        for (swap(arr, left, k), 0 < compare(arr[right], t) && swap(arr, left, right); i < j;) {
          for (swap(arr, i, j), i++, j--; compare(arr[i], t) < 0;) {
            i++;
          }

          for (; 0 < compare(arr[j], t);) {
            j--;
          }
        }

        0 === compare(arr[left], t) ? swap(arr, left, j) : swap(arr, ++j, right), j <= k && (left = j + 1), k <= j && (right = j - 1);
      }
    }

    module.exports = QuickSelect;
  }, function (module, exports, __webpack_require__) {
    var GetValue = __webpack_require__(6),
        Shuffle = __webpack_require__(131);

    module.exports = function (a, b, options) {
      var max = GetValue(options, "max", 0),
          qty = GetValue(options, "qty", 1),
          random = GetValue(options, "random", !1),
          total = GetValue(options, "randomB", !1),
          repeat = GetValue(options, "repeat", 0),
          yoyo = GetValue(options, "yoyo", !1),
          out = [];
      total && Shuffle(b), -1 === repeat && (repeat = 0 === max ? 0 : (total = a.length * b.length * qty, yoyo && (total *= 2), Math.ceil(max / total)));

      for (var i = 0; i <= repeat; i++) {
        var chunk = function (a, b, qty) {
          for (var out = [], aIndex = 0; aIndex < a.length; aIndex++) {
            for (var bIndex = 0; bIndex < b.length; bIndex++) {
              for (var i = 0; i < qty; i++) {
                out.push({
                  a: a[aIndex],
                  b: b[bIndex]
                });
              }
            }
          }

          return out;
        }(a, b, qty);

        random && Shuffle(chunk), out = out.concat(chunk), yoyo && (chunk.reverse(), out = out.concat(chunk));
      }

      return max && out.splice(max), out;
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      PROCESS_QUEUE_ADD: __webpack_require__(1041),
      PROCESS_QUEUE_REMOVE: __webpack_require__(1042)
    };
  }, function (module, exports, __webpack_require__) {
    var GetAdvancedValue = __webpack_require__(13);

    module.exports = function (sprite, play) {
      var anims,
          key,
          delay,
          repeat,
          repeatDelay,
          yoyo,
          playConfig,
          delayedPlay = GetAdvancedValue(play, "anims", null);
      return null === delayedPlay || ("string" == typeof delayedPlay ? sprite.anims.play(delayedPlay) : "object" == _typeof(delayedPlay) && (anims = sprite.anims, (key = GetAdvancedValue(delayedPlay, "key", void 0)) && (playConfig = GetAdvancedValue(delayedPlay, "startFrame", void 0), delay = GetAdvancedValue(delayedPlay, "delay", 0), repeat = GetAdvancedValue(delayedPlay, "repeat", 0), repeatDelay = GetAdvancedValue(delayedPlay, "repeatDelay", 0), yoyo = GetAdvancedValue(delayedPlay, "yoyo", !1), play = GetAdvancedValue(delayedPlay, "play", !1), delayedPlay = GetAdvancedValue(delayedPlay, "delayedPlay", 0), playConfig = {
        key: key,
        delay: delay,
        repeat: repeat,
        repeatDelay: repeatDelay,
        yoyo: yoyo,
        startFrame: playConfig
      }, play ? anims.play(playConfig) : 0 < delayedPlay ? anims.playAfterDelay(playConfig, delayedPlay) : anims.load(playConfig)))), sprite;
    };
  }, function (module, exports, __webpack_require__) {
    var Bob = __webpack_require__(0),
        Frame = __webpack_require__(109),
        Bob = new Bob({
      initialize: function initialize(blitter, x, y, frame, visible) {
        this.parent = blitter, this.x = x, this.y = y, this.frame = frame, this.data = {}, this.tint = 16777215, this._visible = visible, this._alpha = 1, this.flipX = !1, this.flipY = !1;
      },
      setFrame: function setFrame(frame) {
        return void 0 === frame ? this.frame = this.parent.frame : frame instanceof Frame && frame.texture === this.parent.texture ? this.frame = frame : this.frame = this.parent.texture.get(frame), this;
      },
      resetFlip: function resetFlip() {
        return this.flipX = !1, this.flipY = !1, this;
      },
      reset: function reset(x, y, frame) {
        return this.x = x, this.y = y, this.flipX = !1, this.flipY = !1, this._alpha = 1, this._visible = !0, this.parent.dirty = !0, frame && this.setFrame(frame), this;
      },
      setPosition: function setPosition(x, y) {
        return this.x = x, this.y = y, this;
      },
      setFlipX: function setFlipX(value) {
        return this.flipX = value, this;
      },
      setFlipY: function setFlipY(value) {
        return this.flipY = value, this;
      },
      setFlip: function setFlip(x, y) {
        return this.flipX = x, this.flipY = y, this;
      },
      setVisible: function setVisible(value) {
        return this.visible = value, this;
      },
      setAlpha: function setAlpha(value) {
        return this.alpha = value, this;
      },
      setTint: function setTint(value) {
        return this.tint = value, this;
      },
      destroy: function destroy() {
        this.parent.dirty = !0, this.parent.children.remove(this), this.parent = void 0, this.frame = void 0, this.data = void 0;
      },
      visible: {
        get: function get() {
          return this._visible;
        },
        set: function set(value) {
          this.parent.dirty |= this._visible !== value, this._visible = value;
        }
      },
      alpha: {
        get: function get() {
          return this._alpha;
        },
        set: function set(value) {
          this.parent.dirty |= 0 < this._alpha != 0 < value, this._alpha = value;
        }
      }
    });

    module.exports = Bob;
  }, function (module, exports, __webpack_require__) {
    var Rectangle = __webpack_require__(10);

    module.exports = function (rectA, h, out) {
      void 0 === out && (out = new Rectangle());
      var x = Math.min(rectA.x, h.x),
          y = Math.min(rectA.y, h.y),
          w = Math.max(rectA.right, h.right) - x,
          h = Math.max(rectA.bottom, h.bottom) - y;
      return out.setTo(x, y, w, h);
    };
  }, function (module, exports, __webpack_require__) {
    var Class = __webpack_require__(0),
        Components = __webpack_require__(11),
        DOMElement = __webpack_require__(1055),
        GameObject = __webpack_require__(15),
        IsPlainObject = __webpack_require__(7),
        RemoveFromDOM = __webpack_require__(202),
        SCENE_EVENTS = __webpack_require__(20),
        Vector4 = __webpack_require__(140),
        DOMElement = new Class({
      Extends: GameObject,
      Mixins: [Components.AlphaSingle, Components.BlendMode, Components.Depth, Components.Origin, Components.ScrollFactor, Components.Transform, Components.Visible, DOMElement],
      initialize: function initialize(scene, x, y, element, style, innerText) {
        GameObject.call(this, scene, "DOMElement"), this.parent = scene.sys.game.domContainer, this.cache = scene.sys.cache.html, this.node, this.transformOnly = !1, this.skewX = 0, this.skewY = 0, this.rotate3d = new Vector4(), this.rotate3dAngle = "deg", this.pointerEvents = "auto", this.width = 0, this.height = 0, this.displayWidth = 0, this.displayHeight = 0, this.handler = this.dispatchNativeEvent.bind(this), this.setPosition(x, y), "string" == typeof element ? "#" === element[0] ? this.setElement(element.substr(1), style, innerText) : this.createElement(element, style, innerText) : element && this.setElement(element, style, innerText), scene.sys.events.on(SCENE_EVENTS.SLEEP, this.handleSceneEvent, this), scene.sys.events.on(SCENE_EVENTS.WAKE, this.handleSceneEvent, this);
      },
      addedToScene: function addedToScene() {
        this.scene.sys.updateList.add(this);
      },
      removedFromScene: function removedFromScene() {
        this.scene.sys.updateList.remove(this);
      },
      handleSceneEvent: function handleSceneEvent(sys) {
        var node = this.node,
            style = node.style;
        node && (style.display = sys.settings.visible ? "block" : "none");
      },
      setSkew: function setSkew(x, y) {
        return void 0 === x && (x = 0), void 0 === y && (y = x), this.skewX = x, this.skewY = y, this;
      },
      setPerspective: function setPerspective(value) {
        return this.parent.style.perspective = value + "px", this;
      },
      perspective: {
        get: function get() {
          return parseFloat(this.parent.style.perspective);
        },
        set: function set(value) {
          this.parent.style.perspective = value + "px";
        }
      },
      addListener: function addListener(events) {
        if (this.node) {
          events = events.split(" ");

          for (var i = 0; i < events.length; i++) {
            this.node.addEventListener(events[i], this.handler, !1);
          }
        }

        return this;
      },
      removeListener: function removeListener(events) {
        if (this.node) {
          events = events.split(" ");

          for (var i = 0; i < events.length; i++) {
            this.node.removeEventListener(events[i], this.handler);
          }
        }

        return this;
      },
      dispatchNativeEvent: function dispatchNativeEvent(event) {
        this.emit(event.type, event);
      },
      createElement: function createElement(tagName, style, innerText) {
        return this.setElement(document.createElement(tagName), style, innerText);
      },
      setElement: function setElement(element, style, innerText) {
        var target;
        if (this.removeElement(), "string" == typeof element ? ("#" === element[0] && (element = element.substr(1)), target = document.getElementById(element)) : "object" == _typeof(element) && 1 === element.nodeType && (target = element), !target) return this;
        if (this.node = target, style && IsPlainObject(style)) for (var key in style) {
          target.style[key] = style[key];
        } else "string" == typeof style && (target.style = style);
        return target.style.zIndex = "0", target.style.display = "inline", target.style.position = "absolute", (target.phaser = this).parent && this.parent.appendChild(target), innerText && (target.innerText = innerText), this.updateSize();
      },
      createFromCache: function createFromCache(html, tagName) {
        html = this.cache.get(html);
        return html && this.createFromHTML(html, tagName), this;
      },
      createFromHTML: function createFromHTML(html, element) {
        void 0 === element && (element = "div"), this.removeElement();
        element = document.createElement(element);
        return (this.node = element).style.zIndex = "0", element.style.display = "inline", element.style.position = "absolute", (element.phaser = this).parent && this.parent.appendChild(element), element.innerHTML = html, this.updateSize();
      },
      removeElement: function removeElement() {
        return this.node && (RemoveFromDOM(this.node), this.node = null), this;
      },
      updateSize: function updateSize() {
        var node = this.node,
            nodeBounds = node.getBoundingClientRect();
        return this.width = node.clientWidth, this.height = node.clientHeight, this.displayWidth = nodeBounds.width || 0, this.displayHeight = nodeBounds.height || 0, this;
      },
      getChildByProperty: function getChildByProperty(property, value) {
        if (this.node) for (var children = this.node.querySelectorAll("*"), i = 0; i < children.length; i++) {
          if (children[i][property] === value) return children[i];
        }
        return null;
      },
      getChildByID: function getChildByID(id) {
        return this.getChildByProperty("id", id);
      },
      getChildByName: function getChildByName(name) {
        return this.getChildByProperty("name", name);
      },
      setClassName: function setClassName(className) {
        return this.node && (this.node.className = className, this.updateSize()), this;
      },
      setText: function setText(text) {
        return this.node && (this.node.innerText = text, this.updateSize()), this;
      },
      setHTML: function setHTML(html) {
        return this.node && (this.node.innerHTML = html, this.updateSize()), this;
      },
      preUpdate: function preUpdate() {
        var parent = this.parentContainer,
            node = this.node;
        node && parent && !parent.willRender() && (node.style.display = "none");
      },
      willRender: function willRender() {
        return !0;
      },
      preDestroy: function preDestroy() {
        this.removeElement(), this.scene.sys.events.off(SCENE_EVENTS.SLEEP, this.handleSceneEvent, this), this.scene.sys.events.off(SCENE_EVENTS.WAKE, this.handleSceneEvent, this);
      }
    });

    module.exports = DOMElement;
  }, function (module, exports, TransformMatrix) {
    var CSSBlendModes = TransformMatrix(1056),
        GameObject = TransformMatrix(15),
        TransformMatrix = TransformMatrix(25),
        tempMatrix1 = new TransformMatrix(),
        tempMatrix2 = new TransformMatrix(),
        tempMatrix3 = new TransformMatrix();

    module.exports = function (renderer, src, camera, parentMatrix) {
      var style, alpha, camMatrix, srcMatrix, calcMatrix, dx, dy, tx, ty;
      src.node && (style = src.node.style, tx = src.scene.sys.settings, !style || !tx.visible || GameObject.RENDER_MASK !== src.renderFlags || 0 !== src.cameraFilter && src.cameraFilter & camera.id || src.parentContainer && !src.parentContainer.willRender() ? style.display = "none" : (ty = src.parentContainer, alpha = camera.alpha * src.alpha, ty && (alpha *= ty.alpha), camMatrix = tempMatrix1, srcMatrix = tempMatrix2, calcMatrix = tempMatrix3, dy = dx = 0, ty = tx = "0%", parentMatrix ? (dx = src.width * src.scaleX * src.originX, dy = src.height * src.scaleY * src.originY, srcMatrix.applyITRS(src.x - dx, src.y - dy, src.rotation, src.scaleX, src.scaleY), camMatrix.copyFrom(camera.matrix), camMatrix.multiplyWithOffset(parentMatrix, -camera.scrollX * src.scrollFactorX, -camera.scrollY * src.scrollFactorY), srcMatrix.e = src.x - dx, srcMatrix.f = src.y - dy) : (dx = src.width * src.originX, dy = src.height * src.originY, srcMatrix.applyITRS(src.x - dx, src.y - dy, src.rotation, src.scaleX, src.scaleY), camMatrix.copyFrom(camera.matrix), tx = 100 * src.originX + "%", ty = 100 * src.originY + "%", srcMatrix.e -= camera.scrollX * src.scrollFactorX, srcMatrix.f -= camera.scrollY * src.scrollFactorY), camMatrix.multiply(srcMatrix, calcMatrix), src.transformOnly || (style.display = "block", style.opacity = alpha, style.zIndex = src._depth, style.pointerEvents = src.pointerEvents, style.mixBlendMode = CSSBlendModes[src._blendMode]), style.transform = calcMatrix.getCSSMatrix() + " skew(" + src.skewX + "rad, " + src.skewY + "rad) rotate3d(" + src.rotate3d.x + "," + src.rotate3d.y + "," + src.rotate3d.z + "," + src.rotate3d.w + src.rotate3dAngle + ")", style.transformOrigin = tx + " " + ty));
    };
  }, function (module, exports, Extern) {
    var Class = Extern(0),
        Components = Extern(11),
        GameObject = Extern(15),
        Extern = Extern(1060),
        Extern = new Class({
      Extends: GameObject,
      Mixins: [Components.Alpha, Components.BlendMode, Components.Depth, Components.Flip, Components.Origin, Components.ScrollFactor, Components.Size, Components.Texture, Components.Tint, Components.Transform, Components.Visible, Extern],
      initialize: function initialize(scene) {
        GameObject.call(this, scene, "Extern");
      },
      addedToScene: function addedToScene() {
        this.scene.sys.updateList.add(this);
      },
      removedFromScene: function removedFromScene() {
        this.scene.sys.updateList.remove(this);
      },
      preUpdate: function preUpdate() {},
      render: function render() {}
    });
    module.exports = Extern;
  }, function (module, exports, __webpack_require__) {
    var CircumferencePoint = __webpack_require__(218),
        FromPercent = __webpack_require__(98),
        MATH_CONST = __webpack_require__(14),
        Point = __webpack_require__(4);

    module.exports = function (ellipse, angle, out) {
      void 0 === out && (out = new Point());
      angle = FromPercent(angle, 0, MATH_CONST.PI2);
      return CircumferencePoint(ellipse, angle, out);
    };
  }, function (module, exports, __webpack_require__) {
    var Circumference = __webpack_require__(447),
        CircumferencePoint = __webpack_require__(218),
        FromPercent = __webpack_require__(98),
        MATH_CONST = __webpack_require__(14);

    module.exports = function (ellipse, quantity, stepRate, out) {
      void 0 === out && (out = []), !quantity && 0 < stepRate && (quantity = Circumference(ellipse) / stepRate);

      for (var i = 0; i < quantity; i++) {
        var angle = FromPercent(i / quantity, 0, MATH_CONST.PI2);
        out.push(CircumferencePoint(ellipse, angle));
      }

      return out;
    };
  }, function (module, exports) {
    module.exports = function (h) {
      var rx = h.width / 2,
          ry = h.height / 2,
          h = Math.pow(rx - ry, 2) / Math.pow(rx + ry, 2);
      return Math.PI * (rx + ry) * (1 + 3 * h / (10 + Math.sqrt(4 - 3 * h)));
    };
  }, function (module, exports, __webpack_require__) {
    var Commands = __webpack_require__(217),
        SetTransform = __webpack_require__(30);

    module.exports = function (renderer, src, camera, parentMatrix, renderTargetCtx, allowClip) {
      var commandBuffer = src.commandBuffer,
          commandBufferLength = commandBuffer.length,
          ctx = renderTargetCtx || renderer.currentContext;

      if (0 !== commandBufferLength && SetTransform(renderer, ctx, src, camera, parentMatrix)) {
        camera.addToRenderList(src);
        var lineColor, fillColor, fillAlpha;
        ctx.beginPath();

        for (var index = 0; index < commandBufferLength; ++index) {
          switch (commandBuffer[index]) {
            case Commands.ARC:
              ctx.arc(commandBuffer[index + 1], commandBuffer[index + 2], commandBuffer[index + 3], commandBuffer[index + 4], commandBuffer[index + 5], commandBuffer[index + 6]), index += 7;
              break;

            case Commands.LINE_STYLE:
              fillAlpha = commandBuffer[index + 1], lineColor = commandBuffer[index + 2], fillColor = commandBuffer[index + 3], ctx.strokeStyle = "rgba(" + ((16711680 & lineColor) >>> 16) + "," + ((65280 & lineColor) >>> 8) + "," + (255 & lineColor) + "," + fillColor + ")", ctx.lineWidth = fillAlpha, index += 3;
              break;

            case Commands.FILL_STYLE:
              fillColor = commandBuffer[index + 1], fillAlpha = commandBuffer[index + 2], ctx.fillStyle = "rgba(" + ((16711680 & fillColor) >>> 16) + "," + ((65280 & fillColor) >>> 8) + "," + (255 & fillColor) + "," + fillAlpha + ")", index += 2;
              break;

            case Commands.BEGIN_PATH:
              ctx.beginPath();
              break;

            case Commands.CLOSE_PATH:
              ctx.closePath();
              break;

            case Commands.FILL_PATH:
              allowClip || ctx.fill();
              break;

            case Commands.STROKE_PATH:
              allowClip || ctx.stroke();
              break;

            case Commands.FILL_RECT:
              allowClip ? ctx.rect(commandBuffer[index + 1], commandBuffer[index + 2], commandBuffer[index + 3], commandBuffer[index + 4]) : ctx.fillRect(commandBuffer[index + 1], commandBuffer[index + 2], commandBuffer[index + 3], commandBuffer[index + 4]), index += 4;
              break;

            case Commands.FILL_TRIANGLE:
              ctx.beginPath(), ctx.moveTo(commandBuffer[index + 1], commandBuffer[index + 2]), ctx.lineTo(commandBuffer[index + 3], commandBuffer[index + 4]), ctx.lineTo(commandBuffer[index + 5], commandBuffer[index + 6]), ctx.closePath(), allowClip || ctx.fill(), index += 6;
              break;

            case Commands.STROKE_TRIANGLE:
              ctx.beginPath(), ctx.moveTo(commandBuffer[index + 1], commandBuffer[index + 2]), ctx.lineTo(commandBuffer[index + 3], commandBuffer[index + 4]), ctx.lineTo(commandBuffer[index + 5], commandBuffer[index + 6]), ctx.closePath(), allowClip || ctx.stroke(), index += 6;
              break;

            case Commands.LINE_TO:
              ctx.lineTo(commandBuffer[index + 1], commandBuffer[index + 2]), index += 2;
              break;

            case Commands.MOVE_TO:
              ctx.moveTo(commandBuffer[index + 1], commandBuffer[index + 2]), index += 2;
              break;

            case Commands.LINE_FX_TO:
              ctx.lineTo(commandBuffer[index + 1], commandBuffer[index + 2]), index += 5;
              break;

            case Commands.MOVE_FX_TO:
              ctx.moveTo(commandBuffer[index + 1], commandBuffer[index + 2]), index += 5;
              break;

            case Commands.SAVE:
              ctx.save();
              break;

            case Commands.RESTORE:
              ctx.restore();
              break;

            case Commands.TRANSLATE:
              ctx.translate(commandBuffer[index + 1], commandBuffer[index + 2]), index += 2;
              break;

            case Commands.SCALE:
              ctx.scale(commandBuffer[index + 1], commandBuffer[index + 2]), index += 2;
              break;

            case Commands.ROTATE:
              ctx.rotate(commandBuffer[index + 1]), index += 1;
              break;

            case Commands.GRADIENT_FILL_STYLE:
              index += 5;
              break;

            case Commands.GRADIENT_LINE_STYLE:
              index += 6;
          }
        }

        ctx.restore();
      }
    };
  }, function (module, exports, __webpack_require__) {
    var EmitterOp = __webpack_require__(0),
        FloatBetween = __webpack_require__(137),
        GetEaseFunction = __webpack_require__(80),
        GetFastValue = __webpack_require__(2),
        Wrap = __webpack_require__(68),
        EmitterOp = new EmitterOp({
      initialize: function initialize(config, key, defaultValue, emitOnly) {
        void 0 === emitOnly && (emitOnly = !1), this.propertyKey = key, this.propertyValue = defaultValue, this.defaultValue = defaultValue, this.steps = 0, this.counter = 0, this.start = 0, this.end = 0, this.ease, this.emitOnly = emitOnly, this.onEmit = this.defaultEmit, this.onUpdate = this.defaultUpdate, this.loadConfig(config);
      },
      loadConfig: function loadConfig(config, newKey) {
        void 0 === config && (config = {}), newKey && (this.propertyKey = newKey), this.propertyValue = GetFastValue(config, this.propertyKey, this.defaultValue), this.setMethods(), this.emitOnly && (this.onUpdate = this.defaultUpdate);
      },
      toJSON: function toJSON() {
        return this.propertyValue;
      },
      onChange: function onChange(value) {
        return this.propertyValue = value, this.setMethods();
      },
      setMethods: function setMethods() {
        var easeType,
            rnd,
            value = this.propertyValue,
            t = _typeof(value);

        return this.onEmit = this.defaultEmit, this.onUpdate = this.defaultUpdate, "number" == t ? (this.onEmit = this.staticValueEmit, this.onUpdate = this.staticValueUpdate) : Array.isArray(value) ? this.onEmit = this.randomStaticValueEmit : "function" == t ? this.emitOnly ? this.onEmit = value : this.onUpdate = value : "object" == t && this.hasBoth(value, "start", "end") ? (this.start = value.start, this.end = value.end, (rnd = this.has(value, "random")) && (this.onEmit = this.randomRangedValueEmit), this.has(value, "steps") ? (this.steps = value.steps, this.counter = this.start, this.onEmit = this.steppedEmit) : (easeType = this.has(value, "ease") ? value.ease : "Linear", this.ease = GetEaseFunction(easeType, value.easeParams), rnd || (this.onEmit = this.easedValueEmit), this.onUpdate = this.easeValueUpdate)) : "object" == t && this.hasBoth(value, "min", "max") ? (this.start = value.min, this.end = value.max, this.onEmit = this.randomRangedValueEmit) : "object" == t && this.has(value, "random") ? (rnd = value.random, Array.isArray(rnd) && (this.start = rnd[0], this.end = rnd[1]), this.onEmit = this.randomRangedValueEmit) : "object" == t && this.hasEither(value, "onEmit", "onUpdate") && (this.has(value, "onEmit") && (this.onEmit = value.onEmit), this.has(value, "onUpdate") && (this.onUpdate = value.onUpdate)), this;
      },
      has: function has(object, key) {
        return object.hasOwnProperty(key);
      },
      hasBoth: function hasBoth(object, key1, key2) {
        return object.hasOwnProperty(key1) && object.hasOwnProperty(key2);
      },
      hasEither: function hasEither(object, key1, key2) {
        return object.hasOwnProperty(key1) || object.hasOwnProperty(key2);
      },
      defaultEmit: function defaultEmit(particle, key, value) {
        return value;
      },
      defaultUpdate: function defaultUpdate(particle, key, t, value) {
        return value;
      },
      staticValueEmit: function staticValueEmit() {
        return this.propertyValue;
      },
      staticValueUpdate: function staticValueUpdate() {
        return this.propertyValue;
      },
      randomStaticValueEmit: function randomStaticValueEmit() {
        var randomIndex = Math.floor(Math.random() * this.propertyValue.length);
        return this.propertyValue[randomIndex];
      },
      randomRangedValueEmit: function randomRangedValueEmit(particle, key) {
        var value = FloatBetween(this.start, this.end);
        return particle && particle.data[key] && (particle.data[key].min = value), value;
      },
      steppedEmit: function steppedEmit() {
        var current = this.counter,
            next = this.counter + (this.end - this.start) / this.steps;
        return this.counter = Wrap(next, this.start, this.end), current;
      },
      easedValueEmit: function easedValueEmit(particle, data) {
        return particle && particle.data[data] && ((data = particle.data[data]).min = this.start, data.max = this.end), this.start;
      },
      easeValueUpdate: function easeValueUpdate(particle, data, t) {
        data = particle.data[data];
        return (data.max - data.min) * this.ease(t) + data.min;
      }
    });

    module.exports = EmitterOp;
  }, function (module, exports, __webpack_require__) {
    var GravityWell = __webpack_require__(0),
        GetFastValue = __webpack_require__(2),
        GravityWell = new GravityWell({
      initialize: function initialize(x, y, power, epsilon, gravity) {
        var config;
        "object" == _typeof(x) ? (x = GetFastValue(config = x, "x", 0), y = GetFastValue(config, "y", 0), power = GetFastValue(config, "power", 0), epsilon = GetFastValue(config, "epsilon", 100), gravity = GetFastValue(config, "gravity", 50)) : (void 0 === x && (x = 0), void 0 === y && (y = 0), void 0 === power && (power = 0), void 0 === epsilon && (epsilon = 100), void 0 === gravity && (gravity = 50)), this.x = x, this.y = y, this.active = !0, this._gravity = gravity, this._power = 0, this._epsilon = 0, this.power = power, this.epsilon = epsilon;
      },
      update: function update(particle, delta) {
        var factor,
            x = this.x - particle.x,
            y = this.y - particle.y,
            dSq = x * x + y * y;
        0 !== dSq && (factor = Math.sqrt(dSq), dSq < this._epsilon && (dSq = this._epsilon), factor = this._power * delta / (dSq * factor) * 100, particle.velocityX += x * factor, particle.velocityY += y * factor);
      },
      epsilon: {
        get: function get() {
          return Math.sqrt(this._epsilon);
        },
        set: function set(value) {
          this._epsilon = value * value;
        }
      },
      power: {
        get: function get() {
          return this._power / this._gravity;
        },
        set: function set(value) {
          this._power = value * this._gravity;
        }
      },
      gravity: {
        get: function get() {
          return this._gravity;
        },
        set: function set(value) {
          var pwr = this.power;
          this._gravity = value, this.power = pwr;
        }
      }
    });

    module.exports = GravityWell;
  }, function (module, exports, __webpack_require__) {
    var Particle = __webpack_require__(0),
        DegToRad = __webpack_require__(36),
        DistanceBetween = __webpack_require__(50),
        Particle = new Particle({
      initialize: function initialize(emitter) {
        this.emitter = emitter, this.frame = null, this.x = 0, this.y = 0, this.velocityX = 0, this.velocityY = 0, this.accelerationX = 0, this.accelerationY = 0, this.maxVelocityX = 1e4, this.maxVelocityY = 1e4, this.bounce = 0, this.scaleX = 1, this.scaleY = 1, this.alpha = 1, this.angle = 0, this.rotation = 0, this.tint = 16777215, this.life = 1e3, this.lifeCurrent = 1e3, this.delayCurrent = 0, this.lifeT = 0, this.data = {
          tint: {
            min: 16777215,
            max: 16777215,
            current: 16777215
          },
          alpha: {
            min: 1,
            max: 1
          },
          rotate: {
            min: 0,
            max: 0
          },
          scaleX: {
            min: 1,
            max: 1
          },
          scaleY: {
            min: 1,
            max: 1
          }
        };
      },
      isAlive: function isAlive() {
        return 0 < this.lifeCurrent;
      },
      resetPosition: function resetPosition() {
        this.x = 0, this.y = 0;
      },
      fire: function fire(mx, speed) {
        var emitter = this.emitter;
        this.frame = emitter.getFrame(), emitter.emitZone && emitter.emitZone.getPoint(this), this.x += void 0 === mx ? emitter.x.onEmit(this, "x") : mx, this.y += void 0 === speed ? emitter.y.onEmit(this, "y") : speed, this.life = emitter.lifespan.onEmit(this, "lifespan"), this.lifeCurrent = this.life, this.lifeT = 0;
        var angle,
            sx = emitter.speedX.onEmit(this, "speedX"),
            sy = emitter.speedY ? emitter.speedY.onEmit(this, "speedY") : sx;
        emitter.radial ? (angle = DegToRad(emitter.angle.onEmit(this, "angle")), this.velocityX = Math.cos(angle) * Math.abs(sx), this.velocityY = Math.sin(angle) * Math.abs(sy)) : emitter.moveTo ? (mx = emitter.moveToX.onEmit(this, "moveToX"), speed = emitter.moveToY ? emitter.moveToY.onEmit(this, "moveToY") : mx, angle = Math.atan2(speed - this.y, mx - this.x), speed = DistanceBetween(this.x, this.y, mx, speed) / (this.life / 1e3), this.velocityX = Math.cos(angle) * speed, this.velocityY = Math.sin(angle) * speed) : (this.velocityX = sx, this.velocityY = sy), emitter.acceleration && (this.accelerationX = emitter.accelerationX.onEmit(this, "accelerationX"), this.accelerationY = emitter.accelerationY.onEmit(this, "accelerationY")), this.maxVelocityX = emitter.maxVelocityX.onEmit(this, "maxVelocityX"), this.maxVelocityY = emitter.maxVelocityY.onEmit(this, "maxVelocityY"), this.delayCurrent = emitter.delay.onEmit(this, "delay"), this.scaleX = emitter.scaleX.onEmit(this, "scaleX"), this.scaleY = emitter.scaleY ? emitter.scaleY.onEmit(this, "scaleY") : this.scaleX, this.angle = emitter.rotate.onEmit(this, "rotate"), this.rotation = DegToRad(this.angle), this.bounce = emitter.bounce.onEmit(this, "bounce"), this.alpha = emitter.alpha.onEmit(this, "alpha"), this.tint = emitter.tint.onEmit(this, "tint");
      },
      computeVelocity: function computeVelocity(emitter, delta, step, processors) {
        var vx = this.velocityX,
            vy = this.velocityY,
            ax = this.accelerationX,
            ay = this.accelerationY,
            mx = this.maxVelocityX,
            my = this.maxVelocityY;
        vx += emitter.gravityX * step, vy += emitter.gravityY * step, ax && (vx += ax * step), ay && (vy += ay * step), mx < vx ? vx = mx : vx < -mx && (vx = -mx), my < vy ? vy = my : vy < -my && (vy = -my), this.velocityX = vx, this.velocityY = vy;

        for (var i = 0; i < processors.length; i++) {
          processors[i].update(this, delta, step);
        }
      },
      checkBounds: function checkBounds(emitter) {
        var bounds = emitter.bounds,
            bounce = -this.bounce;
        this.x < bounds.x && emitter.collideLeft ? (this.x = bounds.x, this.velocityX *= bounce) : this.x > bounds.right && emitter.collideRight && (this.x = bounds.right, this.velocityX *= bounce), this.y < bounds.y && emitter.collideTop ? (this.y = bounds.y, this.velocityY *= bounce) : this.y > bounds.bottom && emitter.collideBottom && (this.y = bounds.bottom, this.velocityY *= bounce);
      },
      update: function update(delta, step, processors) {
        if (0 < this.delayCurrent) return this.delayCurrent -= delta, !1;
        var emitter = this.emitter,
            t = 1 - this.lifeCurrent / this.life;
        return this.lifeT = t, this.computeVelocity(emitter, delta, step, processors), this.x += this.velocityX * step, this.y += this.velocityY * step, emitter.bounds && this.checkBounds(emitter), emitter.deathZone && emitter.deathZone.willKill(this) ? !(this.lifeCurrent = 0) : (this.scaleX = emitter.scaleX.onUpdate(this, "scaleX", t, this.scaleX), emitter.scaleY ? this.scaleY = emitter.scaleY.onUpdate(this, "scaleY", t, this.scaleY) : this.scaleY = this.scaleX, this.angle = emitter.rotate.onUpdate(this, "rotate", t, this.angle), this.rotation = DegToRad(this.angle), this.alpha = emitter.alpha.onUpdate(this, "alpha", t, this.alpha), this.tint = emitter.tint.onUpdate(this, "tint", t, this.tint), this.lifeCurrent -= delta, this.lifeCurrent <= 0);
      }
    });

    module.exports = Particle;
  }, function (module, exports, __webpack_require__) {
    var BlendModes = __webpack_require__(35),
        Class = __webpack_require__(0),
        ParticleEmitter = __webpack_require__(11),
        DeathZone = __webpack_require__(453),
        EdgeZone = __webpack_require__(454),
        EmitterOp = __webpack_require__(449),
        GetFastValue = __webpack_require__(2),
        GetRandom = __webpack_require__(210),
        HasAny = __webpack_require__(455),
        HasValue = __webpack_require__(126),
        Particle = __webpack_require__(451),
        RandomZone = __webpack_require__(456),
        Rectangle = __webpack_require__(10),
        StableSort = __webpack_require__(79),
        Vector2 = __webpack_require__(3),
        Wrap = __webpack_require__(68),
        ParticleEmitter = new Class({
      Mixins: [ParticleEmitter.BlendMode, ParticleEmitter.Mask, ParticleEmitter.ScrollFactor, ParticleEmitter.Visible],
      initialize: function initialize(manager, config) {
        this.manager = manager, this.texture = manager.texture, this.frames = [manager.defaultFrame], this.defaultFrame = manager.defaultFrame, this.configFastMap = ["active", "blendMode", "collideBottom", "collideLeft", "collideRight", "collideTop", "deathCallback", "deathCallbackScope", "emitCallback", "emitCallbackScope", "follow", "frequency", "gravityX", "gravityY", "maxParticles", "name", "on", "particleBringToTop", "particleClass", "radial", "timeScale", "trackVisible", "visible"], this.configOpMap = ["accelerationX", "accelerationY", "angle", "alpha", "bounce", "delay", "lifespan", "maxVelocityX", "maxVelocityY", "moveToX", "moveToY", "quantity", "rotate", "scaleX", "scaleY", "speedX", "speedY", "tint", "x", "y"], this.name = "", this.particleClass = Particle, this.x = new EmitterOp(config, "x", 0, !0), this.y = new EmitterOp(config, "y", 0, !0), this.radial = !0, this.gravityX = 0, this.gravityY = 0, this.acceleration = !1, this.accelerationX = new EmitterOp(config, "accelerationX", 0, !0), this.accelerationY = new EmitterOp(config, "accelerationY", 0, !0), this.maxVelocityX = new EmitterOp(config, "maxVelocityX", 1e4, !0), this.maxVelocityY = new EmitterOp(config, "maxVelocityY", 1e4, !0), this.speedX = new EmitterOp(config, "speedX", 0, !0), this.speedY = new EmitterOp(config, "speedY", 0, !0), this.moveTo = !1, this.moveToX = new EmitterOp(config, "moveToX", 0, !0), this.moveToY = new EmitterOp(config, "moveToY", 0, !0), this.bounce = new EmitterOp(config, "bounce", 0, !0), this.scaleX = new EmitterOp(config, "scaleX", 1), this.scaleY = new EmitterOp(config, "scaleY", 1), this.tint = new EmitterOp(config, "tint", 16777215), this.alpha = new EmitterOp(config, "alpha", 1), this.lifespan = new EmitterOp(config, "lifespan", 1e3, !0), this.angle = new EmitterOp(config, "angle", {
          min: 0,
          max: 360
        }, !0), this.rotate = new EmitterOp(config, "rotate", 0), this.emitCallback = null, this.emitCallbackScope = null, this.deathCallback = null, this.deathCallbackScope = null, this.maxParticles = 0, this.quantity = new EmitterOp(config, "quantity", 1, !0), this.delay = new EmitterOp(config, "delay", 0, !0), this.frequency = 0, this.on = !0, this.particleBringToTop = !0, this.timeScale = 1, this.emitZone = null, this.deathZone = null, this.bounds = null, this.collideLeft = !0, this.collideRight = !0, this.collideTop = !0, this.collideBottom = !0, this.active = !0, this.visible = !0, this.blendMode = BlendModes.NORMAL, this.follow = null, this.followOffset = new Vector2(), this.trackVisible = !1, this.currentFrame = 0, this.randomFrame = !0, this.frameQuantity = 1, this.dead = [], this.alive = [], this._counter = 0, this._frameCounter = 0, config && this.fromJSON(config);
      },
      fromJSON: function fromJSON(config) {
        if (!config) return this;

        for (var callbackScope, i = 0, key = "", i = 0; i < this.configFastMap.length; i++) {
          key = this.configFastMap[i], HasValue(config, key) && (this[key] = GetFastValue(config, key));
        }

        for (i = 0; i < this.configOpMap.length; i++) {
          key = this.configOpMap[i], HasValue(config, key) && this[key].loadConfig(config);
        }

        return this.acceleration = 0 !== this.accelerationX.propertyValue || 0 !== this.accelerationY.propertyValue, this.moveTo = 0 !== this.moveToX.propertyValue || 0 !== this.moveToY.propertyValue, HasValue(config, "speed") && (this.speedX.loadConfig(config, "speed"), this.speedY = null), (HasAny(config, ["speedX", "speedY"]) || this.moveTo) && (this.radial = !1), HasValue(config, "scale") && (this.scaleX.loadConfig(config, "scale"), this.scaleY = null), HasValue(config, "callbackScope") && (callbackScope = GetFastValue(config, "callbackScope", null), this.emitCallbackScope = callbackScope, this.deathCallbackScope = callbackScope), HasValue(config, "emitZone") && this.setEmitZone(config.emitZone), HasValue(config, "deathZone") && this.setDeathZone(config.deathZone), HasValue(config, "bounds") && this.setBounds(config.bounds), HasValue(config, "followOffset") && this.followOffset.setFromObject(GetFastValue(config, "followOffset", 0)), HasValue(config, "frame") && this.setFrame(config.frame), HasValue(config, "reserve") && this.reserve(config.reserve), this;
      },
      toJSON: function toJSON(output) {
        void 0 === output && (output = {});

        for (var i = 0, key = "", i = 0; i < this.configFastMap.length; i++) {
          output[key = this.configFastMap[i]] = this[key];
        }

        for (i = 0; i < this.configOpMap.length; i++) {
          this[key = this.configOpMap[i]] && (output[key] = this[key].toJSON());
        }

        return this.speedY || (delete output.speedX, output.speed = this.speedX.toJSON()), this.scaleY || (delete output.scaleX, output.scale = this.scaleX.toJSON()), output;
      },
      startFollow: function startFollow(target, offsetX, offsetY, trackVisible) {
        return void 0 === offsetX && (offsetX = 0), void 0 === offsetY && (offsetY = 0), void 0 === trackVisible && (trackVisible = !1), this.follow = target, this.followOffset.set(offsetX, offsetY), this.trackVisible = trackVisible, this;
      },
      stopFollow: function stopFollow() {
        return this.follow = null, this.followOffset.set(0, 0), this.trackVisible = !1, this;
      },
      getFrame: function getFrame() {
        if (1 === this.frames.length) return this.defaultFrame;
        if (this.randomFrame) return GetRandom(this.frames);
        var frame = this.frames[this.currentFrame];
        return this._frameCounter++, this._frameCounter === this.frameQuantity && (this._frameCounter = 0, this.currentFrame = Wrap(this.currentFrame + 1, 0, this._frameLength)), frame;
      },
      setFrame: function setFrame(isCycle, frameConfig, quantity) {
        void 0 === quantity && (quantity = 1), this.randomFrame = frameConfig = void 0 === frameConfig ? !0 : frameConfig, this.frameQuantity = quantity, this.currentFrame = 0, this._frameCounter = 0;

        var frameConfig = _typeof(isCycle);

        return Array.isArray(isCycle) || "string" == frameConfig || "number" == frameConfig ? this.manager.setEmitterFrames(isCycle, this) : "object" == frameConfig && ((isCycle = GetFastValue(frameConfig = isCycle, "frames", null)) && this.manager.setEmitterFrames(isCycle, this), isCycle = GetFastValue(frameConfig, "cycle", !1), this.randomFrame = !isCycle, this.frameQuantity = GetFastValue(frameConfig, "quantity", quantity)), this._frameLength = this.frames.length, 1 === this._frameLength && (this.frameQuantity = 1, this.randomFrame = !1), this;
      },
      setRadial: function setRadial(value) {
        return this.radial = value = void 0 === value ? !0 : value, this;
      },
      setPosition: function setPosition(x, y) {
        return this.x.onChange(x), this.y.onChange(y), this;
      },
      setBounds: function setBounds(x, y, width, height) {
        var obj;
        return "object" == _typeof(x) && (x = (obj = x).x, y = obj.y, width = HasValue(obj, "w") ? obj.w : obj.width, height = HasValue(obj, "h") ? obj.h : obj.height), this.bounds ? this.bounds.setTo(x, y, width, height) : this.bounds = new Rectangle(x, y, width, height), this;
      },
      setSpeedX: function setSpeedX(value) {
        return this.speedX.onChange(value), this.radial = !1, this;
      },
      setSpeedY: function setSpeedY(value) {
        return this.speedY && (this.speedY.onChange(value), this.radial = !1), this;
      },
      setSpeed: function setSpeed(value) {
        return this.speedX.onChange(value), this.speedY = null, this.radial = !0, this;
      },
      setScaleX: function setScaleX(value) {
        return this.scaleX.onChange(value), this;
      },
      setScaleY: function setScaleY(value) {
        return this.scaleY.onChange(value), this;
      },
      setScale: function setScale(value) {
        return this.scaleX.onChange(value), this.scaleY = null, this;
      },
      setGravityX: function setGravityX(value) {
        return this.gravityX = value, this;
      },
      setGravityY: function setGravityY(value) {
        return this.gravityY = value, this;
      },
      setGravity: function setGravity(x, y) {
        return this.gravityX = x, this.gravityY = y, this;
      },
      setAlpha: function setAlpha(value) {
        return this.alpha.onChange(value), this;
      },
      setTint: function setTint(value) {
        return this.tint.onChange(value), this;
      },
      setEmitterAngle: function setEmitterAngle(value) {
        return this.angle.onChange(value), this;
      },
      setAngle: function setAngle(value) {
        return this.angle.onChange(value), this;
      },
      setLifespan: function setLifespan(value) {
        return this.lifespan.onChange(value), this;
      },
      setQuantity: function setQuantity(quantity) {
        return this.quantity.onChange(quantity), this;
      },
      setFrequency: function setFrequency(frequency, quantity) {
        return this.frequency = frequency, this._counter = 0, quantity && this.quantity.onChange(quantity), this;
      },
      setEmitZone: function setEmitZone(zoneConfig) {
        if (void 0 === zoneConfig) this.emitZone = null;else {
          var type = GetFastValue(zoneConfig, "type", "random"),
              source = GetFastValue(zoneConfig, "source", null);

          switch (type) {
            case "random":
              this.emitZone = new RandomZone(source);
              break;

            case "edge":
              var quantity = GetFastValue(zoneConfig, "quantity", 1),
                  stepRate = GetFastValue(zoneConfig, "stepRate", 0),
                  yoyo = GetFastValue(zoneConfig, "yoyo", !1),
                  seamless = GetFastValue(zoneConfig, "seamless", !0);
              this.emitZone = new EdgeZone(source, quantity, stepRate, yoyo, seamless);
          }
        }
        return this;
      },
      setDeathZone: function setDeathZone(source) {
        var type;
        return void 0 === source ? this.deathZone = null : (type = GetFastValue(source, "type", "onEnter"), (source = GetFastValue(source, "source", null)) && "function" == typeof source.contains && (this.deathZone = new DeathZone(source, "onEnter" === type))), this;
      },
      reserve: function reserve(particleCount) {
        for (var dead = this.dead, i = 0; i < particleCount; i++) {
          dead.push(new this.particleClass(this));
        }

        return this;
      },
      getAliveParticleCount: function getAliveParticleCount() {
        return this.alive.length;
      },
      getDeadParticleCount: function getDeadParticleCount() {
        return this.dead.length;
      },
      getParticleCount: function getParticleCount() {
        return this.getAliveParticleCount() + this.getDeadParticleCount();
      },
      atLimit: function atLimit() {
        return 0 < this.maxParticles && this.getParticleCount() === this.maxParticles;
      },
      onParticleEmit: function onParticleEmit(callback, context) {
        return void 0 === callback ? (this.emitCallback = null, this.emitCallbackScope = null) : "function" == typeof callback && (this.emitCallback = callback, context && (this.emitCallbackScope = context)), this;
      },
      onParticleDeath: function onParticleDeath(callback, context) {
        return void 0 === callback ? (this.deathCallback = null, this.deathCallbackScope = null) : "function" == typeof callback && (this.deathCallback = callback, context && (this.deathCallbackScope = context)), this;
      },
      killAll: function killAll() {
        for (var dead = this.dead, alive = this.alive; 0 < alive.length;) {
          dead.push(alive.pop());
        }

        return this;
      },
      forEachAlive: function forEachAlive(callback, context) {
        for (var alive = this.alive, length = alive.length, index = 0; index < length; ++index) {
          callback.call(context, alive[index], this);
        }

        return this;
      },
      forEachDead: function forEachDead(callback, context) {
        for (var dead = this.dead, length = dead.length, index = 0; index < length; ++index) {
          callback.call(context, dead[index], this);
        }

        return this;
      },
      start: function start() {
        return this.on = !0, this._counter = 0, this;
      },
      stop: function stop() {
        return this.on = !1, this;
      },
      pause: function pause() {
        return this.active = !1, this;
      },
      resume: function resume() {
        return this.active = !0, this;
      },
      remove: function remove() {
        return this.manager.removeEmitter(this), this;
      },
      depthSort: function depthSort() {
        return StableSort(this.alive, this.depthSortCallback), this;
      },
      flow: function flow(frequency, count) {
        return void 0 === count && (count = 1), this.frequency = frequency, this.quantity.onChange(count), this.start();
      },
      explode: function explode(count, x, y) {
        return this.frequency = -1, this.emitParticle(count, x, y);
      },
      emitParticleAt: function emitParticleAt(x, y, count) {
        return this.emitParticle(count, x, y);
      },
      emitParticle: function emitParticle(count, x, y) {
        if (!this.atLimit()) {
          void 0 === count && (count = this.quantity.onEmit());

          for (var dead = this.dead, followX = this.follow ? this.follow.x + this.followOffset.x : x, followY = this.follow ? this.follow.y + this.followOffset.y : y, i = 0; i < count; i++) {
            var particle = dead.pop();
            if ((particle = particle || new this.particleClass(this)).fire(followX, followY), this.particleBringToTop ? this.alive.push(particle) : this.alive.unshift(particle), this.emitCallback && this.emitCallback.call(this.emitCallbackScope, particle, this), this.atLimit()) break;
          }

          return particle;
        }
      },
      preUpdate: function preUpdate(time, delta) {
        var step = (delta *= this.timeScale) / 1e3;
        this.trackVisible && (this.visible = this.follow.visible);
        var processors = this.manager.getProcessors(),
            particles = this.alive,
            dead = this.dead,
            i = 0,
            rip = [],
            length = particles.length;

        for (i = 0; i < length; i++) {
          var particle = particles[i];
          particle.update(delta, step, processors) && rip.push({
            index: i,
            particle: particle
          });
        }

        if (0 < (length = rip.length)) for (var deathCallback = this.deathCallback, deathCallbackScope = this.deathCallbackScope, i = length - 1; 0 <= i; i--) {
          var entry = rip[i];
          particles.splice(entry.index, 1), dead.push(entry.particle), deathCallback && deathCallback.call(deathCallbackScope, entry.particle), entry.particle.resetPosition();
        }
        this.on && (0 === this.frequency ? this.emitParticle() : 0 < this.frequency && (this._counter -= delta, this._counter <= 0 && (this.emitParticle(), this._counter = this.frequency - Math.abs(this._counter))));
      },
      depthSortCallback: function depthSortCallback(a, b) {
        return a.y - b.y;
      }
    });

    module.exports = ParticleEmitter;
  }, function (module, exports, DeathZone) {
    DeathZone = new (DeathZone(0))({
      initialize: function initialize(source, killOnEnter) {
        this.source = source, this.killOnEnter = killOnEnter;
      },
      willKill: function willKill(withinZone) {
        withinZone = this.source.contains(withinZone.x, withinZone.y);
        return withinZone && this.killOnEnter || !withinZone && !this.killOnEnter;
      }
    });
    module.exports = DeathZone;
  }, function (module, exports, EdgeZone) {
    EdgeZone = new (EdgeZone(0))({
      initialize: function initialize(source, quantity, stepRate, yoyo, seamless) {
        void 0 === yoyo && (yoyo = !1), void 0 === seamless && (seamless = !0), this.source = source, this.points = [], this.quantity = quantity, this.stepRate = stepRate, this.yoyo = yoyo, this.counter = -1, this.seamless = seamless, this._length = 0, this._direction = 0, this.updateSource();
      },
      updateSource: function updateSource() {
        var a;
        this.points = this.source.getPoints(this.quantity, this.stepRate), this.seamless && (a = this.points[0], oldLength = this.points[this.points.length - 1], a.x === oldLength.x && a.y === oldLength.y && this.points.pop());
        var oldLength = this._length;
        return this._length = this.points.length, this._length < oldLength && this.counter > this._length && (this.counter = this._length - 1), this;
      },
      changeSource: function changeSource(source) {
        return this.source = source, this.updateSource();
      },
      getPoint: function getPoint(particle) {
        0 === this._direction ? (this.counter++, this.counter >= this._length && (this.yoyo ? (this._direction = 1, this.counter = this._length - 1) : this.counter = 0)) : (this.counter--, -1 === this.counter && (this.yoyo ? (this._direction = 0, this.counter = 0) : this.counter = this._length - 1));
        var point = this.points[this.counter];
        point && (particle.x = point.x, particle.y = point.y);
      }
    });
    module.exports = EdgeZone;
  }, function (module, exports) {
    module.exports = function (source, keys) {
      for (var i = 0; i < keys.length; i++) {
        if (source.hasOwnProperty(keys[i])) return !0;
      }

      return !1;
    };
  }, function (module, exports, __webpack_require__) {
    var RandomZone = __webpack_require__(0),
        Vector2 = __webpack_require__(3),
        RandomZone = new RandomZone({
      initialize: function initialize(source) {
        this.source = source, this._tempVec = new Vector2();
      },
      getPoint: function getPoint(particle) {
        var vec = this._tempVec;
        this.source.getRandomPoint(vec), particle.x = vec.x, particle.y = vec.y;
      }
    });

    module.exports = RandomZone;
  }, function (module, exports, __webpack_require__) {
    var Class = __webpack_require__(0),
        PathFollower = __webpack_require__(11),
        Sprite = __webpack_require__(73),
        PathFollower = new Class({
      Extends: Sprite,
      Mixins: [PathFollower.PathFollower],
      initialize: function initialize(scene, path, x, y, texture, frame) {
        Sprite.call(this, scene, x, y, texture, frame), this.path = path;
      },
      preUpdate: function preUpdate(time, delta) {
        this.anims.update(time, delta), this.pathUpdate(time);
      }
    });

    module.exports = PathFollower;
  }, function (module, exports) {
    module.exports = function (lineSpacing, height, lines) {
      var lineHeight = lineSpacing.canvas,
          context = lineSpacing.context,
          style = lineSpacing.style,
          lineWidths = [],
          maxLineWidth = 0,
          drawnLines = lines.length;
      0 < style.maxLines && style.maxLines < lines.length && (drawnLines = style.maxLines), style.syncFont(lineHeight, context);

      for (var i = 0; i < drawnLines; i++) {
        var lineWidth = style.strokeThickness;
        lineWidth += context.measureText(lines[i]).width, style.wordWrap && (lineWidth -= context.measureText(" ").width), lineWidths[i] = Math.ceil(lineWidth), maxLineWidth = Math.max(maxLineWidth, lineWidths[i]);
      }

      lineHeight = height.fontSize + style.strokeThickness, height = lineHeight * drawnLines, lineSpacing = lineSpacing.lineSpacing;
      return 1 < drawnLines && (height += lineSpacing * (drawnLines - 1)), {
        width: maxLineWidth,
        height: height,
        lines: drawnLines,
        lineWidths: lineWidths,
        lineSpacing: lineSpacing,
        lineHeight: lineHeight
      };
    };
  }, function (module, exports, __webpack_require__) {
    var TextStyle = __webpack_require__(0),
        GetAdvancedValue = __webpack_require__(13),
        GetValue = __webpack_require__(6),
        MeasureText = __webpack_require__(460),
        propertyMap = {
      fontFamily: ["fontFamily", "Courier"],
      fontSize: ["fontSize", "16px"],
      fontStyle: ["fontStyle", ""],
      backgroundColor: ["backgroundColor", null],
      color: ["color", "#fff"],
      stroke: ["stroke", "#fff"],
      strokeThickness: ["strokeThickness", 0],
      shadowOffsetX: ["shadow.offsetX", 0],
      shadowOffsetY: ["shadow.offsetY", 0],
      shadowColor: ["shadow.color", "#000"],
      shadowBlur: ["shadow.blur", 0],
      shadowStroke: ["shadow.stroke", !1],
      shadowFill: ["shadow.fill", !1],
      align: ["align", "left"],
      maxLines: ["maxLines", 0],
      fixedWidth: ["fixedWidth", 0],
      fixedHeight: ["fixedHeight", 0],
      resolution: ["resolution", 0],
      rtl: ["rtl", !1],
      testString: ["testString", "|MÃ‰qgy"],
      baselineX: ["baselineX", 1.2],
      baselineY: ["baselineY", 1.4],
      wordWrapWidth: ["wordWrap.width", null],
      wordWrapCallback: ["wordWrap.callback", null],
      wordWrapCallbackScope: ["wordWrap.callbackScope", null],
      wordWrapUseAdvanced: ["wordWrap.useAdvancedWrap", !1]
    },
        TextStyle = new TextStyle({
      initialize: function initialize(text, metrics) {
        this.parent = text, this.fontFamily, this.fontSize, this.fontStyle, this.backgroundColor, this.color, this.stroke, this.strokeThickness, this.shadowOffsetX, this.shadowOffsetY, this.shadowColor, this.shadowBlur, this.shadowStroke, this.shadowFill, this.align, this.maxLines, this.fixedWidth, this.fixedHeight, this.resolution, this.rtl, this.testString, this.baselineX, this.baselineY, this.wordWrapWidth, this.wordWrapCallback, this.wordWrapCallbackScope, this.wordWrapUseAdvanced, this._font, this.setStyle(metrics, !1, !0);
        metrics = GetValue(metrics, "metrics", !1);
        this.metrics = metrics ? {
          ascent: GetValue(metrics, "ascent", 0),
          descent: GetValue(metrics, "descent", 0),
          fontSize: GetValue(metrics, "fontSize", 0)
        } : MeasureText(this);
      },
      setStyle: function setStyle(style, updateText, setDefaults) {
        for (var key in void 0 === updateText && (updateText = !0), void 0 === setDefaults && (setDefaults = !1), style && style.hasOwnProperty("fontSize") && "number" == typeof style.fontSize && (style.fontSize = style.fontSize.toString() + "px"), propertyMap) {
          var value = setDefaults ? propertyMap[key][1] : this[key];
          this[key] = ("wordWrapCallback" === key || "wordWrapCallbackScope" === key ? GetValue : GetAdvancedValue)(style, propertyMap[key][0], value);
        }

        var fill = GetValue(style, "font", null);
        null !== fill && this.setFont(fill, !1), this._font = [this.fontStyle, this.fontSize, this.fontFamily].join(" ").trim();
        fill = GetValue(style, "fill", null);
        return null !== fill && (this.color = fill), updateText ? this.update(!0) : this.parent;
      },
      syncFont: function syncFont(canvas, context) {
        context.font = this._font;
      },
      syncStyle: function syncStyle(canvas, context) {
        context.textBaseline = "alphabetic", context.fillStyle = this.color, context.strokeStyle = this.stroke, context.lineWidth = this.strokeThickness, context.lineCap = "round", context.lineJoin = "round";
      },
      syncShadow: function syncShadow(context, enabled) {
        enabled ? (context.shadowOffsetX = this.shadowOffsetX, context.shadowOffsetY = this.shadowOffsetY, context.shadowColor = this.shadowColor, context.shadowBlur = this.shadowBlur) : (context.shadowOffsetX = 0, context.shadowOffsetY = 0, context.shadowColor = 0, context.shadowBlur = 0);
      },
      update: function update(recalculateMetrics) {
        return recalculateMetrics && (this._font = [this.fontStyle, this.fontSize, this.fontFamily].join(" ").trim(), this.metrics = MeasureText(this)), this.parent.updateText();
      },
      setFont: function setFont(fontSplit, updateText) {
        void 0 === updateText && (updateText = !0);
        var i,
            fontFamily = fontSplit,
            fontSize = "",
            fontStyle = "";
        return "string" != typeof fontSplit ? (fontFamily = GetValue(fontSplit, "fontFamily", "Courier"), fontSize = GetValue(fontSplit, "fontSize", "16px"), fontStyle = GetValue(fontSplit, "fontStyle", "")) : (i = 0, fontStyle = 2 < (fontSplit = fontSplit.split(" ")).length ? fontSplit[i++] : "", fontSize = fontSplit[i++] || "16px", fontFamily = fontSplit[i++] || "Courier"), fontFamily === this.fontFamily && fontSize === this.fontSize && fontStyle === this.fontStyle || (this.fontFamily = fontFamily, this.fontSize = fontSize, this.fontStyle = fontStyle, updateText && this.update(!0)), this.parent;
      },
      setFontFamily: function setFontFamily(family) {
        return this.fontFamily !== family && (this.fontFamily = family, this.update(!0)), this.parent;
      },
      setFontStyle: function setFontStyle(style) {
        return this.fontStyle !== style && (this.fontStyle = style, this.update(!0)), this.parent;
      },
      setFontSize: function setFontSize(size) {
        return "number" == typeof size && (size = size.toString() + "px"), this.fontSize !== size && (this.fontSize = size, this.update(!0)), this.parent;
      },
      setTestString: function setTestString(string) {
        return this.testString = string, this.update(!0);
      },
      setFixedSize: function setFixedSize(width, height) {
        return this.fixedWidth = width, this.fixedHeight = height, width && (this.parent.width = width), height && (this.parent.height = height), this.update(!1);
      },
      setBackgroundColor: function setBackgroundColor(color) {
        return this.backgroundColor = color, this.update(!1);
      },
      setFill: function setFill(color) {
        return this.color = color, this.update(!1);
      },
      setColor: function setColor(color) {
        return this.color = color, this.update(!1);
      },
      setResolution: function setResolution(value) {
        return this.resolution = value, this.update(!1);
      },
      setStroke: function setStroke(color, thickness) {
        return void 0 === thickness && (thickness = this.strokeThickness), void 0 === color && 0 !== this.strokeThickness ? (this.strokeThickness = 0, this.update(!0)) : this.stroke === color && this.strokeThickness === thickness || (this.stroke = color, this.strokeThickness = thickness, this.update(!0)), this.parent;
      },
      setShadow: function setShadow(x, y, color, blur, shadowStroke, shadowFill) {
        return void 0 === y && (y = 0), void 0 === color && (color = "#000"), void 0 === blur && (blur = 0), void 0 === shadowStroke && (shadowStroke = !1), void 0 === shadowFill && (shadowFill = !0), this.shadowOffsetX = x = void 0 === x ? 0 : x, this.shadowOffsetY = y, this.shadowColor = color, this.shadowBlur = blur, this.shadowStroke = shadowStroke, this.shadowFill = shadowFill, this.update(!1);
      },
      setShadowOffset: function setShadowOffset(x, y) {
        return void 0 === x && (x = 0), void 0 === y && (y = x), this.shadowOffsetX = x, this.shadowOffsetY = y, this.update(!1);
      },
      setShadowColor: function setShadowColor(color) {
        return this.shadowColor = color = void 0 === color ? "#000" : color, this.update(!1);
      },
      setShadowBlur: function setShadowBlur(blur) {
        return this.shadowBlur = blur = void 0 === blur ? 0 : blur, this.update(!1);
      },
      setShadowStroke: function setShadowStroke(enabled) {
        return this.shadowStroke = enabled, this.update(!1);
      },
      setShadowFill: function setShadowFill(enabled) {
        return this.shadowFill = enabled, this.update(!1);
      },
      setWordWrapWidth: function setWordWrapWidth(width, useAdvancedWrap) {
        return void 0 === useAdvancedWrap && (useAdvancedWrap = !1), this.wordWrapWidth = width, this.wordWrapUseAdvanced = useAdvancedWrap, this.update(!1);
      },
      setWordWrapCallback: function setWordWrapCallback(callback, scope) {
        return void 0 === scope && (scope = null), this.wordWrapCallback = callback, this.wordWrapCallbackScope = scope, this.update(!1);
      },
      setAlign: function setAlign(align) {
        return this.align = align = void 0 === align ? "left" : align, this.update(!1);
      },
      setMaxLines: function setMaxLines(max) {
        return this.maxLines = max = void 0 === max ? 0 : max, this.update(!1);
      },
      getTextMetrics: function getTextMetrics() {
        var metrics = this.metrics;
        return {
          ascent: metrics.ascent,
          descent: metrics.descent,
          fontSize: metrics.fontSize
        };
      },
      toJSON: function toJSON() {
        var key,
            output = {};

        for (key in propertyMap) {
          output[key] = this[key];
        }

        return output.metrics = this.getTextMetrics(), output;
      },
      destroy: function destroy() {
        this.parent = void 0;
      }
    });

    module.exports = TextStyle;
  }, function (module, exports, __webpack_require__) {
    var CanvasPool = __webpack_require__(31);

    module.exports = function (output) {
      var canvas = CanvasPool.create(this),
          numPixels = canvas.getContext("2d");
      output.syncFont(canvas, numPixels);
      var height = numPixels.measureText(output.testString);

      if ("actualBoundingBoxAscent" in height) {
        var ascent = height.actualBoundingBoxAscent,
            width = height.actualBoundingBoxDescent;
        return CanvasPool.remove(canvas), {
          ascent: ascent,
          descent: width,
          fontSize: ascent + width
        };
      }

      var width = Math.ceil(height.width * output.baselineX),
          height = 2 * width,
          baseline = width * output.baselineY | 0;
      canvas.width = width, canvas.height = height, numPixels.fillStyle = "#f00", numPixels.fillRect(0, 0, width, height), numPixels.font = output._font, numPixels.textBaseline = "alphabetic", numPixels.fillStyle = "#000", numPixels.fillText(output.testString, 0, baseline);
      output = {
        ascent: 0,
        descent: 0,
        fontSize: 0
      }, numPixels = numPixels.getImageData(0, 0, width, height);
      if (!numPixels) return output.ascent = baseline, output.descent = 6 + baseline, output.fontSize = output.ascent + output.descent, CanvasPool.remove(canvas), output;

      for (var j, pixels = numPixels.data, numPixels = pixels.length, line = 4 * width, idx = 0, stop = !1, i = 0; i < baseline; i++) {
        for (j = 0; j < line; j += 4) {
          if (255 !== pixels[idx + j]) {
            stop = !0;
            break;
          }
        }

        if (stop) break;
        idx += line;
      }

      for (output.ascent = baseline - i, idx = numPixels - line, stop = !1, i = height; baseline < i; i--) {
        for (j = 0; j < line; j += 4) {
          if (255 !== pixels[idx + j]) {
            stop = !0;
            break;
          }
        }

        if (stop) break;
        idx -= line;
      }

      return output.descent = i - baseline, output.fontSize = output.ascent + output.descent, CanvasPool.remove(canvas), output;
    };
  }, function (module, exports, __webpack_require__) {
    var Arc = __webpack_require__(1097),
        Class = __webpack_require__(0),
        DegToRad = __webpack_require__(36),
        Earcut = __webpack_require__(59),
        GeomCircle = __webpack_require__(65),
        MATH_CONST = __webpack_require__(14),
        Shape = __webpack_require__(34),
        Arc = new Class({
      Extends: Shape,
      Mixins: [Arc],
      initialize: function initialize(scene, x, diameter, radius, startAngle, endAngle, anticlockwise, fillColor, fillAlpha) {
        void 0 === x && (x = 0), void 0 === diameter && (diameter = 0), void 0 === startAngle && (startAngle = 0), void 0 === endAngle && (endAngle = 360), void 0 === anticlockwise && (anticlockwise = !1), Shape.call(this, scene, "Arc", new GeomCircle(0, 0, radius = void 0 === radius ? 128 : radius)), this._startAngle = startAngle, this._endAngle = endAngle, this._anticlockwise = anticlockwise, this._iterations = .01, this.setPosition(x, diameter);
        diameter = 2 * this.geom.radius;
        this.setSize(diameter, diameter), void 0 !== fillColor && this.setFillStyle(fillColor, fillAlpha), this.updateDisplayOrigin(), this.updateData();
      },
      iterations: {
        get: function get() {
          return this._iterations;
        },
        set: function set(value) {
          this._iterations = value, this.updateData();
        }
      },
      radius: {
        get: function get() {
          return this.geom.radius;
        },
        set: function set(diameter) {
          diameter = 2 * (this.geom.radius = diameter);
          this.setSize(diameter, diameter), this.updateDisplayOrigin(), this.updateData();
        }
      },
      startAngle: {
        get: function get() {
          return this._startAngle;
        },
        set: function set(value) {
          this._startAngle = value, this.updateData();
        }
      },
      endAngle: {
        get: function get() {
          return this._endAngle;
        },
        set: function set(value) {
          this._endAngle = value, this.updateData();
        }
      },
      anticlockwise: {
        get: function get() {
          return this._anticlockwise;
        },
        set: function set(value) {
          this._anticlockwise = value, this.updateData();
        }
      },
      setRadius: function setRadius(value) {
        return this.radius = value, this;
      },
      setIterations: function setIterations(value) {
        return this.iterations = value = void 0 === value ? .01 : value, this;
      },
      setStartAngle: function setStartAngle(angle, anticlockwise) {
        return this._startAngle = angle, void 0 !== anticlockwise && (this._anticlockwise = anticlockwise), this.updateData();
      },
      setEndAngle: function setEndAngle(angle, anticlockwise) {
        return this._endAngle = angle, void 0 !== anticlockwise && (this._anticlockwise = anticlockwise), this.updateData();
      },
      updateData: function updateData() {
        var step = this._iterations,
            iteration = step,
            radius = this.geom.radius,
            startAngle = DegToRad(this._startAngle),
            endAngle = DegToRad(this._endAngle),
            x = radius,
            y = radius;
        endAngle -= startAngle, this._anticlockwise ? endAngle < -MATH_CONST.PI2 ? endAngle = -MATH_CONST.PI2 : 0 < endAngle && (endAngle = -MATH_CONST.PI2 + endAngle % MATH_CONST.PI2) : endAngle > MATH_CONST.PI2 ? endAngle = MATH_CONST.PI2 : endAngle < 0 && (endAngle = MATH_CONST.PI2 + endAngle % MATH_CONST.PI2);

        for (var ta, path = [x + Math.cos(startAngle) * radius, y + Math.sin(startAngle) * radius]; iteration < 1;) {
          ta = endAngle * iteration + startAngle, path.push(x + Math.cos(ta) * radius, y + Math.sin(ta) * radius), iteration += step;
        }

        return ta = endAngle + startAngle, path.push(x + Math.cos(ta) * radius, y + Math.sin(ta) * radius), path.push(x + Math.cos(startAngle) * radius, y + Math.sin(startAngle) * radius), this.pathIndexes = Earcut(path), this.pathData = path, this;
      }
    });

    module.exports = Arc;
  }, function (module, exports, __webpack_require__) {
    var Class = __webpack_require__(0),
        Curve = __webpack_require__(1100),
        Earcut = __webpack_require__(59),
        Rectangle = __webpack_require__(10),
        Shape = __webpack_require__(34),
        Curve = new Class({
      Extends: Shape,
      Mixins: [Curve],
      initialize: function initialize(scene, x, y, curve, fillColor, fillAlpha) {
        void 0 === x && (x = 0), void 0 === y && (y = 0), Shape.call(this, scene, "Curve", curve), this._smoothness = 32, this._curveBounds = new Rectangle(), this.closePath = !1, this.setPosition(x, y), void 0 !== fillColor && this.setFillStyle(fillColor, fillAlpha), this.updateData();
      },
      smoothness: {
        get: function get() {
          return this._smoothness;
        },
        set: function set(value) {
          this._smoothness = value, this.updateData();
        }
      },
      setSmoothness: function setSmoothness(value) {
        return this._smoothness = value, this.updateData();
      },
      updateData: function updateData() {
        var bounds = this._curveBounds,
            smoothness = this._smoothness;
        this.geom.getBounds(bounds, smoothness), this.setSize(bounds.width, bounds.height), this.updateDisplayOrigin();

        for (var path = [], points = this.geom.getPoints(smoothness), i = 0; i < points.length; i++) {
          path.push(points[i].x, points[i].y);
        }

        return path.push(points[0].x, points[0].y), this.pathIndexes = Earcut(path), this.pathData = path, this;
      }
    });

    module.exports = Curve;
  }, function (module, exports, __webpack_require__) {
    var Class = __webpack_require__(0),
        Earcut = __webpack_require__(59),
        Ellipse = __webpack_require__(1103),
        GeomEllipse = __webpack_require__(111),
        Shape = __webpack_require__(34),
        Ellipse = new Class({
      Extends: Shape,
      Mixins: [Ellipse],
      initialize: function initialize(scene, x, y, width, height, fillColor, fillAlpha) {
        void 0 === x && (x = 0), void 0 === y && (y = 0), Shape.call(this, scene, "Ellipse", new GeomEllipse((width = void 0 === width ? 128 : width) / 2, (height = void 0 === height ? 128 : height) / 2, width, height)), this._smoothness = 64, this.setPosition(x, y), this.width = width, this.height = height, void 0 !== fillColor && this.setFillStyle(fillColor, fillAlpha), this.updateDisplayOrigin(), this.updateData();
      },
      smoothness: {
        get: function get() {
          return this._smoothness;
        },
        set: function set(value) {
          this._smoothness = value, this.updateData();
        }
      },
      setSize: function setSize(width, height) {
        return this.width = width, this.height = height, this.geom.setPosition(width / 2, height / 2), this.geom.setSize(width, height), this.updateData();
      },
      setSmoothness: function setSmoothness(value) {
        return this._smoothness = value, this.updateData();
      },
      updateData: function updateData() {
        for (var path = [], points = this.geom.getPoints(this._smoothness), i = 0; i < points.length; i++) {
          path.push(points[i].x, points[i].y);
        }

        return path.push(points[0].x, points[0].y), this.pathIndexes = Earcut(path), this.pathData = path, this;
      }
    });

    module.exports = Ellipse;
  }, function (module, exports, Grid) {
    var Class = Grid(0),
        Shape = Grid(34),
        Grid = Grid(1106),
        Grid = new Class({
      Extends: Shape,
      Mixins: [Grid],
      initialize: function initialize(scene, x, y, width, height, cellWidth, cellHeight, fillColor, fillAlpha, outlineFillColor, outlineFillAlpha) {
        void 0 === x && (x = 0), void 0 === y && (y = 0), void 0 === width && (width = 128), void 0 === height && (height = 128), void 0 === cellWidth && (cellWidth = 32), void 0 === cellHeight && (cellHeight = 32), Shape.call(this, scene, "Grid", null), this.cellWidth = cellWidth, this.cellHeight = cellHeight, this.showCells = !0, this.outlineFillColor = 0, this.outlineFillAlpha = 0, this.showOutline = !0, this.showAltCells = !1, this.altFillColor, this.altFillAlpha, this.setPosition(x, y), this.setSize(width, height), this.setFillStyle(fillColor, fillAlpha), void 0 !== outlineFillColor && this.setOutlineStyle(outlineFillColor, outlineFillAlpha), this.updateDisplayOrigin();
      },
      setFillStyle: function setFillStyle(fillColor, fillAlpha) {
        return void 0 === fillAlpha && (fillAlpha = 1), void 0 === fillColor ? this.showCells = !1 : (this.fillColor = fillColor, this.fillAlpha = fillAlpha, this.showCells = !0), this;
      },
      setAltFillStyle: function setAltFillStyle(fillColor, fillAlpha) {
        return void 0 === fillAlpha && (fillAlpha = 1), void 0 === fillColor ? this.showAltCells = !1 : (this.altFillColor = fillColor, this.altFillAlpha = fillAlpha, this.showAltCells = !0), this;
      },
      setOutlineStyle: function setOutlineStyle(fillColor, fillAlpha) {
        return void 0 === fillAlpha && (fillAlpha = 1), void 0 === fillColor ? this.showOutline = !1 : (this.outlineFillColor = fillColor, this.outlineFillAlpha = fillAlpha, this.showOutline = !0), this;
      }
    });
    module.exports = Grid;
  }, function (module, exports, __webpack_require__) {
    var IsoBox = __webpack_require__(1109),
        Class = __webpack_require__(0),
        Shape = __webpack_require__(34),
        IsoBox = new Class({
      Extends: Shape,
      Mixins: [IsoBox],
      initialize: function initialize(scene, x, y, size, height, fillTop, fillLeft, fillRight) {
        void 0 === x && (x = 0), void 0 === y && (y = 0), void 0 === size && (size = 48), void 0 === height && (height = 32), void 0 === fillTop && (fillTop = 15658734), void 0 === fillLeft && (fillLeft = 10066329), void 0 === fillRight && (fillRight = 13421772), Shape.call(this, scene, "IsoBox", null), this.projection = 4, this.fillTop = fillTop, this.fillLeft = fillLeft, this.fillRight = fillRight, this.showTop = !0, this.showLeft = !0, this.showRight = !0, this.isFilled = !0, this.setPosition(x, y), this.setSize(size, height), this.updateDisplayOrigin();
      },
      setProjection: function setProjection(value) {
        return this.projection = value, this;
      },
      setFaces: function setFaces(showTop, showLeft, showRight) {
        return void 0 === showLeft && (showLeft = !0), void 0 === showRight && (showRight = !0), this.showTop = showTop = void 0 === showTop ? !0 : showTop, this.showLeft = showLeft, this.showRight = showRight, this;
      },
      setFillStyle: function setFillStyle(fillTop, fillLeft, fillRight) {
        return this.fillTop = fillTop, this.fillLeft = fillLeft, this.fillRight = fillRight, this.isFilled = !0, this;
      }
    });

    module.exports = IsoBox;
  }, function (module, exports, __webpack_require__) {
    var Class = __webpack_require__(0),
        IsoTriangle = __webpack_require__(1112),
        Shape = __webpack_require__(34),
        IsoTriangle = new Class({
      Extends: Shape,
      Mixins: [IsoTriangle],
      initialize: function initialize(scene, x, y, size, height, reversed, fillTop, fillLeft, fillRight) {
        void 0 === x && (x = 0), void 0 === y && (y = 0), void 0 === size && (size = 48), void 0 === height && (height = 32), void 0 === reversed && (reversed = !1), void 0 === fillTop && (fillTop = 15658734), void 0 === fillLeft && (fillLeft = 10066329), void 0 === fillRight && (fillRight = 13421772), Shape.call(this, scene, "IsoTriangle", null), this.projection = 4, this.fillTop = fillTop, this.fillLeft = fillLeft, this.fillRight = fillRight, this.showTop = !0, this.showLeft = !0, this.showRight = !0, this.isReversed = reversed, this.isFilled = !0, this.setPosition(x, y), this.setSize(size, height), this.updateDisplayOrigin();
      },
      setProjection: function setProjection(value) {
        return this.projection = value, this;
      },
      setReversed: function setReversed(reversed) {
        return this.isReversed = reversed, this;
      },
      setFaces: function setFaces(showTop, showLeft, showRight) {
        return void 0 === showLeft && (showLeft = !0), void 0 === showRight && (showRight = !0), this.showTop = showTop = void 0 === showTop ? !0 : showTop, this.showLeft = showLeft, this.showRight = showRight, this;
      },
      setFillStyle: function setFillStyle(fillTop, fillLeft, fillRight) {
        return this.fillTop = fillTop, this.fillLeft = fillLeft, this.fillRight = fillRight, this.isFilled = !0, this;
      }
    });

    module.exports = IsoTriangle;
  }, function (module, exports, Line) {
    var Class = Line(0),
        Shape = Line(34),
        GeomLine = Line(47),
        Line = Line(1115),
        Line = new Class({
      Extends: Shape,
      Mixins: [Line],
      initialize: function initialize(scene, x, y, x1, y1, width, height, strokeColor, strokeAlpha) {
        void 0 === x && (x = 0), void 0 === y && (y = 0), Shape.call(this, scene, "Line", new GeomLine(x1 = void 0 === x1 ? 0 : x1, y1 = void 0 === y1 ? 0 : y1, width = void 0 === width ? 128 : width, height = void 0 === height ? 0 : height));
        width = Math.max(1, this.geom.right - this.geom.left), height = Math.max(1, this.geom.bottom - this.geom.top);
        this.lineWidth = 1, this._startWidth = 1, this._endWidth = 1, this.setPosition(x, y), this.setSize(width, height), void 0 !== strokeColor && this.setStrokeStyle(1, strokeColor, strokeAlpha), this.updateDisplayOrigin();
      },
      setLineWidth: function setLineWidth(startWidth, endWidth) {
        return void 0 === endWidth && (endWidth = startWidth), this._startWidth = startWidth, this._endWidth = endWidth, this.lineWidth = startWidth, this;
      },
      setTo: function setTo(x1, y1, x2, y2) {
        return this.geom.setTo(x1, y1, x2, y2), this;
      }
    });
    module.exports = Line;
  }, function (module, exports, __webpack_require__) {
    var Polygon = __webpack_require__(1118),
        Class = __webpack_require__(0),
        Earcut = __webpack_require__(59),
        GetAABB = __webpack_require__(469),
        GeomPolygon = __webpack_require__(227),
        Shape = __webpack_require__(34),
        Smooth = __webpack_require__(472),
        Polygon = new Class({
      Extends: Shape,
      Mixins: [Polygon],
      initialize: function initialize(scene, x, y, bounds, fillColor, fillAlpha) {
        void 0 === x && (x = 0), void 0 === y && (y = 0), Shape.call(this, scene, "Polygon", new GeomPolygon(bounds));
        bounds = GetAABB(this.geom);
        this.setPosition(x, y), this.setSize(bounds.width, bounds.height), void 0 !== fillColor && this.setFillStyle(fillColor, fillAlpha), this.updateDisplayOrigin(), this.updateData();
      },
      smooth: function smooth(iterations) {
        void 0 === iterations && (iterations = 1);

        for (var i = 0; i < iterations; i++) {
          Smooth(this.geom);
        }

        return this.updateData();
      },
      updateData: function updateData() {
        for (var path = [], points = this.geom.points, i = 0; i < points.length; i++) {
          path.push(points[i].x, points[i].y);
        }

        return path.push(points[0].x, points[0].y), this.pathIndexes = Earcut(path), this.pathData = path, this;
      }
    });

    module.exports = Polygon;
  }, function (module, exports, __webpack_require__) {
    var Rectangle = __webpack_require__(10);

    module.exports = function (polygon, out) {
      void 0 === out && (out = new Rectangle());

      for (var p, minX = 1 / 0, minY = 1 / 0, maxX = -minX, maxY = -minY, i = 0; i < polygon.points.length; i++) {
        p = polygon.points[i], minX = Math.min(minX, p.x), minY = Math.min(minY, p.y), maxX = Math.max(maxX, p.x), maxY = Math.max(maxY, p.y);
      }

      return out.x = minX, out.y = minY, out.width = maxX - minX, out.height = maxY - minY, out;
    };
  }, function (module, exports, __webpack_require__) {
    var Length = __webpack_require__(67),
        Line = __webpack_require__(47),
        Perimeter = __webpack_require__(471);

    module.exports = function (polygon, quantity, stepRate, out) {
      void 0 === out && (out = []);
      var points = polygon.points,
          perimeter = Perimeter(polygon);
      !quantity && 0 < stepRate && (quantity = perimeter / stepRate);

      for (var i = 0; i < quantity; i++) {
        for (var position = perimeter * (i / quantity), accumulatedPerimeter = 0, j = 0; j < points.length; j++) {
          var point = points[j],
              length = points[(j + 1) % points.length],
              point = new Line(point.x, point.y, length.x, length.y),
              length = Length(point);

          if (!(position < accumulatedPerimeter || accumulatedPerimeter + length < position)) {
            point = point.getPoint((position - accumulatedPerimeter) / length);
            out.push(point);
            break;
          }

          accumulatedPerimeter += length;
        }
      }

      return out;
    };
  }, function (module, exports, __webpack_require__) {
    var Length = __webpack_require__(67),
        Line = __webpack_require__(47);

    module.exports = function (polygon) {
      for (var points = polygon.points, perimeter = 0, i = 0; i < points.length; i++) {
        var pointA = points[i],
            line = points[(i + 1) % points.length],
            line = new Line(pointA.x, pointA.y, line.x, line.y);
        perimeter += Length(line);
      }

      return perimeter;
    };
  }, function (module, exports) {
    function copy(out, a) {
      return out[0] = a[0], out[1] = a[1], out;
    }

    module.exports = function (polygon) {
      for (var points = [], data = polygon.points, i = 0; i < data.length; i++) {
        points.push([data[i].x, data[i].y]);
      }

      var output = [];

      for (0 < points.length && output.push(copy([0, 0], points[0])), i = 0; i < points.length - 1; i++) {
        var p1x = points[i],
            p1y = points[i + 1],
            p0x = p1x[0],
            p0y = p1x[1],
            p1x = p1y[0],
            p1y = p1y[1];
        output.push([.85 * p0x + .15 * p1x, .85 * p0y + .15 * p1y]), output.push([.15 * p0x + .85 * p1x, .15 * p0y + .85 * p1y]);
      }

      return 1 < points.length && output.push(copy([0, 0], points[points.length - 1])), polygon.setTo(output);
    };
  }, function (module, exports, Rectangle) {
    var Class = Rectangle(0),
        GeomRectangle = Rectangle(10),
        Shape = Rectangle(34),
        Rectangle = Rectangle(1121),
        Rectangle = new Class({
      Extends: Shape,
      Mixins: [Rectangle],
      initialize: function initialize(scene, x, y, width, height, fillColor, fillAlpha) {
        void 0 === x && (x = 0), void 0 === y && (y = 0), Shape.call(this, scene, "Rectangle", new GeomRectangle(0, 0, width = void 0 === width ? 128 : width, height = void 0 === height ? 128 : height)), this.setPosition(x, y), this.setSize(width, height), void 0 !== fillColor && this.setFillStyle(fillColor, fillAlpha), this.updateDisplayOrigin(), this.updateData();
      },
      setSize: function setSize(width, height) {
        return this.width = width, this.height = height, this.geom.setSize(width, height), this.updateData(), this;
      },
      updateData: function updateData() {
        var path = [],
            rect = this.geom,
            line = this._tempLine;
        return rect.getLineA(line), path.push(line.x1, line.y1, line.x2, line.y2), rect.getLineB(line), path.push(line.x2, line.y2), rect.getLineC(line), path.push(line.x2, line.y2), rect.getLineD(line), path.push(line.x2, line.y2), this.pathData = path, this;
      }
    });
    module.exports = Rectangle;
  }, function (module, exports, __webpack_require__) {
    var Star = __webpack_require__(1124),
        Class = __webpack_require__(0),
        Earcut = __webpack_require__(59),
        Shape = __webpack_require__(34),
        Star = new Class({
      Extends: Shape,
      Mixins: [Star],
      initialize: function initialize(scene, x, y, points, innerRadius, outerRadius, fillColor, fillAlpha) {
        void 0 === x && (x = 0), void 0 === y && (y = 0), void 0 === points && (points = 5), void 0 === innerRadius && (innerRadius = 32), void 0 === outerRadius && (outerRadius = 64), Shape.call(this, scene, "Star", null), this._points = points, this._innerRadius = innerRadius, this._outerRadius = outerRadius, this.setPosition(x, y), this.setSize(2 * outerRadius, 2 * outerRadius), void 0 !== fillColor && this.setFillStyle(fillColor, fillAlpha), this.updateDisplayOrigin(), this.updateData();
      },
      setPoints: function setPoints(value) {
        return this._points = value, this.updateData();
      },
      setInnerRadius: function setInnerRadius(value) {
        return this._innerRadius = value, this.updateData();
      },
      setOuterRadius: function setOuterRadius(value) {
        return this._outerRadius = value, this.updateData();
      },
      points: {
        get: function get() {
          return this._points;
        },
        set: function set(value) {
          this._points = value, this.updateData();
        }
      },
      innerRadius: {
        get: function get() {
          return this._innerRadius;
        },
        set: function set(value) {
          this._innerRadius = value, this.updateData();
        }
      },
      outerRadius: {
        get: function get() {
          return this._outerRadius;
        },
        set: function set(value) {
          this._outerRadius = value, this.updateData();
        }
      },
      updateData: function updateData() {
        var path = [],
            points = this._points,
            innerRadius = this._innerRadius,
            outerRadius = this._outerRadius,
            rot = Math.PI / 2 * 3,
            step = Math.PI / points,
            x = outerRadius,
            y = outerRadius;
        path.push(x, y + -outerRadius);

        for (var i = 0; i < points; i++) {
          path.push(x + Math.cos(rot) * outerRadius, y + Math.sin(rot) * outerRadius), rot += step, path.push(x + Math.cos(rot) * innerRadius, y + Math.sin(rot) * innerRadius), rot += step;
        }

        return path.push(x, y + -outerRadius), this.pathIndexes = Earcut(path), this.pathData = path, this;
      }
    });

    module.exports = Star;
  }, function (module, exports, Triangle) {
    var Class = Triangle(0),
        Shape = Triangle(34),
        GeomTriangle = Triangle(82),
        Triangle = Triangle(1127),
        Triangle = new Class({
      Extends: Shape,
      Mixins: [Triangle],
      initialize: function initialize(scene, x, y, x1, y1, x2, y2, width, height, fillColor, fillAlpha) {
        void 0 === x && (x = 0), void 0 === y && (y = 0), Shape.call(this, scene, "Triangle", new GeomTriangle(x1 = void 0 === x1 ? 0 : x1, y1 = void 0 === y1 ? 128 : y1, x2 = void 0 === x2 ? 64 : x2, y2 = void 0 === y2 ? 0 : y2, width = void 0 === width ? 128 : width, height = void 0 === height ? 128 : height));
        width = this.geom.right - this.geom.left, height = this.geom.bottom - this.geom.top;
        this.setPosition(x, y), this.setSize(width, height), void 0 !== fillColor && this.setFillStyle(fillColor, fillAlpha), this.updateDisplayOrigin(), this.updateData();
      },
      setTo: function setTo(x1, y1, x2, y2, x3, y3) {
        return this.geom.setTo(x1, y1, x2, y2, x3, y3), this.updateData();
      },
      updateData: function updateData() {
        var path = [],
            tri = this.geom,
            line = this._tempLine;
        return tri.getLineA(line), path.push(line.x1, line.y1, line.x2, line.y2), tri.getLineB(line), path.push(line.x2, line.y2), tri.getLineC(line), path.push(line.x2, line.y2), this.pathData = path, this;
      }
    });
    module.exports = Triangle;
  }, function (module, exports, __webpack_require__) {
    var Point = __webpack_require__(4),
        Length = __webpack_require__(67);

    module.exports = function (p, localPosition, out) {
      void 0 === out && (out = new Point());
      var line1 = p.getLineA(),
          line2 = p.getLineB(),
          line3 = p.getLineC();
      if (localPosition <= 0 || 1 <= localPosition) return out.x = line1.x1, out.y = line1.y1, out;
      var length1 = Length(line1),
          length2 = Length(line2),
          length3 = Length(line3),
          p = (length1 + length2 + length3) * localPosition,
          localPosition = 0;
      return p < length1 ? (out.x = line1.x1 + (line1.x2 - line1.x1) * (localPosition = p / length1), out.y = line1.y1 + (line1.y2 - line1.y1) * localPosition) : length1 + length2 < p ? (out.x = line3.x1 + (line3.x2 - line3.x1) * (localPosition = (p -= length1 + length2) / length3), out.y = line3.y1 + (line3.y2 - line3.y1) * localPosition) : (out.x = line2.x1 + (line2.x2 - line2.x1) * (localPosition = (p -= length1) / length2), out.y = line2.y1 + (line2.y2 - line2.y1) * localPosition), out;
    };
  }, function (module, exports, __webpack_require__) {
    var Length = __webpack_require__(67),
        Point = __webpack_require__(4);

    module.exports = function (triangle, quantity, stepRate, out) {
      void 0 === out && (out = []);
      var line1 = triangle.getLineA(),
          line2 = triangle.getLineB(),
          line3 = triangle.getLineC(),
          length1 = Length(line1),
          length2 = Length(line2),
          length3 = Length(line3),
          perimeter = length1 + length2 + length3;
      !quantity && 0 < stepRate && (quantity = perimeter / stepRate);

      for (var i = 0; i < quantity; i++) {
        var p = perimeter * (i / quantity),
            localPosition = 0,
            point = new Point();
        p < length1 ? (point.x = line1.x1 + (line1.x2 - line1.x1) * (localPosition = p / length1), point.y = line1.y1 + (line1.y2 - line1.y1) * localPosition) : length1 + length2 < p ? (p -= length1 + length2, point.x = line3.x1 + (line3.x2 - line3.x1) * (localPosition = p / length3), point.y = line3.y1 + (line3.y2 - line3.y1) * localPosition) : (p -= length1, point.x = line2.x1 + (line2.x2 - line2.x1) * (localPosition = p / length2), point.y = line2.y1 + (line2.y2 - line2.y1) * localPosition), out.push(point);
      }

      return out;
    };
  }, function (module, exports) {
    module.exports = function (source, key, value) {
      if (!source || "number" == typeof source) return !1;
      if (source.hasOwnProperty(key)) return source[key] = value, !0;
      if (-1 === key.indexOf(".")) return !1;

      for (var keys = key.split("."), parent = source, prev = source, i = 0; i < keys.length; i++) {
        if (!parent.hasOwnProperty(keys[i])) return !1;
        parent = (prev = parent)[keys[i]];
      }

      return prev[keys[keys.length - 1]] = value, !0;
    };
  }, function (module, exports, __webpack_require__) {
    var Face = __webpack_require__(116),
        Vertex = __webpack_require__(117);

    module.exports = function (vertices, uvs, indicies, containsZ, normals, colors, alphas) {
      if (void 0 === containsZ && (containsZ = !1), void 0 === colors && (colors = 16777215), void 0 === alphas && (alphas = 1), vertices.length === uvs.length) {
        var result = {
          faces: [],
          vertices: []
        },
            iInc = containsZ ? 3 : 2,
            isColorArray = Array.isArray(colors),
            isAlphaArray = Array.isArray(alphas);
        if (Array.isArray(indicies) && 0 < indicies.length) for (i = 0; i < indicies.length; i++) {
          var index1 = indicies[i],
              index2 = 2 * indicies[i],
              index3 = indicies[i] * iInc,
              x = vertices[index3],
              y = vertices[1 + index3],
              z = containsZ ? vertices[2 + index3] : 0,
              u = uvs[index2],
              v = uvs[1 + index2],
              color = isColorArray ? colors[index1] : colors,
              alpha = isAlphaArray ? alphas[index1] : alphas,
              normalX = 0,
              normalY = 0,
              normalZ = 0;
          normals && (normalX = normals[index3], normalY = normals[1 + index3], normalZ = containsZ ? normals[2 + index3] : 0), result.vertices.push(new Vertex(x, y, z, u, v, color, alpha, normalX, normalY, normalZ));
        } else for (var uvIndex = 0, colorIndex = 0, i = 0; i < vertices.length; i += iInc) {
          x = vertices[i], y = vertices[i + 1], z = containsZ ? vertices[i + 2] : 0, u = uvs[uvIndex], v = uvs[uvIndex + 1], color = isColorArray ? colors[colorIndex] : colors, alpha = isAlphaArray ? alphas[colorIndex] : alphas, normalZ = normalY = normalX = 0, normals && (normalX = normals[i], normalY = normals[i + 1], normalZ = containsZ ? normals[i + 2] : 0), result.vertices.push(new Vertex(x, y, z, u, v, color, alpha, normalX, normalY, normalZ)), uvIndex += 2, colorIndex++;
        }

        for (i = 0; i < result.vertices.length; i += 3) {
          var vert1 = result.vertices[i],
              vert2 = result.vertices[i + 1],
              vert3 = result.vertices[i + 2];
          result.faces.push(new Face(vert1, vert2, vert3));
        }

        return result;
      }

      console.warn("GenerateVerts: vertices and uvs count not equal");
    };
  }, function (module, exports, __webpack_require__) {
    var Face = __webpack_require__(116),
        Matrix4 = __webpack_require__(69),
        Vector3 = __webpack_require__(39),
        Vertex = __webpack_require__(117),
        tempPosition = new Vector3(),
        tempRotation = new Vector3(),
        tempMatrix = new Matrix4();

    module.exports = function (data, mesh, scale, x, y, z, rotateX, rotateY, rotateZ, zIsUp) {
      void 0 === scale && (scale = 1), void 0 === rotateX && (rotateX = 0), void 0 === rotateY && (rotateY = 0), void 0 === rotateZ && (rotateZ = 0), void 0 === zIsUp && (zIsUp = !0);
      var result = {
        faces: [],
        verts: []
      },
          materials = data.materials;
      tempPosition.set(x = void 0 === x ? 0 : x, y = void 0 === y ? 0 : y, z = void 0 === z ? 0 : z), tempRotation.set(rotateX, rotateY, rotateZ), tempMatrix.fromRotationXYTranslation(tempRotation, tempPosition, zIsUp);

      for (var m = 0; m < data.models.length; m++) {
        for (var model = data.models[m], vertices = model.vertices, textureCoords = model.textureCoords, faces = model.faces, i = 0; i < faces.length; i++) {
          var face = faces[i],
              uv3 = face.vertices[0],
              vert3 = face.vertices[1],
              vert1 = face.vertices[2],
              m1 = vertices[uv3.vertexIndex],
              m2 = vertices[vert3.vertexIndex],
              m3 = vertices[vert1.vertexIndex],
              vert2 = uv3.textureCoordsIndex,
              uv3 = vert3.textureCoordsIndex,
              vert3 = vert1.textureCoordsIndex,
              vert1 = -1 === vert2 ? {
            u: 0,
            v: 1
          } : textureCoords[vert2],
              vert2 = -1 === uv3 ? {
            u: 0,
            v: 0
          } : textureCoords[uv3],
              uv3 = -1 === vert3 ? {
            u: 1,
            v: 1
          } : textureCoords[vert3],
              vert3 = 16777215;
          "" !== face.material && materials[face.material] && (vert3 = materials[face.material]);
          vert1 = new Vertex(m1.x * scale, m1.y * scale, m1.z * scale, vert1.u, vert1.v, vert3).transformMat4(tempMatrix), vert2 = new Vertex(m2.x * scale, m2.y * scale, m2.z * scale, vert2.u, vert2.v, vert3).transformMat4(tempMatrix), vert3 = new Vertex(m3.x * scale, m3.y * scale, m3.z * scale, uv3.u, uv3.v, vert3).transformMat4(tempMatrix);
          result.verts.push(vert1, vert2, vert3), result.faces.push(new Face(vert1, vert2, vert3));
        }
      }

      return mesh && (mesh.faces = mesh.faces.concat(result.faces), mesh.vertices = mesh.vertices.concat(result.verts)), result;
    };
  }, function (module, exports, __webpack_require__) {
    var Circle = __webpack_require__(65),
        Class = __webpack_require__(0),
        Components = __webpack_require__(11),
        RGB = __webpack_require__(200),
        Utils = __webpack_require__(12),
        Light = new Class({
      Extends: Circle,
      Mixins: [Components.ScrollFactor, Components.Visible],
      initialize: function initialize(x, y, radius, r, g, b, intensity) {
        Circle.call(this, x, y, radius), this.color = new RGB(r, g, b), this.intensity = intensity, this.renderFlags = 15, this.cameraFilter = 0, this.setScrollFactor(1, 1);
      },
      willRender: function willRender(camera) {
        return !(Light.RENDER_MASK !== this.renderFlags || 0 !== this.cameraFilter && this.cameraFilter & camera.id);
      },
      setColor: function setColor(color) {
        color = Utils.getFloatsFromUintRGB(color);
        return this.color.set(color[0], color[1], color[2]), this;
      },
      setIntensity: function setIntensity(intensity) {
        return this.intensity = intensity, this;
      },
      setRadius: function setRadius(radius) {
        return this.radius = radius, this;
      }
    });

    Light.RENDER_MASK = 15, module.exports = Light;
  }, function (module, exports, __webpack_require__) {
    var CircleToRectangle = __webpack_require__(151),
        LightsManager = __webpack_require__(0),
        DistanceBetween = __webpack_require__(50),
        Light = __webpack_require__(481),
        PointLight = __webpack_require__(150),
        RGB = __webpack_require__(200),
        SpliceOne = __webpack_require__(74),
        StableSort = __webpack_require__(79),
        Utils = __webpack_require__(12),
        LightsManager = new LightsManager({
      initialize: function initialize() {
        this.lights = [], this.ambientColor = new RGB(.1, .1, .1), this.active = !1, this.maxLights = -1, this.visibleLights = 0;
      },
      addPointLight: function addPointLight(x, y, color, radius, intensity, attenuation) {
        return this.systems.displayList.add(new PointLight(this.scene, x, y, color, radius, intensity, attenuation));
      },
      enable: function enable() {
        return -1 === this.maxLights && (this.maxLights = this.systems.renderer.config.maxLights), this.active = !0, this;
      },
      disable: function disable() {
        return this.active = !1, this;
      },
      getLights: function getLights(camera) {
        for (var lights = this.lights, worldView = camera.worldView, visibleLights = [], i = 0; i < lights.length; i++) {
          var light = lights[i];
          light.willRender(camera) && CircleToRectangle(light, worldView) && visibleLights.push({
            light: light,
            distance: DistanceBetween(light.x, light.y, worldView.centerX, worldView.centerY)
          });
        }

        return visibleLights.length > this.maxLights && (StableSort(visibleLights, this.sortByDistance), visibleLights = visibleLights.slice(0, this.maxLights)), this.visibleLights = visibleLights.length, visibleLights;
      },
      sortByDistance: function sortByDistance(a, b) {
        return a.distance >= b.distance;
      },
      setAmbientColor: function setAmbientColor(color) {
        color = Utils.getFloatsFromUintRGB(color);
        return this.ambientColor.set(color[0], color[1], color[2]), this;
      },
      getMaxVisibleLights: function getMaxVisibleLights() {
        return this.maxLights;
      },
      getLightCount: function getLightCount() {
        return this.lights.length;
      },
      addLight: function addLight(x, y, radius, color, light) {
        void 0 === x && (x = 0), void 0 === y && (y = 0), void 0 === radius && (radius = 128), void 0 === light && (light = 1);
        color = Utils.getFloatsFromUintRGB(color = void 0 === color ? 16777215 : color), light = new Light(x, y, radius, color[0], color[1], color[2], light);
        return this.lights.push(light), light;
      },
      removeLight: function removeLight(index) {
        index = this.lights.indexOf(index);
        return 0 <= index && SpliceOne(this.lights, index), this;
      },
      shutdown: function shutdown() {
        this.lights.length = 0;
      },
      destroy: function destroy() {
        this.shutdown();
      }
    });

    module.exports = LightsManager;
  }, function (module, exports, Geom) {
    var CONST = Geom(56),
        Geom = Geom(17)(!1, Geom = {
      Circle: Geom(1191),
      Ellipse: Geom(1201),
      Intersects: Geom(484),
      Line: Geom(1221),
      Mesh: Geom(1243),
      Point: Geom(1246),
      Polygon: Geom(1260),
      Rectangle: Geom(502),
      Triangle: Geom(1293)
    }, CONST);
    module.exports = Geom;
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      CircleToCircle: __webpack_require__(231),
      CircleToRectangle: __webpack_require__(151),
      GetCircleToCircle: __webpack_require__(1211),
      GetCircleToRectangle: __webpack_require__(1212),
      GetLineToCircle: __webpack_require__(232),
      GetLineToLine: __webpack_require__(485),
      GetLineToPoints: __webpack_require__(486),
      GetLineToPolygon: __webpack_require__(487),
      GetLineToRectangle: __webpack_require__(234),
      GetRaysFromPointToPolygon: __webpack_require__(1213),
      GetRectangleIntersection: __webpack_require__(1214),
      GetRectangleToRectangle: __webpack_require__(1215),
      GetRectangleToTriangle: __webpack_require__(1216),
      GetTriangleToCircle: __webpack_require__(1217),
      GetTriangleToLine: __webpack_require__(492),
      GetTriangleToTriangle: __webpack_require__(1218),
      LineToCircle: __webpack_require__(233),
      LineToLine: __webpack_require__(96),
      LineToRectangle: __webpack_require__(488),
      PointToLine: __webpack_require__(496),
      PointToLineSegment: __webpack_require__(1219),
      RectangleToRectangle: __webpack_require__(152),
      RectangleToTriangle: __webpack_require__(489),
      RectangleToValues: __webpack_require__(1220),
      TriangleToCircle: __webpack_require__(491),
      TriangleToLine: __webpack_require__(493),
      TriangleToTriangle: __webpack_require__(494)
    };
  }, function (module, exports, __webpack_require__) {
    var Vector3 = __webpack_require__(39);

    module.exports = function (dx1, T2, out) {
      var x1 = dx1.x1,
          y1 = dx1.y1,
          dy1 = dx1.x2,
          T1 = dx1.y2,
          x3 = T2.x1,
          y3 = T2.y1,
          dx1 = dy1 - x1,
          dy1 = T1 - y1,
          T1 = T2.x2 - x3,
          T2 = T2.y2 - y3;
      if (0 == dx1 || 0 == T2 * dx1 - T1 * dy1) return !1;
      T2 = (dx1 * (y3 - y1) + dy1 * (x1 - x3)) / (T1 * dy1 - T2 * dx1), T1 = (x3 + T1 * T2 - x1) / dx1;
      return T1 < 0 || T2 < 0 || 1 < T2 ? null : (out = void 0 === out ? new Vector3() : out).set(x1 + dx1 * T1, y1 + dy1 * T1, T1);
    };
  }, function (module, exports, __webpack_require__) {
    var Vector3 = __webpack_require__(39),
        GetLineToLine = __webpack_require__(485),
        segment = new (__webpack_require__(47))(),
        tempIntersect = new Vector3();

    module.exports = function (line, points, out) {
      var closestIntersect = !1;
      (out = void 0 === out ? new Vector3() : out).set(), tempIntersect.set();

      for (var prev = points[0], i = 1; i < points.length; i++) {
        var current = points[i];
        segment.setTo(prev.x, prev.y, current.x, current.y), prev = current, GetLineToLine(line, segment, tempIntersect) && (!closestIntersect || tempIntersect.z < out.z) && (out.copy(tempIntersect), closestIntersect = !0);
      }

      return closestIntersect ? out : null;
    };
  }, function (module, exports, __webpack_require__) {
    var Vector3 = __webpack_require__(39),
        Vector4 = __webpack_require__(140),
        GetLineToPoints = __webpack_require__(486),
        tempIntersect = new Vector3();

    module.exports = function (line, polygons, out) {
      void 0 === out && (out = new Vector4()), Array.isArray(polygons) || (polygons = [polygons]);
      var closestIntersect = !1;
      out.set(), tempIntersect.set();

      for (var i = 0; i < polygons.length; i++) {
        GetLineToPoints(line, polygons[i].points, tempIntersect) && (!closestIntersect || tempIntersect.z < out.z) && (out.set(tempIntersect.x, tempIntersect.y, tempIntersect.z, i), closestIntersect = !0);
      }

      return closestIntersect ? out : null;
    };
  }, function (module, exports) {
    module.exports = function (by2, t) {
      var x1 = by2.x1,
          y1 = by2.y1,
          x2 = by2.x2,
          y2 = by2.y2,
          bx1 = t.x,
          by1 = t.y,
          bx2 = t.right,
          by2 = t.bottom,
          t = 0;
      if (bx1 <= x1 && x1 <= bx2 && by1 <= y1 && y1 <= by2 || bx1 <= x2 && x2 <= bx2 && by1 <= y2 && y2 <= by2) return !0;

      if (x1 < bx1 && bx1 <= x2) {
        if (by1 < (t = y1 + (y2 - y1) * (bx1 - x1) / (x2 - x1)) && t <= by2) return !0;
      } else if (bx2 < x1 && x2 <= bx2 && by1 <= (t = y1 + (y2 - y1) * (bx2 - x1) / (x2 - x1)) && t <= by2) return !0;

      if (y1 < by1 && by1 <= y2) {
        if (bx1 <= (t = x1 + (x2 - x1) * (by1 - y1) / (y2 - y1)) && t <= bx2) return !0;
      } else if (by2 < y1 && y2 <= by2 && bx1 <= (t = x1 + (x2 - x1) * (by2 - y1) / (y2 - y1)) && t <= bx2) return !0;

      return !1;
    };
  }, function (module, exports, __webpack_require__) {
    var LineToLine = __webpack_require__(96),
        Contains = __webpack_require__(57),
        ContainsArray = __webpack_require__(235),
        Decompose = __webpack_require__(490);

    module.exports = function (points, triangle) {
      if (triangle.left > points.right || triangle.right < points.left || triangle.top > points.bottom || triangle.bottom < points.top) return !1;
      var triA = triangle.getLineA(),
          triB = triangle.getLineB(),
          triC = triangle.getLineC();
      if (Contains(points, triA.x1, triA.y1) || Contains(points, triA.x2, triA.y2)) return !0;
      if (Contains(points, triB.x1, triB.y1) || Contains(points, triB.x2, triB.y2)) return !0;
      if (Contains(points, triC.x1, triC.y1) || Contains(points, triC.x2, triC.y2)) return !0;
      var rectA = points.getLineA(),
          rectB = points.getLineB(),
          rectC = points.getLineC(),
          rectD = points.getLineD();
      if (LineToLine(triA, rectA) || LineToLine(triA, rectB) || LineToLine(triA, rectC) || LineToLine(triA, rectD)) return !0;
      if (LineToLine(triB, rectA) || LineToLine(triB, rectB) || LineToLine(triB, rectC) || LineToLine(triB, rectD)) return !0;
      if (LineToLine(triC, rectA) || LineToLine(triC, rectB) || LineToLine(triC, rectC) || LineToLine(triC, rectD)) return !0;
      points = Decompose(points);
      return 0 < ContainsArray(triangle, points, !0).length;
    };
  }, function (module, exports) {
    module.exports = function (rect, out) {
      return (out = void 0 === out ? [] : out).push({
        x: rect.x,
        y: rect.y
      }), out.push({
        x: rect.right,
        y: rect.y
      }), out.push({
        x: rect.right,
        y: rect.bottom
      }), out.push({
        x: rect.x,
        y: rect.bottom
      }), out;
    };
  }, function (module, exports, __webpack_require__) {
    var LineToCircle = __webpack_require__(233),
        Contains = __webpack_require__(115);

    module.exports = function (triangle, circle) {
      return !(triangle.left > circle.right || triangle.right < circle.left || triangle.top > circle.bottom || triangle.bottom < circle.top) && (!!Contains(triangle, circle.x, circle.y) || !!LineToCircle(triangle.getLineA(), circle) || !!LineToCircle(triangle.getLineB(), circle) || !!LineToCircle(triangle.getLineC(), circle));
    };
  }, function (module, exports, __webpack_require__) {
    var Point = __webpack_require__(4),
        TriangleToLine = __webpack_require__(493),
        LineToLine = __webpack_require__(96);

    module.exports = function (lineC, line, out) {
      if (void 0 === out && (out = []), TriangleToLine(lineC, line)) for (var lineA = lineC.getLineA(), lineB = lineC.getLineB(), lineC = lineC.getLineC(), output = [new Point(), new Point(), new Point()], result = [LineToLine(lineA, line, output[0]), LineToLine(lineB, line, output[1]), LineToLine(lineC, line, output[2])], i = 0; i < 3; i++) {
        result[i] && out.push(output[i]);
      }
      return out;
    };
  }, function (module, exports, __webpack_require__) {
    var LineToLine = __webpack_require__(96);

    module.exports = function (triangle, line) {
      return !(!triangle.contains(line.x1, line.y1) && !triangle.contains(line.x2, line.y2)) || !!LineToLine(triangle.getLineA(), line) || !!LineToLine(triangle.getLineB(), line) || !!LineToLine(triangle.getLineC(), line);
    };
  }, function (module, exports, __webpack_require__) {
    var ContainsArray = __webpack_require__(235),
        Decompose = __webpack_require__(495),
        LineToLine = __webpack_require__(96);

    module.exports = function (triangleA, triangleB) {
      if (triangleA.left > triangleB.right || triangleA.right < triangleB.left || triangleA.top > triangleB.bottom || triangleA.bottom < triangleB.top) return !1;
      var lineAA = triangleA.getLineA(),
          lineAB = triangleA.getLineB(),
          lineAC = triangleA.getLineC(),
          lineBA = triangleB.getLineA(),
          lineBB = triangleB.getLineB(),
          points = triangleB.getLineC();
      if (LineToLine(lineAA, lineBA) || LineToLine(lineAA, lineBB) || LineToLine(lineAA, points)) return !0;
      if (LineToLine(lineAB, lineBA) || LineToLine(lineAB, lineBB) || LineToLine(lineAB, points)) return !0;
      if (LineToLine(lineAC, lineBA) || LineToLine(lineAC, lineBB) || LineToLine(lineAC, points)) return !0;
      points = Decompose(triangleA);
      return 0 < ContainsArray(triangleB, points, !0).length || (points = Decompose(triangleB), 0 < ContainsArray(triangleA, points, !0).length);
    };
  }, function (module, exports) {
    module.exports = function (triangle, out) {
      return (out = void 0 === out ? [] : out).push({
        x: triangle.x1,
        y: triangle.y1
      }), out.push({
        x: triangle.x2,
        y: triangle.y2
      }), out.push({
        x: triangle.x3,
        y: triangle.y3
      }), out;
    };
  }, function (module, exports) {
    module.exports = function (r, L2, lineThickness) {
      void 0 === lineThickness && (lineThickness = 1);
      var x1 = L2.x1,
          y1 = L2.y1,
          x2 = L2.x2,
          y2 = L2.y2,
          px = r.x,
          py = r.y,
          L2 = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
      if (0 == L2) return !1;
      r = ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / L2;
      return r < 0 ? Math.sqrt((x1 - px) * (x1 - px) + (y1 - py) * (y1 - py)) <= lineThickness : 0 <= r && r <= 1 ? Math.abs(((y1 - py) * (x2 - x1) - (x1 - px) * (y2 - y1)) / L2) * Math.sqrt(L2) <= lineThickness : Math.sqrt((x2 - px) * (x2 - px) + (y2 - py) * (y2 - py)) <= lineThickness;
    };
  }, function (module, exports, __webpack_require__) {
    var MATH_CONST = __webpack_require__(14),
        Wrap = __webpack_require__(68),
        Angle = __webpack_require__(97);

    module.exports = function (angle) {
      angle = Angle(angle) - MATH_CONST.TAU;
      return Wrap(angle, -Math.PI, Math.PI);
    };
  }, function (module, exports) {
    var flip = !0,
        defaultModelName = "untitled",
        currentGroup = "",
        currentMaterial = "";

    function currentModel(result) {
      return 0 === result.models.length && result.models.push({
        faces: [],
        name: defaultModelName,
        textureCoords: [],
        vertexNormals: [],
        vertices: []
      }), currentGroup = "", result.models[result.models.length - 1];
    }

    module.exports = function (data, flipUV) {
      flip = flipUV = void 0 === flipUV ? !0 : flipUV;
      var result = {
        materials: {},
        materialLibraries: [],
        models: []
      };
      currentMaterial = currentGroup = "";

      for (var lines = data.split("\n"), i = 0; i < lines.length; i++) {
        var lineItems = function (line) {
          var idx = line.indexOf("#");
          return -1 < idx ? line.substring(0, idx) : line;
        }(lines[i]).replace(/\s\s+/g, " ").trim().split(" ");

        switch (lineItems[0].toLowerCase()) {
          case "o":
            !function (modelName, result) {
              modelName = 2 <= modelName.length ? modelName[1] : defaultModelName, result.models.push({
                faces: [],
                name: modelName,
                textureCoords: [],
                vertexNormals: [],
                vertices: []
              }), currentGroup = "";
            }(lineItems, result);
            break;

          case "g":
            !function (lineItems) {
              2 === lineItems.length && (currentGroup = lineItems[1]);
            }(lineItems);
            break;

          case "v":
            !function (z, result) {
              var len = z.length,
                  x = 2 <= len ? parseFloat(z[1]) : 0,
                  y = 3 <= len ? parseFloat(z[2]) : 0,
                  z = 4 <= len ? parseFloat(z[3]) : 0;
              currentModel(result).vertices.push({
                x: x,
                y: y,
                z: z
              });
            }(lineItems, result);
            break;

          case "vt":
            !function (w, result) {
              var len = w.length,
                  u = 2 <= len ? parseFloat(w[1]) : 0,
                  v = 3 <= len ? parseFloat(w[2]) : 0,
                  w = 4 <= len ? parseFloat(w[3]) : 0;
              isNaN(u) && (u = 0), isNaN(v) && (v = 0), isNaN(w) && (w = 0), flip && (v = 1 - v), currentModel(result).textureCoords.push({
                u: u,
                v: v,
                w: w
              });
            }(lineItems, result);
            break;

          case "vn":
            !function (z, result) {
              var len = z.length,
                  x = 2 <= len ? parseFloat(z[1]) : 0,
                  y = 3 <= len ? parseFloat(z[2]) : 0,
                  z = 4 <= len ? parseFloat(z[3]) : 0;
              currentModel(result).vertexNormals.push({
                x: x,
                y: y,
                z: z
              });
            }(lineItems, result);
            break;

          case "f":
            !function (lineItems, result) {
              var totalVertices = lineItems.length - 1;

              if (!(totalVertices < 3)) {
                for (var face = {
                  group: currentGroup,
                  material: currentMaterial,
                  vertices: []
                }, i = 0; i < totalVertices; i++) {
                  var textureCoordsIndex,
                      vertexNormalIndex,
                      vertexIndex,
                      vertexValues = lineItems[i + 1].split("/"),
                      vvLen = vertexValues.length;
                  vvLen < 1 || 3 < vvLen || (vertexNormalIndex = textureCoordsIndex = vertexIndex = 0, vertexIndex = parseInt(vertexValues[0], 10), 1 < vvLen && "" !== vertexValues[1] && (textureCoordsIndex = parseInt(vertexValues[1], 10)), 2 < vvLen && (vertexNormalIndex = parseInt(vertexValues[2], 10)), 0 !== vertexIndex && (vertexIndex < 0 && (vertexIndex = currentModel(result).vertices.length + 1 + vertexIndex), --textureCoordsIndex, --vertexIndex, --vertexNormalIndex, face.vertices.push({
                    textureCoordsIndex: textureCoordsIndex,
                    vertexIndex: vertexIndex,
                    vertexNormalIndex: vertexNormalIndex
                  })));
                }

                currentModel(result).faces.push(face);
              }
            }(lineItems, result);
            break;

          case "mtllib":
            !function (lineItems, result) {
              2 <= lineItems.length && result.materialLibraries.push(lineItems[1]);
            }(lineItems, result);
            break;

          case "usemtl":
            !function (lineItems) {
              2 <= lineItems.length && (currentMaterial = lineItems[1]);
            }(lineItems);
        }
      }

      return result;
    };
  }, function (module, exports, __webpack_require__) {
    var GetColor = __webpack_require__(103);

    module.exports = function (mtl) {
      for (var output = {}, lines = mtl.split("\n"), currentMaterial = "", i = 0; i < lines.length; i++) {
        var line = lines[i].trim();

        if (0 !== line.indexOf("#") && "" !== line) {
          var lineItems = line.replace(/\s\s+/g, " ").trim().split(" ");

          switch (lineItems[0].toLowerCase()) {
            case "newmtl":
              currentMaterial = lineItems[1];
              break;

            case "kd":
              var r = Math.floor(255 * lineItems[1]),
                  g = 2 <= lineItems.length ? Math.floor(255 * lineItems[2]) : r,
                  b = 3 <= lineItems.length ? Math.floor(255 * lineItems[3]) : r;
              output[currentMaterial] = GetColor(r, g, b);
          }
        }
      }

      return output;
    };
  }, function (module, exports) {
    module.exports = function (point) {
      return Math.sqrt(point.x * point.x + point.y * point.y);
    };
  }, function (module, exports) {
    module.exports = function (point) {
      return point.x * point.x + point.y * point.y;
    };
  }, function (module, exports, __webpack_require__) {
    var Rectangle = __webpack_require__(10);

    Rectangle.Area = __webpack_require__(1267), Rectangle.Ceil = __webpack_require__(1268), Rectangle.CeilAll = __webpack_require__(1269), Rectangle.CenterOn = __webpack_require__(190), Rectangle.Clone = __webpack_require__(1270), Rectangle.Contains = __webpack_require__(57), Rectangle.ContainsPoint = __webpack_require__(1271), Rectangle.ContainsRect = __webpack_require__(503), Rectangle.CopyFrom = __webpack_require__(1272), Rectangle.Decompose = __webpack_require__(490), Rectangle.Equals = __webpack_require__(1273), Rectangle.FitInside = __webpack_require__(1274), Rectangle.FitOutside = __webpack_require__(1275), Rectangle.Floor = __webpack_require__(1276), Rectangle.FloorAll = __webpack_require__(1277), Rectangle.FromPoints = __webpack_require__(199), Rectangle.FromXY = __webpack_require__(1278), Rectangle.GetAspectRatio = __webpack_require__(237), Rectangle.GetCenter = __webpack_require__(1279), Rectangle.GetPoint = __webpack_require__(171), Rectangle.GetPoints = __webpack_require__(306), Rectangle.GetSize = __webpack_require__(1280), Rectangle.Inflate = __webpack_require__(1281), Rectangle.Intersection = __webpack_require__(1282), Rectangle.MarchingAnts = __webpack_require__(316), Rectangle.MergePoints = __webpack_require__(1283), Rectangle.MergeRect = __webpack_require__(1284), Rectangle.MergeXY = __webpack_require__(1285), Rectangle.Offset = __webpack_require__(1286), Rectangle.OffsetPoint = __webpack_require__(1287), Rectangle.Overlaps = __webpack_require__(1288), Rectangle.Perimeter = __webpack_require__(130), Rectangle.PerimeterPoint = __webpack_require__(1289), Rectangle.Random = __webpack_require__(174), Rectangle.RandomOutside = __webpack_require__(1290), Rectangle.SameDimensions = __webpack_require__(1291), Rectangle.Scale = __webpack_require__(1292), Rectangle.Union = __webpack_require__(441), module.exports = Rectangle;
  }, function (module, exports) {
    module.exports = function (rectA, rectB) {
      return !(rectB.width * rectB.height > rectA.width * rectA.height) && rectB.x > rectA.x && rectB.x < rectA.right && rectB.right > rectA.x && rectB.right < rectA.right && rectB.y > rectA.y && rectB.y < rectA.bottom && rectB.bottom > rectA.y && rectB.bottom < rectA.bottom;
    };
  }, function (module, exports, __webpack_require__) {
    var Point = __webpack_require__(4);

    module.exports = function (triangle, out) {
      return (out = void 0 === out ? new Point() : out).x = (triangle.x1 + triangle.x2 + triangle.x3) / 3, out.y = (triangle.y1 + triangle.y2 + triangle.y3) / 3, out;
    };
  }, function (module, exports) {
    module.exports = function (triangle, x, y) {
      return triangle.x1 += x, triangle.y1 += y, triangle.x2 += x, triangle.y2 += y, triangle.x3 += x, triangle.y3 += y, triangle;
    };
  }, function (module, exports, __webpack_require__) {
    var Point = __webpack_require__(4);

    function getLength(x1, y1, x, y) {
      x = x1 - x, y = y1 - y;
      return Math.sqrt(x * x + y * y);
    }

    module.exports = function (p, out) {
      void 0 === out && (out = new Point());
      var x1 = p.x1,
          y1 = p.y1,
          x2 = p.x2,
          y2 = p.y2,
          x3 = p.x3,
          y3 = p.y3,
          d1 = getLength(x3, y3, x2, y2),
          d2 = getLength(x1, y1, x3, y3),
          d3 = getLength(x2, y2, x1, y1),
          p = d1 + d2 + d3;
      return out.x = (x1 * d1 + x2 * d2 + x3 * d3) / p, out.y = (y1 * d1 + y2 * d2 + y3 * d3) / p, out;
    };
  }, function (module, exports) {
    module.exports = function (textureManager, alphaTolerance) {
      return function (hitArea, x, y, alpha) {
        alpha = textureManager.getPixelAlpha(x, y, alpha.texture.key, alpha.frame.name);
        return alpha && alphaTolerance <= alpha;
      };
    };
  }, function (module, exports) {
    module.exports = function (gameObject, hitArea, hitAreaCallback) {
      return {
        gameObject: gameObject,
        enabled: !0,
        alwaysEnabled: !1,
        draggable: !1,
        dropZone: !1,
        cursor: !1,
        target: null,
        camera: null,
        hitArea: hitArea,
        hitAreaCallback: hitAreaCallback,
        hitAreaDebug: null,
        customHitArea: !1,
        localX: 0,
        localY: 0,
        dragState: 0,
        dragStartX: 0,
        dragStartY: 0,
        dragStartXGlobal: 0,
        dragStartYGlobal: 0,
        dragX: 0,
        dragY: 0
      };
    };
  }, function (module, exports, Axis) {
    Axis = new (Axis(0))({
      initialize: function initialize(pad, index) {
        this.pad = pad, this.events = pad.events, this.index = index, this.value = 0, this.threshold = .1;
      },
      update: function update(value) {
        this.value = value;
      },
      getValue: function getValue() {
        return Math.abs(this.value) < this.threshold ? 0 : this.value;
      },
      destroy: function destroy() {
        this.pad = null, this.events = null;
      }
    });
    module.exports = Axis;
  }, function (module, exports, __webpack_require__) {
    var Button = __webpack_require__(0),
        Events = __webpack_require__(239),
        Button = new Button({
      initialize: function initialize(pad, index) {
        this.pad = pad, this.events = pad.manager, this.index = index, this.value = 0, this.threshold = 1, this.pressed = !1;
      },
      update: function update(value) {
        this.value = value;
        var pad = this.pad,
            index = this.index;
        value >= this.threshold ? this.pressed || (this.pressed = !0, this.events.emit(Events.BUTTON_DOWN, pad, this, value), this.pad.emit(Events.GAMEPAD_BUTTON_DOWN, index, value, this)) : this.pressed && (this.pressed = !1, this.events.emit(Events.BUTTON_UP, pad, this, value), this.pad.emit(Events.GAMEPAD_BUTTON_UP, index, value, this));
      },
      destroy: function destroy() {
        this.pad = null, this.events = null;
      }
    });

    module.exports = Button;
  }, function (module, exports, __webpack_require__) {
    var Axis = __webpack_require__(509),
        Button = __webpack_require__(510),
        Gamepad = __webpack_require__(0),
        EventEmitter = __webpack_require__(9),
        Vector2 = __webpack_require__(3),
        Gamepad = new Gamepad({
      Extends: EventEmitter,
      initialize: function initialize(_noAxis, pad) {
        EventEmitter.call(this), this.manager = _noAxis, this.pad = pad, this.id = pad.id, this.index = pad.index;

        for (var buttons = [], i = 0; i < pad.buttons.length; i++) {
          buttons.push(new Button(this, i));
        }

        this.buttons = buttons;

        for (var axes = [], i = 0; i < pad.axes.length; i++) {
          axes.push(new Axis(this, i));
        }

        this.axes = axes, this.vibration = pad.vibrationActuator;
        _noAxis = {
          value: 0,
          pressed: !1
        };
        this._LCLeft = buttons[14] || _noAxis, this._LCRight = buttons[15] || _noAxis, this._LCTop = buttons[12] || _noAxis, this._LCBottom = buttons[13] || _noAxis, this._RCLeft = buttons[2] || _noAxis, this._RCRight = buttons[1] || _noAxis, this._RCTop = buttons[3] || _noAxis, this._RCBottom = buttons[0] || _noAxis, this._FBLeftTop = buttons[4] || _noAxis, this._FBLeftBottom = buttons[6] || _noAxis, this._FBRightTop = buttons[5] || _noAxis, this._FBRightBottom = buttons[7] || _noAxis;
        _noAxis = {
          value: 0
        };
        this._HAxisLeft = axes[0] || _noAxis, this._VAxisLeft = axes[1] || _noAxis, this._HAxisRight = axes[2] || _noAxis, this._VAxisRight = axes[3] || _noAxis, this.leftStick = new Vector2(), this.rightStick = new Vector2(), this._created = performance.now();
      },
      getAxisTotal: function getAxisTotal() {
        return this.axes.length;
      },
      getAxisValue: function getAxisValue(index) {
        return this.axes[index].getValue();
      },
      setAxisThreshold: function setAxisThreshold(value) {
        for (var i = 0; i < this.axes.length; i++) {
          this.axes[i].threshold = value;
        }
      },
      getButtonTotal: function getButtonTotal() {
        return this.buttons.length;
      },
      getButtonValue: function getButtonValue(index) {
        return this.buttons[index].value;
      },
      isButtonDown: function isButtonDown(index) {
        return this.buttons[index].pressed;
      },
      update: function update(pad) {
        if (!(pad.timestamp < this._created)) {
          for (var localButtons = this.buttons, gamepadButtons = pad.buttons, len = localButtons.length, i = 0; i < len; i++) {
            localButtons[i].update(gamepadButtons[i].value);
          }

          var localAxes = this.axes,
              gamepadAxes = pad.axes,
              len = localAxes.length;

          for (i = 0; i < len; i++) {
            localAxes[i].update(gamepadAxes[i]);
          }

          2 <= len && (this.leftStick.set(localAxes[0].getValue(), localAxes[1].getValue()), 4 <= len && this.rightStick.set(localAxes[2].getValue(), localAxes[3].getValue()));
        }
      },
      destroy: function destroy() {
        var i;

        for (this.removeAllListeners(), this.manager = null, this.pad = null, i = 0; i < this.buttons.length; i++) {
          this.buttons[i].destroy();
        }

        for (i = 0; i < this.axes.length; i++) {
          this.axes[i].destroy();
        }

        this.buttons = [], this.axes = [];
      },
      connected: {
        get: function get() {
          return this.pad.connected;
        }
      },
      timestamp: {
        get: function get() {
          return this.pad.timestamp;
        }
      },
      left: {
        get: function get() {
          return this._LCLeft.pressed;
        }
      },
      right: {
        get: function get() {
          return this._LCRight.pressed;
        }
      },
      up: {
        get: function get() {
          return this._LCTop.pressed;
        }
      },
      down: {
        get: function get() {
          return this._LCBottom.pressed;
        }
      },
      A: {
        get: function get() {
          return this._RCBottom.pressed;
        }
      },
      Y: {
        get: function get() {
          return this._RCTop.pressed;
        }
      },
      X: {
        get: function get() {
          return this._RCLeft.pressed;
        }
      },
      B: {
        get: function get() {
          return this._RCRight.pressed;
        }
      },
      L1: {
        get: function get() {
          return this._FBLeftTop.value;
        }
      },
      L2: {
        get: function get() {
          return this._FBLeftBottom.value;
        }
      },
      R1: {
        get: function get() {
          return this._FBRightTop.value;
        }
      },
      R2: {
        get: function get() {
          return this._FBRightBottom.value;
        }
      }
    });

    module.exports = Gamepad;
  }, function (module, exports, __webpack_require__) {
    var Key = __webpack_require__(0),
        EventEmitter = __webpack_require__(9),
        Events = __webpack_require__(154),
        Key = new Key({
      Extends: EventEmitter,
      initialize: function initialize(plugin, keyCode) {
        EventEmitter.call(this), this.plugin = plugin, this.keyCode = keyCode, this.originalEvent = void 0, this.enabled = !0, this.isDown = !1, this.isUp = !0, this.altKey = !1, this.ctrlKey = !1, this.shiftKey = !1, this.metaKey = !1, this.location = 0, this.timeDown = 0, this.duration = 0, this.timeUp = 0, this.emitOnRepeat = !1, this.repeats = 0, this._justDown = !1, this._justUp = !1, this._tick = -1;
      },
      setEmitOnRepeat: function setEmitOnRepeat(value) {
        return this.emitOnRepeat = value, this;
      },
      onDown: function onDown(event) {
        this.originalEvent = event, this.enabled && (this.altKey = event.altKey, this.ctrlKey = event.ctrlKey, this.shiftKey = event.shiftKey, this.metaKey = event.metaKey, this.location = event.location, this.repeats++, this.isDown ? this.emitOnRepeat && this.emit(Events.DOWN, this, event) : (this.isDown = !0, this.isUp = !1, this.timeDown = event.timeStamp, this.duration = 0, this._justDown = !0, this._justUp = !1, this.emit(Events.DOWN, this, event)));
      },
      onUp: function onUp(event) {
        this.originalEvent = event, this.enabled && (this.isDown = !1, this.isUp = !0, this.timeUp = event.timeStamp, this.duration = this.timeUp - this.timeDown, this.repeats = 0, this._justDown = !1, this._justUp = !0, this._tick = -1, this.emit(Events.UP, this, event));
      },
      reset: function reset() {
        return this.preventDefault = !0, this.enabled = !0, this.isDown = !1, this.isUp = !0, this.altKey = !1, this.ctrlKey = !1, this.shiftKey = !1, this.metaKey = !1, this.timeDown = 0, this.duration = 0, this.timeUp = 0, this.repeats = 0, this._justDown = !1, this._justUp = !1, this._tick = -1, this;
      },
      getDuration: function getDuration() {
        return this.isDown ? this.plugin.game.loop.time - this.timeDown : 0;
      },
      destroy: function destroy() {
        this.removeAllListeners(), this.originalEvent = null, this.plugin = null;
      }
    });

    module.exports = Key;
  }, function (module, exports, __webpack_require__) {
    var KeyCombo = __webpack_require__(0),
        Events = __webpack_require__(154),
        GetFastValue = __webpack_require__(2),
        ProcessKeyCombo = __webpack_require__(514),
        ResetKeyCombo = __webpack_require__(516),
        KeyCombo = new KeyCombo({
      initialize: function initialize(keyboardPlugin, keys, config) {
        if (void 0 === config && (config = {}), keys.length < 2) return !1;
        this.manager = keyboardPlugin, this.enabled = !0, this.keyCodes = [];

        for (var i = 0; i < keys.length; i++) {
          var char = keys[i];
          "string" == typeof char ? this.keyCodes.push(char.toUpperCase().charCodeAt(0)) : "number" == typeof char ? this.keyCodes.push(char) : char.hasOwnProperty("keyCode") && this.keyCodes.push(char.keyCode);
        }

        this.current = this.keyCodes[0], this.index = 0, this.size = this.keyCodes.length, this.timeLastMatched = 0, this.matched = !1, this.timeMatched = 0, this.resetOnWrongKey = GetFastValue(config, "resetOnWrongKey", !0), this.maxKeyDelay = GetFastValue(config, "maxKeyDelay", 0), this.resetOnMatch = GetFastValue(config, "resetOnMatch", !1), this.deleteOnMatch = GetFastValue(config, "deleteOnMatch", !1);

        var _this = this;

        this.onKeyDown = function (event) {
          !_this.matched && _this.enabled && ProcessKeyCombo(event, _this) && (_this.manager.emit(Events.COMBO_MATCH, _this, event), _this.resetOnMatch ? ResetKeyCombo(_this) : _this.deleteOnMatch && _this.destroy());
        }, this.manager.on(Events.ANY_KEY_DOWN, this.onKeyDown);
      },
      progress: {
        get: function get() {
          return this.index / this.size;
        }
      },
      destroy: function destroy() {
        this.enabled = !1, this.keyCodes = [], this.manager.off(Events.ANY_KEY_DOWN, this.onKeyDown), this.manager = null;
      }
    });

    module.exports = KeyCombo;
  }, function (module, exports, __webpack_require__) {
    var AdvanceKeyCombo = __webpack_require__(515);

    module.exports = function (event, combo) {
      if (combo.matched) return !0;
      var timeLimit,
          comboMatched = !1,
          keyMatched = !1;
      return event.keyCode === combo.current && (0 < combo.index && 0 < combo.maxKeyDelay ? (timeLimit = combo.timeLastMatched + combo.maxKeyDelay, event.timeStamp <= timeLimit && (keyMatched = !0, comboMatched = AdvanceKeyCombo(event, combo))) : (keyMatched = !0, comboMatched = AdvanceKeyCombo(event, combo))), !keyMatched && combo.resetOnWrongKey && (combo.index = 0, combo.current = combo.keyCodes[0]), comboMatched && (combo.timeLastMatched = event.timeStamp, combo.matched = !0, combo.timeMatched = event.timeStamp), comboMatched;
    };
  }, function (module, exports) {
    module.exports = function (event, combo) {
      return combo.timeLastMatched = event.timeStamp, combo.index++, combo.index === combo.size || (combo.current = combo.keyCodes[combo.index], !1);
    };
  }, function (module, exports) {
    module.exports = function (combo) {
      return combo.current = combo.keyCodes[0], combo.index = 0, combo.timeLastMatched = 0, combo.matched = !1, combo.timeMatched = 0, combo;
    };
  }, function (module, exports, __webpack_require__) {
    var MergeXHRSettings = __webpack_require__(240);

    module.exports = function (file, globalXHRSettings) {
      var config = MergeXHRSettings(globalXHRSettings, file.xhrSettings),
          xhr = new XMLHttpRequest();
      if (xhr.open("GET", file.src, config.async, config.user, config.password), xhr.responseType = file.xhrSettings.responseType, xhr.timeout = config.timeout, config.headers) for (var key in config.headers) {
        xhr.setRequestHeader(key, config.headers[key]);
      }
      return config.header && config.headerValue && xhr.setRequestHeader(config.header, config.headerValue), config.requestedWith && xhr.setRequestHeader("X-Requested-With", config.requestedWith), config.overrideMimeType && xhr.overrideMimeType(config.overrideMimeType), config.withCredentials && (xhr.withCredentials = !0), xhr.onload = file.onLoad.bind(file, xhr), xhr.onerror = file.onError.bind(file, xhr), xhr.onprogress = file.onProgress.bind(file), xhr.send(), xhr;
    };
  }, function (module, exports, __webpack_require__) {
    var Class = __webpack_require__(0),
        CONST = __webpack_require__(21),
        File = __webpack_require__(23),
        FileTypesManager = __webpack_require__(8),
        GetFastValue = __webpack_require__(2),
        HTML5AudioFile = __webpack_require__(519),
        IsPlainObject = __webpack_require__(7),
        AudioFile = new Class({
      Extends: File,
      initialize: function initialize(loader, key, urlConfig, xhrSettings, fileConfig) {
        var config;
        IsPlainObject(key) && (key = GetFastValue(config = key, "key"), xhrSettings = GetFastValue(config, "xhrSettings"), fileConfig = GetFastValue(config, "context", fileConfig));
        fileConfig = {
          type: "audio",
          cache: loader.cacheManager.audio,
          extension: urlConfig.type,
          responseType: "arraybuffer",
          key: key,
          url: urlConfig.url,
          xhrSettings: xhrSettings,
          config: {
            context: fileConfig
          }
        };
        File.call(this, loader, fileConfig);
      },
      onProcess: function onProcess() {
        this.state = CONST.FILE_PROCESSING;

        var _this = this;

        this.config.context.decodeAudioData(this.xhrLoader.response, function (audioBuffer) {
          _this.data = audioBuffer, _this.onProcessComplete();
        }, function (e) {
          console.error("Error decoding audio: " + _this.key + " - ", e ? e.message : null), _this.onProcessError();
        }), this.config.context = null;
      }
    });

    AudioFile.create = function (loader, key, urlConfig, config, xhrSettings) {
      var game = loader.systems.game,
          audioConfig = game.config.audio,
          deviceAudio = game.device.audio;
      IsPlainObject(key) && (urlConfig = GetFastValue(key, "url", []), config = GetFastValue(key, "config", {}));
      urlConfig = AudioFile.getAudioURL(game, urlConfig);
      return urlConfig ? deviceAudio.webAudio && !audioConfig.disableWebAudio ? new AudioFile(loader, key, urlConfig, xhrSettings, game.sound.context) : new HTML5AudioFile(loader, key, urlConfig, config) : null;
    }, AudioFile.getAudioURL = function (game, urls) {
      Array.isArray(urls) || (urls = [urls]);

      for (var i = 0; i < urls.length; i++) {
        var url = GetFastValue(urls[i], "url", urls[i]);
        if (0 === url.indexOf("blob:") || 0 === url.indexOf("data:")) return {
          url: url,
          type: ""
        };
        var audioType = url.match(/\.([a-zA-Z0-9]+)($|\?)/),
            audioType = GetFastValue(urls[i], "type", audioType ? audioType[1] : "").toLowerCase();
        if (game.device.audio[audioType]) return {
          url: url,
          type: audioType
        };
      }

      return null;
    }, FileTypesManager.register("audio", function (key, urls, config, xhrSettings) {
      var audioFile,
          deviceAudio = this.systems.game,
          audioConfig = deviceAudio.config.audio,
          deviceAudio = deviceAudio.device.audio;
      if (audioConfig.noAudio || !deviceAudio.webAudio && !deviceAudio.audioData) return this;
      if (Array.isArray(key)) for (var i = 0; i < key.length; i++) {
        (audioFile = AudioFile.create(this, key[i])) && this.addFile(audioFile);
      } else (audioFile = AudioFile.create(this, key, urls, config, xhrSettings)) && this.addFile(audioFile);
      return this;
    }), module.exports = AudioFile;
  }, function (module, exports, __webpack_require__) {
    var HTML5AudioFile = __webpack_require__(0),
        Events = __webpack_require__(95),
        File = __webpack_require__(23),
        GetFastValue = __webpack_require__(2),
        GetURL = __webpack_require__(155),
        IsPlainObject = __webpack_require__(7),
        HTML5AudioFile = new HTML5AudioFile({
      Extends: File,
      initialize: function initialize(loader, key, urlConfig, fileConfig) {
        var config;
        IsPlainObject(key) && (key = GetFastValue(config = key, "key"), fileConfig = GetFastValue(config, "config", fileConfig));
        fileConfig = {
          type: "audio",
          cache: loader.cacheManager.audio,
          extension: urlConfig.type,
          key: key,
          url: urlConfig.url,
          config: fileConfig
        };
        File.call(this, loader, fileConfig), this.locked = "ontouchstart" in window, this.loaded = !1, this.filesLoaded = 0, this.filesTotal = 0;
      },
      onLoad: function onLoad() {
        this.loaded || (this.loaded = !0, this.loader.nextFile(this, !0));
      },
      onError: function onError() {
        for (var i = 0; i < this.data.length; i++) {
          var audio = this.data[i];
          audio.oncanplaythrough = null, audio.onerror = null;
        }

        this.loader.nextFile(this, !1);
      },
      onProgress: function onProgress(audio) {
        audio = audio.target;
        audio.oncanplaythrough = null, audio.onerror = null, this.filesLoaded++, this.percentComplete = Math.min(this.filesLoaded / this.filesTotal, 1), this.loader.emit(Events.FILE_PROGRESS, this, this.percentComplete), this.filesLoaded === this.filesTotal && this.onLoad();
      },
      load: function load() {
        this.data = [];
        var instances = this.config && this.config.instances || 1;
        this.filesTotal = instances, this.filesLoaded = 0;

        for (var i = this.percentComplete = 0; i < instances; i++) {
          var audio = new Audio();
          audio.dataset || (audio.dataset = {}), audio.dataset.name = this.key + ("0" + i).slice(-2), audio.dataset.used = "false", this.locked ? audio.dataset.locked = "true" : (audio.dataset.locked = "false", audio.preload = "auto", audio.oncanplaythrough = this.onProgress.bind(this), audio.onerror = this.onError.bind(this)), this.data.push(audio);
        }

        for (i = 0; i < this.data.length; i++) {
          (audio = this.data[i]).src = GetURL(this, this.loader.baseURL), this.locked || audio.load();
        }

        this.locked && setTimeout(this.onLoad.bind(this));
      }
    });

    module.exports = HTML5AudioFile;
  }, function (module, exports, __webpack_require__) {
    var Class = __webpack_require__(0),
        CONST = __webpack_require__(21),
        File = __webpack_require__(23),
        FileTypesManager = __webpack_require__(8),
        GetFastValue = __webpack_require__(2),
        IsPlainObject = __webpack_require__(7),
        ScriptFile = new Class({
      Extends: File,
      initialize: function initialize(loader, key, url, xhrSettings) {
        var config,
            extension = "js";
        IsPlainObject(key) && (key = GetFastValue(config = key, "key"), url = GetFastValue(config, "url"), xhrSettings = GetFastValue(config, "xhrSettings"), extension = GetFastValue(config, "extension", extension)), File.call(this, loader, {
          type: "script",
          cache: !1,
          extension: extension,
          responseType: "text",
          key: key,
          url: url,
          xhrSettings: xhrSettings
        });
      },
      onProcess: function onProcess() {
        this.state = CONST.FILE_PROCESSING, this.data = document.createElement("script"), this.data.language = "javascript", this.data.type = "text/javascript", this.data.defer = !1, this.data.text = this.xhrLoader.responseText, document.head.appendChild(this.data), this.onProcessComplete();
      }
    });

    FileTypesManager.register("script", function (key, url, xhrSettings) {
      if (Array.isArray(key)) for (var i = 0; i < key.length; i++) {
        this.addFile(new ScriptFile(this, key[i]));
      } else this.addFile(new ScriptFile(this, key, url, xhrSettings));
      return this;
    }), module.exports = ScriptFile;
  }, function (module, exports, __webpack_require__) {
    var ArcadeImage = __webpack_require__(522),
        ArcadeSprite = __webpack_require__(157),
        Factory = __webpack_require__(0),
        CONST = __webpack_require__(62),
        PhysicsGroup = __webpack_require__(524),
        StaticPhysicsGroup = __webpack_require__(525),
        Factory = new Factory({
      initialize: function initialize(world) {
        this.world = world, this.scene = world.scene, this.sys = world.scene.sys;
      },
      collider: function collider(object1, object2, collideCallback, processCallback, callbackContext) {
        return this.world.addCollider(object1, object2, collideCallback, processCallback, callbackContext);
      },
      overlap: function overlap(object1, object2, collideCallback, processCallback, callbackContext) {
        return this.world.addOverlap(object1, object2, collideCallback, processCallback, callbackContext);
      },
      existing: function existing(gameObject, type) {
        type = type ? CONST.STATIC_BODY : CONST.DYNAMIC_BODY;
        return this.world.enableBody(gameObject, type), gameObject;
      },
      staticImage: function staticImage(x, y, key, image) {
        image = new ArcadeImage(this.scene, x, y, key, image);
        return this.sys.displayList.add(image), this.world.enableBody(image, CONST.STATIC_BODY), image;
      },
      image: function image(x, y, key, _image) {
        _image = new ArcadeImage(this.scene, x, y, key, _image);
        return this.sys.displayList.add(_image), this.world.enableBody(_image, CONST.DYNAMIC_BODY), _image;
      },
      staticSprite: function staticSprite(x, y, key, sprite) {
        sprite = new ArcadeSprite(this.scene, x, y, key, sprite);
        return this.sys.displayList.add(sprite), this.sys.updateList.add(sprite), this.world.enableBody(sprite, CONST.STATIC_BODY), sprite;
      },
      sprite: function sprite(x, y, key, _sprite) {
        _sprite = new ArcadeSprite(this.scene, x, y, key, _sprite);
        return this.sys.displayList.add(_sprite), this.sys.updateList.add(_sprite), this.world.enableBody(_sprite, CONST.DYNAMIC_BODY), _sprite;
      },
      staticGroup: function staticGroup(children, config) {
        return this.sys.updateList.add(new StaticPhysicsGroup(this.world, this.world.scene, children, config));
      },
      group: function group(children, config) {
        return this.sys.updateList.add(new PhysicsGroup(this.world, this.world.scene, children, config));
      },
      destroy: function destroy() {
        this.world = null, this.scene = null, this.sys = null;
      }
    });

    module.exports = Factory;
  }, function (module, exports, __webpack_require__) {
    var Class = __webpack_require__(0),
        ArcadeImage = __webpack_require__(243),
        Image = __webpack_require__(125),
        ArcadeImage = new Class({
      Extends: Image,
      Mixins: [ArcadeImage.Acceleration, ArcadeImage.Angular, ArcadeImage.Bounce, ArcadeImage.Debug, ArcadeImage.Drag, ArcadeImage.Enable, ArcadeImage.Friction, ArcadeImage.Gravity, ArcadeImage.Immovable, ArcadeImage.Mass, ArcadeImage.Pushable, ArcadeImage.Size, ArcadeImage.Velocity],
      initialize: function initialize(scene, x, y, texture, frame) {
        Image.call(this, scene, x, y, texture, frame), this.body = null;
      }
    });

    module.exports = ArcadeImage;
  }, function (module, exports, __webpack_require__) {
    var OverlapRect = __webpack_require__(244),
        Circle = __webpack_require__(65),
        CircleToCircle = __webpack_require__(231),
        CircleToRectangle = __webpack_require__(151);

    module.exports = function (world, x, y, radius, includeDynamic, includeStatic) {
      var bodiesInRect = OverlapRect(world, x - radius, y - radius, 2 * radius, 2 * radius, includeDynamic, includeStatic);
      if (0 === bodiesInRect.length) return bodiesInRect;

      for (var area = new Circle(x, y, radius), circFromBody = new Circle(), bodiesInArea = [], i = 0; i < bodiesInRect.length; i++) {
        var body = bodiesInRect[i];
        body.isCircle ? (circFromBody.setTo(body.center.x, body.center.y, body.halfWidth), CircleToCircle(area, circFromBody) && bodiesInArea.push(body)) : CircleToRectangle(area, body) && bodiesInArea.push(body);
      }

      return bodiesInArea;
    };
  }, function (module, exports, __webpack_require__) {
    var ArcadeSprite = __webpack_require__(157),
        PhysicsGroup = __webpack_require__(0),
        CONST = __webpack_require__(62),
        GetFastValue = __webpack_require__(2),
        Group = __webpack_require__(113),
        IsPlainObject = __webpack_require__(7),
        PhysicsGroup = new PhysicsGroup({
      Extends: Group,
      initialize: function initialize(world, scene, children, config) {
        var _this;

        children || config ? IsPlainObject(children) ? (config = children, children = null, config.internalCreateCallback = this.createCallbackHandler, config.internalRemoveCallback = this.removeCallbackHandler) : Array.isArray(children) && IsPlainObject(children[0]) ? (config = children[0], _this = this, children.forEach(function (singleConfig) {
          singleConfig.internalCreateCallback = _this.createCallbackHandler, singleConfig.internalRemoveCallback = _this.removeCallbackHandler;
        }), children = null) : config = {
          internalCreateCallback: this.createCallbackHandler,
          internalRemoveCallback: this.removeCallbackHandler
        } : config = {
          internalCreateCallback: this.createCallbackHandler,
          internalRemoveCallback: this.removeCallbackHandler
        }, this.world = world, config.classType = GetFastValue(config, "classType", ArcadeSprite), this.physicsType = CONST.DYNAMIC_BODY, this.defaults = {
          setCollideWorldBounds: GetFastValue(config, "collideWorldBounds", !1),
          setBoundsRectangle: GetFastValue(config, "customBoundsRectangle", null),
          setAccelerationX: GetFastValue(config, "accelerationX", 0),
          setAccelerationY: GetFastValue(config, "accelerationY", 0),
          setAllowDrag: GetFastValue(config, "allowDrag", !0),
          setAllowGravity: GetFastValue(config, "allowGravity", !0),
          setAllowRotation: GetFastValue(config, "allowRotation", !0),
          setBounceX: GetFastValue(config, "bounceX", 0),
          setBounceY: GetFastValue(config, "bounceY", 0),
          setDragX: GetFastValue(config, "dragX", 0),
          setDragY: GetFastValue(config, "dragY", 0),
          setEnable: GetFastValue(config, "enable", !0),
          setGravityX: GetFastValue(config, "gravityX", 0),
          setGravityY: GetFastValue(config, "gravityY", 0),
          setFrictionX: GetFastValue(config, "frictionX", 0),
          setFrictionY: GetFastValue(config, "frictionY", 0),
          setMaxVelocityX: GetFastValue(config, "maxVelocityX", 1e4),
          setMaxVelocityY: GetFastValue(config, "maxVelocityY", 1e4),
          setVelocityX: GetFastValue(config, "velocityX", 0),
          setVelocityY: GetFastValue(config, "velocityY", 0),
          setAngularVelocity: GetFastValue(config, "angularVelocity", 0),
          setAngularAcceleration: GetFastValue(config, "angularAcceleration", 0),
          setAngularDrag: GetFastValue(config, "angularDrag", 0),
          setMass: GetFastValue(config, "mass", 1),
          setImmovable: GetFastValue(config, "immovable", !1)
        }, Group.call(this, scene, children, config), this.type = "PhysicsGroup";
      },
      createCallbackHandler: function createCallbackHandler(child) {
        child.body || this.world.enableBody(child, CONST.DYNAMIC_BODY);
        var key,
            body = child.body;

        for (key in this.defaults) {
          body[key](this.defaults[key]);
        }
      },
      removeCallbackHandler: function removeCallbackHandler(child) {
        child.body && this.world.disableBody(child);
      },
      setVelocity: function setVelocity(x, y, step) {
        void 0 === step && (step = 0);

        for (var items = this.getChildren(), i = 0; i < items.length; i++) {
          items[i].body.velocity.set(x + i * step, y + i * step);
        }

        return this;
      },
      setVelocityX: function setVelocityX(value, step) {
        void 0 === step && (step = 0);

        for (var items = this.getChildren(), i = 0; i < items.length; i++) {
          items[i].body.velocity.x = value + i * step;
        }

        return this;
      },
      setVelocityY: function setVelocityY(value, step) {
        void 0 === step && (step = 0);

        for (var items = this.getChildren(), i = 0; i < items.length; i++) {
          items[i].body.velocity.y = value + i * step;
        }

        return this;
      }
    });

    module.exports = PhysicsGroup;
  }, function (module, exports, __webpack_require__) {
    var ArcadeSprite = __webpack_require__(157),
        StaticPhysicsGroup = __webpack_require__(0),
        CONST = __webpack_require__(62),
        GetFastValue = __webpack_require__(2),
        Group = __webpack_require__(113),
        IsPlainObject = __webpack_require__(7),
        StaticPhysicsGroup = new StaticPhysicsGroup({
      Extends: Group,
      initialize: function initialize(world, scene, children, config) {
        children || config ? IsPlainObject(children) ? (config = children, children = null, config.internalCreateCallback = this.createCallbackHandler, config.internalRemoveCallback = this.removeCallbackHandler, config.createMultipleCallback = this.createMultipleCallbackHandler, config.classType = GetFastValue(config, "classType", ArcadeSprite)) : Array.isArray(children) && IsPlainObject(children[0]) ? (config = children, children = null, config.forEach(function (singleConfig) {
          singleConfig.internalCreateCallback = this.createCallbackHandler, singleConfig.internalRemoveCallback = this.removeCallbackHandler, singleConfig.createMultipleCallback = this.createMultipleCallbackHandler, singleConfig.classType = GetFastValue(singleConfig, "classType", ArcadeSprite);
        })) : config = {
          internalCreateCallback: this.createCallbackHandler,
          internalRemoveCallback: this.removeCallbackHandler
        } : config = {
          internalCreateCallback: this.createCallbackHandler,
          internalRemoveCallback: this.removeCallbackHandler,
          createMultipleCallback: this.createMultipleCallbackHandler,
          classType: ArcadeSprite
        }, this.world = world, this.physicsType = CONST.STATIC_BODY, Group.call(this, scene, children, config), this.type = "StaticPhysicsGroup";
      },
      createCallbackHandler: function createCallbackHandler(child) {
        child.body || this.world.enableBody(child, CONST.STATIC_BODY);
      },
      removeCallbackHandler: function removeCallbackHandler(child) {
        child.body && this.world.disableBody(child);
      },
      createMultipleCallbackHandler: function createMultipleCallbackHandler() {
        this.refresh();
      },
      refresh: function refresh() {
        for (var children = this.children.entries, i = 0; i < children.length; i++) {
          children[i].body.reset();
        }

        return this;
      }
    });

    module.exports = StaticPhysicsGroup;
  }, function (module, exports, __webpack_require__) {
    var AngleBetweenPoints = __webpack_require__(350),
        Body = __webpack_require__(527),
        Clamp = __webpack_require__(18),
        World = __webpack_require__(0),
        Collider = __webpack_require__(528),
        CONST = __webpack_require__(62),
        DistanceBetween = __webpack_require__(50),
        EventEmitter = __webpack_require__(9),
        Events = __webpack_require__(245),
        FuzzyEqual = __webpack_require__(124),
        FuzzyGreaterThan = __webpack_require__(354),
        FuzzyLessThan = __webpack_require__(355),
        GetOverlapX = __webpack_require__(246),
        GetOverlapY = __webpack_require__(247),
        GetTilesWithinWorldXY = __webpack_require__(529),
        GetValue = __webpack_require__(6),
        MATH_CONST = __webpack_require__(14),
        ProcessQueue = __webpack_require__(211),
        ProcessTileCallbacks = __webpack_require__(530),
        Rectangle = __webpack_require__(10),
        RTree = __webpack_require__(531),
        SeparateTile = __webpack_require__(532),
        SeparateX = __webpack_require__(537),
        SeparateY = __webpack_require__(538),
        Set = __webpack_require__(149),
        StaticBody = __webpack_require__(539),
        TileIntersectsBody = __webpack_require__(248),
        TransformMatrix = __webpack_require__(25),
        Vector2 = __webpack_require__(3),
        Wrap = __webpack_require__(68),
        World = new World({
      Extends: EventEmitter,
      initialize: function initialize(scene, config) {
        EventEmitter.call(this), this.scene = scene, this.bodies = new Set(), this.staticBodies = new Set(), this.pendingDestroy = new Set(), this.colliders = new ProcessQueue(), this.gravity = new Vector2(GetValue(config, "gravity.x", 0), GetValue(config, "gravity.y", 0)), this.bounds = new Rectangle(GetValue(config, "x", 0), GetValue(config, "y", 0), GetValue(config, "width", scene.sys.scale.width), GetValue(config, "height", scene.sys.scale.height)), this.checkCollision = {
          up: GetValue(config, "checkCollision.up", !0),
          down: GetValue(config, "checkCollision.down", !0),
          left: GetValue(config, "checkCollision.left", !0),
          right: GetValue(config, "checkCollision.right", !0)
        }, this.fps = GetValue(config, "fps", 60), this.fixedStep = GetValue(config, "fixedStep", !0), this._elapsed = 0, this._frameTime = 1 / this.fps, this._frameTimeMS = 1e3 * this._frameTime, this.stepsLastFrame = 0, this.timeScale = GetValue(config, "timeScale", 1), this.OVERLAP_BIAS = GetValue(config, "overlapBias", 4), this.TILE_BIAS = GetValue(config, "tileBias", 16), this.forceX = GetValue(config, "forceX", !1), this.isPaused = GetValue(config, "isPaused", !1), this._total = 0, this.drawDebug = GetValue(config, "debug", !1), this.debugGraphic, this.defaults = {
          debugShowBody: GetValue(config, "debugShowBody", !0),
          debugShowStaticBody: GetValue(config, "debugShowStaticBody", !0),
          debugShowVelocity: GetValue(config, "debugShowVelocity", !0),
          bodyDebugColor: GetValue(config, "debugBodyColor", 16711935),
          staticBodyDebugColor: GetValue(config, "debugStaticBodyColor", 255),
          velocityDebugColor: GetValue(config, "debugVelocityColor", 65280)
        }, this.maxEntries = GetValue(config, "maxEntries", 16), this.useTree = GetValue(config, "useTree", !0), this.tree = new RTree(this.maxEntries), this.staticTree = new RTree(this.maxEntries), this.treeMinMax = {
          minX: 0,
          minY: 0,
          maxX: 0,
          maxY: 0
        }, this._tempMatrix = new TransformMatrix(), this._tempMatrix2 = new TransformMatrix(), this.drawDebug && this.createDebugGraphic();
      },
      enable: function enable(object, bodyType) {
        void 0 === bodyType && (bodyType = CONST.DYNAMIC_BODY), Array.isArray(object) || (object = [object]);

        for (var i = 0; i < object.length; i++) {
          var entry = object[i];
          if (entry.isParent) for (var children = entry.getChildren(), c = 0; c < children.length; c++) {
            var child = children[c];
            child.isParent ? this.enable(child, bodyType) : this.enableBody(child, bodyType);
          } else this.enableBody(entry, bodyType);
        }
      },
      enableBody: function enableBody(object, bodyType) {
        return void 0 === bodyType && (bodyType = CONST.DYNAMIC_BODY), object.body || (bodyType === CONST.DYNAMIC_BODY ? object.body = new Body(this, object) : bodyType === CONST.STATIC_BODY && (object.body = new StaticBody(this, object))), this.add(object.body), object;
      },
      add: function add(body) {
        return body.physicsType === CONST.DYNAMIC_BODY ? this.bodies.set(body) : body.physicsType === CONST.STATIC_BODY && (this.staticBodies.set(body), this.staticTree.insert(body)), body.enable = !0, body;
      },
      disable: function disable(object) {
        Array.isArray(object) || (object = [object]);

        for (var i = 0; i < object.length; i++) {
          var entry = object[i];
          if (entry.isParent) for (var children = entry.getChildren(), c = 0; c < children.length; c++) {
            var child = children[c];
            child.isParent ? this.disable(child) : this.disableBody(child.body);
          } else this.disableBody(entry.body);
        }
      },
      disableBody: function disableBody(body) {
        this.remove(body), body.enable = !1;
      },
      remove: function remove(body) {
        body.physicsType === CONST.DYNAMIC_BODY ? (this.tree.remove(body), this.bodies.delete(body)) : body.physicsType === CONST.STATIC_BODY && (this.staticBodies.delete(body), this.staticTree.remove(body));
      },
      createDebugGraphic: function createDebugGraphic() {
        var graphic = this.scene.sys.add.graphics({
          x: 0,
          y: 0
        });
        return graphic.setDepth(Number.MAX_VALUE), this.debugGraphic = graphic, this.drawDebug = !0, graphic;
      },
      setBounds: function setBounds(x, y, width, height, checkLeft, checkRight, checkUp, checkDown) {
        return this.bounds.setTo(x, y, width, height), void 0 !== checkLeft && this.setBoundsCollision(checkLeft, checkRight, checkUp, checkDown), this;
      },
      setBoundsCollision: function setBoundsCollision(left, right, up, down) {
        return void 0 === right && (right = !0), void 0 === up && (up = !0), void 0 === down && (down = !0), this.checkCollision.left = left = void 0 === left ? !0 : left, this.checkCollision.right = right, this.checkCollision.up = up, this.checkCollision.down = down, this;
      },
      pause: function pause() {
        return this.isPaused = !0, this.emit(Events.PAUSE), this;
      },
      resume: function resume() {
        return this.isPaused = !1, this.emit(Events.RESUME), this;
      },
      addCollider: function addCollider(object1, object2, collideCallback, processCallback, collider) {
        collider = new Collider(this, !1, object1, object2, collideCallback = void 0 === collideCallback ? null : collideCallback, processCallback = void 0 === processCallback ? null : processCallback, collider = void 0 === collider ? collideCallback : collider);
        return this.colliders.add(collider), collider;
      },
      addOverlap: function addOverlap(object1, object2, collideCallback, processCallback, collider) {
        collider = new Collider(this, !0, object1, object2, collideCallback = void 0 === collideCallback ? null : collideCallback, processCallback = void 0 === processCallback ? null : processCallback, collider = void 0 === collider ? collideCallback : collider);
        return this.colliders.add(collider), collider;
      },
      removeCollider: function removeCollider(collider) {
        return this.colliders.remove(collider), this;
      },
      setFPS: function setFPS(framerate) {
        return this.fps = framerate, this._frameTime = 1 / this.fps, this._frameTimeMS = 1e3 * this._frameTime, this;
      },
      update: function update(time, delta) {
        if (!this.isPaused && 0 !== this.bodies.size) {
          var body,
              fixedDelta = this._frameTime,
              msPerFrame = this._frameTimeMS * this.timeScale;
          this._elapsed += delta;
          var bodies = this.bodies.entries,
              willStep = this._elapsed >= msPerFrame;

          for (this.fixedStep || (fixedDelta = .001 * delta, willStep = !0, this._elapsed = 0), i = 0; i < bodies.length; i++) {
            (body = bodies[i]).enable && body.preUpdate(willStep, fixedDelta);
          }

          if (willStep) {
            this._elapsed -= msPerFrame, this.stepsLastFrame = 1, this.useTree && (this.tree.clear(), this.tree.load(bodies));

            for (var colliders = this.colliders.update(), i = 0; i < colliders.length; i++) {
              var collider = colliders[i];
              collider.active && collider.update();
            }

            this.emit(Events.WORLD_STEP, fixedDelta);
          }

          for (; this._elapsed >= msPerFrame;) {
            this._elapsed -= msPerFrame, this.step(fixedDelta);
          }
        }
      },
      step: function step(delta) {
        for (var body, bodies = this.bodies.entries, len = bodies.length, i = 0; i < len; i++) {
          (body = bodies[i]).enable && body.update(delta);
        }

        this.useTree && (this.tree.clear(), this.tree.load(bodies));
        var colliders = this.colliders.update();

        for (i = 0; i < colliders.length; i++) {
          var collider = colliders[i];
          collider.active && collider.update();
        }

        this.emit(Events.WORLD_STEP, delta), this.stepsLastFrame++;
      },
      postUpdate: function postUpdate() {
        var body,
            len = (bodies = this.bodies.entries).length,
            dynamic = this.bodies,
            staticBodies = this.staticBodies;
        if (this.stepsLastFrame) for (i = this.stepsLastFrame = 0; i < len; i++) {
          (body = bodies[i]).enable && body.postUpdate();
        }

        if (this.drawDebug) {
          var graphics = this.debugGraphic;

          for (graphics.clear(), i = 0; i < len; i++) {
            (body = bodies[i]).willDrawDebug() && body.drawDebug(graphics);
          }

          for (len = (bodies = staticBodies.entries).length, i = 0; i < len; i++) {
            (body = bodies[i]).willDrawDebug() && body.drawDebug(graphics);
          }
        }

        var pending = this.pendingDestroy;

        if (0 < pending.size) {
          for (var bodies, dynamicTree = this.tree, staticTree = this.staticTree, len = (bodies = pending.entries).length, i = 0; i < len; i++) {
            (body = bodies[i]).physicsType === CONST.DYNAMIC_BODY ? (dynamicTree.remove(body), dynamic.delete(body)) : body.physicsType === CONST.STATIC_BODY && (staticTree.remove(body), staticBodies.delete(body)), body.world = void 0, body.gameObject = void 0;
          }

          pending.clear();
        }
      },
      updateMotion: function updateMotion(body, delta) {
        body.allowRotation && this.computeAngularVelocity(body, delta), this.computeVelocity(body, delta);
      },
      computeAngularVelocity: function computeAngularVelocity(body, delta) {
        var velocityDelta = body.angularVelocity,
            acceleration = body.angularAcceleration,
            drag = body.angularDrag,
            max = body.maxAngular;
        acceleration ? velocityDelta += acceleration * delta : body.allowDrag && drag && (FuzzyGreaterThan(velocityDelta - (drag *= delta), 0, .1) ? velocityDelta -= drag : FuzzyLessThan(velocityDelta + drag, 0, .1) ? velocityDelta += drag : velocityDelta = 0);
        velocityDelta = (velocityDelta = Clamp(velocityDelta, -max, max)) - body.angularVelocity;
        body.angularVelocity += velocityDelta, body.rotation += body.angularVelocity * delta;
      },
      computeVelocity: function computeVelocity(body, delta) {
        var velocityX = body.velocity.x,
            accelerationX = body.acceleration.x,
            dragX = body.drag.x,
            maxX = body.maxVelocity.x,
            velocityY = body.velocity.y,
            accelerationY = body.acceleration.y,
            dragY = body.drag.y,
            maxY = body.maxVelocity.y,
            speed = body.speed,
            maxSpeed = body.maxSpeed,
            allowDrag = body.allowDrag,
            useDamping = body.useDamping;
        body.allowGravity && (velocityX += (this.gravity.x + body.gravity.x) * delta, velocityY += (this.gravity.y + body.gravity.y) * delta), accelerationX ? velocityX += accelerationX * delta : allowDrag && dragX && (useDamping ? (velocityX *= dragX = Math.pow(dragX, delta), speed = Math.sqrt(velocityX * velocityX + velocityY * velocityY), FuzzyEqual(speed, 0, .001) && (velocityX = 0)) : FuzzyGreaterThan(velocityX - (dragX *= delta), 0, .01) ? velocityX -= dragX : FuzzyLessThan(velocityX + dragX, 0, .01) ? velocityX += dragX : velocityX = 0), accelerationY ? velocityY += accelerationY * delta : allowDrag && dragY && (useDamping ? (velocityY *= dragY = Math.pow(dragY, delta), speed = Math.sqrt(velocityX * velocityX + velocityY * velocityY), FuzzyEqual(speed, 0, .001) && (velocityY = 0)) : FuzzyGreaterThan(velocityY - (dragY *= delta), 0, .01) ? velocityY -= dragY : FuzzyLessThan(velocityY + dragY, 0, .01) ? velocityY += dragY : velocityY = 0), velocityX = Clamp(velocityX, -maxX, maxX), velocityY = Clamp(velocityY, -maxY, maxY), body.velocity.set(velocityX, velocityY), -1 < maxSpeed && maxSpeed < speed && (body.velocity.normalize().scale(maxSpeed), speed = maxSpeed), body.speed = speed;
      },
      separate: function separate(body1, body2, rect_x, rect_y, overlapOnly, rect_bottom) {
        if (!rect_bottom && !body1.enable || !body2.enable || body1.checkCollision.none || body2.checkCollision.none || !this.intersects(body1, body2)) return !1;
        if (rect_x && !1 === rect_x.call(rect_y, body1.gameObject, body2.gameObject)) return !1;
        if (body1.isCircle && body2.isCircle) return this.separateCircle(body1, body2, overlapOnly);

        if (body1.isCircle !== body2.isCircle) {
          var rect_bottom = body1.isCircle ? body2 : body1,
              resultX = body1.isCircle ? body1 : body2,
              rect_x = rect_bottom.x,
              rect_y = rect_bottom.y,
              result = rect_bottom.right,
              rect_bottom = rect_bottom.bottom,
              resultX = resultX.center;
          if ((resultX.y < rect_y || resultX.y > rect_bottom) && (resultX.x < rect_x || resultX.x > result)) return this.separateCircle(body1, body2, overlapOnly);
        }

        resultX = !1, result = !1;
        overlapOnly ? (resultX = SeparateX(body1, body2, overlapOnly, this.OVERLAP_BIAS), result = SeparateY(body1, body2, overlapOnly, this.OVERLAP_BIAS)) : this.forceX || Math.abs(this.gravity.y + body1.gravity.y) < Math.abs(this.gravity.x + body1.gravity.x) ? (resultX = SeparateX(body1, body2, overlapOnly, this.OVERLAP_BIAS), this.intersects(body1, body2) && (result = SeparateY(body1, body2, overlapOnly, this.OVERLAP_BIAS))) : (result = SeparateY(body1, body2, overlapOnly, this.OVERLAP_BIAS), this.intersects(body1, body2) && (resultX = SeparateX(body1, body2, overlapOnly, this.OVERLAP_BIAS)));
        result = resultX || result;
        return result && (overlapOnly ? (body1.onOverlap || body2.onOverlap) && this.emit(Events.OVERLAP, body1.gameObject, body2.gameObject, body1, body2) : (body1.onCollide || body2.onCollide) && this.emit(Events.COLLIDE, body1.gameObject, body2.gameObject, body1, body2)), result;
      },
      separateCircle: function separateCircle(body1, body2, overlapY, overlap) {
        GetOverlapX(body1, body2, !1, overlap), GetOverlapY(body1, body2, !1, overlap);
        overlap = 0;
        if (body1.isCircle !== body2.isCircle ? (nx = {
          x: (body2.isCircle ? body1 : body2).position.x,
          y: (body2.isCircle ? body1 : body2).position.y,
          right: (body2.isCircle ? body1 : body2).right,
          bottom: (body2.isCircle ? body1 : body2).bottom
        }, (overlapX = {
          x: (body1.isCircle ? body1 : body2).center.x,
          y: (body1.isCircle ? body1 : body2).center.y,
          radius: (body1.isCircle ? body1 : body2).halfWidth
        }).y < nx.y ? overlapX.x < nx.x ? overlap = DistanceBetween(overlapX.x, overlapX.y, nx.x, nx.y) - overlapX.radius : nx.right < overlapX.x && (overlap = DistanceBetween(overlapX.x, overlapX.y, nx.right, nx.y) - overlapX.radius) : nx.bottom < overlapX.y && (overlapX.x < nx.x ? overlap = DistanceBetween(overlapX.x, overlapX.y, nx.x, nx.bottom) - overlapX.radius : nx.right < overlapX.x && (overlap = DistanceBetween(overlapX.x, overlapX.y, nx.right, nx.bottom) - overlapX.radius)), overlap *= -1) : overlap = body1.halfWidth + body2.halfWidth - DistanceBetween(body1.center.x, body1.center.y, body2.center.x, body2.center.y), body1.overlapR = overlap, body2.overlapR = overlap, overlapY || 0 === overlap || body1.immovable && body2.immovable || body1.customSeparateX || body2.customSeparateX) return 0 !== overlap && (body1.onOverlap || body2.onOverlap) && this.emit(Events.OVERLAP, body1.gameObject, body2.gameObject, body1, body2), 0 !== overlap;
        var nx = body1.center.x - body2.center.x,
            overlapX = body1.center.y - body2.center.y,
            overlapY = Math.sqrt(Math.pow(nx, 2) + Math.pow(overlapX, 2)),
            nx = (body2.center.x - body1.center.x) / overlapY || 0,
            overlapX = (body2.center.y - body1.center.y) / overlapY || 0,
            overlapY = 2 * (body1.velocity.x * nx + body1.velocity.y * overlapX - body2.velocity.x * nx - body2.velocity.y * overlapX) / (body1.mass + body2.mass);
        (body1.immovable || body2.immovable) && (overlapY *= 2), body1.immovable || (body1.velocity.x = body1.velocity.x - overlapY / body1.mass * nx, body1.velocity.y = body1.velocity.y - overlapY / body1.mass * overlapX), body2.immovable || (body2.velocity.x = body2.velocity.x + overlapY / body2.mass * nx, body2.velocity.y = body2.velocity.y + overlapY / body2.mass * overlapX), body1.immovable || body2.immovable || (overlap /= 2);
        overlapY = AngleBetweenPoints(body1.center, body2.center), overlapX = (overlap + MATH_CONST.EPSILON) * Math.cos(overlapY), overlapY = (overlap + MATH_CONST.EPSILON) * Math.sin(overlapY);
        return body1.immovable || (body1.x -= overlapX, body1.y -= overlapY, body1.updateCenter()), body2.immovable || (body2.x += overlapX, body2.y += overlapY, body2.updateCenter()), body1.velocity.x *= body1.bounce.x, body1.velocity.y *= body1.bounce.y, body2.velocity.x *= body2.bounce.x, body2.velocity.y *= body2.bounce.y, (body1.onCollide || body2.onCollide) && this.emit(Events.COLLIDE, body1.gameObject, body2.gameObject, body1, body2), !0;
      },
      intersects: function intersects(body1, body2) {
        return body1 !== body2 && (body1.isCircle || body2.isCircle ? body1.isCircle ? body2.isCircle ? DistanceBetween(body1.center.x, body1.center.y, body2.center.x, body2.center.y) <= body1.halfWidth + body2.halfWidth : this.circleBodyIntersects(body1, body2) : this.circleBodyIntersects(body2, body1) : !(body1.right <= body2.position.x || body1.bottom <= body2.position.y || body1.position.x >= body2.right || body1.position.y >= body2.bottom));
      },
      circleBodyIntersects: function circleBodyIntersects(circle, y) {
        var x = Clamp(circle.center.x, y.left, y.right),
            y = Clamp(circle.center.y, y.top, y.bottom);
        return (circle.center.x - x) * (circle.center.x - x) + (circle.center.y - y) * (circle.center.y - y) <= circle.halfWidth * circle.halfWidth;
      },
      overlap: function overlap(object1, object2, overlapCallback, processCallback, callbackContext) {
        return void 0 === overlapCallback && (overlapCallback = null), void 0 === callbackContext && (callbackContext = overlapCallback), this.collideObjects(object1, object2, overlapCallback, processCallback = void 0 === processCallback ? null : processCallback, callbackContext, !0);
      },
      collide: function collide(object1, object2, collideCallback, processCallback, callbackContext) {
        return void 0 === collideCallback && (collideCallback = null), void 0 === callbackContext && (callbackContext = collideCallback), this.collideObjects(object1, object2, collideCallback, processCallback = void 0 === processCallback ? null : processCallback, callbackContext, !1);
      },
      collideObjects: function collideObjects(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly) {
        var i;
        object1.isParent && void 0 === object1.physicsType && (object1 = object1.children.entries), object2 && object2.isParent && void 0 === object2.physicsType && (object2 = object2.children.entries);
        var object1isArray = Array.isArray(object1),
            object2isArray = Array.isArray(object2);
        if (this._total = 0, object1isArray || object2isArray) {
          if (!object1isArray && object2isArray) for (i = 0; i < object2.length; i++) {
            this.collideHandler(object1, object2[i], collideCallback, processCallback, callbackContext, overlapOnly);
          } else if (object1isArray && !object2isArray) {
            if (object2) for (i = 0; i < object1.length; i++) {
              this.collideHandler(object1[i], object2, collideCallback, processCallback, callbackContext, overlapOnly);
            } else for (i = 0; i < object1.length; i++) {
              for (var child = object1[i], j = i + 1; j < object1.length; j++) {
                i !== j && this.collideHandler(child, object1[j], collideCallback, processCallback, callbackContext, overlapOnly);
              }
            }
          } else for (i = 0; i < object1.length; i++) {
            for (j = 0; j < object2.length; j++) {
              this.collideHandler(object1[i], object2[j], collideCallback, processCallback, callbackContext, overlapOnly);
            }
          }
        } else this.collideHandler(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);
        return 0 < this._total;
      },
      collideHandler: function collideHandler(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly) {
        return void 0 === object2 && object1.isParent ? this.collideGroupVsGroup(object1, object1, collideCallback, processCallback, callbackContext, overlapOnly) : !(!object1 || !object2) && (object1.body ? object2.body ? this.collideSpriteVsSprite(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly) : object2.isParent ? this.collideSpriteVsGroup(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly) : object2.isTilemap ? this.collideSpriteVsTilemapLayer(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly) : void 0 : object1.isParent ? object2.body ? this.collideSpriteVsGroup(object2, object1, collideCallback, processCallback, callbackContext, overlapOnly) : object2.isParent ? this.collideGroupVsGroup(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly) : object2.isTilemap ? this.collideGroupVsTilemapLayer(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly) : void 0 : object1.isTilemap ? object2.body ? this.collideSpriteVsTilemapLayer(object2, object1, collideCallback, processCallback, callbackContext, overlapOnly) : object2.isParent ? this.collideGroupVsTilemapLayer(object2, object1, collideCallback, processCallback, callbackContext, overlapOnly) : void 0 : void 0);
      },
      collideSpriteVsSprite: function collideSpriteVsSprite(sprite1, sprite2, collideCallback, processCallback, callbackContext, overlapOnly) {
        return !(!sprite1.body || !sprite2.body) && (this.separate(sprite1.body, sprite2.body, processCallback, callbackContext, overlapOnly) && (collideCallback && collideCallback.call(callbackContext, sprite1, sprite2), this._total++), !0);
      },
      collideSpriteVsGroup: function collideSpriteVsGroup(sprite, group, collideCallback, processCallback, callbackContext, overlapOnly) {
        var bodyB,
            bodyA = sprite.body;
        if (0 !== group.length && bodyA && bodyA.enable && !bodyA.checkCollision.none) if (this.useTree || group.physicsType === CONST.STATIC_BODY) {
          var minMax = this.treeMinMax;
          minMax.minX = bodyA.left, minMax.minY = bodyA.top, minMax.maxX = bodyA.right, minMax.maxY = bodyA.bottom;

          for (var results = (group.physicsType === CONST.DYNAMIC_BODY ? this.tree : this.staticTree).search(minMax), len = results.length, i = 0; i < len; i++) {
            bodyA !== (bodyB = results[i]) && bodyB.enable && !bodyB.checkCollision.none && group.contains(bodyB.gameObject) && this.separate(bodyA, bodyB, processCallback, callbackContext, overlapOnly, !0) && (collideCallback && collideCallback.call(callbackContext, bodyA.gameObject, bodyB.gameObject), this._total++);
          }
        } else {
          var children = group.getChildren(),
              skipIndex = group.children.entries.indexOf(sprite);

          for (len = children.length, i = 0; i < len; i++) {
            (bodyB = children[i].body) && i !== skipIndex && bodyB.enable && this.separate(bodyA, bodyB, processCallback, callbackContext, overlapOnly) && (collideCallback && collideCallback.call(callbackContext, bodyA.gameObject, bodyB.gameObject), this._total++);
          }
        }
      },
      collideGroupVsTilemapLayer: function collideGroupVsTilemapLayer(group, tilemapLayer, collideCallback, processCallback, callbackContext, overlapOnly) {
        var children = group.getChildren();
        if (0 === children.length) return !1;

        for (var didCollide = !1, i = 0; i < children.length; i++) {
          children[i].body && this.collideSpriteVsTilemapLayer(children[i], tilemapLayer, collideCallback, processCallback, callbackContext, overlapOnly) && (didCollide = !0);
        }

        return didCollide;
      },
      collideTiles: function collideTiles(sprite, tiles, collideCallback, processCallback, callbackContext) {
        return !(!sprite.body.enable || 0 === tiles.length) && this.collideSpriteVsTilesHandler(sprite, tiles, collideCallback, processCallback, callbackContext, !1, !1);
      },
      overlapTiles: function overlapTiles(sprite, tiles, collideCallback, processCallback, callbackContext) {
        return !(!sprite.body.enable || 0 === tiles.length) && this.collideSpriteVsTilesHandler(sprite, tiles, collideCallback, processCallback, callbackContext, !0, !1);
      },
      collideSpriteVsTilemapLayer: function collideSpriteVsTilemapLayer(sprite, mapData, collideCallback, processCallback, callbackContext, overlapOnly) {
        var xDiff = sprite.body;
        if (!xDiff.enable || xDiff.checkCollision.none) return !1;
        var x = xDiff.position.x,
            y = xDiff.position.y,
            w = xDiff.width,
            h = xDiff.height,
            layerData = mapData.layer;
        layerData.tileWidth > layerData.baseTileWidth && (x -= xDiff = (layerData.tileWidth - layerData.baseTileWidth) * mapData.scaleX, w += xDiff), layerData.tileHeight > layerData.baseTileHeight && (h += (layerData.tileHeight - layerData.baseTileHeight) * mapData.scaleY);
        mapData = GetTilesWithinWorldXY(x, y, w, h, null, mapData.scene.cameras.main, mapData.layer);
        return 0 !== mapData.length && this.collideSpriteVsTilesHandler(sprite, mapData, collideCallback, processCallback, callbackContext, overlapOnly, !0);
      },
      collideSpriteVsTilesHandler: function collideSpriteVsTilesHandler(sprite, tiles, collideCallback, processCallback, callbackContext, overlapOnly, isLayer) {
        for (var body = sprite.body, tileWorldRect = {
          left: 0,
          right: 0,
          top: 0,
          bottom: 0
        }, collision = !1, i = 0; i < tiles.length; i++) {
          var tile,
              tilemapLayer,
              point = (tilemapLayer = (tile = tiles[i]).tilemapLayer).tileToWorldXY(tile.x, tile.y);
          tileWorldRect.left = point.x, tileWorldRect.top = point.y, tile.baseHeight !== tile.height && (tileWorldRect.top -= (tile.height - tile.baseHeight) * tilemapLayer.scaleY), tileWorldRect.right = tileWorldRect.left + tile.width * tilemapLayer.scaleX, tileWorldRect.bottom = tileWorldRect.top + tile.height * tilemapLayer.scaleY, TileIntersectsBody(tileWorldRect, body) && (!processCallback || processCallback.call(callbackContext, sprite, tile)) && ProcessTileCallbacks(tile, sprite) && (overlapOnly || SeparateTile(i, body, tile, tileWorldRect, tilemapLayer, this.TILE_BIAS, isLayer)) && (this._total++, collision = !0, collideCallback && collideCallback.call(callbackContext, sprite, tile), overlapOnly && body.onOverlap ? this.emit(Events.TILE_OVERLAP, sprite, tile, body) : body.onCollide && this.emit(Events.TILE_COLLIDE, sprite, tile, body));
        }

        return collision;
      },
      collideGroupVsGroup: function collideGroupVsGroup(group1, group2, collideCallback, processCallback, callbackContext, overlapOnly) {
        if (0 !== group1.length && 0 !== group2.length) for (var children = group1.getChildren(), i = 0; i < children.length; i++) {
          this.collideSpriteVsGroup(children[i], group2, collideCallback, processCallback, callbackContext, overlapOnly);
        }
      },
      wrap: function wrap(object, padding) {
        object.body ? this.wrapObject(object, padding) : object.getChildren ? this.wrapArray(object.getChildren(), padding) : Array.isArray(object) ? this.wrapArray(object, padding) : this.wrapObject(object, padding);
      },
      wrapArray: function wrapArray(objects, padding) {
        for (var i = 0; i < objects.length; i++) {
          this.wrapObject(objects[i], padding);
        }
      },
      wrapObject: function wrapObject(object, padding) {
        object.x = Wrap(object.x, this.bounds.left - (padding = void 0 === padding ? 0 : padding), this.bounds.right + padding), object.y = Wrap(object.y, this.bounds.top - padding, this.bounds.bottom + padding);
      },
      shutdown: function shutdown() {
        this.tree.clear(), this.staticTree.clear(), this.bodies.clear(), this.staticBodies.clear(), this.colliders.destroy(), this.removeAllListeners();
      },
      destroy: function destroy() {
        this.shutdown(), this.scene = null;
      }
    });

    module.exports = World;
  }, function (module, exports, __webpack_require__) {
    var Body = __webpack_require__(0),
        CONST = __webpack_require__(62),
        Events = __webpack_require__(245),
        RadToDeg = __webpack_require__(196),
        Rectangle = __webpack_require__(10),
        RectangleContains = __webpack_require__(57),
        Vector2 = __webpack_require__(3),
        Body = new Body({
      initialize: function initialize(world, gameObject) {
        var width = gameObject.displayWidth || 64,
            height = gameObject.displayHeight || 64;
        this.world = world, this.gameObject = gameObject, this.transform = {
          x: gameObject.x,
          y: gameObject.y,
          rotation: gameObject.angle,
          scaleX: gameObject.scaleX,
          scaleY: gameObject.scaleY,
          displayOriginX: gameObject.displayOriginX,
          displayOriginY: gameObject.displayOriginY
        }, this.debugShowBody = world.defaults.debugShowBody, this.debugShowVelocity = world.defaults.debugShowVelocity, this.debugBodyColor = world.defaults.bodyDebugColor, this.enable = !0, this.isCircle = !1, this.radius = 0, this.offset = new Vector2(), this.position = new Vector2(gameObject.x - gameObject.scaleX * gameObject.displayOriginX, gameObject.y - gameObject.scaleY * gameObject.displayOriginY), this.prev = this.position.clone(), this.prevFrame = this.position.clone(), this.allowRotation = !0, this.rotation = gameObject.angle, this.preRotation = gameObject.angle, this.width = width, this.height = height, this.sourceWidth = width, this.sourceHeight = height, gameObject.frame && (this.sourceWidth = gameObject.frame.realWidth, this.sourceHeight = gameObject.frame.realHeight), this.halfWidth = Math.abs(width / 2), this.halfHeight = Math.abs(height / 2), this.center = new Vector2(this.position.x + this.halfWidth, this.position.y + this.halfHeight), this.velocity = new Vector2(), this.newVelocity = new Vector2(), this.deltaMax = new Vector2(), this.acceleration = new Vector2(), this.allowDrag = !0, this.drag = new Vector2(), this.allowGravity = !0, this.gravity = new Vector2(), this.bounce = new Vector2(), this.worldBounce = null, this.customBoundsRectangle = world.bounds, this.onWorldBounds = !1, this.onCollide = !1, this.onOverlap = !1, this.maxVelocity = new Vector2(1e4, 1e4), this.maxSpeed = -1, this.friction = new Vector2(1, 0), this.useDamping = !1, this.angularVelocity = 0, this.angularAcceleration = 0, this.angularDrag = 0, this.maxAngular = 1e3, this.mass = 1, this.angle = 0, this.speed = 0, this.facing = CONST.FACING_NONE, this.immovable = !1, this.pushable = !0, this.moves = !0, this.customSeparateX = !1, this.customSeparateY = !1, this.overlapX = 0, this.overlapY = 0, this.overlapR = 0, this.embedded = !1, this.collideWorldBounds = !1, this.checkCollision = {
          none: !1,
          up: !0,
          down: !0,
          left: !0,
          right: !0
        }, this.touching = {
          none: !0,
          up: !1,
          down: !1,
          left: !1,
          right: !1
        }, this.wasTouching = {
          none: !0,
          up: !1,
          down: !1,
          left: !1,
          right: !1
        }, this.blocked = {
          none: !0,
          up: !1,
          down: !1,
          left: !1,
          right: !1
        }, this.syncBounds = !1, this.physicsType = CONST.DYNAMIC_BODY, this._sx = gameObject.scaleX, this._sy = gameObject.scaleY, this._dx = 0, this._dy = 0, this._tx = 0, this._ty = 0, this._bounds = new Rectangle();
      },
      updateBounds: function updateBounds() {
        var sprite = this.gameObject,
            asy = this.transform;
        sprite.parentContainer ? (recalc = sprite.getWorldTransformMatrix(this.world._tempMatrix, this.world._tempMatrix2), asy.x = recalc.tx, asy.y = recalc.ty, asy.rotation = RadToDeg(recalc.rotation), asy.scaleX = recalc.scaleX, asy.scaleY = recalc.scaleY) : (asy.x = sprite.x, asy.y = sprite.y, asy.rotation = sprite.angle, asy.scaleX = sprite.scaleX, asy.scaleY = sprite.scaleY), asy.displayOriginX = sprite.displayOriginX, asy.displayOriginY = sprite.displayOriginY;
        var asx,
            recalc = !1;
        this.syncBounds ? (asx = sprite.getBounds(this._bounds), this.width = asx.width, this.height = asx.height, recalc = !0) : (asx = Math.abs(asy.scaleX), asy = Math.abs(asy.scaleY), this._sx === asx && this._sy === asy || (this.width = this.sourceWidth * asx, this.height = this.sourceHeight * asy, this._sx = asx, this._sy = asy, recalc = !0)), recalc && (this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.updateCenter());
      },
      updateCenter: function updateCenter() {
        this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight);
      },
      updateFromGameObject: function updateFromGameObject() {
        this.updateBounds();
        var transform = this.transform;
        this.position.x = transform.x + transform.scaleX * (this.offset.x - transform.displayOriginX), this.position.y = transform.y + transform.scaleY * (this.offset.y - transform.displayOriginY), this.updateCenter();
      },
      resetFlags: function resetFlags(clear) {
        var wasTouching = this.wasTouching,
            touching = this.touching,
            blocked = this.blocked;
        (clear = void 0 === clear ? !1 : clear) ? (wasTouching.none = !0, wasTouching.up = !1, wasTouching.down = !1, wasTouching.left = !1, wasTouching.right = !1) : (wasTouching.none = touching.none, wasTouching.up = touching.up, wasTouching.down = touching.down, wasTouching.left = touching.left, wasTouching.right = touching.right), touching.none = !0, touching.up = !1, touching.down = !1, touching.left = !1, touching.right = !1, blocked.none = !0, blocked.up = !1, blocked.down = !1, blocked.left = !1, blocked.right = !1, this.overlapR = 0, this.overlapX = 0, this.overlapY = 0, this.embedded = !1;
      },
      preUpdate: function preUpdate(willStep, delta) {
        willStep && this.resetFlags(), this.updateFromGameObject(), this.rotation = this.transform.rotation, this.preRotation = this.rotation, this.moves && (this.prev.x = this.position.x, this.prev.y = this.position.y, this.prevFrame.x = this.position.x, this.prevFrame.y = this.position.y), willStep && this.update(delta);
      },
      update: function update(delta) {
        var vx, vy;
        this.prev.x = this.position.x, this.prev.y = this.position.y, this.moves && (this.world.updateMotion(this, delta), vx = this.velocity.x, vy = this.velocity.y, this.newVelocity.set(vx * delta, vy * delta), this.position.add(this.newVelocity), this.updateCenter(), this.angle = Math.atan2(vy, vx), this.speed = Math.sqrt(vx * vx + vy * vy), this.collideWorldBounds && this.checkWorldBounds() && this.onWorldBounds && this.world.emit(Events.WORLD_BOUNDS, this, this.blocked.up, this.blocked.down, this.blocked.left, this.blocked.right)), this._dx = this.position.x - this.prev.x, this._dy = this.position.y - this.prev.y;
      },
      postUpdate: function postUpdate() {
        var my,
            dx = this.position.x - this.prevFrame.x,
            dy = this.position.y - this.prevFrame.y;
        this.moves && (0 !== (my = this.deltaMax.x) && 0 !== dx && (dx < 0 && dx < -my ? dx = -my : 0 < dx && my < dx && (dx = my)), 0 !== (my = this.deltaMax.y) && 0 !== dy && (dy < 0 && dy < -my ? dy = -my : 0 < dy && my < dy && (dy = my)), this.gameObject.x += dx, this.gameObject.y += dy), dx < 0 ? this.facing = CONST.FACING_LEFT : 0 < dx && (this.facing = CONST.FACING_RIGHT), dy < 0 ? this.facing = CONST.FACING_UP : 0 < dy && (this.facing = CONST.FACING_DOWN), this.allowRotation && (this.gameObject.angle += this.deltaZ()), this._tx = dx, this._ty = dy;
      },
      setBoundsRectangle: function setBoundsRectangle(bounds) {
        return this.customBoundsRectangle = bounds || this.world.bounds, this;
      },
      checkWorldBounds: function checkWorldBounds() {
        var pos = this.position,
            bounds = this.customBoundsRectangle,
            check = this.world.checkCollision,
            bx = this.worldBounce ? -this.worldBounce.x : -this.bounce.x,
            by = this.worldBounce ? -this.worldBounce.y : -this.bounce.y,
            wasSet = !1;
        return pos.x < bounds.x && check.left ? (pos.x = bounds.x, this.velocity.x *= bx, wasSet = this.blocked.left = !0) : this.right > bounds.right && check.right && (pos.x = bounds.right - this.width, this.velocity.x *= bx, wasSet = this.blocked.right = !0), pos.y < bounds.y && check.up ? (pos.y = bounds.y, this.velocity.y *= by, wasSet = this.blocked.up = !0) : this.bottom > bounds.bottom && check.down && (pos.y = bounds.bottom - this.height, this.velocity.y *= by, wasSet = this.blocked.down = !0), wasSet && (this.blocked.none = !1, this.updateCenter()), wasSet;
      },
      setOffset: function setOffset(x, y) {
        return this.offset.set(x, y = void 0 === y ? x : y), this;
      },
      setSize: function setSize(ox, oy, center) {
        void 0 === center && (center = !0);
        var gameObject = this.gameObject;
        return !ox && gameObject.frame && (ox = gameObject.frame.realWidth), !oy && gameObject.frame && (oy = gameObject.frame.realHeight), this.sourceWidth = ox, this.sourceHeight = oy, this.width = this.sourceWidth * this._sx, this.height = this.sourceHeight * this._sy, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.updateCenter(), center && gameObject.getCenter && (ox = (gameObject.width - ox) / 2, oy = (gameObject.height - oy) / 2, this.offset.set(ox, oy)), this.isCircle = !1, this.radius = 0, this;
      },
      setCircle: function setCircle(radius, offsetX, offsetY) {
        return void 0 === offsetX && (offsetX = this.offset.x), void 0 === offsetY && (offsetY = this.offset.y), 0 < radius ? (this.isCircle = !0, this.radius = radius, this.sourceWidth = 2 * radius, this.sourceHeight = 2 * radius, this.width = this.sourceWidth * this._sx, this.height = this.sourceHeight * this._sy, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.offset.set(offsetX, offsetY), this.updateCenter()) : this.isCircle = !1, this;
      },
      reset: function reset(x, y) {
        this.stop();
        var gameObject = this.gameObject;
        gameObject.setPosition(x, y), gameObject.getTopLeft ? gameObject.getTopLeft(this.position) : this.position.set(x, y), this.prev.copy(this.position), this.prevFrame.copy(this.position), this.rotation = gameObject.angle, this.preRotation = gameObject.angle, this.updateBounds(), this.updateCenter(), this.resetFlags(!0);
      },
      stop: function stop() {
        return this.velocity.set(0), this.acceleration.set(0), this.speed = 0, this.angularVelocity = 0, this.angularAcceleration = 0, this;
      },
      getBounds: function getBounds(obj) {
        return obj.x = this.x, obj.y = this.y, obj.right = this.right, obj.bottom = this.bottom, obj;
      },
      hitTest: function hitTest(x, y) {
        return this.isCircle ? 0 < this.radius && x >= this.left && x <= this.right && y >= this.top && y <= this.bottom && (this.center.x - x) * (this.center.x - x) + (this.center.y - y) * (this.center.y - y) <= this.radius * this.radius : RectangleContains(this, x, y);
      },
      onFloor: function onFloor() {
        return this.blocked.down;
      },
      onCeiling: function onCeiling() {
        return this.blocked.up;
      },
      onWall: function onWall() {
        return this.blocked.left || this.blocked.right;
      },
      deltaAbsX: function deltaAbsX() {
        return 0 < this._dx ? this._dx : -this._dx;
      },
      deltaAbsY: function deltaAbsY() {
        return 0 < this._dy ? this._dy : -this._dy;
      },
      deltaX: function deltaX() {
        return this._dx;
      },
      deltaY: function deltaY() {
        return this._dy;
      },
      deltaXFinal: function deltaXFinal() {
        return this._tx;
      },
      deltaYFinal: function deltaYFinal() {
        return this._ty;
      },
      deltaZ: function deltaZ() {
        return this.rotation - this.preRotation;
      },
      destroy: function destroy() {
        this.enable = !1, this.world && this.world.pendingDestroy.set(this);
      },
      drawDebug: function drawDebug(graphic) {
        var pos = this.position,
            x = pos.x + this.halfWidth,
            y = pos.y + this.halfHeight;
        this.debugShowBody && (graphic.lineStyle(graphic.defaultStrokeWidth, this.debugBodyColor), this.isCircle ? graphic.strokeCircle(x, y, this.width / 2) : (this.checkCollision.up && graphic.lineBetween(pos.x, pos.y, pos.x + this.width, pos.y), this.checkCollision.right && graphic.lineBetween(pos.x + this.width, pos.y, pos.x + this.width, pos.y + this.height), this.checkCollision.down && graphic.lineBetween(pos.x, pos.y + this.height, pos.x + this.width, pos.y + this.height), this.checkCollision.left && graphic.lineBetween(pos.x, pos.y, pos.x, pos.y + this.height)), graphic.lineStyle(graphic.defaultStrokeWidth, this.world.defaults.velocityDebugColor, 1), graphic.lineBetween(x, y, x + this.velocity.x / 2, y + this.velocity.y / 2)), this.debugShowVelocity && (graphic.lineStyle(graphic.defaultStrokeWidth, this.world.defaults.velocityDebugColor, 1), graphic.lineBetween(0, 0, 1, 1));
      },
      willDrawDebug: function willDrawDebug() {
        return this.debugShowBody || this.debugShowVelocity;
      },
      setCollideWorldBounds: function setCollideWorldBounds(setBounceY, bounceX, bounceY, onWorldBounds) {
        this.collideWorldBounds = setBounceY = void 0 === setBounceY ? !0 : setBounceY;
        var setBounceX = void 0 !== bounceX,
            setBounceY = void 0 !== bounceY;
        return (setBounceX || setBounceY) && (this.worldBounce || (this.worldBounce = new Vector2()), setBounceX && (this.worldBounce.x = bounceX), setBounceY && (this.worldBounce.y = bounceY)), void 0 !== onWorldBounds && (this.onWorldBounds = onWorldBounds), this;
      },
      setVelocity: function setVelocity(x, y) {
        return this.velocity.set(x, y), x = this.velocity.x, y = this.velocity.y, this.speed = Math.sqrt(x * x + y * y), this;
      },
      setVelocityX: function setVelocityX(value) {
        this.velocity.x = value;
        var y = this.velocity.y;
        return this.speed = Math.sqrt(value * value + y * y), this;
      },
      setVelocityY: function setVelocityY(value) {
        this.velocity.y = value;
        var x = this.velocity.x;
        return this.speed = Math.sqrt(x * x + value * value), this;
      },
      setMaxVelocity: function setMaxVelocity(x, y) {
        return this.maxVelocity.set(x, y), this;
      },
      setMaxVelocityX: function setMaxVelocityX(value) {
        return this.maxVelocity.x = value, this;
      },
      setMaxVelocityY: function setMaxVelocityY(value) {
        return this.maxVelocity.y = value, this;
      },
      setMaxSpeed: function setMaxSpeed(value) {
        return this.maxSpeed = value, this;
      },
      setBounce: function setBounce(x, y) {
        return this.bounce.set(x, y), this;
      },
      setBounceX: function setBounceX(value) {
        return this.bounce.x = value, this;
      },
      setBounceY: function setBounceY(value) {
        return this.bounce.y = value, this;
      },
      setAcceleration: function setAcceleration(x, y) {
        return this.acceleration.set(x, y), this;
      },
      setAccelerationX: function setAccelerationX(value) {
        return this.acceleration.x = value, this;
      },
      setAccelerationY: function setAccelerationY(value) {
        return this.acceleration.y = value, this;
      },
      setAllowDrag: function setAllowDrag(value) {
        return this.allowDrag = value = void 0 === value ? !0 : value, this;
      },
      setAllowGravity: function setAllowGravity(value) {
        return this.allowGravity = value = void 0 === value ? !0 : value, this;
      },
      setAllowRotation: function setAllowRotation(value) {
        return this.allowRotation = value = void 0 === value ? !0 : value, this;
      },
      setDrag: function setDrag(x, y) {
        return this.drag.set(x, y), this;
      },
      setDamping: function setDamping(value) {
        return this.useDamping = value, this;
      },
      setDragX: function setDragX(value) {
        return this.drag.x = value, this;
      },
      setDragY: function setDragY(value) {
        return this.drag.y = value, this;
      },
      setGravity: function setGravity(x, y) {
        return this.gravity.set(x, y), this;
      },
      setGravityX: function setGravityX(value) {
        return this.gravity.x = value, this;
      },
      setGravityY: function setGravityY(value) {
        return this.gravity.y = value, this;
      },
      setFriction: function setFriction(x, y) {
        return this.friction.set(x, y), this;
      },
      setFrictionX: function setFrictionX(value) {
        return this.friction.x = value, this;
      },
      setFrictionY: function setFrictionY(value) {
        return this.friction.y = value, this;
      },
      setAngularVelocity: function setAngularVelocity(value) {
        return this.angularVelocity = value, this;
      },
      setAngularAcceleration: function setAngularAcceleration(value) {
        return this.angularAcceleration = value, this;
      },
      setAngularDrag: function setAngularDrag(value) {
        return this.angularDrag = value, this;
      },
      setMass: function setMass(value) {
        return this.mass = value, this;
      },
      setImmovable: function setImmovable(value) {
        return this.immovable = value = void 0 === value ? !0 : value, this;
      },
      setEnable: function setEnable(value) {
        return this.enable = value = void 0 === value ? !0 : value, this;
      },
      processX: function processX(x, blocked, left, right) {
        this.x += x, this.updateCenter(), null !== blocked && (this.velocity.x = blocked);
        blocked = this.blocked;
        left && (blocked.left = !0), right && (blocked.right = !0);
      },
      processY: function processY(y, blocked, up, down) {
        this.y += y, this.updateCenter(), null !== blocked && (this.velocity.y = blocked);
        blocked = this.blocked;
        up && (blocked.up = !0), down && (blocked.down = !0);
      },
      x: {
        get: function get() {
          return this.position.x;
        },
        set: function set(value) {
          this.position.x = value;
        }
      },
      y: {
        get: function get() {
          return this.position.y;
        },
        set: function set(value) {
          this.position.y = value;
        }
      },
      left: {
        get: function get() {
          return this.position.x;
        }
      },
      right: {
        get: function get() {
          return this.position.x + this.width;
        }
      },
      top: {
        get: function get() {
          return this.position.y;
        }
      },
      bottom: {
        get: function get() {
          return this.position.y + this.height;
        }
      }
    });

    module.exports = Body;
  }, function (module, exports, Collider) {
    Collider = new (Collider(0))({
      initialize: function initialize(world, overlapOnly, object1, object2, collideCallback, processCallback, callbackContext) {
        this.world = world, this.name = "", this.active = !0, this.overlapOnly = overlapOnly, this.object1 = object1, this.object2 = object2, this.collideCallback = collideCallback, this.processCallback = processCallback, this.callbackContext = callbackContext;
      },
      setName: function setName(name) {
        return this.name = name, this;
      },
      update: function update() {
        this.world.collideObjects(this.object1, this.object2, this.collideCallback, this.processCallback, this.callbackContext, this.overlapOnly);
      },
      destroy: function destroy() {
        this.world.removeCollider(this), this.active = !1, this.world = null, this.object1 = null, this.object2 = null, this.collideCallback = null, this.processCallback = null, this.callbackContext = null;
      }
    });
    module.exports = Collider;
  }, function (module, exports, Vector2) {
    var GetTilesWithin = Vector2(26),
        Vector2 = Vector2(3),
        pointStart = new Vector2(),
        pointEnd = new Vector2();

    module.exports = function (worldX, worldY, width, xEnd, filteringOptions, yEnd, layer) {
      var worldToTileXY = layer.tilemapLayer.tilemap._convert.WorldToTileXY;
      worldToTileXY(worldX, worldY, !0, pointStart, yEnd, layer);
      var xStart = pointStart.x,
          yStart = pointStart.y;
      worldToTileXY(worldX + width, worldY + xEnd, !1, pointEnd, yEnd, layer);
      xEnd = Math.ceil(pointEnd.x), yEnd = Math.ceil(pointEnd.y);
      return GetTilesWithin(xStart, yStart, xEnd - xStart, yEnd - yStart, filteringOptions, layer);
    };
  }, function (module, exports) {
    module.exports = function (tile, sprite) {
      return tile.collisionCallback ? !tile.collisionCallback.call(tile.collisionCallbackContext, sprite, tile) : !tile.layer.callbacks[tile.index] || !tile.layer.callbacks[tile.index].callback.call(tile.layer.callbacks[tile.index].callbackContext, sprite, tile);
    };
  }, function (module, exports, __webpack_require__) {
    var quickselect = __webpack_require__(436);

    function rbush(maxEntries) {
      if (!(this instanceof rbush)) return new rbush(maxEntries);
      this._maxEntries = Math.max(4, maxEntries || 9), this._minEntries = Math.max(2, Math.ceil(.4 * this._maxEntries)), this.clear();
    }

    function calcBBox(node, toBBox) {
      distBBox(node, 0, node.children.length, toBBox, node);
    }

    function distBBox(node, k, p, toBBox, destNode) {
      (destNode = destNode || createNode(null)).minX = 1 / 0, destNode.minY = 1 / 0, destNode.maxX = -1 / 0, destNode.maxY = -1 / 0;

      for (var child, i = k; i < p; i++) {
        child = node.children[i], extend(destNode, node.leaf ? toBBox(child) : child);
      }

      return destNode;
    }

    function extend(a, b) {
      return a.minX = Math.min(a.minX, b.minX), a.minY = Math.min(a.minY, b.minY), a.maxX = Math.max(a.maxX, b.maxX), a.maxY = Math.max(a.maxY, b.maxY), a;
    }

    function compareNodeMinX(a, b) {
      return a.minX - b.minX;
    }

    function compareNodeMinY(a, b) {
      return a.minY - b.minY;
    }

    function bboxArea(a) {
      return (a.maxX - a.minX) * (a.maxY - a.minY);
    }

    function bboxMargin(a) {
      return a.maxX - a.minX + (a.maxY - a.minY);
    }

    function contains(a, b) {
      return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;
    }

    function intersects(a, b) {
      return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;
    }

    function createNode(children) {
      return {
        children: children,
        height: 1,
        leaf: !0,
        minX: 1 / 0,
        minY: 1 / 0,
        maxX: -1 / 0,
        maxY: -1 / 0
      };
    }

    function multiSelect(arr, left, right, n, compare) {
      for (var mid, stack = [left, right]; stack.length;) {
        (right = stack.pop()) - (left = stack.pop()) <= n || (mid = left + Math.ceil((right - left) / n / 2) * n, quickselect(arr, mid, left, right, compare), stack.push(left, mid, mid, right));
      }
    }

    rbush.prototype = {
      all: function all() {
        return this._all(this.data, []);
      },
      search: function search(bbox) {
        var node = this.data,
            result = [],
            toBBox = this.toBBox;
        if (!intersects(bbox, node)) return result;

        for (var i, len, child, childBBox, nodesToSearch = []; node;) {
          for (i = 0, len = node.children.length; i < len; i++) {
            child = node.children[i], intersects(bbox, childBBox = node.leaf ? toBBox(child) : child) && (node.leaf ? result.push(child) : contains(bbox, childBBox) ? this._all(child, result) : nodesToSearch.push(child));
          }

          node = nodesToSearch.pop();
        }

        return result;
      },
      collides: function collides(bbox) {
        var node = this.data,
            toBBox = this.toBBox;
        if (!intersects(bbox, node)) return !1;

        for (var i, len, child, childBBox, nodesToSearch = []; node;) {
          for (i = 0, len = node.children.length; i < len; i++) {
            if (child = node.children[i], intersects(bbox, childBBox = node.leaf ? toBBox(child) : child)) {
              if (node.leaf || contains(bbox, childBBox)) return !0;
              nodesToSearch.push(child);
            }
          }

          node = nodesToSearch.pop();
        }

        return !1;
      },
      load: function load(data) {
        if (!data || !data.length) return this;

        if (data.length < this._minEntries) {
          for (var i = 0, len = data.length; i < len; i++) {
            this.insert(data[i]);
          }

          return this;
        }

        var tmpNode,
            node = this._build(data.slice(), 0, data.length - 1, 0);

        return this.data.children.length ? this.data.height === node.height ? this._splitRoot(this.data, node) : (this.data.height < node.height && (tmpNode = this.data, this.data = node, node = tmpNode), this._insert(node, this.data.height - node.height - 1, !0)) : this.data = node, this;
      },
      insert: function insert(item) {
        return item && this._insert(item, this.data.height - 1), this;
      },
      clear: function clear() {
        return this.data = createNode([]), this;
      },
      remove: function remove(item, equalsFn) {
        if (!item) return this;

        for (var i, parent, index, goingUp, node = this.data, bbox = this.toBBox(item), path = [], indexes = []; node || path.length;) {
          if (node || (node = path.pop(), parent = path[path.length - 1], i = indexes.pop(), goingUp = !0), node.leaf && -1 !== (index = function (item, items, equalsFn) {
            if (!equalsFn) return items.indexOf(item);

            for (var i = 0; i < items.length; i++) {
              if (equalsFn(item, items[i])) return i;
            }

            return -1;
          }(item, node.children, equalsFn))) return node.children.splice(index, 1), path.push(node), this._condense(path), this;
          goingUp || node.leaf || !contains(node, bbox) ? parent ? (i++, node = parent.children[i], goingUp = !1) : node = null : (path.push(node), indexes.push(i), node = (parent = node).children[i = 0]);
        }

        return this;
      },
      toBBox: function toBBox(a) {
        return {
          minX: a.left,
          minY: a.top,
          maxX: a.right,
          maxY: a.bottom
        };
      },
      compareMinX: function compareMinX(a, b) {
        return a.left - b.left;
      },
      compareMinY: function compareMinY(a, b) {
        return a.top - b.top;
      },
      toJSON: function toJSON() {
        return this.data;
      },
      fromJSON: function fromJSON(data) {
        return this.data = data, this;
      },
      _all: function _all(node, result) {
        for (var nodesToSearch = []; node;) {
          node.leaf ? result.push.apply(result, node.children) : nodesToSearch.push.apply(nodesToSearch, node.children), node = nodesToSearch.pop();
        }

        return result;
      },
      _build: function _build(items, left, right, height) {
        var node,
            N = right - left + 1,
            M = this._maxEntries;
        if (N <= M) return calcBBox(node = createNode(items.slice(left, right + 1)), this.toBBox), node;
        height || (height = Math.ceil(Math.log(N) / Math.log(M)), M = Math.ceil(N / Math.pow(M, height - 1))), (node = createNode([])).leaf = !1, node.height = height;
        var i,
            j,
            right2,
            right3,
            N2 = Math.ceil(N / M),
            N1 = N2 * Math.ceil(Math.sqrt(M));

        for (multiSelect(items, left, right, N1, this.compareMinX), i = left; i <= right; i += N1) {
          for (multiSelect(items, i, right2 = Math.min(i + N1 - 1, right), N2, this.compareMinY), j = i; j <= right2; j += N2) {
            right3 = Math.min(j + N2 - 1, right2), node.children.push(this._build(items, j, right3, height - 1));
          }
        }

        return calcBBox(node, this.toBBox), node;
      },
      _chooseSubtree: function _chooseSubtree(bbox, node, level, path) {
        for (var i, len, child, targetNode, area, minArea, minEnlargement, enlargement, b;;) {
          if (path.push(node), node.leaf || path.length - 1 === level) break;

          for (minArea = minEnlargement = 1 / 0, i = 0, len = node.children.length; i < len; i++) {
            area = bboxArea(child = node.children[i]), enlargement = bbox, b = child, (enlargement = (Math.max(b.maxX, enlargement.maxX) - Math.min(b.minX, enlargement.minX)) * (Math.max(b.maxY, enlargement.maxY) - Math.min(b.minY, enlargement.minY)) - area) < minEnlargement ? (minEnlargement = enlargement, minArea = area < minArea ? area : minArea, targetNode = child) : enlargement === minEnlargement && area < minArea && (minArea = area, targetNode = child);
          }

          node = targetNode || node.children[0];
        }

        return node;
      },
      _insert: function _insert(item, level, bbox) {
        var node = this.toBBox,
            bbox = bbox ? item : node(item),
            insertPath = [],
            node = this._chooseSubtree(bbox, this.data, level, insertPath);

        for (node.children.push(item), extend(node, bbox); 0 <= level && insertPath[level].children.length > this._maxEntries;) {
          this._split(insertPath, level), level--;
        }

        this._adjustParentBBoxes(bbox, insertPath, level);
      },
      _split: function _split(insertPath, level) {
        var node = insertPath[level],
            newNode = node.children.length,
            m = this._minEntries;

        this._chooseSplitAxis(node, m, newNode);

        newNode = this._chooseSplitIndex(node, m, newNode), newNode = createNode(node.children.splice(newNode, node.children.length - newNode));
        newNode.height = node.height, newNode.leaf = node.leaf, calcBBox(node, this.toBBox), calcBBox(newNode, this.toBBox), level ? insertPath[level - 1].children.push(newNode) : this._splitRoot(node, newNode);
      },
      _splitRoot: function _splitRoot(node, newNode) {
        this.data = createNode([node, newNode]), this.data.height = node.height + 1, this.data.leaf = !1, calcBBox(this.data, this.toBBox);
      },
      _chooseSplitIndex: function _chooseSplitIndex(node, m, M) {
        for (var bbox1, area, minArea, index, a, maxY, minX, overlap, maxX, minOverlap = minArea = 1 / 0, i = m; i <= M - m; i++) {
          bbox1 = distBBox(node, 0, i, this.toBBox), area = distBBox(node, i, M, this.toBBox), a = bbox1, maxY = area, maxX = overlap = minX = void 0, minX = Math.max(a.minX, maxY.minX), overlap = Math.max(a.minY, maxY.minY), maxX = Math.min(a.maxX, maxY.maxX), maxY = Math.min(a.maxY, maxY.maxY), overlap = Math.max(0, maxX - minX) * Math.max(0, maxY - overlap), area = bboxArea(bbox1) + bboxArea(area), overlap < minOverlap ? (minOverlap = overlap, index = i, minArea = area < minArea ? area : minArea) : overlap === minOverlap && area < minArea && (minArea = area, index = i);
        }

        return index;
      },
      _chooseSplitAxis: function _chooseSplitAxis(node, m, M) {
        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,
            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;
        this._allDistMargin(node, m, M, compareMinX) < this._allDistMargin(node, m, M, compareMinY) && node.children.sort(compareMinX);
      },
      _allDistMargin: function _allDistMargin(node, m, M, compare) {
        node.children.sort(compare);

        for (var child, toBBox = this.toBBox, leftBBox = distBBox(node, 0, m, toBBox), rightBBox = distBBox(node, M - m, M, toBBox), margin = bboxMargin(leftBBox) + bboxMargin(rightBBox), i = m; i < M - m; i++) {
          child = node.children[i], extend(leftBBox, node.leaf ? toBBox(child) : child), margin += bboxMargin(leftBBox);
        }

        for (i = M - m - 1; m <= i; i--) {
          child = node.children[i], extend(rightBBox, node.leaf ? toBBox(child) : child), margin += bboxMargin(rightBBox);
        }

        return margin;
      },
      _adjustParentBBoxes: function _adjustParentBBoxes(bbox, path, level) {
        for (var i = level; 0 <= i; i--) {
          extend(path[i], bbox);
        }
      },
      _condense: function _condense(path) {
        for (var siblings, i = path.length - 1; 0 <= i; i--) {
          0 === path[i].children.length ? 0 < i ? (siblings = path[i - 1].children).splice(siblings.indexOf(path[i]), 1) : this.clear() : calcBBox(path[i], this.toBBox);
        }
      }
    }, module.exports = rbush;
  }, function (module, exports, __webpack_require__) {
    var TileCheckX = __webpack_require__(533),
        TileCheckY = __webpack_require__(535),
        TileIntersectsBody = __webpack_require__(248);

    module.exports = function (i, body, tile, tileWorldRect, tilemapLayer, tileBias, isLayer) {
      var tileLeft = tileWorldRect.left,
          tileTop = tileWorldRect.top,
          tileRight = tileWorldRect.right,
          tileBottom = tileWorldRect.bottom,
          faceHorizontal = tile.faceLeft || tile.faceRight,
          faceVertical = tile.faceTop || tile.faceBottom;
      if (isLayer || (faceVertical = faceHorizontal = !0), !faceHorizontal && !faceVertical) return !1;
      var ox = 0,
          oy = 0,
          minX = 0,
          minY = 1;

      if (body.deltaAbsX() > body.deltaAbsY() ? minX = -1 : body.deltaAbsX() < body.deltaAbsY() && (minY = -1), 0 !== body.deltaX() && 0 !== body.deltaY() && faceHorizontal && faceVertical && (minX = Math.min(Math.abs(body.position.x - tileRight), Math.abs(body.right - tileLeft)), minY = Math.min(Math.abs(body.position.y - tileBottom), Math.abs(body.bottom - tileTop))), minX < minY) {
        if (faceHorizontal && 0 !== (ox = TileCheckX(body, tile, tileLeft, tileRight, tileBias, isLayer)) && !TileIntersectsBody(tileWorldRect, body)) return !0;
        faceVertical && (oy = TileCheckY(body, tile, tileTop, tileBottom, tileBias, isLayer));
      } else {
        if (faceVertical && 0 !== (oy = TileCheckY(body, tile, tileTop, tileBottom, tileBias, isLayer)) && !TileIntersectsBody(tileWorldRect, body)) return !0;
        faceHorizontal && (ox = TileCheckX(body, tile, tileLeft, tileRight, tileBias, isLayer));
      }

      return 0 !== ox || 0 !== oy;
    };
  }, function (module, exports, __webpack_require__) {
    var ProcessTileSeparationX = __webpack_require__(534);

    module.exports = function (body, collideRight, tileLeft, tileRight, tileBias, isLayer) {
      var ox = 0,
          faceLeft = collideRight.faceLeft,
          faceRight = collideRight.faceRight,
          collideLeft = collideRight.collideLeft,
          collideRight = collideRight.collideRight;
      return isLayer || (collideRight = collideLeft = faceRight = faceLeft = !0), body.deltaX() < 0 && collideRight && body.checkCollision.left ? faceRight && body.x < tileRight && (ox = body.x - tileRight) < -tileBias && (ox = 0) : 0 < body.deltaX() && collideLeft && body.checkCollision.right && faceLeft && body.right > tileLeft && tileBias < (ox = body.right - tileLeft) && (ox = 0), 0 !== ox && (body.customSeparateX ? body.overlapX = ox : ProcessTileSeparationX(body, ox)), ox;
    };
  }, function (module, exports) {
    module.exports = function (body, x) {
      x < 0 ? (body.blocked.none = !1, body.blocked.left = !0) : 0 < x && (body.blocked.none = !1, body.blocked.right = !0), body.position.x -= x, 0 === body.bounce.x ? body.velocity.x = 0 : body.velocity.x = -body.velocity.x * body.bounce.x;
    };
  }, function (module, exports, __webpack_require__) {
    var ProcessTileSeparationY = __webpack_require__(536);

    module.exports = function (body, collideDown, tileTop, tileBottom, tileBias, isLayer) {
      var oy = 0,
          faceTop = collideDown.faceTop,
          faceBottom = collideDown.faceBottom,
          collideUp = collideDown.collideUp,
          collideDown = collideDown.collideDown;
      return isLayer || (collideDown = collideUp = faceBottom = faceTop = !0), body.deltaY() < 0 && collideDown && body.checkCollision.up ? faceBottom && body.y < tileBottom && (oy = body.y - tileBottom) < -tileBias && (oy = 0) : 0 < body.deltaY() && collideUp && body.checkCollision.down && faceTop && body.bottom > tileTop && tileBias < (oy = body.bottom - tileTop) && (oy = 0), 0 !== oy && (body.customSeparateY ? body.overlapY = oy : ProcessTileSeparationY(body, oy)), oy;
    };
  }, function (module, exports) {
    module.exports = function (body, y) {
      y < 0 ? (body.blocked.none = !1, body.blocked.up = !0) : 0 < y && (body.blocked.none = !1, body.blocked.down = !0), body.position.y -= y, 0 === body.bounce.y ? body.velocity.y = 0 : body.velocity.y = -body.velocity.y * body.bounce.y;
    };
  }, function (module, exports, __webpack_require__) {
    var GetOverlapX = __webpack_require__(246),
        ProcessX = __webpack_require__(1389);

    module.exports = function (body1, body2, overlapOnly, body2Immovable) {
      var blockedState = GetOverlapX(body1, body2, overlapOnly, body2Immovable),
          body1Immovable = body1.immovable,
          body2Immovable = body2.immovable;
      if (overlapOnly || 0 === blockedState || body1Immovable && body2Immovable || body1.customSeparateX || body2.customSeparateX) return 0 !== blockedState || body1.embedded && body2.embedded;
      blockedState = ProcessX.Set(body1, body2, blockedState);
      return body1Immovable || body2Immovable ? (body1Immovable ? ProcessX.RunImmovableBody1(blockedState) : body2Immovable && ProcessX.RunImmovableBody2(blockedState), !0) : 0 < blockedState || ProcessX.Check();
    };
  }, function (module, exports, __webpack_require__) {
    var GetOverlapY = __webpack_require__(247),
        ProcessY = __webpack_require__(1390);

    module.exports = function (body1, body2, overlapOnly, body2Immovable) {
      var blockedState = GetOverlapY(body1, body2, overlapOnly, body2Immovable),
          body1Immovable = body1.immovable,
          body2Immovable = body2.immovable;
      if (overlapOnly || 0 === blockedState || body1Immovable && body2Immovable || body1.customSeparateY || body2.customSeparateY) return 0 !== blockedState || body1.embedded && body2.embedded;
      blockedState = ProcessY.Set(body1, body2, blockedState);
      return body1Immovable || body2Immovable ? (body1Immovable ? ProcessY.RunImmovableBody1(blockedState) : body2Immovable && ProcessY.RunImmovableBody2(blockedState), !0) : 0 < blockedState || ProcessY.Check();
    };
  }, function (module, exports, __webpack_require__) {
    var CircleContains = __webpack_require__(66),
        StaticBody = __webpack_require__(0),
        CONST = __webpack_require__(62),
        RectangleContains = __webpack_require__(57),
        Vector2 = __webpack_require__(3),
        StaticBody = new StaticBody({
      initialize: function initialize(world, gameObject) {
        var width = gameObject.displayWidth || 64,
            height = gameObject.displayHeight || 64;
        this.world = world, this.gameObject = gameObject, this.debugShowBody = world.defaults.debugShowStaticBody, this.debugBodyColor = world.defaults.staticBodyDebugColor, this.enable = !0, this.isCircle = !1, this.radius = 0, this.offset = new Vector2(), this.position = new Vector2(gameObject.x - width * gameObject.originX, gameObject.y - height * gameObject.originY), this.width = width, this.height = height, this.halfWidth = Math.abs(this.width / 2), this.halfHeight = Math.abs(this.height / 2), this.center = new Vector2(this.position.x + this.halfWidth, this.position.y + this.halfHeight), this.velocity = Vector2.ZERO, this.allowGravity = !1, this.gravity = Vector2.ZERO, this.bounce = Vector2.ZERO, this.onWorldBounds = !1, this.onCollide = !1, this.onOverlap = !1, this.mass = 1, this.immovable = !0, this.pushable = !1, this.customSeparateX = !1, this.customSeparateY = !1, this.overlapX = 0, this.overlapY = 0, this.overlapR = 0, this.embedded = !1, this.collideWorldBounds = !1, this.checkCollision = {
          none: !1,
          up: !0,
          down: !0,
          left: !0,
          right: !0
        }, this.touching = {
          none: !0,
          up: !1,
          down: !1,
          left: !1,
          right: !1
        }, this.wasTouching = {
          none: !0,
          up: !1,
          down: !1,
          left: !1,
          right: !1
        }, this.blocked = {
          none: !0,
          up: !1,
          down: !1,
          left: !1,
          right: !1
        }, this.physicsType = CONST.STATIC_BODY, this._dx = 0, this._dy = 0;
      },
      setGameObject: function setGameObject(gameObject, update) {
        return gameObject && gameObject !== this.gameObject && (this.gameObject.body = null, (gameObject.body = this).gameObject = gameObject), update && this.updateFromGameObject(), this;
      },
      updateFromGameObject: function updateFromGameObject() {
        this.world.staticTree.remove(this);
        var gameObject = this.gameObject;
        return gameObject.getTopLeft(this.position), this.width = gameObject.displayWidth, this.height = gameObject.displayHeight, this.halfWidth = Math.abs(this.width / 2), this.halfHeight = Math.abs(this.height / 2), this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight), this.world.staticTree.insert(this), this;
      },
      setOffset: function setOffset(x, y) {
        return void 0 === y && (y = x), this.world.staticTree.remove(this), this.position.x -= this.offset.x, this.position.y -= this.offset.y, this.offset.set(x, y), this.position.x += this.offset.x, this.position.y += this.offset.y, this.updateCenter(), this.world.staticTree.insert(this), this;
      },
      setSize: function setSize(width, height, ox) {
        void 0 === ox && (ox = !0);
        var oy = this.gameObject;
        return !width && oy.frame && (width = oy.frame.realWidth), !height && oy.frame && (height = oy.frame.realHeight), this.world.staticTree.remove(this), this.width = width, this.height = height, this.halfWidth = Math.floor(width / 2), this.halfHeight = Math.floor(height / 2), ox && oy.getCenter && (ox = oy.displayWidth / 2, oy = oy.displayHeight / 2, this.position.x -= this.offset.x, this.position.y -= this.offset.y, this.offset.set(ox - this.halfWidth, oy - this.halfHeight), this.position.x += this.offset.x, this.position.y += this.offset.y), this.updateCenter(), this.isCircle = !1, this.radius = 0, this.world.staticTree.insert(this), this;
      },
      setCircle: function setCircle(radius, offsetX, offsetY) {
        return void 0 === offsetX && (offsetX = this.offset.x), void 0 === offsetY && (offsetY = this.offset.y), 0 < radius ? (this.world.staticTree.remove(this), this.isCircle = !0, this.radius = radius, this.width = 2 * radius, this.height = 2 * radius, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.offset.set(offsetX, offsetY), this.updateCenter(), this.world.staticTree.insert(this)) : this.isCircle = !1, this;
      },
      updateCenter: function updateCenter() {
        this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight);
      },
      reset: function reset(x, y) {
        var gameObject = this.gameObject;
        void 0 === x && (x = gameObject.x), void 0 === y && (y = gameObject.y), this.world.staticTree.remove(this), gameObject.setPosition(x, y), gameObject.getTopLeft(this.position), this.updateCenter(), this.world.staticTree.insert(this);
      },
      stop: function stop() {
        return this;
      },
      getBounds: function getBounds(obj) {
        return obj.x = this.x, obj.y = this.y, obj.right = this.right, obj.bottom = this.bottom, obj;
      },
      hitTest: function hitTest(x, y) {
        return (this.isCircle ? CircleContains : RectangleContains)(this, x, y);
      },
      postUpdate: function postUpdate() {},
      deltaAbsX: function deltaAbsX() {
        return 0;
      },
      deltaAbsY: function deltaAbsY() {
        return 0;
      },
      deltaX: function deltaX() {
        return 0;
      },
      deltaY: function deltaY() {
        return 0;
      },
      deltaZ: function deltaZ() {
        return 0;
      },
      destroy: function destroy() {
        this.enable = !1, this.world.pendingDestroy.set(this);
      },
      drawDebug: function drawDebug(graphic) {
        var pos = this.position,
            x = pos.x + this.halfWidth,
            y = pos.y + this.halfHeight;
        this.debugShowBody && (graphic.lineStyle(graphic.defaultStrokeWidth, this.debugBodyColor, 1), this.isCircle ? graphic.strokeCircle(x, y, this.width / 2) : graphic.strokeRect(pos.x, pos.y, this.width, this.height));
      },
      willDrawDebug: function willDrawDebug() {
        return this.debugShowBody;
      },
      setMass: function setMass(value) {
        return this.mass = value = value <= 0 ? .1 : value, this;
      },
      x: {
        get: function get() {
          return this.position.x;
        },
        set: function set(value) {
          this.world.staticTree.remove(this), this.position.x = value, this.world.staticTree.insert(this);
        }
      },
      y: {
        get: function get() {
          return this.position.y;
        },
        set: function set(value) {
          this.world.staticTree.remove(this), this.position.y = value, this.world.staticTree.insert(this);
        }
      },
      left: {
        get: function get() {
          return this.position.x;
        }
      },
      right: {
        get: function get() {
          return this.position.x + this.width;
        }
      },
      top: {
        get: function get() {
          return this.position.y;
        }
      },
      bottom: {
        get: function get() {
          return this.position.y + this.height;
        }
      }
    });

    module.exports = StaticBody;
  }, function (module, exports, BasePlugin) {
    BasePlugin = new (BasePlugin(0))({
      initialize: function initialize(pluginManager) {
        this.pluginManager = pluginManager, this.game = pluginManager.game;
      },
      init: function init() {},
      start: function start() {},
      stop: function stop() {},
      destroy: function destroy() {
        this.pluginManager = null, this.game = null, this.scene = null, this.systems = null;
      }
    });
    module.exports = BasePlugin;
  }, function (module, exports, __webpack_require__) {
    var point = new (__webpack_require__(3))();

    module.exports = function (tileX, pos, layer, camera) {
      var tilemapLayer = layer.tilemapLayer,
          cullPaddingX = tilemapLayer.cullPaddingX,
          cullPaddingY = tilemapLayer.cullPaddingY,
          pos = tilemapLayer.tilemap.tileToWorldXY(tileX, pos, point, camera, tilemapLayer);
      return pos.x > camera.worldView.x + tilemapLayer.scaleX * layer.tileWidth * (-cullPaddingX - .5) && pos.x < camera.worldView.right + tilemapLayer.scaleX * layer.tileWidth * (cullPaddingX - .5) && pos.y > camera.worldView.y + tilemapLayer.scaleY * layer.tileHeight * (-cullPaddingY - 1) && pos.y < camera.worldView.bottom + tilemapLayer.scaleY * layer.tileHeight * (cullPaddingY - .5);
    };
  }, function (module, exports, __webpack_require__) {
    var GetTilesWithin = __webpack_require__(26);

    module.exports = function (findIndex, newIndex, tileX, tileY, width, height, layer) {
      for (var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer), i = 0; i < tiles.length; i++) {
        tiles[i] && tiles[i].index === findIndex && (tiles[i].index = newIndex);
      }
    };
  }, function (module, exports, __webpack_require__) {
    var Rectangle = __webpack_require__(10),
        SnapCeil = __webpack_require__(139),
        SnapFloor = __webpack_require__(76),
        bounds = new Rectangle();

    module.exports = function (boundsLeft, camera) {
      var boundsRight = boundsLeft.tilemapLayer.tilemap,
          boundsBottom = boundsLeft.tilemapLayer,
          boundsTop = Math.floor(boundsRight.tileWidth * boundsBottom.scaleX),
          tileH = Math.floor(boundsRight.tileHeight * boundsBottom.scaleY),
          boundsLeft = SnapFloor(camera.worldView.x - boundsBottom.x, boundsTop, 0, !0) - boundsBottom.cullPaddingX,
          boundsRight = SnapCeil(camera.worldView.right - boundsBottom.x, boundsTop, 0, !0) + boundsBottom.cullPaddingX,
          boundsTop = SnapFloor(camera.worldView.y - boundsBottom.y, tileH, 0, !0) - boundsBottom.cullPaddingY,
          boundsBottom = SnapCeil(camera.worldView.bottom - boundsBottom.y, tileH, 0, !0) + boundsBottom.cullPaddingY;
      return bounds.setTo(boundsLeft, boundsTop, boundsRight - boundsLeft, boundsBottom - boundsTop);
    };
  }, function (module, exports, __webpack_require__) {
    var CullBounds = __webpack_require__(543),
        RunCull = __webpack_require__(159);

    module.exports = function (layer, bounds, outputArray, renderOrder) {
      void 0 === renderOrder && (renderOrder = 0), (outputArray = void 0 === outputArray ? [] : outputArray).length = 0;
      var tilemapLayer = layer.tilemapLayer,
          bounds = CullBounds(layer, bounds);
      return !tilemapLayer.skipCull && 1 === tilemapLayer.scrollFactorX && 1 === tilemapLayer.scrollFactorY || (bounds.left = 0, bounds.right = layer.width, bounds.top = 0, bounds.bottom = layer.height), RunCull(layer, bounds, renderOrder, outputArray), outputArray;
    };
  }, function (module, exports, __webpack_require__) {
    var CullBounds = __webpack_require__(546),
        RunCull = __webpack_require__(159);

    module.exports = function (layer, bounds, outputArray, renderOrder) {
      void 0 === renderOrder && (renderOrder = 0), (outputArray = void 0 === outputArray ? [] : outputArray).length = 0;
      var tilemapLayer = layer.tilemapLayer;
      return tilemapLayer.skipCull || 1 !== tilemapLayer.scrollFactorX || 1 !== tilemapLayer.scrollFactorY || (bounds = CullBounds(layer, bounds), RunCull(layer, bounds, renderOrder, outputArray)), outputArray;
    };
  }, function (module, exports, __webpack_require__) {
    var SnapCeil = __webpack_require__(139),
        SnapFloor = __webpack_require__(76);

    module.exports = function (rowH, camera) {
      var tileH = rowH.tilemapLayer.tilemap,
          tilemapLayer = rowH.tilemapLayer,
          tileW = Math.floor(tileH.tileWidth * tilemapLayer.scaleX),
          tileH = Math.floor(tileH.tileHeight * tilemapLayer.scaleY),
          rowH = rowH.hexSideLength,
          rowH = (tileH - rowH) / 2 + rowH;
      return {
        left: SnapFloor(camera.worldView.x - tilemapLayer.x, tileW, 0, !0) - tilemapLayer.cullPaddingX,
        right: SnapCeil(camera.worldView.right - tilemapLayer.x, tileW, 0, !0) + tilemapLayer.cullPaddingX,
        top: SnapFloor(camera.worldView.y - tilemapLayer.y, rowH, 0, !0) - tilemapLayer.cullPaddingY,
        bottom: SnapCeil(camera.worldView.bottom - tilemapLayer.y, rowH, 0, !0) + tilemapLayer.cullPaddingY
      };
    };
  }, function (module, exports, __webpack_require__) {
    var CheckIsoBounds = __webpack_require__(541);

    module.exports = function (layer, camera, outputArray, renderOrder) {
      void 0 === renderOrder && (renderOrder = 0), (outputArray = void 0 === outputArray ? [] : outputArray).length = 0;
      var x,
          y,
          tile,
          tilemapLayer = layer.tilemapLayer,
          mapData = layer.data,
          mapWidth = layer.width,
          mapHeight = layer.height,
          drawRight = mapWidth,
          drawBottom = mapHeight;
      if (!tilemapLayer.skipCull) if (0 === renderOrder) for (y = 0; y < drawBottom; y++) {
        for (x = 0; mapData[y] && x < drawRight; x++) {
          CheckIsoBounds(x, y, layer, camera) && (tile = mapData[y][x]) && -1 !== tile.index && tile.visible && 0 !== tile.alpha && outputArray.push(tile);
        }
      } else if (1 === renderOrder) for (y = 0; y < drawBottom; y++) {
        for (x = drawRight; mapData[y] && 0 <= x; x--) {
          CheckIsoBounds(x, y, layer, camera) && (tile = mapData[y][x]) && -1 !== tile.index && tile.visible && 0 !== tile.alpha && outputArray.push(tile);
        }
      } else if (2 === renderOrder) for (y = drawBottom; 0 <= y; y--) {
        for (x = 0; mapData[y] && x < drawRight; x++) {
          CheckIsoBounds(x, y, layer, camera) && (tile = mapData[y][x]) && -1 !== tile.index && tile.visible && 0 !== tile.alpha && outputArray.push(tile);
        }
      } else if (3 === renderOrder) for (y = drawBottom; 0 <= y; y--) {
        for (x = drawRight; mapData[y] && 0 <= x; x--) {
          CheckIsoBounds(x, y, layer, camera) && (tile = mapData[y][x]) && -1 !== tile.index && tile.visible && 0 !== tile.alpha && outputArray.push(tile);
        }
      }
      return tilemapLayer.tilesDrawn = outputArray.length, tilemapLayer.tilesTotal = mapWidth * mapHeight, outputArray;
    };
  }, function (module, exports, __webpack_require__) {
    var CullBounds = __webpack_require__(549),
        RunCull = __webpack_require__(159);

    module.exports = function (layer, bounds, outputArray, renderOrder) {
      void 0 === renderOrder && (renderOrder = 0), (outputArray = void 0 === outputArray ? [] : outputArray).length = 0;
      var tilemapLayer = layer.tilemapLayer;
      return tilemapLayer.skipCull || 1 !== tilemapLayer.scrollFactorX || 1 !== tilemapLayer.scrollFactorY || (bounds = CullBounds(layer, bounds), RunCull(layer, bounds, renderOrder, outputArray)), outputArray;
    };
  }, function (module, exports, __webpack_require__) {
    var SnapCeil = __webpack_require__(139),
        SnapFloor = __webpack_require__(76);

    module.exports = function (tileW, camera) {
      var tileH = tileW.tilemapLayer.tilemap,
          tilemapLayer = tileW.tilemapLayer,
          tileW = Math.floor(tileH.tileWidth * tilemapLayer.scaleX),
          tileH = Math.floor(tileH.tileHeight * tilemapLayer.scaleY);
      return {
        left: SnapFloor(camera.worldView.x - tilemapLayer.x, tileW, 0, !0) - tilemapLayer.cullPaddingX,
        right: SnapCeil(camera.worldView.right - tilemapLayer.x, tileW, 0, !0) + tilemapLayer.cullPaddingX,
        top: SnapFloor(camera.worldView.y - tilemapLayer.y, tileH / 2, 0, !0) - tilemapLayer.cullPaddingY,
        bottom: SnapCeil(camera.worldView.bottom - tilemapLayer.y, tileH / 2, 0, !0) + tilemapLayer.cullPaddingY
      };
    };
  }, function (module, exports, __webpack_require__) {
    var Vector2 = __webpack_require__(3);

    module.exports = function (tileX, tileY, point, camera, len) {
      point = point || new Vector2();
      var tileWidth = len.baseTileWidth,
          tileHeight = len.baseTileHeight,
          tilemapLayer = len.tilemapLayer,
          layerWorldX = 0,
          layerWorldY = 0;
      tilemapLayer && (camera = camera || tilemapLayer.scene.cameras.main, layerWorldX = tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX), tileWidth *= tilemapLayer.scaleX, layerWorldY = tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY), tileHeight *= tilemapLayer.scaleY);
      len = len.hexSideLength;
      return point.set(layerWorldX + tileX * tileWidth + tileY % 2 * (tileWidth / 2), layerWorldY + tileY * ((tileHeight - len) / 2 + len));
    };
  }, function (module, exports, __webpack_require__) {
    var Vector2 = __webpack_require__(3);

    module.exports = function (tileX, tileY, point, camera, layerWorldY) {
      point = point || new Vector2();
      var tileWidth = layerWorldY.baseTileWidth,
          tileHeight = layerWorldY.baseTileHeight,
          tilemapLayer = layerWorldY.tilemapLayer,
          layerWorldX = 0,
          layerWorldY = 0;
      return tilemapLayer && (camera = camera || tilemapLayer.scene.cameras.main, layerWorldX = tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX), tileWidth *= tilemapLayer.scaleX, layerWorldY = tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY), tileHeight *= tilemapLayer.scaleY), point.set(layerWorldX + tileWidth / 2 * (tileX - tileY), layerWorldY + (tileX + tileY) * (tileHeight / 2));
    };
  }, function (module, exports, __webpack_require__) {
    var Vector2 = __webpack_require__(3);

    module.exports = function (tileX, tileY, point, camera, layerWorldY) {
      point = point || new Vector2();
      var tileWidth = layerWorldY.baseTileWidth,
          tileHeight = layerWorldY.baseTileHeight,
          tilemapLayer = layerWorldY.tilemapLayer,
          layerWorldX = 0,
          layerWorldY = 0;
      return tilemapLayer && (camera = camera || tilemapLayer.scene.cameras.main, layerWorldX = tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX), tileWidth *= tilemapLayer.scaleX, layerWorldY = tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY), tileHeight *= tilemapLayer.scaleY), point.set(layerWorldX + tileX * tileWidth + tileY % 2 * (tileWidth / 2), layerWorldY + tileY * (tileHeight / 2));
    };
  }, function (module, exports, __webpack_require__) {
    var TileToWorldX = __webpack_require__(253),
        TileToWorldY = __webpack_require__(254),
        Vector2 = __webpack_require__(3);

    module.exports = function (tileX, tileY, point, camera, layer) {
      return (point = point || new Vector2(0, 0)).x = TileToWorldX(tileX, camera, layer), point.y = TileToWorldY(tileY, camera, layer), point;
    };
  }, function (module, exports) {
    module.exports = function (tileY, camera, layerWorldY) {
      var tileHeight = layerWorldY.baseTileHeight,
          len = layerWorldY.tilemapLayer,
          layerWorldY = 0;
      len && (void 0 === camera && (camera = len.scene.cameras.main), layerWorldY = len.y + camera.scrollY * (1 - len.scrollFactorY), tileHeight *= len.scaleY);
      len = len.tilemap.hexSideLength;
      return layerWorldY + tileY * ((tileHeight - len) / 2 + len);
    };
  }, function (module, exports) {
    module.exports = function (tileY, camera, layerWorldY) {
      var tileHeight = layerWorldY.baseTileHeight,
          tilemapLayer = layerWorldY.tilemapLayer,
          layerWorldY = 0;
      return tilemapLayer && (void 0 === camera && (camera = tilemapLayer.scene.cameras.main), layerWorldY = tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY), tileHeight *= tilemapLayer.scaleY), layerWorldY + tileY * (tileHeight / 2);
    };
  }, function (module, exports, __webpack_require__) {
    var Vector2 = __webpack_require__(3);

    module.exports = function (worldX, worldY, snapToFloor, point, camera, y) {
      point = point || new Vector2();
      var x = y.baseTileWidth,
          tileHeight = y.baseTileHeight,
          tilemapLayer = y.tilemapLayer;
      tilemapLayer && (camera = camera || tilemapLayer.scene.cameras.main, worldY -= tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY), tileHeight *= tilemapLayer.scaleY, worldX -= tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX), x *= tilemapLayer.scaleX);
      y = y.hexSideLength, y = (tileHeight - y) / 2 + y, y = snapToFloor ? Math.floor(worldY / y) : worldY / y, x = snapToFloor ? Math.floor((worldX - y % 2 * .5 * x) / x) : (worldX - y % 2 * .5 * x) / x;
      return point.set(x, y);
    };
  }, function (module, exports, __webpack_require__) {
    var Vector2 = __webpack_require__(3);

    module.exports = function (worldX, worldY, snapToFloor, point, camera, x) {
      point = point || new Vector2();
      var y = x.baseTileWidth,
          tileHeight = x.baseTileHeight,
          x = x.tilemapLayer;
      x && (camera = camera || x.scene.cameras.main, worldY -= x.y + camera.scrollY * (1 - x.scrollFactorY), tileHeight *= x.scaleY, worldX -= x.x + camera.scrollX * (1 - x.scrollFactorX), y *= x.scaleX);
      x = snapToFloor ? Math.floor((worldX / (y / 2) + worldY / (tileHeight / 2)) / 2) : (worldX / (y / 2) + worldY / (tileHeight / 2)) / 2, y = snapToFloor ? Math.floor((worldY / (tileHeight / 2) - worldX / (y / 2)) / 2) : (worldY / (tileHeight / 2) - worldX / (y / 2)) / 2;
      return point.set(x, y);
    };
  }, function (module, exports, __webpack_require__) {
    var Vector2 = __webpack_require__(3);

    module.exports = function (worldX, worldY, snapToFloor, point, camera, tilemapLayer) {
      point = point || new Vector2();
      var x = tilemapLayer.baseTileWidth,
          y = tilemapLayer.baseTileHeight,
          tilemapLayer = tilemapLayer.tilemapLayer;
      tilemapLayer && (camera = camera || tilemapLayer.scene.cameras.main, worldY -= tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY), y *= tilemapLayer.scaleY, worldX -= tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX), x *= tilemapLayer.scaleX);
      y = snapToFloor ? Math.floor(worldY / (y / 2)) : worldY / (y / 2), x = snapToFloor ? Math.floor((worldX + y % 2 * .5 * x) / x) : (worldX + y % 2 * .5 * x) / x;
      return point.set(x, y);
    };
  }, function (module, exports, __webpack_require__) {
    var WorldToTileX = __webpack_require__(255),
        WorldToTileY = __webpack_require__(256),
        Vector2 = __webpack_require__(3);

    module.exports = function (worldX, worldY, snapToFloor, point, camera, layer) {
      return void 0 === snapToFloor && (snapToFloor = !0), (point = point || new Vector2(0, 0)).x = WorldToTileX(worldX, snapToFloor, camera, layer), point.y = WorldToTileY(worldY, snapToFloor, camera, layer), point;
    };
  }, function (module, exports) {
    module.exports = function (worldY, snapToFloor, camera, rowHeight) {
      var tileHeight = rowHeight.baseTileHeight,
          tilemapLayer = rowHeight.tilemapLayer;
      tilemapLayer && (camera = camera || tilemapLayer.scene.cameras.main, worldY -= tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY), tileHeight *= tilemapLayer.scaleY);
      rowHeight = rowHeight.hexSideLength, rowHeight = (tileHeight - rowHeight) / 2 + rowHeight;
      return snapToFloor ? Math.floor(worldY / rowHeight) : worldY / rowHeight;
    };
  }, function (module, exports) {
    module.exports = function (worldY, snapToFloor, camera, tilemapLayer) {
      var tileHeight = tilemapLayer.baseTileHeight,
          tilemapLayer = tilemapLayer.tilemapLayer;
      return tilemapLayer && (camera = camera || tilemapLayer.scene.cameras.main, worldY -= tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY), tileHeight *= tilemapLayer.scaleY), snapToFloor ? Math.floor(worldY / (tileHeight / 2)) : worldY / (tileHeight / 2);
    };
  }, function (module, exports, __webpack_require__) {
    var IsInLayerBounds = __webpack_require__(119);

    module.exports = function (tile, tileY, layer) {
      if (IsInLayerBounds(tile, tileY, layer)) {
        tile = layer.data[tileY][tile];
        return null !== tile && -1 < tile.index;
      }

      return !1;
    };
  }, function (module, exports, __webpack_require__) {
    var Tile = __webpack_require__(85),
        IsInLayerBounds = __webpack_require__(119),
        CalculateFacesAt = __webpack_require__(252);

    module.exports = function (tileX, tileY, replaceWithNull, recalculateFaces, layer) {
      if (void 0 === replaceWithNull && (replaceWithNull = !0), void 0 === recalculateFaces && (recalculateFaces = !0), !IsInLayerBounds(tileX, tileY, layer)) return null;
      var tile = layer.data[tileY][tileX];
      return tile ? (layer.data[tileY][tileX] = replaceWithNull ? null : new Tile(layer, -1, tileX, tileY, layer.tileWidth, layer.tileHeight), recalculateFaces && tile && tile.collides && CalculateFacesAt(tileX, tileY, layer), tile) : null;
    };
  }, function (module, exports, __webpack_require__) {
    var Formats = __webpack_require__(40),
        Parse2DArray = __webpack_require__(259),
        ParseCSV = __webpack_require__(565),
        ParseJSONTiled = __webpack_require__(566),
        ParseWeltmeister = __webpack_require__(577);

    module.exports = function (name, mapFormat, data, tileWidth, tileHeight, insertNull) {
      var newMap;

      switch (mapFormat) {
        case Formats.ARRAY_2D:
          newMap = Parse2DArray(name, data, tileWidth, tileHeight, insertNull);
          break;

        case Formats.CSV:
          newMap = ParseCSV(name, data, tileWidth, tileHeight, insertNull);
          break;

        case Formats.TILED_JSON:
          newMap = ParseJSONTiled(name, data, insertNull);
          break;

        case Formats.WELTMEISTER:
          newMap = ParseWeltmeister(name, data, insertNull);
          break;

        default:
          console.warn("Unrecognized tilemap data format: " + mapFormat), newMap = null;
      }

      return newMap;
    };
  }, function (module, exports, __webpack_require__) {
    var Formats = __webpack_require__(40),
        Parse2DArray = __webpack_require__(259);

    module.exports = function (name, array2D, tileWidth, tileHeight, map) {
      array2D = array2D.trim().split("\n").map(function (row) {
        return row.split(",");
      }), map = Parse2DArray(name, array2D, tileWidth, tileHeight, map);
      return map.format = Formats.CSV, map;
    };
  }, function (module, exports, __webpack_require__) {
    var AssignTileProperties = __webpack_require__(567),
        BuildTilesetIndex = __webpack_require__(568),
        CONST = __webpack_require__(29),
        Formats = __webpack_require__(40),
        FromOrientationString = __webpack_require__(258),
        MapData = __webpack_require__(121),
        ParseImageLayers = __webpack_require__(569),
        ParseObjectLayers = __webpack_require__(570),
        ParseTileLayers = __webpack_require__(573),
        ParseTilesets = __webpack_require__(575);

    module.exports = function (mapData, json, sets) {
      mapData = new MapData({
        width: json.width,
        height: json.height,
        name: mapData,
        tileWidth: json.tilewidth,
        tileHeight: json.tileheight,
        orientation: FromOrientationString(json.orientation),
        format: Formats.TILED_JSON,
        version: json.version,
        properties: json.properties,
        renderOrder: json.renderorder,
        infinite: json.infinite
      });
      mapData.orientation === CONST.HEXAGONAL && (mapData.hexSideLength = json.hexsidelength), mapData.layers = ParseTileLayers(json, sets), mapData.images = ParseImageLayers(json);
      sets = ParseTilesets(json);
      return mapData.tilesets = sets.tilesets, mapData.imageCollections = sets.imageCollections, mapData.objects = ParseObjectLayers(json), mapData.tiles = BuildTilesetIndex(mapData), AssignTileProperties(mapData), mapData;
    };
  }, function (module, exports, __webpack_require__) {
    var Extend = __webpack_require__(17);

    module.exports = function (mapData) {
      for (var tile, i = 0; i < mapData.layers.length; i++) {
        for (var set, layerData = mapData.layers[i], j = 0; j < layerData.data.length; j++) {
          for (var row = layerData.data[j], k = 0; k < row.length; k++) {
            null === (tile = row[k]) || tile.index < 0 || (set = mapData.tiles[tile.index][2], set = mapData.tilesets[set], tile.width = set.tileWidth, tile.height = set.tileHeight, set.tileProperties && set.tileProperties[tile.index - set.firstgid] && (tile.properties = Extend(tile.properties, set.tileProperties[tile.index - set.firstgid])));
          }
        }
      }
    };
  }, function (module, exports, __webpack_require__) {
    var Tileset = __webpack_require__(122);

    module.exports = function (mapData) {
      for (var tiles = [], i = 0; i < mapData.imageCollections.length; i++) {
        for (var collection = mapData.imageCollections[i], images = collection.images, j = 0; j < images.length; j++) {
          var set,
              image = images[j];
          (set = new Tileset(image.image, image.gid, collection.imageWidth, collection.imageHeight, 0, 0)).updateTileData(collection.imageWidth, collection.imageHeight), mapData.tilesets.push(set);
        }
      }

      for (i = 0; i < mapData.tilesets.length; i++) {
        for (var x = (set = mapData.tilesets[i]).tileMargin, y = set.tileMargin, count = 0, countX = 0, countY = 0, t = set.firstgid; t < set.firstgid + set.total && (tiles[t] = [x, y, i], x += set.tileWidth + set.tileSpacing, ++count !== set.total) && (++countX !== set.columns || (x = set.tileMargin, y += set.tileHeight + set.tileSpacing, countX = 0, ++countY !== set.rows)); t++) {
          ;
        }
      }

      return tiles;
    };
  }, function (module, exports, __webpack_require__) {
    var GetFastValue = __webpack_require__(2),
        CreateGroupLayer = __webpack_require__(161);

    module.exports = function (json) {
      for (var images = [], groupStack = [], curGroupState = CreateGroupLayer(json); curGroupState.i < curGroupState.layers.length || 0 < groupStack.length;) {
        if (curGroupState.i >= curGroupState.layers.length) {
          if (groupStack.length < 1) {
            console.warn("TilemapParser.parseTiledJSON - Invalid layer group hierarchy");
            break;
          }

          curGroupState = groupStack.pop();
        } else {
          var layerOffsetX,
              layerOffsetY,
              nextGroupState = curGroupState.layers[curGroupState.i];
          curGroupState.i++, "imagelayer" === nextGroupState.type ? (layerOffsetX = GetFastValue(nextGroupState, "offsetx", 0) + GetFastValue(nextGroupState, "startx", 0), layerOffsetY = GetFastValue(nextGroupState, "offsety", 0) + GetFastValue(nextGroupState, "starty", 0), images.push({
            name: curGroupState.name + nextGroupState.name,
            image: nextGroupState.image,
            x: curGroupState.x + layerOffsetX + nextGroupState.x,
            y: curGroupState.y + layerOffsetY + nextGroupState.y,
            alpha: curGroupState.opacity * nextGroupState.opacity,
            visible: curGroupState.visible && nextGroupState.visible,
            properties: GetFastValue(nextGroupState, "properties", {})
          })) : "group" === nextGroupState.type && (nextGroupState = CreateGroupLayer(json, nextGroupState, curGroupState), groupStack.push(curGroupState), curGroupState = nextGroupState);
        }
      }

      return images;
    };
  }, function (module, exports, __webpack_require__) {
    var GetFastValue = __webpack_require__(2),
        ParseObject = __webpack_require__(260),
        ObjectLayer = __webpack_require__(572),
        CreateGroupLayer = __webpack_require__(161);

    module.exports = function (json) {
      for (var objectLayers = [], groupStack = [], curGroupState = CreateGroupLayer(json); curGroupState.i < curGroupState.layers.length || 0 < groupStack.length;) {
        if (curGroupState.i >= curGroupState.layers.length) {
          if (groupStack.length < 1) {
            console.warn("TilemapParser.parseTiledJSON - Invalid layer group hierarchy");
            break;
          }

          curGroupState = groupStack.pop();
        } else {
          var curo = curGroupState.layers[curGroupState.i];

          if (curGroupState.i++, curo.opacity *= curGroupState.opacity, curo.visible = curGroupState.visible && curo.visible, "objectgroup" === curo.type) {
            curo.name = curGroupState.name + curo.name;

            for (var offsetX = curGroupState.x + GetFastValue(curo, "startx", 0) + GetFastValue(curo, "offsetx", 0), offsetY = curGroupState.y + GetFastValue(curo, "starty", 0) + GetFastValue(curo, "offsety", 0), objects = [], j = 0; j < curo.objects.length; j++) {
              var parsedObject = ParseObject(curo.objects[j], offsetX, offsetY);
              objects.push(parsedObject);
            }

            var nextGroupState = new ObjectLayer(curo);
            nextGroupState.objects = objects, objectLayers.push(nextGroupState);
          } else "group" === curo.type && (nextGroupState = CreateGroupLayer(json, curo, curGroupState), groupStack.push(curGroupState), curGroupState = nextGroupState);
        }
      }

      return objectLayers;
    };
  }, function (module, exports, __webpack_require__) {
    var HasValue = __webpack_require__(126);

    module.exports = function (object, keys) {
      for (var obj = {}, i = 0; i < keys.length; i++) {
        var key = keys[i];
        HasValue(object, key) && (obj[key] = object[key]);
      }

      return obj;
    };
  }, function (module, exports, __webpack_require__) {
    var ObjectLayer = __webpack_require__(0),
        GetFastValue = __webpack_require__(2),
        ObjectLayer = new ObjectLayer({
      initialize: function initialize(config) {
        this.name = GetFastValue(config = void 0 === config ? {} : config, "name", "object layer"), this.opacity = GetFastValue(config, "opacity", 1), this.properties = GetFastValue(config, "properties", {}), this.propertyTypes = GetFastValue(config, "propertytypes", {}), this.type = GetFastValue(config, "type", "objectgroup"), this.visible = GetFastValue(config, "visible", !0), this.objects = GetFastValue(config, "objects", []);
      }
    });

    module.exports = ObjectLayer;
  }, function (module, exports, __webpack_require__) {
    var Base64Decode = __webpack_require__(574),
        CONST = __webpack_require__(29),
        CreateGroupLayer = __webpack_require__(161),
        FromOrientationString = __webpack_require__(258),
        GetFastValue = __webpack_require__(2),
        LayerData = __webpack_require__(120),
        ParseGID = __webpack_require__(261),
        Tile = __webpack_require__(85);

    module.exports = function (json, insertNull) {
      for (var infiniteMap = GetFastValue(json, "infinite", !1), tileLayers = [], groupStack = [], curGroupState = CreateGroupLayer(json); curGroupState.i < curGroupState.layers.length || 0 < groupStack.length;) {
        if (curGroupState.i >= curGroupState.layers.length) {
          if (groupStack.length < 1) {
            console.warn("TilemapParser.parseTiledJSON - Invalid layer group hierarchy");
            break;
          }

          curGroupState = groupStack.pop();
        } else {
          var nextGroupState,
              curl = curGroupState.layers[curGroupState.i];
          if (curGroupState.i++, "tilelayer" === curl.type) {
            if (curl.compression) console.warn("TilemapParser.parseTiledJSON - Layer compression is unsupported, skipping layer '" + curl.name + "'");else {
              if (curl.encoding && "base64" === curl.encoding) {
                if (curl.chunks) for (var i = 0; i < curl.chunks.length; i++) {
                  curl.chunks[i].data = Base64Decode(curl.chunks[i].data);
                }
                curl.data && (curl.data = Base64Decode(curl.data)), delete curl.encoding;
              }

              var tile,
                  blankTile,
                  output = [],
                  x = 0;

              if (infiniteMap) {
                var layerData,
                    layerOffsetX = GetFastValue(curl, "startx", 0) + curl.x,
                    layerOffsetY = GetFastValue(curl, "starty", 0) + curl.y;
                (layerData = new LayerData({
                  name: curGroupState.name + curl.name,
                  x: curGroupState.x + GetFastValue(curl, "offsetx", 0) + layerOffsetX * json.tilewidth,
                  y: curGroupState.y + GetFastValue(curl, "offsety", 0) + layerOffsetY * json.tileheight,
                  width: curl.width,
                  height: curl.height,
                  tileWidth: json.tilewidth,
                  tileHeight: json.tileheight,
                  alpha: curGroupState.opacity * curl.opacity,
                  visible: curGroupState.visible && curl.visible,
                  properties: GetFastValue(curl, "properties", []),
                  orientation: FromOrientationString(json.orientation)
                })).orientation === CONST.HEXAGONAL && (layerData.hexSideLength = json.hexsidelength);

                for (var c = 0; c < curl.height; c++) {
                  output.push([null]);

                  for (var j = 0; j < curl.width; j++) {
                    output[c][j] = null;
                  }
                }

                for (c = 0, len = curl.chunks.length; c < len; c++) {
                  for (var chunk = curl.chunks[c], offsetX = chunk.x - layerOffsetX, offsetY = chunk.y - layerOffsetY, y = 0, t = 0, len2 = chunk.data.length; t < len2; t++) {
                    var gidInfo,
                        newOffsetX = x + offsetX,
                        newOffsetY = y + offsetY;
                    0 < (gidInfo = ParseGID(chunk.data[t])).gid ? ((tile = new Tile(layerData, gidInfo.gid, newOffsetX, newOffsetY, json.tilewidth, json.tileheight)).rotation = gidInfo.rotation, tile.flipX = gidInfo.flipped, output[newOffsetY][newOffsetX] = tile) : (blankTile = insertNull ? null : new Tile(layerData, -1, newOffsetX, newOffsetY, json.tilewidth, json.tileheight), output[newOffsetY][newOffsetX] = blankTile), ++x === chunk.width && (y++, x = 0);
                  }
                }
              } else {
                (layerData = new LayerData({
                  name: curGroupState.name + curl.name,
                  x: curGroupState.x + GetFastValue(curl, "offsetx", 0) + curl.x,
                  y: curGroupState.y + GetFastValue(curl, "offsety", 0) + curl.y,
                  width: curl.width,
                  height: curl.height,
                  tileWidth: json.tilewidth,
                  tileHeight: json.tileheight,
                  alpha: curGroupState.opacity * curl.opacity,
                  visible: curGroupState.visible && curl.visible,
                  properties: GetFastValue(curl, "properties", []),
                  orientation: FromOrientationString(json.orientation)
                })).orientation === CONST.HEXAGONAL && (layerData.hexSideLength = json.hexsidelength);

                for (var row = [], k = 0, len = curl.data.length; k < len; k++) {
                  0 < (gidInfo = ParseGID(curl.data[k])).gid ? ((tile = new Tile(layerData, gidInfo.gid, x, output.length, json.tilewidth, json.tileheight)).rotation = gidInfo.rotation, tile.flipX = gidInfo.flipped, row.push(tile)) : (blankTile = insertNull ? null : new Tile(layerData, -1, x, output.length, json.tilewidth, json.tileheight), row.push(blankTile)), ++x === curl.width && (output.push(row), x = 0, row = []);
                }
              }

              layerData.data = output, tileLayers.push(layerData);
            }
          } else "group" === curl.type && (nextGroupState = CreateGroupLayer(json, curl, curGroupState), groupStack.push(curGroupState), curGroupState = nextGroupState);
        }
      }

      return tileLayers;
    };
  }, function (module, exports) {
    module.exports = function (data) {
      for (var binaryString = window.atob(data), len = binaryString.length, bytes = new Array(len / 4), i = 0; i < len; i += 4) {
        bytes[i / 4] = (binaryString.charCodeAt(i) | binaryString.charCodeAt(i + 1) << 8 | binaryString.charCodeAt(i + 2) << 16 | binaryString.charCodeAt(i + 3) << 24) >>> 0;
      }

      return bytes;
    };
  }, function (module, exports, __webpack_require__) {
    var Tileset = __webpack_require__(122),
        ImageCollection = __webpack_require__(576),
        ParseObject = __webpack_require__(260),
        ParseWangsets = __webpack_require__(1453);

    module.exports = function (json) {
      for (var stringID, tilesets = [], imageCollections = [], lastSet = null, i = 0; i < json.tilesets.length; i++) {
        var set = json.tilesets[i];
        if (set.source) console.warn("External tilesets unsupported. Use Embed Tileset and re-export");else if (set.image) {
          var newSet = new Tileset(set.name, set.firstgid, set.tilewidth, set.tileheight, set.margin, set.spacing);

          if (1 < json.version) {
            var datas = void 0,
                props = void 0;
            if (Array.isArray(set.tiles)) for (var datas = datas || {}, props = props || {}, t = 0; t < set.tiles.length; t++) {
              var newPropData,
                  parsedObjects2,
                  tile = set.tiles[t];
              tile.properties && (newPropData = {}, tile.properties.forEach(function (propData) {
                newPropData[propData.name] = propData.value;
              }), props[tile.id] = newPropData), tile.objectgroup && ((datas[tile.id] || (datas[tile.id] = {})).objectgroup = tile.objectgroup, tile.objectgroup.objects && (parsedObjects2 = tile.objectgroup.objects.map(function (obj) {
                return ParseObject(obj);
              }), datas[tile.id].objectgroup.objects = parsedObjects2)), tile.animation && ((datas[tile.id] || (datas[tile.id] = {})).animation = tile.animation), tile.type && ((datas[tile.id] || (datas[tile.id] = {})).type = tile.type);
            }
            Array.isArray(set.wangsets) && (props = props || {}, ParseWangsets(set.wangsets, datas = datas || {})), datas && (newSet.tileData = datas, newSet.tileProperties = props);
          } else if (set.tileproperties && (newSet.tileProperties = set.tileproperties), set.tiles) for (stringID in newSet.tileData = set.tiles, newSet.tileData) {
            var parsedObjects1 = newSet.tileData[stringID].objectgroup;
            parsedObjects1 && parsedObjects1.objects && (parsedObjects1 = parsedObjects1.objects.map(function (obj) {
              return ParseObject(obj);
            }), newSet.tileData[stringID].objectgroup.objects = parsedObjects1);
          }

          newSet.updateTileData(set.imagewidth, set.imageheight), tilesets.push(newSet);
        } else {
          for (var newCollection = new ImageCollection(set.name, set.firstgid, set.tilewidth, set.tileheight, set.margin, set.spacing, set.properties), maxId = 0, t = 0; t < set.tiles.length; t++) {
            var image = (tile = set.tiles[t]).image,
                tileId = parseInt(tile.id, 10),
                gid = set.firstgid + tileId;
            newCollection.addImage(gid, image), maxId = Math.max(tileId, maxId);
          }

          newCollection.maxId = maxId, imageCollections.push(newCollection);
        }
        lastSet && (lastSet.lastgid = set.firstgid - 1), lastSet = set;
      }

      return {
        tilesets: tilesets,
        imageCollections: imageCollections
      };
    };
  }, function (module, exports, ImageCollection) {
    ImageCollection = new (ImageCollection(0))({
      initialize: function initialize(name, firstgid, width, height, margin, spacing, properties) {
        (void 0 === width || width <= 0) && (width = 32), (void 0 === height || height <= 0) && (height = 32), void 0 === margin && (margin = 0), void 0 === spacing && (spacing = 0), this.name = name, this.firstgid = 0 | firstgid, this.imageWidth = 0 | width, this.imageHeight = 0 | height, this.imageMargin = 0 | margin, this.imageSpacing = 0 | spacing, this.properties = properties || {}, this.images = [], this.total = 0;
      },
      containsImageIndex: function containsImageIndex(imageIndex) {
        return imageIndex >= this.firstgid && imageIndex < this.firstgid + this.total;
      },
      addImage: function addImage(gid, image) {
        return this.images.push({
          gid: gid,
          image: image
        }), this.total++, this;
      }
    });
    module.exports = ImageCollection;
  }, function (module, exports, __webpack_require__) {
    var Formats = __webpack_require__(40),
        MapData = __webpack_require__(121),
        ParseTileLayers = __webpack_require__(578),
        ParseTilesets = __webpack_require__(579);

    module.exports = function (mapData, json, insertNull) {
      if (0 === json.layer.length) return console.warn("No layers found in the Weltmeister map: " + mapData), null;

      for (var width = 0, height = 0, i = 0; i < json.layer.length; i++) {
        json.layer[i].width > width && (width = json.layer[i].width), json.layer[i].height > height && (height = json.layer[i].height);
      }

      mapData = new MapData({
        width: width,
        height: height,
        name: mapData,
        tileWidth: json.layer[0].tilesize,
        tileHeight: json.layer[0].tilesize,
        format: Formats.WELTMEISTER
      });
      return mapData.layers = ParseTileLayers(json, insertNull), mapData.tilesets = ParseTilesets(json), mapData;
    };
  }, function (module, exports, __webpack_require__) {
    var LayerData = __webpack_require__(120),
        Tile = __webpack_require__(85);

    module.exports = function (json, insertNull) {
      for (var tileLayers = [], i = 0; i < json.layer.length; i++) {
        for (var layer = json.layer[i], layerData = new LayerData({
          name: layer.name,
          width: layer.width,
          height: layer.height,
          tileWidth: layer.tilesize,
          tileHeight: layer.tilesize,
          visible: 1 === layer.visible
        }), row = [], tileGrid = [], y = 0; y < layer.data.length; y++) {
          for (var x = 0; x < layer.data[y].length; x++) {
            var tile = layer.data[y][x] - 1,
                tile = -1 < tile ? new Tile(layerData, tile, x, y, layer.tilesize, layer.tilesize) : insertNull ? null : new Tile(layerData, -1, x, y, layer.tilesize, layer.tilesize);
            row.push(tile);
          }

          tileGrid.push(row), row = [];
        }

        layerData.data = tileGrid, tileLayers.push(layerData);
      }

      return tileLayers;
    };
  }, function (module, exports, __webpack_require__) {
    var Tileset = __webpack_require__(122);

    module.exports = function (json) {
      for (var tilesets = [], tilesetsNames = [], i = 0; i < json.layer.length; i++) {
        var layer = json.layer[i],
            tilesetName = layer.tilesetName;
        "" !== tilesetName && -1 === tilesetsNames.indexOf(tilesetName) && (tilesetsNames.push(tilesetName), tilesets.push(new Tileset(tilesetName, 0, layer.tilesize, layer.tilesize, 0, 0)));
      }

      return tilesets;
    };
  }, function (module, exports, __webpack_require__) {
    var Tilemap = __webpack_require__(0),
        DegToRad = __webpack_require__(36),
        Formats = __webpack_require__(40),
        GetFastValue = __webpack_require__(2),
        LayerData = __webpack_require__(120),
        ORIENTATION = __webpack_require__(29),
        Rotate = __webpack_require__(362),
        SpliceOne = __webpack_require__(74),
        Sprite = __webpack_require__(73),
        Tile = __webpack_require__(85),
        TilemapComponents = __webpack_require__(251),
        TilemapLayer = __webpack_require__(581),
        Tileset = __webpack_require__(122),
        Tilemap = new Tilemap({
      initialize: function initialize(scene, orientation) {
        this.scene = scene, this.tileWidth = orientation.tileWidth, this.tileHeight = orientation.tileHeight, this.width = orientation.width, this.height = orientation.height, this.orientation = orientation.orientation, this.renderOrder = orientation.renderOrder, this.format = orientation.format, this.version = orientation.version, this.properties = orientation.properties, this.widthInPixels = orientation.widthInPixels, this.heightInPixels = orientation.heightInPixels, this.imageCollections = orientation.imageCollections, this.images = orientation.images, this.layers = orientation.layers, this.tilesets = orientation.tilesets, this.objects = orientation.objects, this.currentLayerIndex = 0, this.hexSideLength = orientation.hexSideLength;
        orientation = this.orientation;
        this._convert = {
          WorldToTileXY: TilemapComponents.GetWorldToTileXYFunction(orientation),
          WorldToTileX: TilemapComponents.GetWorldToTileXFunction(orientation),
          WorldToTileY: TilemapComponents.GetWorldToTileYFunction(orientation),
          TileToWorldXY: TilemapComponents.GetTileToWorldXYFunction(orientation),
          TileToWorldX: TilemapComponents.GetTileToWorldXFunction(orientation),
          TileToWorldY: TilemapComponents.GetTileToWorldYFunction(orientation)
        };
      },
      createBlankDynamicLayer: function createBlankDynamicLayer(name, tileset, x, y, width, height, tileWidth, tileHeight) {
        return console.warn("createBlankDynamicLayer is deprecated. Use createBlankLayer"), this.createBlankLayer(name, tileset, x, y, width, height, tileWidth, tileHeight);
      },
      createDynamicLayer: function createDynamicLayer(layerID, tileset, x, y) {
        return console.warn("createDynamicLayer is deprecated. Use createLayer"), this.createLayer(layerID, tileset, x, y);
      },
      createStaticLayer: function createStaticLayer(layerID, tileset, x, y) {
        return console.warn("createStaticLayer is deprecated. Use createLayer"), this.createLayer(layerID, tileset, x, y);
      },
      setRenderOrder: function setRenderOrder(renderOrder) {
        var orders = ["right-down", "left-down", "right-up", "left-up"];
        return "number" == typeof renderOrder && (renderOrder = orders[renderOrder]), -1 < orders.indexOf(renderOrder) && (this.renderOrder = renderOrder), this;
      },
      addTilesetImage: function addTilesetImage(tilesetName, tileset, tileWidth, tileHeight, tileMargin, tileSpacing, gid) {
        if (void 0 === tilesetName) return null;
        if (!this.scene.sys.textures.exists(tileset = null == tileset ? tilesetName : tileset)) return console.warn("Invalid Tileset Image: " + tileset), null;
        var texture = this.scene.sys.textures.get(tileset),
            tileset = this.getTilesetIndex(tilesetName);
        if (null === tileset && this.format === Formats.TILED_JSON) return console.warn("No data found for Tileset: " + tilesetName), null;
        tileset = this.tilesets[tileset];
        return tileset ? (tileset.setTileSize(tileWidth, tileHeight), tileset.setSpacing(tileMargin, tileSpacing), tileset.setImage(texture)) : (void 0 === tileWidth && (tileWidth = this.tileWidth), void 0 === tileHeight && (tileHeight = this.tileHeight), (tileset = new Tileset(tilesetName, gid = void 0 === gid ? 0 : gid, tileWidth, tileHeight, tileMargin = void 0 === tileMargin ? 0 : tileMargin, tileSpacing = void 0 === tileSpacing ? 0 : tileSpacing)).setImage(texture), this.tilesets.push(tileset)), tileset;
      },
      copy: function copy(srcTileX, srcTileY, width, height, destTileX, destTileY, recalculateFaces, layer) {
        return null !== (layer = this.getLayer(layer)) ? (TilemapComponents.Copy(srcTileX, srcTileY, width, height, destTileX, destTileY, recalculateFaces, layer), this) : null;
      },
      createBlankLayer: function createBlankLayer(name, tileset, x, layer, width, height, tileWidth, tileHeight) {
        if (void 0 === x && (x = 0), void 0 === layer && (layer = 0), void 0 === width && (width = this.width), void 0 === height && (height = this.height), void 0 === tileWidth && (tileWidth = this.tileWidth), void 0 === tileHeight && (tileHeight = this.tileHeight), null !== this.getLayerIndex(name)) return console.warn("Invalid Tilemap Layer ID: " + name), null;

        for (var layerData = new LayerData({
          name: name,
          tileWidth: tileWidth,
          tileHeight: tileHeight,
          width: width,
          height: height,
          orientation: this.orientation
        }), tileY = 0; tileY < height; tileY++) {
          for (var row = [], tileX = 0; tileX < width; tileX++) {
            row.push(new Tile(layerData, -1, tileX, tileY, tileWidth, tileHeight, this.tileWidth, this.tileHeight));
          }

          layerData.data.push(row);
        }

        this.layers.push(layerData), this.currentLayerIndex = this.layers.length - 1;
        layer = new TilemapLayer(this.scene, this, this.currentLayerIndex, tileset, x, layer);
        return layer.setRenderOrder(this.renderOrder), this.scene.sys.displayList.add(layer), layer;
      },
      createLayer: function createLayer(layerID, tileset, x, layer) {
        var index = this.getLayerIndex(layerID);
        if (null === index) return console.warn("Invalid Tilemap Layer ID: " + layerID), "string" == typeof layerID && console.warn("Valid tilelayer names:\n\t" + this.getTileLayerNames().join(",\n\t")), null;
        var layerData = this.layers[index];
        if (layerData.tilemapLayer) return console.warn("Tilemap Layer ID already exists:" + layerID), null;
        this.currentLayerIndex = index, void 0 === x && (x = layerData.x), void 0 === layer && (layer = layerData.y);
        layer = new TilemapLayer(this.scene, this, index, tileset, x, layer);
        return layer.setRenderOrder(this.renderOrder), this.scene.sys.displayList.add(layer), layer;
      },
      createFromObjects: function createFromObjects(objectLayerName, config) {
        var results = [],
            objectLayer = this.getObjectLayer(objectLayerName);
        if (!objectLayer) return console.warn("createFromObjects: Invalid objectLayerName given: " + objectLayerName), results;
        Array.isArray(config) || (config = [config]);

        for (var objects = objectLayer.objects, c = 0; c < config.length; c++) {
          for (var singleConfig = config[c], id = GetFastValue(singleConfig, "id", null), gid = GetFastValue(singleConfig, "gid", null), name = GetFastValue(singleConfig, "name", null), toConvert = [], s = 0; s < objects.length; s++) {
            obj = objects[s], (null === id && null === gid && null === name || null !== id && obj.id === id || null !== gid && obj.gid === gid || null !== name && obj.name === name) && toConvert.push(obj);
          }

          for (var classType = GetFastValue(singleConfig, "classType", Sprite), scene = GetFastValue(singleConfig, "scene", this.scene), container = GetFastValue(singleConfig, "container", null), texture = GetFastValue(singleConfig, "key", null), frame = GetFastValue(singleConfig, "frame", null), i = 0; i < toConvert.length; i++) {
            var obj = toConvert[i],
                sprite = new classType(scene);
            sprite.setName(obj.name), sprite.setPosition(obj.x, obj.y), sprite.setTexture(texture, frame), obj.width && (sprite.displayWidth = obj.width), obj.height && (sprite.displayHeight = obj.height);
            var angle,
                offset = {
              x: sprite.originX * obj.width,
              y: (sprite.originY - 1) * obj.height
            };
            if (obj.rotation && (angle = DegToRad(obj.rotation), Rotate(offset, angle), sprite.rotation = angle), sprite.x += offset.x, sprite.y += offset.y, void 0 === obj.flippedHorizontal && void 0 === obj.flippedVertical || sprite.setFlip(obj.flippedHorizontal, obj.flippedVertical), obj.visible || (sprite.visible = !1), Array.isArray(obj.properties)) obj.properties.forEach(function (propData) {
              var key = propData.name;
              void 0 !== sprite[key] ? sprite[key] = propData.value : sprite.setData(key, propData.value);
            });else for (var key in obj.properties) {
              void 0 !== sprite[key] ? sprite[key] = obj.properties[key] : sprite.setData(key, obj.properties[key]);
            }
            container ? container.add(sprite) : scene.add.existing(sprite), results.push(sprite);
          }
        }

        return results;
      },
      createFromTiles: function createFromTiles(indexes, replacements, spriteConfig, scene, camera, layer) {
        return null === (layer = this.getLayer(layer)) ? null : TilemapComponents.CreateFromTiles(indexes, replacements, spriteConfig, scene, camera, layer);
      },
      fill: function fill(index, tileX, tileY, width, height, recalculateFaces, layer) {
        return void 0 === recalculateFaces && (recalculateFaces = !0), null === (layer = this.getLayer(layer)) ? null : (TilemapComponents.Fill(index, tileX, tileY, width, height, recalculateFaces, layer), this);
      },
      filterObjects: function filterObjects(objectLayer, callback, context) {
        if ("string" == typeof objectLayer) {
          var name = objectLayer;
          if (!(objectLayer = this.getObjectLayer(objectLayer))) return console.warn("No object layer found with the name: " + name), null;
        }

        return objectLayer.objects.filter(callback, context);
      },
      filterTiles: function filterTiles(callback, context, tileX, tileY, width, height, filteringOptions, layer) {
        return null === (layer = this.getLayer(layer)) ? null : TilemapComponents.FilterTiles(callback, context, tileX, tileY, width, height, filteringOptions, layer);
      },
      findByIndex: function findByIndex(findIndex, skip, reverse, layer) {
        return null === (layer = this.getLayer(layer)) ? null : TilemapComponents.FindByIndex(findIndex, skip, reverse, layer);
      },
      findObject: function findObject(objectLayer, callback, context) {
        if ("string" == typeof objectLayer) {
          var name = objectLayer;
          if (!(objectLayer = this.getObjectLayer(objectLayer))) return console.warn("No object layer found with the name: " + name), null;
        }

        return objectLayer.objects.find(callback, context) || null;
      },
      findTile: function findTile(callback, context, tileX, tileY, width, height, filteringOptions, layer) {
        return null === (layer = this.getLayer(layer)) ? null : TilemapComponents.FindTile(callback, context, tileX, tileY, width, height, filteringOptions, layer);
      },
      forEachTile: function forEachTile(callback, context, tileX, tileY, width, height, filteringOptions, layer) {
        return null === (layer = this.getLayer(layer)) ? null : (TilemapComponents.ForEachTile(callback, context, tileX, tileY, width, height, filteringOptions, layer), this);
      },
      getImageIndex: function getImageIndex(name) {
        return this.getIndex(this.images, name);
      },
      getImageLayerNames: function getImageLayerNames() {
        return this.images && Array.isArray(this.images) ? this.images.map(function (image) {
          return image.name;
        }) : [];
      },
      getIndex: function getIndex(location, name) {
        for (var i = 0; i < location.length; i++) {
          if (location[i].name === name) return i;
        }

        return null;
      },
      getLayer: function getLayer(index) {
        index = this.getLayerIndex(index);
        return null !== index ? this.layers[index] : null;
      },
      getObjectLayer: function getObjectLayer(index) {
        index = this.getIndex(this.objects, index);
        return null !== index ? this.objects[index] : null;
      },
      getObjectLayerNames: function getObjectLayerNames() {
        return this.objects && Array.isArray(this.objects) ? this.objects.map(function (object) {
          return object.name;
        }) : [];
      },
      getLayerIndex: function getLayerIndex(layer) {
        return void 0 === layer ? this.currentLayerIndex : "string" == typeof layer ? this.getLayerIndexByName(layer) : "number" == typeof layer && layer < this.layers.length ? layer : layer instanceof TilemapLayer ? layer.layerIndex : null;
      },
      getLayerIndexByName: function getLayerIndexByName(name) {
        return this.getIndex(this.layers, name);
      },
      getTileAt: function getTileAt(tileX, tileY, nonNull, layer) {
        return null === (layer = this.getLayer(layer)) ? null : TilemapComponents.GetTileAt(tileX, tileY, nonNull, layer);
      },
      getTileAtWorldXY: function getTileAtWorldXY(worldX, worldY, nonNull, camera, layer) {
        return null === (layer = this.getLayer(layer)) ? null : TilemapComponents.GetTileAtWorldXY(worldX, worldY, nonNull, camera, layer);
      },
      getTileLayerNames: function getTileLayerNames() {
        return this.layers && Array.isArray(this.layers) ? this.layers.map(function (layer) {
          return layer.name;
        }) : [];
      },
      getTilesWithin: function getTilesWithin(tileX, tileY, width, height, filteringOptions, layer) {
        return null === (layer = this.getLayer(layer)) ? null : TilemapComponents.GetTilesWithin(tileX, tileY, width, height, filteringOptions, layer);
      },
      getTilesWithinShape: function getTilesWithinShape(shape, filteringOptions, camera, layer) {
        return null === (layer = this.getLayer(layer)) ? null : TilemapComponents.GetTilesWithinShape(shape, filteringOptions, camera, layer);
      },
      getTilesWithinWorldXY: function getTilesWithinWorldXY(worldX, worldY, width, height, filteringOptions, camera, layer) {
        return null === (layer = this.getLayer(layer)) ? null : TilemapComponents.GetTilesWithinWorldXY(worldX, worldY, width, height, filteringOptions, camera, layer);
      },
      getTileset: function getTileset(index) {
        index = this.getIndex(this.tilesets, index);
        return null !== index ? this.tilesets[index] : null;
      },
      getTilesetIndex: function getTilesetIndex(name) {
        return this.getIndex(this.tilesets, name);
      },
      hasTileAt: function hasTileAt(tileX, tileY, layer) {
        return null === (layer = this.getLayer(layer)) ? null : TilemapComponents.HasTileAt(tileX, tileY, layer);
      },
      hasTileAtWorldXY: function hasTileAtWorldXY(worldX, worldY, camera, layer) {
        return null === (layer = this.getLayer(layer)) ? null : TilemapComponents.HasTileAtWorldXY(worldX, worldY, camera, layer);
      },
      layer: {
        get: function get() {
          return this.layers[this.currentLayerIndex];
        },
        set: function set(layer) {
          this.setLayer(layer);
        }
      },
      putTileAt: function putTileAt(tile, tileX, tileY, recalculateFaces, layer) {
        return void 0 === recalculateFaces && (recalculateFaces = !0), null === (layer = this.getLayer(layer)) ? null : TilemapComponents.PutTileAt(tile, tileX, tileY, recalculateFaces, layer);
      },
      putTileAtWorldXY: function putTileAtWorldXY(tile, worldX, worldY, recalculateFaces, camera, layer) {
        return void 0 === recalculateFaces && (recalculateFaces = !0), null === (layer = this.getLayer(layer)) ? null : TilemapComponents.PutTileAtWorldXY(tile, worldX, worldY, recalculateFaces, camera, layer);
      },
      putTilesAt: function putTilesAt(tilesArray, tileX, tileY, recalculateFaces, layer) {
        return void 0 === recalculateFaces && (recalculateFaces = !0), null === (layer = this.getLayer(layer)) ? null : (TilemapComponents.PutTilesAt(tilesArray, tileX, tileY, recalculateFaces, layer), this);
      },
      randomize: function randomize(tileX, tileY, width, height, indexes, layer) {
        return null === (layer = this.getLayer(layer)) ? null : (TilemapComponents.Randomize(tileX, tileY, width, height, indexes, layer), this);
      },
      calculateFacesAt: function calculateFacesAt(tileX, tileY, layer) {
        return null === (layer = this.getLayer(layer)) ? null : (TilemapComponents.CalculateFacesAt(tileX, tileY, layer), this);
      },
      calculateFacesWithin: function calculateFacesWithin(tileX, tileY, width, height, layer) {
        return null === (layer = this.getLayer(layer)) ? null : (TilemapComponents.CalculateFacesWithin(tileX, tileY, width, height, layer), this);
      },
      removeLayer: function removeLayer(index) {
        index = this.getLayerIndex(index);
        if (null === index) return null;
        SpliceOne(this.layers, index);

        for (var i = index; i < this.layers.length; i++) {
          this.layers[i].tilemapLayer && this.layers[i].tilemapLayer.layerIndex--;
        }

        return this.currentLayerIndex === index && (this.currentLayerIndex = 0), this;
      },
      destroyLayer: function destroyLayer(layer) {
        var index = this.getLayerIndex(layer);
        return null !== index ? ((layer = this.layers[index]).destroy(), SpliceOne(this.layers, index), this.currentLayerIndex === index && (this.currentLayerIndex = 0), this) : null;
      },
      removeAllLayers: function removeAllLayers() {
        for (var layers = this.layers, i = 0; i < layers.length; i++) {
          layers[i].tilemapLayer && layers[i].tilemapLayer.destroy(!1);
        }

        return layers.length = 0, this.currentLayerIndex = 0, this;
      },
      removeTile: function removeTile(tiles, replaceIndex, recalculateFaces) {
        void 0 === replaceIndex && (replaceIndex = -1), void 0 === recalculateFaces && (recalculateFaces = !0);
        var removed = [];
        Array.isArray(tiles) || (tiles = [tiles]);

        for (var i = 0; i < tiles.length; i++) {
          var tile = tiles[i];
          removed.push(this.removeTileAt(tile.x, tile.y, !0, recalculateFaces, tile.tilemapLayer)), -1 < replaceIndex && this.putTileAt(replaceIndex, tile.x, tile.y, recalculateFaces, tile.tilemapLayer);
        }

        return removed;
      },
      removeTileAt: function removeTileAt(tileX, tileY, replaceWithNull, recalculateFaces, layer) {
        return void 0 === replaceWithNull && (replaceWithNull = !0), void 0 === recalculateFaces && (recalculateFaces = !0), null === (layer = this.getLayer(layer)) ? null : TilemapComponents.RemoveTileAt(tileX, tileY, replaceWithNull, recalculateFaces, layer);
      },
      removeTileAtWorldXY: function removeTileAtWorldXY(worldX, worldY, replaceWithNull, recalculateFaces, camera, layer) {
        return void 0 === replaceWithNull && (replaceWithNull = !0), void 0 === recalculateFaces && (recalculateFaces = !0), null === (layer = this.getLayer(layer)) ? null : TilemapComponents.RemoveTileAtWorldXY(worldX, worldY, replaceWithNull, recalculateFaces, camera, layer);
      },
      renderDebug: function renderDebug(graphics, styleConfig, layer) {
        return null === (layer = this.getLayer(layer)) ? null : (this.orientation === ORIENTATION.ORTHOGONAL && TilemapComponents.RenderDebug(graphics, styleConfig, layer), this);
      },
      renderDebugFull: function renderDebugFull(graphics, styleConfig) {
        for (var layers = this.layers, i = 0; i < layers.length; i++) {
          TilemapComponents.RenderDebug(graphics, styleConfig, layers[i]);
        }

        return this;
      },
      replaceByIndex: function replaceByIndex(findIndex, newIndex, tileX, tileY, width, height, layer) {
        return null === (layer = this.getLayer(layer)) ? null : (TilemapComponents.ReplaceByIndex(findIndex, newIndex, tileX, tileY, width, height, layer), this);
      },
      setCollision: function setCollision(indexes, collides, recalculateFaces, layer, updateLayer) {
        return void 0 === collides && (collides = !0), void 0 === recalculateFaces && (recalculateFaces = !0), void 0 === updateLayer && (updateLayer = !0), null === (layer = this.getLayer(layer)) ? null : (TilemapComponents.SetCollision(indexes, collides, recalculateFaces, layer, updateLayer), this);
      },
      setCollisionBetween: function setCollisionBetween(start, stop, collides, recalculateFaces, layer) {
        return void 0 === collides && (collides = !0), void 0 === recalculateFaces && (recalculateFaces = !0), null === (layer = this.getLayer(layer)) ? null : (TilemapComponents.SetCollisionBetween(start, stop, collides, recalculateFaces, layer), this);
      },
      setCollisionByProperty: function setCollisionByProperty(properties, collides, recalculateFaces, layer) {
        return void 0 === collides && (collides = !0), void 0 === recalculateFaces && (recalculateFaces = !0), null === (layer = this.getLayer(layer)) ? null : (TilemapComponents.SetCollisionByProperty(properties, collides, recalculateFaces, layer), this);
      },
      setCollisionByExclusion: function setCollisionByExclusion(indexes, collides, recalculateFaces, layer) {
        return void 0 === collides && (collides = !0), void 0 === recalculateFaces && (recalculateFaces = !0), null === (layer = this.getLayer(layer)) ? null : (TilemapComponents.SetCollisionByExclusion(indexes, collides, recalculateFaces, layer), this);
      },
      setCollisionFromCollisionGroup: function setCollisionFromCollisionGroup(collides, recalculateFaces, layer) {
        return void 0 === collides && (collides = !0), void 0 === recalculateFaces && (recalculateFaces = !0), null === (layer = this.getLayer(layer)) ? null : (TilemapComponents.SetCollisionFromCollisionGroup(collides, recalculateFaces, layer), this);
      },
      setTileIndexCallback: function setTileIndexCallback(indexes, callback, callbackContext, layer) {
        return null === (layer = this.getLayer(layer)) ? null : (TilemapComponents.SetTileIndexCallback(indexes, callback, callbackContext, layer), this);
      },
      setTileLocationCallback: function setTileLocationCallback(tileX, tileY, width, height, callback, callbackContext, layer) {
        return null === (layer = this.getLayer(layer)) ? null : (TilemapComponents.SetTileLocationCallback(tileX, tileY, width, height, callback, callbackContext, layer), this);
      },
      setLayer: function setLayer(index) {
        index = this.getLayerIndex(index);
        return null !== index && (this.currentLayerIndex = index), this;
      },
      setBaseTileSize: function setBaseTileSize(tileWidth, tileHeight) {
        this.tileWidth = tileWidth, this.tileHeight = tileHeight, this.widthInPixels = this.width * tileWidth, this.heightInPixels = this.height * tileHeight;

        for (var i = 0; i < this.layers.length; i++) {
          this.layers[i].baseTileWidth = tileWidth, this.layers[i].baseTileHeight = tileHeight;

          for (var mapData = this.layers[i].data, mapWidth = this.layers[i].width, mapHeight = this.layers[i].height, row = 0; row < mapHeight; row++) {
            for (var col = 0; col < mapWidth; col++) {
              var tile = mapData[row][col];
              null !== tile && tile.setSize(void 0, void 0, tileWidth, tileHeight);
            }
          }
        }

        return this;
      },
      setLayerTileSize: function setLayerTileSize(tileWidth, tileHeight, layer) {
        if (null === (layer = this.getLayer(layer))) return this;
        layer.tileWidth = tileWidth, layer.tileHeight = tileHeight;

        for (var mapData = layer.data, mapWidth = layer.width, mapHeight = layer.height, row = 0; row < mapHeight; row++) {
          for (var col = 0; col < mapWidth; col++) {
            var tile = mapData[row][col];
            null !== tile && tile.setSize(tileWidth, tileHeight);
          }
        }

        return this;
      },
      shuffle: function shuffle(tileX, tileY, width, height, layer) {
        return null === (layer = this.getLayer(layer)) ? null : (TilemapComponents.Shuffle(tileX, tileY, width, height, layer), this);
      },
      swapByIndex: function swapByIndex(indexA, indexB, tileX, tileY, width, height, layer) {
        return null === (layer = this.getLayer(layer)) ? null : (TilemapComponents.SwapByIndex(indexA, indexB, tileX, tileY, width, height, layer), this);
      },
      tileToWorldX: function tileToWorldX(tileX, camera, layer) {
        return null === (layer = this.getLayer(layer)) ? null : this._convert.TileToWorldX(tileX, camera, layer);
      },
      tileToWorldY: function tileToWorldY(tileX, camera, layer) {
        return null === (layer = this.getLayer(layer)) ? null : this._convert.TileToWorldY(tileX, camera, layer);
      },
      tileToWorldXY: function tileToWorldXY(tileX, tileY, vec2, camera, layer) {
        return null === (layer = this.getLayer(layer)) ? null : this._convert.TileToWorldXY(tileX, tileY, vec2, camera, layer);
      },
      weightedRandomize: function weightedRandomize(weightedIndexes, tileX, tileY, width, height, layer) {
        return null === (layer = this.getLayer(layer)) ? null : (TilemapComponents.WeightedRandomize(tileX, tileY, width, height, weightedIndexes, layer), this);
      },
      worldToTileX: function worldToTileX(worldX, snapToFloor, camera, layer) {
        return null === (layer = this.getLayer(layer)) ? null : this._convert.WorldToTileX(worldX, snapToFloor, camera, layer);
      },
      worldToTileY: function worldToTileY(worldY, snapToFloor, camera, layer) {
        return null === (layer = this.getLayer(layer)) ? null : this._convert.WorldToTileY(worldY, snapToFloor, camera, layer);
      },
      worldToTileXY: function worldToTileXY(worldX, worldY, snapToFloor, vec2, camera, layer) {
        return null === (layer = this.getLayer(layer)) ? null : this._convert.WorldToTileXY(worldX, worldY, snapToFloor, vec2, camera, layer);
      },
      destroy: function destroy() {
        this.removeAllLayers(), this.tilesets.length = 0, this.objects.length = 0, this.scene = null;
      }
    });

    module.exports = Tilemap;
  }, function (module, exports, TilemapLayer) {
    var Class = TilemapLayer(0),
        Components = TilemapLayer(11),
        GameObject = TilemapLayer(15),
        TilemapComponents = TilemapLayer(251),
        TilemapLayer = TilemapLayer(1456),
        TilemapLayer = new Class({
      Extends: GameObject,
      Mixins: [Components.Alpha, Components.BlendMode, Components.ComputedSize, Components.Depth, Components.Flip, Components.GetBounds, Components.Origin, Components.Pipeline, Components.Transform, Components.Visible, Components.ScrollFactor, TilemapLayer],
      initialize: function initialize(scene, tilemap, layerIndex, tileset, x, y) {
        GameObject.call(this, scene, "TilemapLayer"), this.isTilemap = !0, this.tilemap = tilemap, this.layerIndex = layerIndex, this.layer = tilemap.layers[layerIndex], (this.layer.tilemapLayer = this).tileset = [], this.tilesDrawn = 0, this.tilesTotal = this.layer.width * this.layer.height, this.culledTiles = [], this.skipCull = !1, this.cullPaddingX = 1, this.cullPaddingY = 1, this.cullCallback = TilemapComponents.GetCullTilesFunction(this.layer.orientation), this._renderOrder = 0, this.gidMap = [], this.setTilesets(tileset), this.setAlpha(this.layer.alpha), this.setPosition(x, y), this.setOrigin(), this.setSize(tilemap.tileWidth * this.layer.width, tilemap.tileHeight * this.layer.height), this.initPipeline();
      },
      setTilesets: function setTilesets(tilesets) {
        var gidMap = [],
            setList = [],
            map = this.tilemap;
        Array.isArray(tilesets) || (tilesets = [tilesets]);

        for (var i = 0; i < tilesets.length; i++) {
          var tileset = tilesets[i];

          if (tileset = "string" == typeof tileset ? map.getTileset(tileset) : tileset) {
            setList.push(tileset);

            for (var s = tileset.firstgid, t = 0; t < tileset.total; t++) {
              gidMap[s + t] = tileset;
            }
          }
        }

        this.gidMap = gidMap, this.tileset = setList;
      },
      setRenderOrder: function setRenderOrder(renderOrder) {
        return 0 <= (renderOrder = "string" == typeof renderOrder ? ["right-down", "left-down", "right-up", "left-up"].indexOf(renderOrder) : renderOrder) && renderOrder < 4 && (this._renderOrder = renderOrder), this;
      },
      calculateFacesAt: function calculateFacesAt(tileX, tileY) {
        return TilemapComponents.CalculateFacesAt(tileX, tileY, this.layer), this;
      },
      calculateFacesWithin: function calculateFacesWithin(tileX, tileY, width, height) {
        return TilemapComponents.CalculateFacesWithin(tileX, tileY, width, height, this.layer), this;
      },
      createFromTiles: function createFromTiles(indexes, replacements, spriteConfig, scene, camera) {
        return TilemapComponents.CreateFromTiles(indexes, replacements, spriteConfig, scene, camera, this.layer);
      },
      cull: function cull(camera) {
        return this.cullCallback(this.layer, camera, this.culledTiles, this._renderOrder);
      },
      copy: function copy(srcTileX, srcTileY, width, height, destTileX, destTileY, recalculateFaces) {
        return TilemapComponents.Copy(srcTileX, srcTileY, width, height, destTileX, destTileY, recalculateFaces, this.layer), this;
      },
      fill: function fill(index, tileX, tileY, width, height, recalculateFaces) {
        return TilemapComponents.Fill(index, tileX, tileY, width, height, recalculateFaces, this.layer), this;
      },
      filterTiles: function filterTiles(callback, context, tileX, tileY, width, height, filteringOptions) {
        return TilemapComponents.FilterTiles(callback, context, tileX, tileY, width, height, filteringOptions, this.layer);
      },
      findByIndex: function findByIndex(findIndex, skip, reverse) {
        return TilemapComponents.FindByIndex(findIndex, skip, reverse, this.layer);
      },
      findTile: function findTile(callback, context, tileX, tileY, width, height, filteringOptions) {
        return TilemapComponents.FindTile(callback, context, tileX, tileY, width, height, filteringOptions, this.layer);
      },
      forEachTile: function forEachTile(callback, context, tileX, tileY, width, height, filteringOptions) {
        return TilemapComponents.ForEachTile(callback, context, tileX, tileY, width, height, filteringOptions, this.layer), this;
      },
      getTileAt: function getTileAt(tileX, tileY, nonNull) {
        return TilemapComponents.GetTileAt(tileX, tileY, nonNull, this.layer);
      },
      getTileAtWorldXY: function getTileAtWorldXY(worldX, worldY, nonNull, camera) {
        return TilemapComponents.GetTileAtWorldXY(worldX, worldY, nonNull, camera, this.layer);
      },
      getTilesWithin: function getTilesWithin(tileX, tileY, width, height, filteringOptions) {
        return TilemapComponents.GetTilesWithin(tileX, tileY, width, height, filteringOptions, this.layer);
      },
      getTilesWithinShape: function getTilesWithinShape(shape, filteringOptions, camera) {
        return TilemapComponents.GetTilesWithinShape(shape, filteringOptions, camera, this.layer);
      },
      getTilesWithinWorldXY: function getTilesWithinWorldXY(worldX, worldY, width, height, filteringOptions, camera) {
        return TilemapComponents.GetTilesWithinWorldXY(worldX, worldY, width, height, filteringOptions, camera, this.layer);
      },
      hasTileAt: function hasTileAt(tileX, tileY) {
        return TilemapComponents.HasTileAt(tileX, tileY, this.layer);
      },
      hasTileAtWorldXY: function hasTileAtWorldXY(worldX, worldY, camera) {
        return TilemapComponents.HasTileAtWorldXY(worldX, worldY, camera, this.layer);
      },
      putTileAt: function putTileAt(tile, tileX, tileY, recalculateFaces) {
        return TilemapComponents.PutTileAt(tile, tileX, tileY, recalculateFaces, this.layer);
      },
      putTileAtWorldXY: function putTileAtWorldXY(tile, worldX, worldY, recalculateFaces, camera) {
        return TilemapComponents.PutTileAtWorldXY(tile, worldX, worldY, recalculateFaces, camera, this.layer);
      },
      putTilesAt: function putTilesAt(tilesArray, tileX, tileY, recalculateFaces) {
        return TilemapComponents.PutTilesAt(tilesArray, tileX, tileY, recalculateFaces, this.layer), this;
      },
      randomize: function randomize(tileX, tileY, width, height, indexes) {
        return TilemapComponents.Randomize(tileX, tileY, width, height, indexes, this.layer), this;
      },
      removeTileAt: function removeTileAt(tileX, tileY, replaceWithNull, recalculateFaces) {
        return TilemapComponents.RemoveTileAt(tileX, tileY, replaceWithNull, recalculateFaces, this.layer);
      },
      removeTileAtWorldXY: function removeTileAtWorldXY(worldX, worldY, replaceWithNull, recalculateFaces, camera) {
        return TilemapComponents.RemoveTileAtWorldXY(worldX, worldY, replaceWithNull, recalculateFaces, camera, this.layer);
      },
      renderDebug: function renderDebug(graphics, styleConfig) {
        return TilemapComponents.RenderDebug(graphics, styleConfig, this.layer), this;
      },
      replaceByIndex: function replaceByIndex(findIndex, newIndex, tileX, tileY, width, height) {
        return TilemapComponents.ReplaceByIndex(findIndex, newIndex, tileX, tileY, width, height, this.layer), this;
      },
      setSkipCull: function setSkipCull(value) {
        return this.skipCull = value = void 0 === value ? !0 : value, this;
      },
      setCullPadding: function setCullPadding(paddingX, paddingY) {
        return void 0 === paddingY && (paddingY = 1), this.cullPaddingX = paddingX = void 0 === paddingX ? 1 : paddingX, this.cullPaddingY = paddingY, this;
      },
      setCollision: function setCollision(indexes, collides, recalculateFaces, updateLayer) {
        return TilemapComponents.SetCollision(indexes, collides, recalculateFaces, this.layer, updateLayer), this;
      },
      setCollisionBetween: function setCollisionBetween(start, stop, collides, recalculateFaces) {
        return TilemapComponents.SetCollisionBetween(start, stop, collides, recalculateFaces, this.layer), this;
      },
      setCollisionByProperty: function setCollisionByProperty(properties, collides, recalculateFaces) {
        return TilemapComponents.SetCollisionByProperty(properties, collides, recalculateFaces, this.layer), this;
      },
      setCollisionByExclusion: function setCollisionByExclusion(indexes, collides, recalculateFaces) {
        return TilemapComponents.SetCollisionByExclusion(indexes, collides, recalculateFaces, this.layer), this;
      },
      setCollisionFromCollisionGroup: function setCollisionFromCollisionGroup(collides, recalculateFaces) {
        return TilemapComponents.SetCollisionFromCollisionGroup(collides, recalculateFaces, this.layer), this;
      },
      setTileIndexCallback: function setTileIndexCallback(indexes, callback, callbackContext) {
        return TilemapComponents.SetTileIndexCallback(indexes, callback, callbackContext, this.layer), this;
      },
      setTileLocationCallback: function setTileLocationCallback(tileX, tileY, width, height, callback, callbackContext) {
        return TilemapComponents.SetTileLocationCallback(tileX, tileY, width, height, callback, callbackContext, this.layer), this;
      },
      shuffle: function shuffle(tileX, tileY, width, height) {
        return TilemapComponents.Shuffle(tileX, tileY, width, height, this.layer), this;
      },
      swapByIndex: function swapByIndex(indexA, indexB, tileX, tileY, width, height) {
        return TilemapComponents.SwapByIndex(indexA, indexB, tileX, tileY, width, height, this.layer), this;
      },
      tileToWorldX: function tileToWorldX(tileX, camera) {
        return this.tilemap.tileToWorldX(tileX, camera, this);
      },
      tileToWorldY: function tileToWorldY(tileY, camera) {
        return this.tilemap.tileToWorldY(tileY, camera, this);
      },
      tileToWorldXY: function tileToWorldXY(tileX, tileY, point, camera) {
        return this.tilemap.tileToWorldXY(tileX, tileY, point, camera, this);
      },
      weightedRandomize: function weightedRandomize(weightedIndexes, tileX, tileY, width, height) {
        return TilemapComponents.WeightedRandomize(tileX, tileY, width, height, weightedIndexes, this.layer), this;
      },
      worldToTileX: function worldToTileX(worldX, snapToFloor, camera) {
        return this.tilemap.worldToTileX(worldX, snapToFloor, camera, this);
      },
      worldToTileY: function worldToTileY(worldY, snapToFloor, camera) {
        return this.tilemap.worldToTileY(worldY, snapToFloor, camera, this);
      },
      worldToTileXY: function worldToTileXY(worldX, worldY, snapToFloor, point, camera) {
        return this.tilemap.worldToTileXY(worldX, worldY, snapToFloor, point, camera, this);
      },
      destroy: function destroy(removeFromTilemap) {
        void 0 === removeFromTilemap && (removeFromTilemap = !0), this.tilemap && (this.layer.tilemapLayer === this && (this.layer.tilemapLayer = void 0), removeFromTilemap && this.tilemap.removeLayer(this), this.tilemap = void 0, this.layer = void 0, this.culledTiles.length = 0, this.cullCallback = null, this.gidMap = [], this.tileset = [], GameObject.prototype.destroy.call(this));
      }
    });
    module.exports = TilemapLayer;
  }, function (module, exports, __webpack_require__) {
    var TimerEvent = __webpack_require__(0),
        GetFastValue = __webpack_require__(2),
        TimerEvent = new TimerEvent({
      initialize: function initialize(config) {
        this.delay = 0, this.repeat = 0, this.repeatCount = 0, this.loop = !1, this.callback, this.callbackScope, this.args, this.timeScale = 1, this.startAt = 0, this.elapsed = 0, this.paused = !1, this.hasDispatched = !1, this.reset(config);
      },
      reset: function reset(config) {
        return this.delay = GetFastValue(config, "delay", 0), this.repeat = GetFastValue(config, "repeat", 0), this.loop = GetFastValue(config, "loop", !1), this.callback = GetFastValue(config, "callback", void 0), this.callbackScope = GetFastValue(config, "callbackScope", this.callback), this.args = GetFastValue(config, "args", []), this.timeScale = GetFastValue(config, "timeScale", 1), this.startAt = GetFastValue(config, "startAt", 0), this.paused = GetFastValue(config, "paused", !1), this.elapsed = this.startAt, this.hasDispatched = !1, this.repeatCount = -1 === this.repeat || this.loop ? 999999999999 : this.repeat, this;
      },
      getProgress: function getProgress() {
        return this.elapsed / this.delay;
      },
      getOverallProgress: function getOverallProgress() {
        if (0 < this.repeat) {
          var totalDuration = this.delay + this.delay * this.repeat;
          return (this.elapsed + this.delay * (this.repeat - this.repeatCount)) / totalDuration;
        }

        return this.getProgress();
      },
      getRepeatCount: function getRepeatCount() {
        return this.repeatCount;
      },
      getElapsed: function getElapsed() {
        return this.elapsed;
      },
      getElapsedSeconds: function getElapsedSeconds() {
        return .001 * this.elapsed;
      },
      getRemaining: function getRemaining() {
        return this.delay - this.elapsed;
      },
      getRemainingSeconds: function getRemainingSeconds() {
        return .001 * this.getRemaining();
      },
      getOverallRemaining: function getOverallRemaining() {
        return this.delay * (1 + this.repeatCount) - this.elapsed;
      },
      getOverallRemainingSeconds: function getOverallRemainingSeconds() {
        return .001 * this.getOverallRemaining();
      },
      remove: function remove(dispatchCallback) {
        void 0 === dispatchCallback && (dispatchCallback = !1), this.elapsed = this.delay, this.hasDispatched = !dispatchCallback, this.repeatCount = 0;
      },
      destroy: function destroy() {
        this.callback = void 0, this.callbackScope = void 0, this.args = [];
      }
    });

    module.exports = TimerEvent;
  }, function (module, exports, __webpack_require__) {
    var RESERVED = __webpack_require__(1465);

    module.exports = function (config) {
      var key,
          keys = [];
      if (config.hasOwnProperty("props")) for (key in config.props) {
        "_" !== key.substr(0, 1) && keys.push({
          key: key,
          value: config.props[key]
        });
      } else for (key in config) {
        -1 === RESERVED.indexOf(key) && "_" !== key.substr(0, 1) && keys.push({
          key: key,
          value: config[key]
        });
      }
      return keys;
    };
  }, function (module, exports, __webpack_require__) {
    var GetValue = __webpack_require__(6);

    module.exports = function (tweens) {
      tweens = GetValue(tweens, "tweens", null);
      return null === tweens ? [] : ("function" == typeof tweens && (tweens = tweens.call()), Array.isArray(tweens) ? tweens : [tweens]);
    };
  }, function (module, exports, __webpack_require__) {
    var Defaults = __webpack_require__(265),
        GetAdvancedValue = __webpack_require__(13),
        GetBoolean = __webpack_require__(99),
        GetEaseFunction = __webpack_require__(80),
        GetNewValue = __webpack_require__(162),
        GetValue = __webpack_require__(6),
        GetValueOp = __webpack_require__(264),
        Tween = __webpack_require__(266),
        TweenData = __webpack_require__(268);

    module.exports = function (parent, config, ops) {
      void 0 === ops && (ops = Defaults);
      var from = GetValue(config, "from", 0),
          to = GetValue(config, "to", 1),
          targets = [{
        value: from
      }],
          delay = GetNewValue(config, "delay", ops.delay),
          duration = GetNewValue(config, "duration", ops.duration),
          data = GetValue(config, "easeParams", ops.easeParams),
          ease = GetEaseFunction(GetValue(config, "ease", ops.ease), data),
          hold = GetNewValue(config, "hold", ops.hold),
          repeat = GetNewValue(config, "repeat", ops.repeat),
          tweenData = GetNewValue(config, "repeatDelay", ops.repeatDelay),
          yoyo = GetBoolean(config, "yoyo", ops.yoyo),
          data = [],
          ops = GetValueOp("value", to),
          tweenData = TweenData(targets[0], 0, "value", ops.getEnd, ops.getStart, ops.getActive, ease, delay, duration, yoyo, hold, repeat, tweenData, !1, !1);
      tweenData.start = from, tweenData.current = from, tweenData.to = to, data.push(tweenData);
      var tween = new Tween(parent, data, targets);
      tween.offset = GetAdvancedValue(config, "offset", null), tween.completeDelay = GetAdvancedValue(config, "completeDelay", 0), tween.loop = Math.round(GetAdvancedValue(config, "loop", 0)), tween.loopDelay = Math.round(GetAdvancedValue(config, "loopDelay", 0)), tween.paused = GetBoolean(config, "paused", !1), tween.useFrames = GetBoolean(config, "useFrames", !1);

      for (var scope = GetValue(config, "callbackScope", tween), tweenArray = [tween, null], callbacks = Tween.TYPES, i = 0; i < callbacks.length; i++) {
        var callbackScope,
            callbackParams,
            type = callbacks[i],
            callback = GetValue(config, type, !1);
        callback && (callbackScope = GetValue(config, type + "Scope", scope), callbackParams = GetValue(config, type + "Params", []), tween.setCallback(type, callback, tweenArray.concat(callbackParams), callbackScope));
      }

      return tween;
    };
  }, function (module, exports, __webpack_require__) {
    var GetEaseFunction = __webpack_require__(80),
        GetValue = __webpack_require__(6),
        MATH_CONST = __webpack_require__(14);

    module.exports = function (value, options) {
      var start = GetValue(options = void 0 === options ? {} : options, "start", 0),
          ease = GetValue(options, "ease", null),
          grid = GetValue(options, "grid", null),
          from = GetValue(options, "from", 0),
          fromFirst = "first" === from,
          fromCenter = "center" === from,
          fromLast = "last" === from,
          fromValue = "number" == typeof from,
          isRange = Array.isArray(value),
          value1 = isRange ? parseFloat(value[0]) : parseFloat(value),
          value2 = isRange ? parseFloat(value[1]) : 0,
          maxValue = Math.max(value1, value2);

      if (isRange && (start += value1), grid) {
        var gridWidth = grid[0],
            gridHeight = grid[1],
            fromX = 0,
            fromY = 0,
            gridValues = [];
        fromLast ? (fromX = gridWidth - 1, fromY = gridHeight - 1) : fromValue ? (fromX = from % gridWidth, fromY = Math.floor(from / gridWidth)) : fromCenter && (fromX = (gridWidth - 1) / 2, fromY = (gridHeight - 1) / 2);

        for (var gridMax = MATH_CONST.MIN_SAFE_INTEGER, toY = 0; toY < gridHeight; toY++) {
          gridValues[toY] = [];

          for (var toX = 0; toX < gridWidth; toX++) {
            var distanceX = fromX - toX,
                dist = fromY - toY,
                dist = Math.sqrt(distanceX * distanceX + dist * dist);
            gridMax < dist && (gridMax = dist), gridValues[toY][toX] = dist;
          }
        }
      }

      var easeFunction = ease ? GetEaseFunction(ease) : null;
      return grid ? function (target, key, value, toY) {
        var gridSpace = 0,
            diff = toY % gridWidth,
            toY = Math.floor(toY / gridWidth);
        return 0 <= diff && diff < gridWidth && 0 <= toY && toY < gridHeight && (gridSpace = gridValues[toY][diff]), (isRange ? (diff = value2 - value1, easeFunction ? gridSpace / gridMax * diff * easeFunction(gridSpace / gridMax) : gridSpace / gridMax * diff) : easeFunction ? gridSpace * value1 * easeFunction(gridSpace / gridMax) : gridSpace * value1) + start;
      } : function (target, key, value, spacing, total) {
        var fromIndex;
        return total--, fromFirst ? fromIndex = spacing : fromCenter ? fromIndex = Math.abs(total / 2 - spacing) : fromLast ? fromIndex = total - spacing : fromValue && (fromIndex = Math.abs(from - spacing)), (isRange ? (spacing = fromCenter ? (value2 - value1) / total * (2 * fromIndex) : (value2 - value1) / total * fromIndex, easeFunction ? spacing * easeFunction(fromIndex / total) : spacing) : easeFunction ? total * maxValue * easeFunction(fromIndex / total) : fromIndex * value1) + start;
      };
    };
  }, function (module, exports, __webpack_require__) {
    var Clone = __webpack_require__(77),
        Defaults = __webpack_require__(265),
        GetAdvancedValue = __webpack_require__(13),
        GetBoolean = __webpack_require__(99),
        GetEaseFunction = __webpack_require__(80),
        GetNewValue = __webpack_require__(162),
        GetTargets = __webpack_require__(263),
        GetTweens = __webpack_require__(584),
        GetValue = __webpack_require__(6),
        Timeline = __webpack_require__(588),
        TweenBuilder = __webpack_require__(163);

    module.exports = function (onStart, config) {
      var timeline = new Timeline(onStart);
      timeline.completeDelay = GetAdvancedValue(config, "completeDelay", 0), timeline.loop = Math.round(GetAdvancedValue(config, "loop", 0)), timeline.loopDelay = Math.round(GetAdvancedValue(config, "loopDelay", 0)), timeline.paused = GetBoolean(config, "paused", !1), timeline.useFrames = GetBoolean(config, "useFrames", !1);
      var onCompleteParams = GetValue(config, "callbackScope", timeline),
          timelineArray = [timeline],
          onStart = GetValue(config, "onStart", !1);
      onStart && (onUpdateParams = GetValue(config, "onStartScope", onCompleteParams), onUpdate = GetValue(config, "onStartParams", []), timeline.setCallback("onStart", onStart, timelineArray.concat(onUpdate), onUpdateParams));
      var onUpdateParams,
          onUpdate = GetValue(config, "onUpdate", !1);
      onUpdate && (onLoop = GetValue(config, "onUpdateScope", onCompleteParams), onUpdateParams = GetValue(config, "onUpdateParams", []), timeline.setCallback("onUpdate", onUpdate, timelineArray.concat(onUpdateParams), onLoop));
      var onLoop = GetValue(config, "onLoop", !1);
      onLoop && (onYoyoParams = GetValue(config, "onLoopScope", onCompleteParams), onYoyo = GetValue(config, "onLoopParams", []), timeline.setCallback("onLoop", onLoop, timelineArray.concat(onYoyo), onYoyoParams));
      var onYoyoParams,
          onYoyo = GetValue(config, "onYoyo", !1);
      onYoyo && (onComplete = GetValue(config, "onYoyoScope", onCompleteParams), onYoyoParams = GetValue(config, "onYoyoParams", []), timeline.setCallback("onYoyo", onYoyo, timelineArray.concat(null, onYoyoParams), onComplete));
      var onComplete = GetValue(config, "onComplete", !1);
      onComplete && (totalDuration = GetValue(config, "onCompleteScope", onCompleteParams), onCompleteParams = GetValue(config, "onCompleteParams", []), timeline.setCallback("onComplete", onComplete, timelineArray.concat(onCompleteParams), totalDuration));
      var tweens = GetTweens(config);
      if (0 === tweens.length) return timeline.paused = !0, timeline;
      var defaults = Clone(Defaults);
      defaults.targets = GetTargets(config);
      var totalDuration = GetAdvancedValue(config, "totalDuration", 0);
      defaults.duration = 0 < totalDuration ? Math.floor(totalDuration / tweens.length) : GetNewValue(config, "duration", defaults.duration), defaults.delay = GetNewValue(config, "delay", defaults.delay), defaults.easeParams = GetValue(config, "easeParams", defaults.easeParams), defaults.ease = GetEaseFunction(GetValue(config, "ease", defaults.ease), defaults.easeParams), defaults.hold = GetNewValue(config, "hold", defaults.hold), defaults.repeat = GetNewValue(config, "repeat", defaults.repeat), defaults.repeatDelay = GetNewValue(config, "repeatDelay", defaults.repeatDelay), defaults.yoyo = GetBoolean(config, "yoyo", defaults.yoyo), defaults.flipX = GetBoolean(config, "flipX", defaults.flipX), defaults.flipY = GetBoolean(config, "flipY", defaults.flipY);

      for (var i = 0; i < tweens.length; i++) {
        timeline.queue(TweenBuilder(timeline, tweens[i], defaults));
      }

      return timeline;
    };
  }, function (module, exports, __webpack_require__) {
    var Class = __webpack_require__(0),
        EventEmitter = __webpack_require__(9),
        Events = __webpack_require__(267),
        TweenBuilder = __webpack_require__(163),
        TWEEN_CONST = __webpack_require__(100),
        Timeline = new Class({
      Extends: EventEmitter,
      initialize: function initialize(manager) {
        EventEmitter.call(this), this.manager = manager, this.isTimeline = !0, this.data = [], this.totalData = 0, this.useFrames = !1, this.timeScale = 1, this.loop = 0, this.loopDelay = 0, this.loopCounter = 0, this.completeDelay = 0, this.countdown = 0, this.state = TWEEN_CONST.PENDING_ADD, this._pausedState = TWEEN_CONST.PENDING_ADD, this.paused = !1, this.elapsed = 0, this.totalElapsed = 0, this.duration = 0, this.progress = 0, this.totalDuration = 0, this.totalProgress = 0, this.callbacks = {
          onComplete: null,
          onLoop: null,
          onStart: null,
          onUpdate: null,
          onYoyo: null
        }, this.callbackScope;
      },
      dispatchTimelineEvent: function dispatchTimelineEvent(event, callback) {
        this.emit(event, this), callback && callback.func.apply(callback.scope, callback.params);
      },
      setTimeScale: function setTimeScale(value) {
        return this.timeScale = value, this;
      },
      getTimeScale: function getTimeScale() {
        return this.timeScale;
      },
      isPlaying: function isPlaying() {
        return this.state === TWEEN_CONST.ACTIVE;
      },
      add: function add(config) {
        return this.queue(TweenBuilder(this, config));
      },
      queue: function queue(tween) {
        return this.isPlaying() || (tween.parent = this, tween.parentIsTimeline = !0, this.data.push(tween), this.totalData = this.data.length), this;
      },
      hasOffset: function hasOffset(tween) {
        return null !== tween.offset;
      },
      isOffsetAbsolute: function isOffsetAbsolute(value) {
        return "number" == typeof value;
      },
      isOffsetRelative: function isOffsetRelative(op) {
        if ("string" == typeof op) {
          op = op[0];
          if ("-" === op || "+" === op) return !0;
        }

        return !1;
      },
      getRelativeOffset: function getRelativeOffset(value, base) {
        var op = value[0],
            num = parseFloat(value.substr(2)),
            result = base;

        switch (op) {
          case "+":
            result += num;
            break;

          case "-":
            result -= num;
        }

        return Math.max(0, result);
      },
      calcDuration: function calcDuration() {
        for (var prevEnd = 0, totalDuration = 0, offsetDuration = 0, i = 0; i < this.totalData; i++) {
          var tween = this.data[i];
          tween.init(), this.hasOffset(tween) ? this.isOffsetAbsolute(tween.offset) ? (tween.calculatedOffset = tween.offset, 0 === tween.offset && (offsetDuration = 0)) : this.isOffsetRelative(tween.offset) && (tween.calculatedOffset = this.getRelativeOffset(tween.offset, prevEnd)) : tween.calculatedOffset = offsetDuration, prevEnd = tween.totalDuration + tween.calculatedOffset, totalDuration += tween.totalDuration, offsetDuration += tween.totalDuration;
        }

        this.duration = totalDuration, this.loopCounter = -1 === this.loop ? 999999999999 : this.loop, 0 < this.loopCounter ? this.totalDuration = this.duration + this.completeDelay + (this.duration + this.loopDelay) * this.loopCounter : this.totalDuration = this.duration + this.completeDelay;
      },
      init: function init() {
        return this.calcDuration(), this.progress = 0, this.totalProgress = 0, !this.paused || (this.state = TWEEN_CONST.PAUSED, !1);
      },
      resetTweens: function resetTweens(resetFromLoop) {
        for (var i = 0; i < this.totalData; i++) {
          this.data[i].play(resetFromLoop);
        }
      },
      setCallback: function setCallback(type, callback, params, scope) {
        return -1 !== Timeline.TYPES.indexOf(type) && (this.callbacks[type] = {
          func: callback,
          scope: scope,
          params: params
        }), this;
      },
      makeActive: function makeActive(tween) {
        return this.manager.makeActive(tween);
      },
      play: function play() {
        if (this.state !== TWEEN_CONST.ACTIVE) {
          if (this.paused) return this.paused = !1, void this.manager.makeActive(this);
          this.resetTweens(!1), this.state = TWEEN_CONST.ACTIVE, this.dispatchTimelineEvent(Events.TIMELINE_START, this.callbacks.onStart);
        }
      },
      nextState: function nextState() {
        0 < this.loopCounter ? (this.elapsed = 0, this.progress = 0, this.loopCounter--, this.resetTweens(!0), 0 < this.loopDelay ? (this.countdown = this.loopDelay, this.state = TWEEN_CONST.LOOP_DELAY) : (this.state = TWEEN_CONST.ACTIVE, this.dispatchTimelineEvent(Events.TIMELINE_LOOP, this.callbacks.onLoop))) : 0 < this.completeDelay ? (this.state = TWEEN_CONST.COMPLETE_DELAY, this.countdown = this.completeDelay) : (this.state = TWEEN_CONST.PENDING_REMOVE, this.dispatchTimelineEvent(Events.TIMELINE_COMPLETE, this.callbacks.onComplete));
      },
      update: function update(timestamp, delta) {
        if (this.state !== TWEEN_CONST.PAUSED) {
          switch (this.useFrames && (delta = +this.manager.timeScale), delta *= this.timeScale, this.elapsed += delta, this.progress = Math.min(this.elapsed / this.duration, 1), this.totalElapsed += delta, this.totalProgress = Math.min(this.totalElapsed / this.totalDuration, 1), this.state) {
            case TWEEN_CONST.ACTIVE:
              for (var stillRunning = this.totalData, i = 0; i < this.totalData; i++) {
                this.data[i].update(timestamp, delta) && stillRunning--;
              }

              this.dispatchTimelineEvent(Events.TIMELINE_UPDATE, this.callbacks.onUpdate), 0 === stillRunning && this.nextState();
              break;

            case TWEEN_CONST.LOOP_DELAY:
              this.countdown -= delta, this.countdown <= 0 && (this.state = TWEEN_CONST.ACTIVE, this.dispatchTimelineEvent(Events.TIMELINE_LOOP, this.callbacks.onLoop));
              break;

            case TWEEN_CONST.COMPLETE_DELAY:
              this.countdown -= delta, this.countdown <= 0 && (this.state = TWEEN_CONST.PENDING_REMOVE, this.dispatchTimelineEvent(Events.TIMELINE_COMPLETE, this.callbacks.onComplete));
          }

          return this.state === TWEEN_CONST.PENDING_REMOVE;
        }
      },
      stop: function stop() {
        this.state = TWEEN_CONST.PENDING_REMOVE;
      },
      pause: function pause() {
        if (this.state !== TWEEN_CONST.PAUSED) return this.paused = !0, this._pausedState = this.state, this.state = TWEEN_CONST.PAUSED, this.emit(Events.TIMELINE_PAUSE, this), this;
      },
      resume: function resume() {
        return this.state === TWEEN_CONST.PAUSED && (this.paused = !1, this.state = this._pausedState, this.emit(Events.TIMELINE_RESUME, this)), this;
      },
      hasTarget: function hasTarget(target) {
        for (var i = 0; i < this.data.length; i++) {
          if (this.data[i].hasTarget(target)) return !0;
        }

        return !1;
      },
      destroy: function destroy() {
        for (var i = 0; i < this.data.length; i++) {
          this.data[i].stop();
        }
      }
    });

    Timeline.TYPES = ["onStart", "onUpdate", "onLoop", "onComplete", "onYoyo"], module.exports = Timeline;
  }, function (module, exports, __webpack_require__) {
    var Bodies = __webpack_require__(86),
        Body = __webpack_require__(41),
        Common = __webpack_require__(32),
        GetFastValue = __webpack_require__(2),
        Vertices = __webpack_require__(64);

    module.exports = {
      parseBody: function parseBody(x, y, body, options) {
        void 0 === options && (options = {});

        for (var fixtureConfigs = GetFastValue(body, "fixtures", []), fixtures = [], fc = 0; fc < fixtureConfigs.length; fc++) {
          for (var fixtureParts = this.parseFixture(fixtureConfigs[fc]), i = 0; i < fixtureParts.length; i++) {
            fixtures.push(fixtureParts[i]);
          }
        }

        body = Common.clone(body, !0);
        Common.extend(body, options, !0), delete body.fixtures, delete body.type;
        body = Body.create(body);
        return Body.setParts(body, fixtures), Body.setPosition(body, {
          x: x,
          y: y
        }), body;
      },
      parseFixture: function parseFixture(fixtureConfig) {
        var x,
            y,
            fixtures,
            matterConfig = Common.extend({}, !1, fixtureConfig);
        return delete matterConfig.circle, delete matterConfig.vertices, fixtureConfig.circle ? (x = GetFastValue(fixtureConfig.circle, "x"), y = GetFastValue(fixtureConfig.circle, "y"), fixtures = GetFastValue(fixtureConfig.circle, "radius"), fixtures = [Bodies.circle(x, y, fixtures, matterConfig)]) : fixtureConfig.vertices && (fixtures = this.parseVertices(fixtureConfig.vertices, matterConfig)), fixtures;
      },
      parseVertices: function parseVertices(vertexSets, options) {
        void 0 === options && (options = {});

        for (var parts = [], v = 0; v < vertexSets.length; v++) {
          Vertices.clockwiseSort(vertexSets[v]), parts.push(Body.create(Common.extend({
            position: Vertices.centre(vertexSets[v]),
            vertices: vertexSets[v]
          }, options)));
        }

        return Bodies.flagCoincidentParts(parts);
      }
    };
  }, function (module, exports, __webpack_require__) {
    var Bodies = __webpack_require__(86),
        Body = __webpack_require__(41);

    module.exports = {
      parseBody: function parseBody(x, y, config, options) {
        var body;
        void 0 === options && (options = {});
        var vertexSets = config.vertices;
        if (1 === vertexSets.length) options.vertices = vertexSets[0], body = Body.create(options), Bodies.flagCoincidentParts(body.parts);else {
          for (var parts = [], i = 0; i < vertexSets.length; i++) {
            var part = Body.create({
              vertices: vertexSets[i]
            });
            parts.push(part);
          }

          Bodies.flagCoincidentParts(parts), options.parts = parts, body = Body.create(options);
        }
        return body.label = config.label, Body.setPosition(body, {
          x: x,
          y: y
        }), body;
      }
    };
  }, function (module, exports, __webpack_require__) {
    var Composites = {};
    module.exports = Composites;

    var Composite = __webpack_require__(118),
        Constraint = __webpack_require__(128),
        Common = __webpack_require__(32),
        Body = __webpack_require__(41),
        Bodies = __webpack_require__(86);

    Composites.stack = function (xx, yy, columns, rows, columnGap, rowGap, callback) {
      for (var lastBody, stack = Composite.create({
        label: "Stack"
      }), x = xx, y = yy, i = 0, row = 0; row < rows; row++) {
        for (var maxHeight = 0, column = 0; column < columns; column++) {
          var bodyHeight,
              bodyWidth,
              body = callback(x, y, column, row, lastBody, i);
          body ? (bodyHeight = body.bounds.max.y - body.bounds.min.y, bodyWidth = body.bounds.max.x - body.bounds.min.x, maxHeight < bodyHeight && (maxHeight = bodyHeight), Body.translate(body, {
            x: .5 * bodyWidth,
            y: .5 * bodyHeight
          }), x = body.bounds.max.x + columnGap, Composite.addBody(stack, body), lastBody = body, i += 1) : x += columnGap;
        }

        y += maxHeight + rowGap, x = xx;
      }

      return stack;
    }, Composites.chain = function (composite, xOffsetA, yOffsetA, xOffsetB, yOffsetB, options) {
      for (var bodies = composite.bodies, i = 1; i < bodies.length; i++) {
        var bodyA = bodies[i - 1],
            bodyB = bodies[i],
            bodyAHeight = bodyA.bounds.max.y - bodyA.bounds.min.y,
            bodyAWidth = bodyA.bounds.max.x - bodyA.bounds.min.x,
            constraint = bodyB.bounds.max.y - bodyB.bounds.min.y,
            bodyBWidth = bodyB.bounds.max.x - bodyB.bounds.min.x,
            constraint = Common.extend({
          bodyA: bodyA,
          pointA: {
            x: bodyAWidth * xOffsetA,
            y: bodyAHeight * yOffsetA
          },
          bodyB: bodyB,
          pointB: {
            x: bodyBWidth * xOffsetB,
            y: constraint * yOffsetB
          }
        }, options);
        Composite.addConstraint(composite, Constraint.create(constraint));
      }

      return composite.label += " Chain", composite;
    }, Composites.mesh = function (composite, columns, rows, crossBrace, options) {
      for (var col, bodyA, bodyB, bodyC, bodies = composite.bodies, row = 0; row < rows; row++) {
        for (col = 1; col < columns; col++) {
          bodyA = bodies[col - 1 + row * columns], bodyB = bodies[col + row * columns], Composite.addConstraint(composite, Constraint.create(Common.extend({
            bodyA: bodyA,
            bodyB: bodyB
          }, options)));
        }

        if (0 < row) for (col = 0; col < columns; col++) {
          bodyA = bodies[col + (row - 1) * columns], bodyB = bodies[col + row * columns], Composite.addConstraint(composite, Constraint.create(Common.extend({
            bodyA: bodyA,
            bodyB: bodyB
          }, options))), crossBrace && 0 < col && (bodyC = bodies[col - 1 + (row - 1) * columns], Composite.addConstraint(composite, Constraint.create(Common.extend({
            bodyA: bodyC,
            bodyB: bodyB
          }, options)))), crossBrace && col < columns - 1 && (bodyC = bodies[col + 1 + (row - 1) * columns], Composite.addConstraint(composite, Constraint.create(Common.extend({
            bodyA: bodyC,
            bodyB: bodyB
          }, options))));
        }
      }

      return composite.label += " Mesh", composite;
    }, Composites.pyramid = function (xx, yy, columns, rows, columnGap, rowGap, callback) {
      return Composites.stack(xx, yy, columns, rows, columnGap, rowGap, function (x, y, column, row, lastBody, i) {
        var end = Math.min(rows, Math.ceil(columns / 2)),
            lastBodyWidth = lastBody ? lastBody.bounds.max.x - lastBody.bounds.min.x : 0;

        if (!(end < row)) {
          var start = row = end - row,
              end = columns - 1 - row;
          if (!(column < start || end < column)) return 1 === i && Body.translate(lastBody, {
            x: (column + (columns % 2 == 1 ? 1 : -1)) * lastBodyWidth,
            y: 0
          }), callback(xx + (lastBody ? column * lastBodyWidth : 0) + column * columnGap, y, column, row, lastBody, i);
        }
      });
    }, Composites.newtonsCradle = function (xx, yy, number, size, length) {
      for (var newtonsCradle = Composite.create({
        label: "Newtons Cradle"
      }), i = 0; i < number; i++) {
        var circle = Bodies.circle(xx + i * (1.9 * size), yy + length, size, {
          inertia: 1 / 0,
          restitution: 1,
          friction: 0,
          frictionAir: 1e-4,
          slop: 1
        }),
            constraint = Constraint.create({
          pointA: {
            x: xx + i * (1.9 * size),
            y: yy
          },
          bodyB: circle
        });
        Composite.addBody(newtonsCradle, circle), Composite.addConstraint(newtonsCradle, constraint);
      }

      return newtonsCradle;
    }, Composites.car = function (xx, yy, body, wheelA, wheelSize) {
      var wheelB = Body.nextGroup(!0),
          axelA = .5 * -body + 20,
          axelB = .5 * body - 20,
          car = Composite.create({
        label: "Car"
      }),
          body = Bodies.rectangle(xx, yy, body, wheelA, {
        collisionFilter: {
          group: wheelB
        },
        chamfer: {
          radius: .5 * wheelA
        },
        density: 2e-4
      }),
          wheelA = Bodies.circle(xx + axelA, yy + 0, wheelSize, {
        collisionFilter: {
          group: wheelB
        },
        friction: .8
      }),
          wheelB = Bodies.circle(xx + axelB, yy + 0, wheelSize, {
        collisionFilter: {
          group: wheelB
        },
        friction: .8
      }),
          axelA = Constraint.create({
        bodyB: body,
        pointB: {
          x: axelA,
          y: 0
        },
        bodyA: wheelA,
        stiffness: 1,
        length: 0
      }),
          axelB = Constraint.create({
        bodyB: body,
        pointB: {
          x: axelB,
          y: 0
        },
        bodyA: wheelB,
        stiffness: 1,
        length: 0
      });
      return Composite.addBody(car, body), Composite.addBody(car, wheelA), Composite.addBody(car, wheelB), Composite.addConstraint(car, axelA), Composite.addConstraint(car, axelB), car;
    }, Composites.softBody = function (xx, yy, columns, rows, columnGap, softBody, crossBrace, particleRadius, particleOptions, constraintOptions) {
      particleOptions = Common.extend({
        inertia: 1 / 0
      }, particleOptions), constraintOptions = Common.extend({
        stiffness: .2,
        render: {
          type: "line",
          anchors: !1
        }
      }, constraintOptions);
      softBody = Composites.stack(xx, yy, columns, rows, columnGap, softBody, function (x, y) {
        return Bodies.circle(x, y, particleRadius, particleOptions);
      });
      return Composites.mesh(softBody, columns, rows, crossBrace, constraintOptions), softBody.label = "Soft Body", softBody;
    };
  }, function (module, exports, __webpack_require__) {
    var Svg = {};
    module.exports = Svg;

    __webpack_require__(84);

    var Common = __webpack_require__(32);

    Svg.pathToVertices = function (path, sampleLength) {
      "undefined" == typeof window || "SVGPathSeg" in window || Common.warn("Svg.pathToVertices: SVGPathSeg not defined, a polyfill is required.");
      var i,
          il,
          total,
          point,
          segment,
          segments,
          segmentsQueue,
          lastSegment,
          lastPoint,
          lx,
          ly,
          points = [],
          length = 0,
          x = 0,
          y = 0;
      sampleLength = sampleLength || 15;

      function addPoint(px, py, point) {
        var isRelative = point % 2 == 1 && 1 < point;
        lastPoint && px == lastPoint.x && py == lastPoint.y || (ly = lastPoint && isRelative ? (lx = lastPoint.x, lastPoint.y) : lx = 0, point = {
          x: lx + px,
          y: ly + py
        }, !isRelative && lastPoint || (lastPoint = point), points.push(point), x = lx + px, y = ly + py);
      }

      function addSegmentPoint(segment) {
        var segType = segment.pathSegTypeAsLetter.toUpperCase();

        if ("Z" !== segType) {
          switch (segType) {
            case "M":
            case "L":
            case "T":
            case "C":
            case "S":
            case "Q":
              x = segment.x, y = segment.y;
              break;

            case "H":
              x = segment.x;
              break;

            case "V":
              y = segment.y;
          }

          addPoint(x, y, segment.pathSegType);
        }
      }

      for (Svg._svgPathToAbsolute(path), total = path.getTotalLength(), segments = [], i = 0; i < path.pathSegList.numberOfItems; i += 1) {
        segments.push(path.pathSegList.getItem(i));
      }

      for (segmentsQueue = segments.concat(); length < total;) {
        if ((segment = segments[path.getPathSegAtLength(length)]) != lastSegment) {
          for (; segmentsQueue.length && segmentsQueue[0] != segment;) {
            addSegmentPoint(segmentsQueue.shift());
          }

          lastSegment = segment;
        }

        switch (segment.pathSegTypeAsLetter.toUpperCase()) {
          case "C":
          case "T":
          case "S":
          case "Q":
          case "A":
            point = path.getPointAtLength(length), addPoint(point.x, point.y, 0);
        }

        length += sampleLength;
      }

      for (i = 0, il = segmentsQueue.length; i < il; ++i) {
        addSegmentPoint(segmentsQueue[i]);
      }

      return points;
    }, Svg._svgPathToAbsolute = function (path) {
      for (var x0, y0, x1, y1, x2, y2, segs = path.pathSegList, x = 0, y = 0, len = segs.numberOfItems, i = 0; i < len; ++i) {
        var seg = segs.getItem(i),
            segType = seg.pathSegTypeAsLetter;
        if (/[MLHVCSQTA]/.test(segType)) "x" in seg && (x = seg.x), "y" in seg && (y = seg.y);else switch ("x1" in seg && (x1 = x + seg.x1), "x2" in seg && (x2 = x + seg.x2), "y1" in seg && (y1 = y + seg.y1), "y2" in seg && (y2 = y + seg.y2), "x" in seg && (x += seg.x), "y" in seg && (y += seg.y), segType) {
          case "m":
            segs.replaceItem(path.createSVGPathSegMovetoAbs(x, y), i);
            break;

          case "l":
            segs.replaceItem(path.createSVGPathSegLinetoAbs(x, y), i);
            break;

          case "h":
            segs.replaceItem(path.createSVGPathSegLinetoHorizontalAbs(x), i);
            break;

          case "v":
            segs.replaceItem(path.createSVGPathSegLinetoVerticalAbs(y), i);
            break;

          case "c":
            segs.replaceItem(path.createSVGPathSegCurvetoCubicAbs(x, y, x1, y1, x2, y2), i);
            break;

          case "s":
            segs.replaceItem(path.createSVGPathSegCurvetoCubicSmoothAbs(x, y, x2, y2), i);
            break;

          case "q":
            segs.replaceItem(path.createSVGPathSegCurvetoQuadraticAbs(x, y, x1, y1), i);
            break;

          case "t":
            segs.replaceItem(path.createSVGPathSegCurvetoQuadraticSmoothAbs(x, y), i);
            break;

          case "a":
            segs.replaceItem(path.createSVGPathSegArcAbs(x, y, seg.r1, seg.r2, seg.angle, seg.largeArcFlag, seg.sweepFlag), i);
            break;

          case "z":
          case "Z":
            x = x0, y = y0;
        }
        "M" != segType && "m" != segType || (x0 = x, y0 = y);
      }
    };
  }, function (module, exports, __webpack_require__) {
    var Bodies = __webpack_require__(86),
        Body = __webpack_require__(41),
        Class = __webpack_require__(0),
        MatterTileBody = __webpack_require__(249),
        EventEmitter = __webpack_require__(9),
        GetFastValue = __webpack_require__(2),
        HasValue = __webpack_require__(126),
        Vertices = __webpack_require__(64),
        MatterTileBody = new Class({
      Extends: EventEmitter,
      Mixins: [MatterTileBody.Bounce, MatterTileBody.Collision, MatterTileBody.Friction, MatterTileBody.Gravity, MatterTileBody.Mass, MatterTileBody.Sensor, MatterTileBody.Sleep, MatterTileBody.Static],
      initialize: function initialize(addToWorld, collisionGroup, options) {
        EventEmitter.call(this), this.tile = collisionGroup, this.world = addToWorld, collisionGroup.physics.matterBody && collisionGroup.physics.matterBody.destroy(), collisionGroup.physics.matterBody = this;
        var body = GetFastValue(options, "body", null),
            addToWorld = GetFastValue(options, "addToWorld", !0);
        body ? this.setBody(body, addToWorld) : (collisionGroup = collisionGroup.getCollisionGroup(), 0 < GetFastValue(collisionGroup, "objects", []).length ? this.setFromTileCollision(options) : this.setFromTileRectangle(options));
      },
      setFromTileRectangle: function setFromTileRectangle(options) {
        HasValue(options = void 0 === options ? {} : options, "isStatic") || (options.isStatic = !0), HasValue(options, "addToWorld") || (options.addToWorld = !0);
        var body = this.tile.getBounds(),
            cx = body.x + body.width / 2,
            cy = body.y + body.height / 2,
            body = Bodies.rectangle(cx, cy, body.width, body.height, options);
        return this.setBody(body, options.addToWorld), this;
      },
      setFromTileCollision: function setFromTileCollision(options) {
        HasValue(options = void 0 === options ? {} : options, "isStatic") || (options.isStatic = !0), HasValue(options, "addToWorld") || (options.addToWorld = !0);

        for (var sx = this.tile.tilemapLayer.scaleX, sy = this.tile.tilemapLayer.scaleY, tileX = this.tile.getLeft(), tileY = this.tile.getTop(), collisionGroup = this.tile.getCollisionGroup(), collisionObjects = GetFastValue(collisionGroup, "objects", []), parts = [], i = 0; i < collisionObjects.length; i++) {
          var vertices = collisionObjects[i],
              ox = tileX + vertices.x * sx,
              oy = tileY + vertices.y * sy,
              center = vertices.width * sx,
              oh = vertices.height * sy,
              body = null;
          vertices.rectangle ? body = Bodies.rectangle(ox + center / 2, oy + oh / 2, center, oh, options) : vertices.ellipse ? body = Bodies.circle(ox + center / 2, oy + oh / 2, center / 2, options) : (vertices.polygon || vertices.polyline) && (center = (vertices.polygon || vertices.polyline).map(function (p) {
            return {
              x: p.x * sx,
              y: p.y * sy
            };
          }), vertices = Vertices.create(center), ox += (center = Vertices.centre(vertices)).x, oy += center.y, body = Bodies.fromVertices(ox, oy, vertices, options)), body && parts.push(body);
        }

        return 1 === parts.length ? this.setBody(parts[0], options.addToWorld) : 1 < parts.length && (options.parts = parts, this.setBody(Body.create(options), options.addToWorld)), this;
      },
      setBody: function setBody(body, addToWorld) {
        return void 0 === addToWorld && (addToWorld = !0), this.body && this.removeBody(), this.body = body, this.body.gameObject = this, addToWorld && this.world.add(this.body), this;
      },
      removeBody: function removeBody() {
        return this.body && (this.world.remove(this.body), this.body.gameObject = void 0, this.body = void 0), this;
      },
      destroy: function destroy() {
        this.removeBody(), this.tile.physics.matterBody = void 0, this.removeAllListeners();
      }
    });

    module.exports = MatterTileBody;
  }, function (module, exports, __webpack_require__) {
    var Matter = __webpack_require__(1399);

    Matter.Body = __webpack_require__(41), Matter.Composite = __webpack_require__(118), Matter.World = __webpack_require__(596), Matter.Detector = __webpack_require__(273), Matter.Grid = __webpack_require__(597), Matter.Pairs = __webpack_require__(598), Matter.Pair = __webpack_require__(250), Matter.Query = __webpack_require__(1400), Matter.Resolver = __webpack_require__(599), Matter.SAT = __webpack_require__(274), Matter.Constraint = __webpack_require__(128), Matter.Common = __webpack_require__(32), Matter.Engine = __webpack_require__(1401), Matter.Events = __webpack_require__(166), Matter.Sleeping = __webpack_require__(165), Matter.Plugin = __webpack_require__(595), Matter.Bodies = __webpack_require__(86), Matter.Composites = __webpack_require__(591), Matter.Axes = __webpack_require__(271), Matter.Bounds = __webpack_require__(84), Matter.Svg = __webpack_require__(592), Matter.Vector = __webpack_require__(83), Matter.Vertices = __webpack_require__(64), Matter.World.add = Matter.Composite.add, Matter.World.remove = Matter.Composite.remove, Matter.World.addComposite = Matter.Composite.addComposite, Matter.World.addBody = Matter.Composite.addBody, Matter.World.addConstraint = Matter.Composite.addConstraint, Matter.World.clear = Matter.Composite.clear, module.exports = Matter;
  }, function (module, exports, __webpack_require__) {
    var Plugin = {};
    module.exports = Plugin;

    var Common = __webpack_require__(32);

    Plugin._registry = {}, Plugin.register = function (plugin) {
      var registered, pluginVersion, registeredVersion;
      return Plugin.isPlugin(plugin) || Common.warn("Plugin.register:", Plugin.toString(plugin), "does not implement all required fields."), plugin.name in Plugin._registry ? (registered = Plugin._registry[plugin.name], pluginVersion = Plugin.versionParse(plugin.version).number, (registeredVersion = Plugin.versionParse(registered.version).number) < pluginVersion ? (Common.warn("Plugin.register:", Plugin.toString(registered), "was upgraded to", Plugin.toString(plugin)), Plugin._registry[plugin.name] = plugin) : pluginVersion < registeredVersion ? Common.warn("Plugin.register:", Plugin.toString(registered), "can not be downgraded to", Plugin.toString(plugin)) : plugin !== registered && Common.warn("Plugin.register:", Plugin.toString(plugin), "is already registered to different plugin object")) : Plugin._registry[plugin.name] = plugin, plugin;
    }, Plugin.resolve = function (dependency) {
      return Plugin._registry[Plugin.dependencyParse(dependency).name];
    }, Plugin.toString = function (plugin) {
      return "string" == typeof plugin ? plugin : (plugin.name || "anonymous") + "@" + (plugin.version || plugin.range || "0.0.0");
    }, Plugin.isPlugin = function (obj) {
      return obj && obj.name && obj.version && obj.install;
    }, Plugin.isUsed = function (module, name) {
      return -1 < module.used.indexOf(name);
    }, Plugin.isFor = function (plugin, module) {
      var parsed = plugin.for && Plugin.dependencyParse(plugin.for);
      return !plugin.for || module.name === parsed.name && Plugin.versionSatisfies(module.version, parsed.range);
    }, Plugin.use = function (module, dependencies) {
      if (module.uses = (module.uses || []).concat(dependencies || []), 0 !== module.uses.length) {
        for (var plugin, dependencies = Plugin.dependencies(module), sortedDependencies = Common.topologicalSort(dependencies), status = [], i = 0; i < sortedDependencies.length; i += 1) {
          sortedDependencies[i] !== module.name && ((plugin = Plugin.resolve(sortedDependencies[i])) ? Plugin.isUsed(module, plugin.name) || (Plugin.isFor(plugin, module) || (Common.warn("Plugin.use:", Plugin.toString(plugin), "is for", plugin.for, "but installed on", Plugin.toString(module) + "."), plugin._warned = !0), plugin.install ? plugin.install(module) : (Common.warn("Plugin.use:", Plugin.toString(plugin), "does not specify an install function."), plugin._warned = !0), plugin._warned ? (status.push("🔶 " + Plugin.toString(plugin)), delete plugin._warned) : status.push("✅ " + Plugin.toString(plugin)), module.used.push(plugin.name)) : status.push("❌ " + sortedDependencies[i]));
        }

        0 < status.length && !plugin.silent && Common.info(status.join("  "));
      } else Common.warn("Plugin.use:", Plugin.toString(module), "does not specify any dependencies to install.");
    }, Plugin.dependencies = function (module, tracked) {
      var parsedBase = Plugin.dependencyParse(module),
          name = parsedBase.name;

      if (!(name in (tracked = tracked || {}))) {
        module = Plugin.resolve(module) || module, tracked[name] = Common.map(module.uses || [], function (dependency) {
          Plugin.isPlugin(dependency) && Plugin.register(dependency);
          var parsed = Plugin.dependencyParse(dependency),
              resolved = Plugin.resolve(dependency);
          return resolved && !Plugin.versionSatisfies(resolved.version, parsed.range) ? (Common.warn("Plugin.dependencies:", Plugin.toString(resolved), "does not satisfy", Plugin.toString(parsed), "used by", Plugin.toString(parsedBase) + "."), resolved._warned = !0, module._warned = !0) : resolved || (Common.warn("Plugin.dependencies:", Plugin.toString(dependency), "used by", Plugin.toString(parsedBase), "could not be resolved."), module._warned = !0), parsed.name;
        });

        for (var i = 0; i < tracked[name].length; i += 1) {
          Plugin.dependencies(tracked[name][i], tracked);
        }

        return tracked;
      }
    }, Plugin.dependencyParse = function (dependency) {
      if (Common.isString(dependency)) return /^[\w-]+(@(\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-]+)?))?$/.test(dependency) || Common.warn("Plugin.dependencyParse:", dependency, "is not a valid dependency string."), {
        name: dependency.split("@")[0],
        range: dependency.split("@")[1] || "*"
      };
      return {
        name: dependency.name,
        range: dependency.range || dependency.version
      };
    }, Plugin.versionParse = function (range) {
      /^\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-]+)?$/.test(range) || Common.warn("Plugin.versionParse:", range, "is not a valid version or range.");
      var identifiers = range.split("-");
      range = identifiers[0];
      var isRange = isNaN(Number(range[0])),
          version = isRange ? range.substr(1) : range,
          parts = Common.map(version.split("."), function (part) {
        return Number(part);
      });
      return {
        isRange: isRange,
        version: version,
        range: range,
        operator: isRange ? range[0] : "",
        parts: parts,
        prerelease: identifiers[1],
        number: 1e8 * parts[0] + 1e4 * parts[1] + parts[2]
      };
    }, Plugin.versionSatisfies = function (version, range) {
      var rangeParsed = Plugin.versionParse(range = range || "*"),
          rangeParts = rangeParsed.parts,
          versionParsed = Plugin.versionParse(version),
          versionParts = versionParsed.parts;

      if (rangeParsed.isRange) {
        if ("*" === rangeParsed.operator || "*" === version) return !0;
        if ("~" === rangeParsed.operator) return versionParts[0] === rangeParts[0] && versionParts[1] === rangeParts[1] && versionParts[2] >= rangeParts[2];
        if ("^" === rangeParsed.operator) return 0 < rangeParts[0] ? versionParts[0] === rangeParts[0] && versionParsed.number >= rangeParsed.number : 0 < rangeParts[1] ? versionParts[1] === rangeParts[1] && versionParts[2] >= rangeParts[2] : versionParts[2] === rangeParts[2];
      }

      return version === range || "*" === version;
    };
  }, function (module, exports, __webpack_require__) {
    var World = {};
    module.exports = World;

    var Composite = __webpack_require__(118),
        Common = (__webpack_require__(128), __webpack_require__(32));

    World.create = function (options) {
      var composite = Composite.create();
      return Common.extend(composite, {
        label: "World",
        gravity: {
          x: 0,
          y: 1,
          scale: .001
        },
        bounds: {
          min: {
            x: -1 / 0,
            y: -1 / 0
          },
          max: {
            x: 1 / 0,
            y: 1 / 0
          }
        }
      }, options);
    };
  }, function (module, exports, __webpack_require__) {
    var Grid = {};
    module.exports = Grid;

    var Pair = __webpack_require__(250),
        Detector = __webpack_require__(273),
        Common = __webpack_require__(32);

    Grid.create = function (options) {
      var defaults = {
        controller: Grid,
        detector: Detector.collisions,
        buckets: {},
        pairs: {},
        pairsList: [],
        bucketWidth: 48,
        bucketHeight: 48
      };
      return Common.extend(defaults, options);
    }, Grid.update = function (grid, bodies, engine, forceUpdate) {
      for (var row, world = engine.world, buckets = grid.buckets, gridChanged = !1, metrics = engine.metrics, i = metrics.broadphaseTests = 0; i < bodies.length; i++) {
        var body = bodies[i];

        if ((!body.isSleeping || forceUpdate) && !(body.bounds.max.x < world.bounds.min.x || body.bounds.min.x > world.bounds.max.x || body.bounds.max.y < world.bounds.min.y || body.bounds.min.y > world.bounds.max.y)) {
          var newRegion = Grid._getRegion(grid, body);

          if (!body.region || newRegion.id !== body.region.id || forceUpdate) {
            metrics.broadphaseTests += 1, body.region && !forceUpdate || (body.region = newRegion);

            for (var union = Grid._regionUnion(newRegion, body.region), col = union.startCol; col <= union.endCol; col++) {
              for (row = union.startRow; row <= union.endRow; row++) {
                var bucketId,
                    bucket = buckets[bucketId = Grid._getBucketId(col, row)],
                    isInsideNewRegion = col >= newRegion.startCol && col <= newRegion.endCol && row >= newRegion.startRow && row <= newRegion.endRow,
                    isInsideOldRegion = col >= body.region.startCol && col <= body.region.endCol && row >= body.region.startRow && row <= body.region.endRow;

                !isInsideNewRegion && isInsideOldRegion && isInsideOldRegion && bucket && Grid._bucketRemoveBody(grid, bucket, body), (body.region === newRegion || isInsideNewRegion && !isInsideOldRegion || forceUpdate) && (bucket = bucket || Grid._createBucket(buckets, bucketId), Grid._bucketAddBody(grid, bucket, body));
              }
            }

            body.region = newRegion, gridChanged = !0;
          }
        }
      }

      gridChanged && (grid.pairsList = Grid._createActivePairsList(grid));
    }, Grid.clear = function (grid) {
      grid.buckets = {}, grid.pairs = {}, grid.pairsList = [];
    }, Grid._regionUnion = function (regionA, endRow) {
      var startCol = Math.min(regionA.startCol, endRow.startCol),
          endCol = Math.max(regionA.endCol, endRow.endCol),
          startRow = Math.min(regionA.startRow, endRow.startRow),
          endRow = Math.max(regionA.endRow, endRow.endRow);
      return Grid._createRegion(startCol, endCol, startRow, endRow);
    }, Grid._getRegion = function (endRow, startRow) {
      var bounds = startRow.bounds,
          startCol = Math.floor(bounds.min.x / endRow.bucketWidth),
          endCol = Math.floor(bounds.max.x / endRow.bucketWidth),
          startRow = Math.floor(bounds.min.y / endRow.bucketHeight),
          endRow = Math.floor(bounds.max.y / endRow.bucketHeight);
      return Grid._createRegion(startCol, endCol, startRow, endRow);
    }, Grid._createRegion = function (startCol, endCol, startRow, endRow) {
      return {
        id: startCol + "," + endCol + "," + startRow + "," + endRow,
        startCol: startCol,
        endCol: endCol,
        startRow: startRow,
        endRow: endRow
      };
    }, Grid._getBucketId = function (column, row) {
      return "C" + column + "R" + row;
    }, Grid._createBucket = function (buckets, bucketId) {
      return buckets[bucketId] = [];
    }, Grid._bucketAddBody = function (grid, bucket, body) {
      for (var i = 0; i < bucket.length; i++) {
        var pairId,
            pair,
            bodyB = bucket[i];
        body.id === bodyB.id || body.isStatic && bodyB.isStatic || (pairId = Pair.id(body, bodyB), (pair = grid.pairs[pairId]) ? pair[2] += 1 : grid.pairs[pairId] = [body, bodyB, 1]);
      }

      bucket.push(body);
    }, Grid._bucketRemoveBody = function (grid, bucket, body) {
      bucket.splice(bucket.indexOf(body), 1);

      for (var i = 0; i < bucket.length; i++) {
        var pair = bucket[i],
            pair = Pair.id(body, pair),
            pair = grid.pairs[pair];
        pair && --pair[2];
      }
    }, Grid._createActivePairsList = function (grid) {
      for (var pair, pairs = [], pairKeys = Common.keys(grid.pairs), k = 0; k < pairKeys.length; k++) {
        0 < (pair = grid.pairs[pairKeys[k]])[2] ? pairs.push(pair) : delete grid.pairs[pairKeys[k]];
      }

      return pairs;
    };
  }, function (module, exports, __webpack_require__) {
    var Pairs = {};
    module.exports = Pairs;

    var Pair = __webpack_require__(250),
        Common = __webpack_require__(32);

    Pairs._pairMaxIdleLife = 1e3, Pairs.create = function (options) {
      return Common.extend({
        table: {},
        list: [],
        collisionStart: [],
        collisionActive: [],
        collisionEnd: []
      }, options);
    }, Pairs.update = function (pairs, collisions, timestamp) {
      var collision,
          pairId,
          pair,
          i,
          pairsList = pairs.list,
          pairsTable = pairs.table,
          collisionStart = pairs.collisionStart,
          collisionEnd = pairs.collisionEnd,
          collisionActive = pairs.collisionActive;

      for (collisionStart.length = 0, collisionEnd.length = 0, i = collisionActive.length = 0; i < pairsList.length; i++) {
        pairsList[i].confirmedActive = !1;
      }

      for (i = 0; i < collisions.length; i++) {
        (collision = collisions[i]).collided && ((pair = pairsTable[pairId = Pair.id(collision.bodyA, collision.bodyB)]) ? ((pair.isActive ? collisionActive : collisionStart).push(pair), Pair.update(pair, collision, timestamp), pair.confirmedActive = !0) : (pair = Pair.create(collision, timestamp), pairsTable[pairId] = pair, collisionStart.push(pair), pairsList.push(pair)));
      }

      for (i = 0; i < pairsList.length; i++) {
        (pair = pairsList[i]).isActive && !pair.confirmedActive && (Pair.setActive(pair, !1, timestamp), collisionEnd.push(pair));
      }
    }, Pairs.removeOld = function (pairs, timestamp) {
      for (var pair, collision, pairIndex, pairsList = pairs.list, pairsTable = pairs.table, indexesToRemove = [], i = 0; i < pairsList.length; i++) {
        (collision = (pair = pairsList[i]).collision).bodyA.isSleeping || collision.bodyB.isSleeping ? pair.timeUpdated = timestamp : timestamp - pair.timeUpdated > Pairs._pairMaxIdleLife && indexesToRemove.push(i);
      }

      for (i = 0; i < indexesToRemove.length; i++) {
        delete pairsTable[(pair = pairsList[pairIndex = indexesToRemove[i] - i]).id], pairsList.splice(pairIndex, 1);
      }
    }, Pairs.clear = function (pairs) {
      return pairs.table = {}, pairs.list.length = 0, pairs.collisionStart.length = 0, pairs.collisionActive.length = 0, pairs.collisionEnd.length = 0, pairs;
    };
  }, function (module, exports, __webpack_require__) {
    var Resolver = {};
    module.exports = Resolver;

    var Vertices = __webpack_require__(64),
        Vector = __webpack_require__(83),
        Common = __webpack_require__(32),
        Bounds = __webpack_require__(84);

    Resolver._restingThresh = 4, Resolver._restingThreshTangent = 6, Resolver._positionDampen = .9, Resolver._positionWarming = .8, Resolver._frictionNormalMultiplier = 5, Resolver.preSolvePosition = function (pairs) {
      for (var pair, activeCount, i = 0; i < pairs.length; i++) {
        (pair = pairs[i]).isActive && (activeCount = pair.activeContacts.length, pair.collision.parentA.totalContacts += activeCount, pair.collision.parentB.totalContacts += activeCount);
      }
    }, Resolver.solvePosition = function (pairs, bodies, timeScale) {
      for (var bodyA, bodyB, normalY, normalX, positionImpulseB, contactShare, bodyBtoAX, bodyBtoAY, positionImpulse, impulseCoefficient = timeScale * Resolver._positionDampen, i = 0; i < bodies.length; i++) {
        var body = bodies[i];
        body.previousPositionImpulse.x = body.positionImpulse.x, body.previousPositionImpulse.y = body.positionImpulse.y;
      }

      for (i = 0; i < pairs.length; i++) {
        (positionImpulse = pairs[i]).isActive && !positionImpulse.isSensor && (bodyA = (bodyBtoAX = positionImpulse.collision).parentA, bodyB = bodyBtoAX.parentB, normalY = bodyBtoAX.normal, bodyBtoAY = bodyA.previousPositionImpulse, positionImpulseB = bodyB.previousPositionImpulse, normalX = bodyBtoAX.penetration, bodyBtoAX = positionImpulseB.x - bodyBtoAY.x + normalX.x, bodyBtoAY = positionImpulseB.y - bodyBtoAY.y + normalX.y, normalX = normalY.x, normalY = normalY.y, positionImpulse = ((positionImpulse.separation = normalX * bodyBtoAX + normalY * bodyBtoAY) - positionImpulse.slop) * impulseCoefficient, (bodyA.isStatic || bodyB.isStatic) && (positionImpulse *= 2), bodyA.isStatic || bodyA.isSleeping || (contactShare = positionImpulse / bodyA.totalContacts, bodyA.positionImpulse.x += normalX * contactShare, bodyA.positionImpulse.y += normalY * contactShare), bodyB.isStatic || bodyB.isSleeping || (contactShare = positionImpulse / bodyB.totalContacts, bodyB.positionImpulse.x -= normalX * contactShare, bodyB.positionImpulse.y -= normalY * contactShare));
      }
    }, Resolver.postSolvePosition = function (bodies) {
      for (var i = 0; i < bodies.length; i++) {
        var body = bodies[i];

        if ((body.totalContacts = 0) !== body.positionImpulse.x || 0 !== body.positionImpulse.y) {
          for (var j = 0; j < body.parts.length; j++) {
            var part = body.parts[j];
            Vertices.translate(part.vertices, body.positionImpulse), Bounds.update(part.bounds, part.vertices, body.velocity), part.position.x += body.positionImpulse.x, part.position.y += body.positionImpulse.y;
          }

          body.positionPrev.x += body.positionImpulse.x, body.positionPrev.y += body.positionImpulse.y, Vector.dot(body.positionImpulse, body.velocity) < 0 ? (body.positionImpulse.x = 0, body.positionImpulse.y = 0) : (body.positionImpulse.x *= Resolver._positionWarming, body.positionImpulse.y *= Resolver._positionWarming);
        }
      }
    }, Resolver.preSolveVelocity = function (pairs) {
      for (var j, contacts, collision, bodyA, bodyB, normal, tangent, contactVertex, normalImpulse, tangentImpulse, offset, impulse = Vector._temp[0], tempA = Vector._temp[1], i = 0; i < pairs.length; i++) {
        if ((collision = pairs[i]).isActive && !collision.isSensor) for (contacts = collision.activeContacts, bodyA = (collision = collision.collision).parentA, bodyB = collision.parentB, normal = collision.normal, tangent = collision.tangent, j = 0; j < contacts.length; j++) {
          contactVertex = (tangentImpulse = contacts[j]).vertex, normalImpulse = tangentImpulse.normalImpulse, tangentImpulse = tangentImpulse.tangentImpulse, 0 === normalImpulse && 0 === tangentImpulse || (impulse.x = normal.x * normalImpulse + tangent.x * tangentImpulse, impulse.y = normal.y * normalImpulse + tangent.y * tangentImpulse, bodyA.isStatic || bodyA.isSleeping || (offset = Vector.sub(contactVertex, bodyA.position, tempA), bodyA.positionPrev.x += impulse.x * bodyA.inverseMass, bodyA.positionPrev.y += impulse.y * bodyA.inverseMass, bodyA.anglePrev += Vector.cross(offset, impulse) * bodyA.inverseInertia), bodyB.isStatic || bodyB.isSleeping || (offset = Vector.sub(contactVertex, bodyB.position, tempA), bodyB.positionPrev.x -= impulse.x * bodyB.inverseMass, bodyB.positionPrev.y -= impulse.y * bodyB.inverseMass, bodyB.anglePrev -= Vector.cross(offset, impulse) * bodyB.inverseInertia));
        }
      }
    }, Resolver.solveVelocity = function (pairs, timeScale) {
      for (var timeScaleSquared = timeScale * timeScale, impulse = Vector._temp[0], tempA = Vector._temp[1], tempB = Vector._temp[2], tempC = Vector._temp[3], tempD = Vector._temp[4], tempE = Vector._temp[5], i = 0; i < pairs.length; i++) {
        var pair = pairs[i];

        if (pair.isActive && !pair.isSensor) {
          var collision = pair.collision,
              bodyA = collision.parentA,
              bodyB = collision.parentB,
              normal = collision.normal,
              tangent = collision.tangent,
              contacts = pair.activeContacts,
              contactShare = 1 / contacts.length;
          bodyA.velocity.x = bodyA.position.x - bodyA.positionPrev.x, bodyA.velocity.y = bodyA.position.y - bodyA.positionPrev.y, bodyB.velocity.x = bodyB.position.x - bodyB.positionPrev.x, bodyB.velocity.y = bodyB.position.y - bodyB.positionPrev.y, bodyA.angularVelocity = bodyA.angle - bodyA.anglePrev, bodyB.angularVelocity = bodyB.angle - bodyB.anglePrev;

          for (var j = 0; j < contacts.length; j++) {
            var contact = contacts[j],
                normalImpulse = contact.vertex,
                offsetA = Vector.sub(normalImpulse, bodyA.position, tempA),
                offsetB = Vector.sub(normalImpulse, bodyB.position, tempB),
                normalForce = Vector.add(bodyA.velocity, Vector.mult(Vector.perp(offsetA), bodyA.angularVelocity), tempC),
                tangentImpulse = Vector.add(bodyB.velocity, Vector.mult(Vector.perp(offsetB), bodyB.angularVelocity), tempD),
                maxFriction = Vector.sub(normalForce, tangentImpulse, tempE),
                contactNormalImpulse = Vector.dot(normal, maxFriction),
                contactTangentImpulse = Vector.dot(tangent, maxFriction),
                share = Math.abs(contactTangentImpulse),
                oAcN = Common.sign(contactTangentImpulse),
                normalImpulse = (1 + pair.restitution) * contactNormalImpulse,
                normalForce = Common.clamp(pair.separation + contactNormalImpulse, 0, 1) * Resolver._frictionNormalMultiplier,
                tangentImpulse = contactTangentImpulse,
                maxFriction = 1 / 0;

            share > pair.friction * pair.frictionStatic * normalForce * timeScaleSquared && (tangentImpulse = Common.clamp(pair.friction * oAcN * timeScaleSquared, -(maxFriction = share), maxFriction));
            oAcN = Vector.cross(offsetA, normal), share = Vector.cross(offsetB, normal), share = contactShare / (bodyA.inverseMass + bodyB.inverseMass + bodyA.inverseInertia * oAcN * oAcN + bodyB.inverseInertia * share * share);
            normalImpulse *= share, tangentImpulse *= share, contactNormalImpulse < 0 && contactNormalImpulse * contactNormalImpulse > Resolver._restingThresh * timeScaleSquared ? contact.normalImpulse = 0 : (contactNormalImpulse = contact.normalImpulse, contact.normalImpulse = Math.min(contact.normalImpulse + normalImpulse, 0), normalImpulse = contact.normalImpulse - contactNormalImpulse), contactTangentImpulse * contactTangentImpulse > Resolver._restingThreshTangent * timeScaleSquared ? contact.tangentImpulse = 0 : (contactTangentImpulse = contact.tangentImpulse, contact.tangentImpulse = Common.clamp(contact.tangentImpulse + tangentImpulse, -maxFriction, maxFriction), tangentImpulse = contact.tangentImpulse - contactTangentImpulse), impulse.x = normal.x * normalImpulse + tangent.x * tangentImpulse, impulse.y = normal.y * normalImpulse + tangent.y * tangentImpulse, bodyA.isStatic || bodyA.isSleeping || (bodyA.positionPrev.x += impulse.x * bodyA.inverseMass, bodyA.positionPrev.y += impulse.y * bodyA.inverseMass, bodyA.anglePrev += Vector.cross(offsetA, impulse) * bodyA.inverseInertia), bodyB.isStatic || bodyB.isSleeping || (bodyB.positionPrev.x -= impulse.x * bodyB.inverseMass, bodyB.positionPrev.y -= impulse.y * bodyB.inverseMass, bodyB.anglePrev -= Vector.cross(offsetB, impulse) * bodyB.inverseInertia);
          }
        }
      }
    };
  }, function (module, exports) {
    var g = function () {
      return this;
    }();

    try {
      g = g || new Function("return this")();
    } catch (e) {
      "object" == (typeof window === "undefined" ? "undefined" : _typeof(window)) && (g = window);
    }

    module.exports = g;
  }, function (module, exports, __webpack_require__) {
    var QuickSet = __webpack_require__(276);

    module.exports = function (items, position, offsetX, offsetY) {
      for (var target = items[0], i = 1; i < items.length; i++) {
        var item = items[i];
        QuickSet(item, target, position, offsetX, offsetY), target = item;
      }

      return items;
    };
  }, function (module, exports, __webpack_require__) {
    var PropertyValueInc = __webpack_require__(46);

    module.exports = function (items, value, step, index, direction) {
      return PropertyValueInc(items, "angle", value, step, index, direction);
    };
  }, function (module, exports) {
    module.exports = function (items, callback, context) {
      for (var i = 0; i < items.length; i++) {
        var item = items[i];
        callback.call(context, item);
      }

      return items;
    };
  }, function (module, exports) {
    module.exports = function (items, compare, index) {
      for (var i = index = void 0 === index ? 0 : index; i < items.length; i++) {
        var property,
            item = items[i],
            match = !0;

        for (property in compare) {
          item[property] !== compare[property] && (match = !1);
        }

        if (match) return item;
      }

      return null;
    };
  }, function (module, exports) {
    module.exports = function (items, compare, index) {
      for (var i = index = void 0 === index ? 0 : index; i < items.length; i++) {
        var property,
            item = items[i],
            match = !0;

        for (property in compare) {
          item[property] !== compare[property] && (match = !1);
        }

        if (match) return item;
      }

      return null;
    };
  }, function (module, exports, __webpack_require__) {
    var AlignIn = __webpack_require__(289),
        CONST = __webpack_require__(123),
        GetFastValue = __webpack_require__(2),
        NOOP = __webpack_require__(1),
        tempZone = new (__webpack_require__(129))({
      sys: {
        queueDepthSort: NOOP,
        events: {
          once: NOOP
        }
      }
    }, 0, 0, 1, 1);

    module.exports = function (items, options) {
      var widthSet = (options = void 0 === options ? {} : options).hasOwnProperty("width"),
          heightSet = options.hasOwnProperty("height"),
          width = GetFastValue(options, "width", -1),
          height = GetFastValue(options, "height", -1),
          cellWidth = GetFastValue(options, "cellWidth", 1),
          cellHeight = GetFastValue(options, "cellHeight", cellWidth),
          position = GetFastValue(options, "position", CONST.TOP_LEFT),
          x = GetFastValue(options, "x", 0),
          y = GetFastValue(options, "y", 0),
          cx = 0,
          cy = 0,
          w = width * cellWidth,
          h = height * cellHeight;
      tempZone.setPosition(x, y), tempZone.setSize(cellWidth, cellHeight);

      for (var i = 0; i < items.length; i++) {
        if (AlignIn(items[i], tempZone, position), widthSet && -1 === width) tempZone.x += cellWidth;else if (heightSet && -1 === height) tempZone.y += cellHeight;else if (heightSet && !widthSet) {
          if (cy += cellHeight, tempZone.y += cellHeight, cy === h && (cy = 0, cx += cellWidth, tempZone.y = y, tempZone.x += cellWidth, cx === w)) break;
        } else if (cx += cellWidth, tempZone.x += cellWidth, cx === w && (cx = 0, cy += cellHeight, tempZone.x = x, tempZone.y += cellHeight, cy === h)) break;
      }

      return items;
    };
  }, function (module, exports, __webpack_require__) {
    var Clamp = __webpack_require__(18);

    module.exports = {
      _alpha: 1,
      _alphaTL: 1,
      _alphaTR: 1,
      _alphaBL: 1,
      _alphaBR: 1,
      clearAlpha: function clearAlpha() {
        return this.setAlpha(1);
      },
      setAlpha: function setAlpha(topLeft, topRight, bottomLeft, bottomRight) {
        return void 0 === topLeft && (topLeft = 1), void 0 === topRight ? this.alpha = topLeft : (this._alphaTL = Clamp(topLeft, 0, 1), this._alphaTR = Clamp(topRight, 0, 1), this._alphaBL = Clamp(bottomLeft, 0, 1), this._alphaBR = Clamp(bottomRight, 0, 1)), this;
      },
      alpha: {
        get: function get() {
          return this._alpha;
        },
        set: function set(v) {
          v = Clamp(v, 0, 1);
          this._alpha = v, this._alphaTL = v, this._alphaTR = v, this._alphaBL = v, 0 === (this._alphaBR = v) ? this.renderFlags &= -3 : this.renderFlags |= 2;
        }
      },
      alphaTopLeft: {
        get: function get() {
          return this._alphaTL;
        },
        set: function set(v) {
          v = Clamp(v, 0, 1);
          0 !== (this._alphaTL = v) && (this.renderFlags |= 2);
        }
      },
      alphaTopRight: {
        get: function get() {
          return this._alphaTR;
        },
        set: function set(v) {
          v = Clamp(v, 0, 1);
          0 !== (this._alphaTR = v) && (this.renderFlags |= 2);
        }
      },
      alphaBottomLeft: {
        get: function get() {
          return this._alphaBL;
        },
        set: function set(v) {
          v = Clamp(v, 0, 1);
          0 !== (this._alphaBL = v) && (this.renderFlags |= 2);
        }
      },
      alphaBottomRight: {
        get: function get() {
          return this._alphaBR;
        },
        set: function set(v) {
          v = Clamp(v, 0, 1);
          0 !== (this._alphaBR = v) && (this.renderFlags |= 2);
        }
      }
    };
  }, function (module, exports) {
    module.exports = {
      width: 0,
      height: 0,
      displayWidth: {
        get: function get() {
          return this.scaleX * this.width;
        },
        set: function set(value) {
          this.scaleX = value / this.width;
        }
      },
      displayHeight: {
        get: function get() {
          return this.scaleY * this.height;
        },
        set: function set(value) {
          this.scaleY = value / this.height;
        }
      },
      setSize: function setSize(width, height) {
        return this.width = width, this.height = height, this;
      },
      setDisplaySize: function setDisplaySize(width, height) {
        return this.displayWidth = width, this.displayHeight = height, this;
      }
    };
  }, function (module, exports) {
    module.exports = {
      texture: null,
      frame: null,
      isCropped: !1,
      setCrop: function setCrop(x, y, width, height) {
        return void 0 === x ? this.isCropped = !1 : this.frame && ("number" == typeof x ? this.frame.setCropUVs(this._crop, x, y, width, height, this.flipX, this.flipY) : this.frame.setCropUVs(this._crop, x.x, x.y, x.width, x.height, this.flipX, this.flipY), this.isCropped = !0), this;
      },
      resetCropObject: function resetCropObject() {
        return {
          u0: 0,
          v0: 0,
          u1: 0,
          v1: 0,
          width: 0,
          height: 0,
          x: 0,
          y: 0,
          flipX: !1,
          flipY: !1,
          cx: 0,
          cy: 0,
          cw: 0,
          ch: 0
        };
      }
    };
  }, function (module, exports) {
    module.exports = {
      flipX: !1,
      flipY: !1,
      toggleFlipX: function toggleFlipX() {
        return this.flipX = !this.flipX, this;
      },
      toggleFlipY: function toggleFlipY() {
        return this.flipY = !this.flipY, this;
      },
      setFlipX: function setFlipX(value) {
        return this.flipX = value, this;
      },
      setFlipY: function setFlipY(value) {
        return this.flipY = value, this;
      },
      setFlip: function setFlip(x, y) {
        return this.flipX = x, this.flipY = y, this;
      },
      resetFlip: function resetFlip() {
        return this.flipX = !1, this.flipY = !1, this;
      }
    };
  }, function (module, exports, __webpack_require__) {
    var Rectangle = __webpack_require__(10),
        RotateAround = __webpack_require__(308),
        Vector2 = __webpack_require__(3);

    module.exports = {
      prepareBoundsOutput: function prepareBoundsOutput(output, includeParent) {
        return void 0 === includeParent && (includeParent = !1), 0 !== this.rotation && RotateAround(output, this.x, this.y, this.rotation), includeParent && this.parentContainer && this.parentContainer.getBoundsTransformMatrix().transformPoint(output.x, output.y, output), output;
      },
      getCenter: function getCenter(output) {
        return (output = void 0 === output ? new Vector2() : output).x = this.x - this.displayWidth * this.originX + this.displayWidth / 2, output.y = this.y - this.displayHeight * this.originY + this.displayHeight / 2, output;
      },
      getTopLeft: function getTopLeft(output, includeParent) {
        return (output = output || new Vector2()).x = this.x - this.displayWidth * this.originX, output.y = this.y - this.displayHeight * this.originY, this.prepareBoundsOutput(output, includeParent);
      },
      getTopCenter: function getTopCenter(output, includeParent) {
        return (output = output || new Vector2()).x = this.x - this.displayWidth * this.originX + this.displayWidth / 2, output.y = this.y - this.displayHeight * this.originY, this.prepareBoundsOutput(output, includeParent);
      },
      getTopRight: function getTopRight(output, includeParent) {
        return (output = output || new Vector2()).x = this.x - this.displayWidth * this.originX + this.displayWidth, output.y = this.y - this.displayHeight * this.originY, this.prepareBoundsOutput(output, includeParent);
      },
      getLeftCenter: function getLeftCenter(output, includeParent) {
        return (output = output || new Vector2()).x = this.x - this.displayWidth * this.originX, output.y = this.y - this.displayHeight * this.originY + this.displayHeight / 2, this.prepareBoundsOutput(output, includeParent);
      },
      getRightCenter: function getRightCenter(output, includeParent) {
        return (output = output || new Vector2()).x = this.x - this.displayWidth * this.originX + this.displayWidth, output.y = this.y - this.displayHeight * this.originY + this.displayHeight / 2, this.prepareBoundsOutput(output, includeParent);
      },
      getBottomLeft: function getBottomLeft(output, includeParent) {
        return (output = output || new Vector2()).x = this.x - this.displayWidth * this.originX, output.y = this.y - this.displayHeight * this.originY + this.displayHeight, this.prepareBoundsOutput(output, includeParent);
      },
      getBottomCenter: function getBottomCenter(output, includeParent) {
        return (output = output || new Vector2()).x = this.x - this.displayWidth * this.originX + this.displayWidth / 2, output.y = this.y - this.displayHeight * this.originY + this.displayHeight, this.prepareBoundsOutput(output, includeParent);
      },
      getBottomRight: function getBottomRight(output, includeParent) {
        return (output = output || new Vector2()).x = this.x - this.displayWidth * this.originX + this.displayWidth, output.y = this.y - this.displayHeight * this.originY + this.displayHeight, this.prepareBoundsOutput(output, includeParent);
      },
      getBounds: function getBounds(output) {
        var TLx, TLy, TRx, TRy, BLx, BLy, BRx, BRy;
        return void 0 === output && (output = new Rectangle()), BRy = (BRx = (this.parentContainer ? (BRy = this.parentContainer.getBoundsTransformMatrix(), this.getTopLeft(output), BRy.transformPoint(output.x, output.y, output), TLx = output.x, TLy = output.y, this.getTopRight(output), BRy.transformPoint(output.x, output.y, output), TRx = output.x, TRy = output.y, this.getBottomLeft(output), BRy.transformPoint(output.x, output.y, output), BLx = output.x, BLy = output.y, this.getBottomRight(output), BRy.transformPoint(output.x, output.y, output)) : (this.getTopLeft(output), TLx = output.x, TLy = output.y, this.getTopRight(output), TRx = output.x, TRy = output.y, this.getBottomLeft(output), BLx = output.x, BLy = output.y, this.getBottomRight(output)), output.x), output.y), output.x = Math.min(TLx, TRx, BLx, BRx), output.y = Math.min(TLy, TRy, BLy, BRy), output.width = Math.max(TLx, TRx, BLx, BRx) - output.x, output.height = Math.max(TLy, TRy, BLy, BRy) - output.y, output;
      }
    };
  }, function (module, exports) {
    module.exports = "blur";
  }, function (module, exports) {
    module.exports = "boot";
  }, function (module, exports) {
    module.exports = "contextlost";
  }, function (module, exports) {
    module.exports = "contextrestored";
  }, function (module, exports) {
    module.exports = "destroy";
  }, function (module, exports) {
    module.exports = "focus";
  }, function (module, exports) {
    module.exports = "hidden";
  }, function (module, exports) {
    module.exports = "pause";
  }, function (module, exports) {
    module.exports = "postrender";
  }, function (module, exports) {
    module.exports = "poststep";
  }, function (module, exports) {
    module.exports = "prerender";
  }, function (module, exports) {
    module.exports = "prestep";
  }, function (module, exports) {
    module.exports = "ready";
  }, function (module, exports) {
    module.exports = "resume";
  }, function (module, exports) {
    module.exports = "step";
  }, function (module, exports) {
    module.exports = "visible";
  }, function (module, exports) {
    module.exports = "postrender";
  }, function (module, exports) {
    module.exports = "prerender";
  }, function (module, exports) {
    module.exports = "render";
  }, function (module, exports) {
    module.exports = "resize";
  }, function (module, exports) {
    module.exports = {
      _originComponent: !0,
      originX: .5,
      originY: .5,
      _displayOriginX: 0,
      _displayOriginY: 0,
      displayOriginX: {
        get: function get() {
          return this._displayOriginX;
        },
        set: function set(value) {
          this._displayOriginX = value, this.originX = value / this.width;
        }
      },
      displayOriginY: {
        get: function get() {
          return this._displayOriginY;
        },
        set: function set(value) {
          this._displayOriginY = value, this.originY = value / this.height;
        }
      },
      setOrigin: function setOrigin(x, y) {
        return void 0 === x && (x = .5), void 0 === y && (y = x), this.originX = x, this.originY = y, this.updateDisplayOrigin();
      },
      setOriginFromFrame: function setOriginFromFrame() {
        return this.frame && this.frame.customPivot ? (this.originX = this.frame.pivotX, this.originY = this.frame.pivotY, this.updateDisplayOrigin()) : this.setOrigin();
      },
      setDisplayOrigin: function setDisplayOrigin(x, y) {
        return void 0 === x && (x = 0), void 0 === y && (y = x), this.displayOriginX = x, this.displayOriginY = y, this;
      },
      updateDisplayOrigin: function updateDisplayOrigin() {
        return this._displayOriginX = this.originX * this.width, this._displayOriginY = this.originY * this.height, this;
      }
    };
  }, function (module, exports, PathFollower) {
    var DegToRad = PathFollower(36),
        GetBoolean = PathFollower(99),
        GetValue = PathFollower(6),
        TWEEN_CONST = PathFollower(100),
        Vector2 = PathFollower(3),
        PathFollower = {
      path: null,
      rotateToPath: !1,
      pathRotationOffset: 0,
      pathOffset: null,
      pathVector: null,
      pathDelta: null,
      pathTween: null,
      pathConfig: null,
      _prevDirection: TWEEN_CONST.PLAYING_FORWARD,
      setPath: function setPath(path, config) {
        void 0 === config && (config = this.pathConfig);
        var tween = this.pathTween;
        return tween && tween.isPlaying() && tween.stop(), this.path = path, config && this.startFollow(config), this;
      },
      setRotateToPath: function setRotateToPath(value, offset) {
        return void 0 === offset && (offset = 0), this.rotateToPath = value, this.pathRotationOffset = offset, this;
      },
      isFollowing: function isFollowing() {
        var tween = this.pathTween;
        return tween && tween.isPlaying();
      },
      startFollow: function startFollow(config, startAt) {
        void 0 === config && (config = {}), void 0 === startAt && (startAt = 0);
        var nextPoint = this.pathTween;
        nextPoint && nextPoint.isPlaying() && nextPoint.stop(), (config = "number" == typeof config ? {
          duration: config
        } : config).from = GetValue(config, "from", 0), config.to = GetValue(config, "to", 1);
        nextPoint = GetBoolean(config, "positionOnPath", !1);
        this.rotateToPath = GetBoolean(config, "rotateToPath", !1), this.pathRotationOffset = GetValue(config, "rotationOffset", 0);
        var seek = GetValue(config, "startAt", startAt);
        return seek && (config.onStart = function (v) {
          var tweenData = v.data[0];
          tweenData.progress = seek, tweenData.elapsed = tweenData.duration * seek;
          v = tweenData.ease(tweenData.progress);
          tweenData.current = tweenData.start + (tweenData.end - tweenData.start) * v, tweenData.target[tweenData.key] = tweenData.current;
        }), this.pathOffset || (this.pathOffset = new Vector2(this.x, this.y)), this.pathVector || (this.pathVector = new Vector2()), this.pathDelta || (this.pathDelta = new Vector2()), this.pathDelta.reset(), this.pathTween = this.scene.sys.tweens.addCounter(config), this.path.getStartPoint(this.pathOffset), nextPoint && (this.x = this.pathOffset.x, this.y = this.pathOffset.y), this.pathOffset.x = this.x - this.pathOffset.x, this.pathOffset.y = this.y - this.pathOffset.y, this._prevDirection = TWEEN_CONST.PLAYING_FORWARD, this.rotateToPath && (nextPoint = this.path.getPoint(.1), this.rotation = Math.atan2(nextPoint.y - this.y, nextPoint.x - this.x) + DegToRad(this.pathRotationOffset)), this.pathConfig = config, this;
      },
      pauseFollow: function pauseFollow() {
        var tween = this.pathTween;
        return tween && tween.isPlaying() && tween.pause(), this;
      },
      resumeFollow: function resumeFollow() {
        var tween = this.pathTween;
        return tween && tween.isPaused() && tween.resume(), this;
      },
      stopFollow: function stopFollow() {
        var tween = this.pathTween;
        return tween && tween.isPlaying() && tween.stop(), this;
      },
      pathUpdate: function pathUpdate() {
        var speedX = this.pathTween;

        if (speedX) {
          var tweenData = speedX.data[0],
              speedY = this.pathDelta,
              pathVector = this.pathVector;
          if (speedY.copy(pathVector).negate(), tweenData.state === TWEEN_CONST.COMPLETE) return this.path.getPoint(1, pathVector), speedY.add(pathVector), pathVector.add(this.pathOffset), void this.setPosition(pathVector.x, pathVector.y);
          tweenData.state !== TWEEN_CONST.PLAYING_FORWARD && tweenData.state !== TWEEN_CONST.PLAYING_BACKWARD || (this.path.getPoint(speedX.getValue(), pathVector), speedY.add(pathVector), pathVector.add(this.pathOffset), speedX = this.x, speedY = this.y, this.setPosition(pathVector.x, pathVector.y), speedX = this.x - speedX, speedY = this.y - speedY, 0 == speedX && 0 == speedY || (tweenData.state === this._prevDirection ? this.rotateToPath && (this.rotation = Math.atan2(speedY, speedX) + DegToRad(this.pathRotationOffset)) : this._prevDirection = tweenData.state));
        }
      }
    };
    module.exports = PathFollower;
  }, function (module, exports) {
    module.exports = {
      _sizeComponent: !0,
      width: 0,
      height: 0,
      displayWidth: {
        get: function get() {
          return Math.abs(this.scaleX * this.frame.realWidth);
        },
        set: function set(value) {
          this.scaleX = value / this.frame.realWidth;
        }
      },
      displayHeight: {
        get: function get() {
          return Math.abs(this.scaleY * this.frame.realHeight);
        },
        set: function set(value) {
          this.scaleY = value / this.frame.realHeight;
        }
      },
      setSizeToFrame: function setSizeToFrame(frame) {
        return void 0 === frame && (frame = this.frame), this.width = frame.realWidth, this.height = frame.realHeight, this;
      },
      setSize: function setSize(width, height) {
        return this.width = width, this.height = height, this;
      },
      setDisplaySize: function setDisplaySize(width, height) {
        return this.displayWidth = width, this.displayHeight = height, this;
      }
    };
  }, function (module, exports) {
    module.exports = {
      texture: null,
      frame: null,
      isCropped: !1,
      setTexture: function setTexture(key, frame) {
        return this.texture = this.scene.sys.textures.get(key), this.setFrame(frame);
      },
      setFrame: function setFrame(frame, updateSize, updateOrigin) {
        return void 0 === updateSize && (updateSize = !0), void 0 === updateOrigin && (updateOrigin = !0), this.frame = this.texture.get(frame), this.frame.cutWidth && this.frame.cutHeight ? this.renderFlags |= 8 : this.renderFlags &= -9, this._sizeComponent && updateSize && this.setSizeToFrame(), this._originComponent && updateOrigin && (this.frame.customPivot ? this.setOrigin(this.frame.pivotX, this.frame.pivotY) : this.updateDisplayOrigin()), this;
      }
    };
  }, function (module, exports) {
    module.exports = {
      texture: null,
      frame: null,
      isCropped: !1,
      setCrop: function setCrop(x, y, width, height) {
        return void 0 === x ? this.isCropped = !1 : this.frame && ("number" == typeof x ? this.frame.setCropUVs(this._crop, x, y, width, height, this.flipX, this.flipY) : this.frame.setCropUVs(this._crop, x.x, x.y, x.width, x.height, this.flipX, this.flipY), this.isCropped = !0), this;
      },
      setTexture: function setTexture(key, frame) {
        return this.texture = this.scene.sys.textures.get(key), this.setFrame(frame);
      },
      setFrame: function setFrame(frame, updateSize, updateOrigin) {
        return void 0 === updateSize && (updateSize = !0), void 0 === updateOrigin && (updateOrigin = !0), this.frame = this.texture.get(frame), this.frame.cutWidth && this.frame.cutHeight ? this.renderFlags |= 8 : this.renderFlags &= -9, this._sizeComponent && updateSize && this.setSizeToFrame(), this._originComponent && updateOrigin && (this.frame.customPivot ? this.setOrigin(this.frame.pivotX, this.frame.pivotY) : this.updateDisplayOrigin()), this.isCropped && this.frame.updateCropUVs(this._crop, this.flipX, this.flipY), this;
      },
      resetCropObject: function resetCropObject() {
        return {
          u0: 0,
          v0: 0,
          u1: 0,
          v1: 0,
          width: 0,
          height: 0,
          x: 0,
          y: 0,
          flipX: !1,
          flipY: !1,
          cx: 0,
          cy: 0,
          cw: 0,
          ch: 0
        };
      }
    };
  }, function (module, exports) {
    module.exports = {
      tintTopLeft: 16777215,
      tintTopRight: 16777215,
      tintBottomLeft: 16777215,
      tintBottomRight: 16777215,
      tintFill: !1,
      clearTint: function clearTint() {
        return this.setTint(16777215), this;
      },
      setTint: function setTint(topLeft, topRight, bottomLeft, bottomRight) {
        return void 0 === topLeft && (topLeft = 16777215), void 0 === topRight && (bottomRight = bottomLeft = topRight = topLeft), this.tintTopLeft = topLeft, this.tintTopRight = topRight, this.tintBottomLeft = bottomLeft, this.tintBottomRight = bottomRight, this.tintFill = !1, this;
      },
      setTintFill: function setTintFill(topLeft, topRight, bottomLeft, bottomRight) {
        return this.setTint(topLeft, topRight, bottomLeft, bottomRight), this.tintFill = !0, this;
      },
      tint: {
        set: function set(value) {
          this.setTint(value, value, value, value);
        }
      },
      isTinted: {
        get: function get() {
          return this.tintFill || 16777215 !== this.tintTopLeft || 16777215 !== this.tintTopRight || 16777215 !== this.tintBottomLeft || 16777215 !== this.tintBottomRight;
        }
      }
    };
  }, function (module, exports) {
    module.exports = "changedata";
  }, function (module, exports) {
    module.exports = "changedata-";
  }, function (module, exports) {
    module.exports = "destroy";
  }, function (module, exports) {
    module.exports = "removedata";
  }, function (module, exports) {
    module.exports = "setdata";
  }, function (module, exports) {
    module.exports = "addedtoscene";
  }, function (module, exports) {
    module.exports = "destroy";
  }, function (module, exports) {
    module.exports = "removedfromscene";
  }, function (module, exports) {
    module.exports = "complete";
  }, function (module, exports) {
    module.exports = "created";
  }, function (module, exports) {
    module.exports = "error";
  }, function (module, exports) {
    module.exports = "loop";
  }, function (module, exports) {
    module.exports = "play";
  }, function (module, exports) {
    module.exports = "seeked";
  }, function (module, exports) {
    module.exports = "seeking";
  }, function (module, exports) {
    module.exports = "stop";
  }, function (module, exports) {
    module.exports = "timeout";
  }, function (module, exports) {
    module.exports = "unlocked";
  }, function (module, exports) {
    module.exports = "addedtoscene";
  }, function (module, exports) {
    module.exports = "boot";
  }, function (module, exports) {
    module.exports = "create";
  }, function (module, exports) {
    module.exports = "destroy";
  }, function (module, exports) {
    module.exports = "pause";
  }, function (module, exports) {
    module.exports = "postupdate";
  }, function (module, exports) {
    module.exports = "prerender";
  }, function (module, exports) {
    module.exports = "preupdate";
  }, function (module, exports) {
    module.exports = "ready";
  }, function (module, exports) {
    module.exports = "removedfromscene";
  }, function (module, exports) {
    module.exports = "render";
  }, function (module, exports) {
    module.exports = "resume";
  }, function (module, exports) {
    module.exports = "shutdown";
  }, function (module, exports) {
    module.exports = "sleep";
  }, function (module, exports) {
    module.exports = "start";
  }, function (module, exports) {
    module.exports = "transitioncomplete";
  }, function (module, exports) {
    module.exports = "transitioninit";
  }, function (module, exports) {
    module.exports = "transitionout";
  }, function (module, exports) {
    module.exports = "transitionstart";
  }, function (module, exports) {
    module.exports = "transitionwake";
  }, function (module, exports) {
    module.exports = "update";
  }, function (module, exports) {
    module.exports = "wake";
  }, function (module, exports, __webpack_require__) {
    var PropertyValueInc = __webpack_require__(46);

    module.exports = function (items, value, step, index, direction) {
      return PropertyValueInc(items, "alpha", value, step, index, direction);
    };
  }, function (module, exports, __webpack_require__) {
    var PropertyValueInc = __webpack_require__(46);

    module.exports = function (items, value, step, index, direction) {
      return PropertyValueInc(items, "x", value, step, index, direction);
    };
  }, function (module, exports, __webpack_require__) {
    var PropertyValueInc = __webpack_require__(46);

    module.exports = function (items, x, y, stepX, stepY, index, direction) {
      return null == y && (y = x), PropertyValueInc(items, "x", x, stepX, index, direction), PropertyValueInc(items, "y", y, stepY, index, direction);
    };
  }, function (module, exports, __webpack_require__) {
    var PropertyValueInc = __webpack_require__(46);

    module.exports = function (items, value, step, index, direction) {
      return PropertyValueInc(items, "y", value, step, index, direction);
    };
  }, function (module, exports) {
    module.exports = function (items, circle, startAngle, endAngle) {
      for (var angle = startAngle = void 0 === startAngle ? 0 : startAngle, angleStep = ((endAngle = void 0 === endAngle ? 6.28 : endAngle) - startAngle) / items.length, i = 0; i < items.length; i++) {
        items[i].x = circle.x + circle.radius * Math.cos(angle), items[i].y = circle.y + circle.radius * Math.sin(angle), angle += angleStep;
      }

      return items;
    };
  }, function (module, exports) {
    module.exports = function (items, ellipse, startAngle, endAngle) {
      for (var angle = startAngle = void 0 === startAngle ? 0 : startAngle, angleStep = ((endAngle = void 0 === endAngle ? 6.28 : endAngle) - startAngle) / items.length, a = ellipse.width / 2, b = ellipse.height / 2, i = 0; i < items.length; i++) {
        items[i].x = ellipse.x + a * Math.cos(angle), items[i].y = ellipse.y + b * Math.sin(angle), angle += angleStep;
      }

      return items;
    };
  }, function (module, exports, __webpack_require__) {
    var GetPoints = __webpack_require__(172);

    module.exports = function (items, line) {
      for (var points = GetPoints(line, items.length), i = 0; i < items.length; i++) {
        var item = items[i],
            point = points[i];
        item.x = point.x, item.y = point.y;
      }

      return items;
    };
  }, function (module, exports, __webpack_require__) {
    var MarchingAnts = __webpack_require__(316),
        RotateLeft = __webpack_require__(178),
        RotateRight = __webpack_require__(179);

    module.exports = function (items, rect, shift) {
      void 0 === shift && (shift = 0);
      var points = MarchingAnts(rect, !1, items.length);
      0 < shift ? RotateLeft(points, shift) : shift < 0 && RotateRight(points, Math.abs(shift));

      for (var i = 0; i < items.length; i++) {
        items[i].x = points[i].x, items[i].y = points[i].y;
      }

      return items;
    };
  }, function (module, exports, __webpack_require__) {
    var BresenhamPoints = __webpack_require__(317);

    module.exports = function (items, triangle, p3) {
      var p1 = BresenhamPoints({
        x1: triangle.x1,
        y1: triangle.y1,
        x2: triangle.x2,
        y2: triangle.y2
      }, p3),
          p2 = BresenhamPoints({
        x1: triangle.x2,
        y1: triangle.y2,
        x2: triangle.x3,
        y2: triangle.y3
      }, p3),
          p3 = BresenhamPoints({
        x1: triangle.x3,
        y1: triangle.y3,
        x2: triangle.x1,
        y2: triangle.y1
      }, p3);
      p1.pop(), p2.pop(), p3.pop();

      for (var step = (p1 = p1.concat(p2, p3)).length / items.length, p = 0, i = 0; i < items.length; i++) {
        var item = items[i],
            point = p1[Math.floor(p)];
        item.x = point.x, item.y = point.y, p += step;
      }

      return items;
    };
  }, function (module, exports) {
    module.exports = function (items, key, ignoreIfPlaying) {
      for (var i = 0; i < items.length; i++) {
        var gameObject = items[i];
        gameObject.anims && gameObject.anims.play(key, ignoreIfPlaying);
      }

      return items;
    };
  }, function (module, exports, __webpack_require__) {
    var Random = __webpack_require__(170);

    module.exports = function (items, circle) {
      for (var i = 0; i < items.length; i++) {
        Random(circle, items[i]);
      }

      return items;
    };
  }, function (module, exports, __webpack_require__) {
    var Random = __webpack_require__(180);

    module.exports = function (items, ellipse) {
      for (var i = 0; i < items.length; i++) {
        Random(ellipse, items[i]);
      }

      return items;
    };
  }, function (module, exports, __webpack_require__) {
    var Random = __webpack_require__(173);

    module.exports = function (items, line) {
      for (var i = 0; i < items.length; i++) {
        Random(line, items[i]);
      }

      return items;
    };
  }, function (module, exports, __webpack_require__) {
    var Random = __webpack_require__(174);

    module.exports = function (items, rect) {
      for (var i = 0; i < items.length; i++) {
        Random(rect, items[i]);
      }

      return items;
    };
  }, function (module, exports, __webpack_require__) {
    var Random = __webpack_require__(181);

    module.exports = function (items, triangle) {
      for (var i = 0; i < items.length; i++) {
        Random(triangle, items[i]);
      }

      return items;
    };
  }, function (module, exports, __webpack_require__) {
    var PropertyValueInc = __webpack_require__(46);

    module.exports = function (items, value, step, index, direction) {
      return PropertyValueInc(items, "rotation", value, step, index, direction);
    };
  }, function (module, exports, __webpack_require__) {
    var RotateAroundDistance = __webpack_require__(182),
        DistanceBetween = __webpack_require__(50);

    module.exports = function (items, point, angle) {
      for (var x = point.x, y = point.y, i = 0; i < items.length; i++) {
        var item = items[i];
        RotateAroundDistance(item, x, y, angle, Math.max(1, DistanceBetween(item.x, item.y, x, y)));
      }

      return items;
    };
  }, function (module, exports, __webpack_require__) {
    var MathRotateAroundDistance = __webpack_require__(182);

    module.exports = function (items, point, angle, distance) {
      var x = point.x,
          y = point.y;
      if (0 === distance) return items;

      for (var i = 0; i < items.length; i++) {
        MathRotateAroundDistance(items[i], x, y, angle, distance);
      }

      return items;
    };
  }, function (module, exports, __webpack_require__) {
    var PropertyValueInc = __webpack_require__(46);

    module.exports = function (items, value, step, index, direction) {
      return PropertyValueInc(items, "scaleX", value, step, index, direction);
    };
  }, function (module, exports, __webpack_require__) {
    var PropertyValueInc = __webpack_require__(46);

    module.exports = function (items, scaleX, scaleY, stepX, stepY, index, direction) {
      return null == scaleY && (scaleY = scaleX), PropertyValueInc(items, "scaleX", scaleX, stepX, index, direction), PropertyValueInc(items, "scaleY", scaleY, stepY, index, direction);
    };
  }, function (module, exports, __webpack_require__) {
    var PropertyValueInc = __webpack_require__(46);

    module.exports = function (items, value, step, index, direction) {
      return PropertyValueInc(items, "scaleY", value, step, index, direction);
    };
  }, function (module, exports, __webpack_require__) {
    var PropertyValueSet = __webpack_require__(27);

    module.exports = function (items, value, step, index, direction) {
      return PropertyValueSet(items, "alpha", value, step, index, direction);
    };
  }, function (module, exports, __webpack_require__) {
    var PropertyValueSet = __webpack_require__(27);

    module.exports = function (items, value, index, direction) {
      return PropertyValueSet(items, "blendMode", value, 0, index, direction);
    };
  }, function (module, exports, __webpack_require__) {
    var PropertyValueSet = __webpack_require__(27);

    module.exports = function (items, value, step, index, direction) {
      return PropertyValueSet(items, "depth", value, step, index, direction);
    };
  }, function (module, exports) {
    module.exports = function (items, hitArea, hitAreaCallback) {
      for (var i = 0; i < items.length; i++) {
        items[i].setInteractive(hitArea, hitAreaCallback);
      }

      return items;
    };
  }, function (module, exports, __webpack_require__) {
    var PropertyValueSet = __webpack_require__(27);

    module.exports = function (items, originX, originY, stepX, stepY, index, direction) {
      return null == originY && (originY = originX), PropertyValueSet(items, "originX", originX, stepX, index, direction), PropertyValueSet(items, "originY", originY, stepY, index, direction), items.forEach(function (item) {
        item.updateDisplayOrigin();
      }), items;
    };
  }, function (module, exports, __webpack_require__) {
    var PropertyValueSet = __webpack_require__(27);

    module.exports = function (items, value, step, index, direction) {
      return PropertyValueSet(items, "rotation", value, step, index, direction);
    };
  }, function (module, exports, __webpack_require__) {
    var PropertyValueSet = __webpack_require__(27);

    module.exports = function (items, scaleX, scaleY, stepX, stepY, index, direction) {
      return null == scaleY && (scaleY = scaleX), PropertyValueSet(items, "scaleX", scaleX, stepX, index, direction), PropertyValueSet(items, "scaleY", scaleY, stepY, index, direction);
    };
  }, function (module, exports, __webpack_require__) {
    var PropertyValueSet = __webpack_require__(27);

    module.exports = function (items, value, step, index, direction) {
      return PropertyValueSet(items, "scaleX", value, step, index, direction);
    };
  }, function (module, exports, __webpack_require__) {
    var PropertyValueSet = __webpack_require__(27);

    module.exports = function (items, value, step, index, direction) {
      return PropertyValueSet(items, "scaleY", value, step, index, direction);
    };
  }, function (module, exports, __webpack_require__) {
    var PropertyValueSet = __webpack_require__(27);

    module.exports = function (items, scrollFactorX, scrollFactorY, stepX, stepY, index, direction) {
      return null == scrollFactorY && (scrollFactorY = scrollFactorX), PropertyValueSet(items, "scrollFactorX", scrollFactorX, stepX, index, direction), PropertyValueSet(items, "scrollFactorY", scrollFactorY, stepY, index, direction);
    };
  }, function (module, exports, __webpack_require__) {
    var PropertyValueSet = __webpack_require__(27);

    module.exports = function (items, value, step, index, direction) {
      return PropertyValueSet(items, "scrollFactorX", value, step, index, direction);
    };
  }, function (module, exports, __webpack_require__) {
    var PropertyValueSet = __webpack_require__(27);

    module.exports = function (items, value, step, index, direction) {
      return PropertyValueSet(items, "scrollFactorY", value, step, index, direction);
    };
  }, function (module, exports) {
    module.exports = function (items, topLeft, topRight, bottomLeft, bottomRight) {
      for (var i = 0; i < items.length; i++) {
        items[i].setTint(topLeft, topRight, bottomLeft, bottomRight);
      }

      return items;
    };
  }, function (module, exports, __webpack_require__) {
    var PropertyValueSet = __webpack_require__(27);

    module.exports = function (items, value, index, direction) {
      return PropertyValueSet(items, "visible", value, 0, index, direction);
    };
  }, function (module, exports, __webpack_require__) {
    var PropertyValueSet = __webpack_require__(27);

    module.exports = function (items, value, step, index, direction) {
      return PropertyValueSet(items, "x", value, step, index, direction);
    };
  }, function (module, exports, __webpack_require__) {
    var PropertyValueSet = __webpack_require__(27);

    module.exports = function (items, x, y, stepX, stepY, index, direction) {
      return null == y && (y = x), PropertyValueSet(items, "x", x, stepX, index, direction), PropertyValueSet(items, "y", y, stepY, index, direction);
    };
  }, function (module, exports, __webpack_require__) {
    var PropertyValueSet = __webpack_require__(27);

    module.exports = function (items, value, step, index, direction) {
      return PropertyValueSet(items, "y", value, step, index, direction);
    };
  }, function (module, exports, __webpack_require__) {
    var Vector2 = __webpack_require__(3);

    module.exports = function (items, x, y, len, output) {
      var cx, cy, cur;
      if (void 0 === len && (len = 0), void 0 === output && (output = new Vector2()), 1 < items.length) {
        if (0 === len) {
          for (var len = items.length - 1, px = items[len].x, py = items[len].y, i = len - 1; 0 <= i; i--) {
            cx = (cur = items[i]).x, cy = cur.y, cur.x = px, cur.y = py, px = cx, py = cy;
          }

          items[len].x = x, items[len].y = y;
        } else {
          for (px = items[0].x, py = items[0].y, i = 1; i < items.length; i++) {
            cx = (cur = items[i]).x, cy = cur.y, cur.x = px, cur.y = py, px = cx, py = cy;
          }

          items[0].x = x, items[0].y = y;
        }
      } else px = items[0].x, py = items[0].y, items[0].x = x, items[0].y = y;
      return output.x = px, output.y = py, output;
    };
  }, function (module, exports, __webpack_require__) {
    var ArrayShuffle = __webpack_require__(131);

    module.exports = function (items) {
      return ArrayShuffle(items);
    };
  }, function (module, exports, __webpack_require__) {
    var MathSmootherStep = __webpack_require__(183);

    module.exports = function (items, property, min, max, inc) {
      void 0 === inc && (inc = !1);
      var i,
          step = Math.abs(max - min) / items.length;
      if (inc) for (i = 0; i < items.length; i++) {
        items[i][property] += MathSmootherStep(i * step, min, max);
      } else for (i = 0; i < items.length; i++) {
        items[i][property] = MathSmootherStep(i * step, min, max);
      }
      return items;
    };
  }, function (module, exports, __webpack_require__) {
    var MathSmoothStep = __webpack_require__(184);

    module.exports = function (items, property, min, max, inc) {
      void 0 === inc && (inc = !1);
      var i,
          step = Math.abs(max - min) / items.length;
      if (inc) for (i = 0; i < items.length; i++) {
        items[i][property] += MathSmoothStep(i * step, min, max);
      } else for (i = 0; i < items.length; i++) {
        items[i][property] = MathSmoothStep(i * step, min, max);
      }
      return items;
    };
  }, function (module, exports) {
    module.exports = function (items, property, min, max, inc) {
      void 0 === inc && (inc = !1);
      var i,
          step = Math.abs(max - min) / items.length;
      if (inc) for (i = 0; i < items.length; i++) {
        items[i][property] += i * step + min;
      } else for (i = 0; i < items.length; i++) {
        items[i][property] = i * step + min;
      }
      return items;
    };
  }, function (module, exports) {
    module.exports = function (items) {
      for (var i = 0; i < items.length; i++) {
        items[i].visible = !items[i].visible;
      }

      return items;
    };
  }, function (module, exports, __webpack_require__) {
    var Wrap = __webpack_require__(68);

    module.exports = function (items, rect, padding) {
      void 0 === padding && (padding = 0);

      for (var i = 0; i < items.length; i++) {
        var item = items[i];
        item.x = Wrap(item.x, rect.left - padding, rect.right + padding), item.y = Wrap(item.y, rect.top - padding, rect.bottom + padding);
      }

      return items;
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      Animation: __webpack_require__(185),
      AnimationFrame: __webpack_require__(319),
      AnimationManager: __webpack_require__(321),
      AnimationState: __webpack_require__(164),
      Events: __webpack_require__(132)
    };
  }, function (module, exports) {
    module.exports = "add";
  }, function (module, exports) {
    module.exports = "animationcomplete";
  }, function (module, exports) {
    module.exports = "animationcomplete-";
  }, function (module, exports) {
    module.exports = "animationrepeat";
  }, function (module, exports) {
    module.exports = "animationrestart";
  }, function (module, exports) {
    module.exports = "animationstart";
  }, function (module, exports) {
    module.exports = "animationstop";
  }, function (module, exports) {
    module.exports = "animationupdate";
  }, function (module, exports) {
    module.exports = "pauseall";
  }, function (module, exports) {
    module.exports = "remove";
  }, function (module, exports) {
    module.exports = "resumeall";
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      BaseCache: __webpack_require__(323),
      CacheManager: __webpack_require__(325),
      Events: __webpack_require__(324)
    };
  }, function (module, exports) {
    module.exports = "add";
  }, function (module, exports) {
    module.exports = "remove";
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      Controls: __webpack_require__(739),
      Scene2D: __webpack_require__(742)
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      FixedKeyControl: __webpack_require__(740),
      SmoothedKeyControl: __webpack_require__(741)
    };
  }, function (module, exports, __webpack_require__) {
    var FixedKeyControl = __webpack_require__(0),
        GetValue = __webpack_require__(6),
        FixedKeyControl = new FixedKeyControl({
      initialize: function initialize(config) {
        this.camera = GetValue(config, "camera", null), this.left = GetValue(config, "left", null), this.right = GetValue(config, "right", null), this.up = GetValue(config, "up", null), this.down = GetValue(config, "down", null), this.zoomIn = GetValue(config, "zoomIn", null), this.zoomOut = GetValue(config, "zoomOut", null), this.zoomSpeed = GetValue(config, "zoomSpeed", .01), this.minZoom = GetValue(config, "minZoom", .001), this.maxZoom = GetValue(config, "maxZoom", 1e3), this.speedX = 0, this.speedY = 0;
        var speed = GetValue(config, "speed", null);
        "number" == typeof speed ? (this.speedX = speed, this.speedY = speed) : (this.speedX = GetValue(config, "speed.x", 0), this.speedY = GetValue(config, "speed.y", 0)), this._zoom = 0, this.active = null !== this.camera;
      },
      start: function start() {
        return this.active = null !== this.camera, this;
      },
      stop: function stop() {
        return this.active = !1, this;
      },
      setCamera: function setCamera(camera) {
        return this.camera = camera, this;
      },
      update: function update(delta) {
        var cam;
        this.active && (void 0 === delta && (delta = 1), cam = this.camera, this.up && this.up.isDown ? cam.scrollY -= this.speedY * delta | 0 : this.down && this.down.isDown && (cam.scrollY += this.speedY * delta | 0), this.left && this.left.isDown ? cam.scrollX -= this.speedX * delta | 0 : this.right && this.right.isDown && (cam.scrollX += this.speedX * delta | 0), this.zoomIn && this.zoomIn.isDown ? (cam.zoom -= this.zoomSpeed, cam.zoom < this.minZoom && (cam.zoom = this.minZoom)) : this.zoomOut && this.zoomOut.isDown && (cam.zoom += this.zoomSpeed, cam.zoom > this.maxZoom && (cam.zoom = this.maxZoom)));
      },
      destroy: function destroy() {
        this.camera = null, this.left = null, this.right = null, this.up = null, this.down = null, this.zoomIn = null, this.zoomOut = null;
      }
    });

    module.exports = FixedKeyControl;
  }, function (module, exports, __webpack_require__) {
    var SmoothedKeyControl = __webpack_require__(0),
        GetValue = __webpack_require__(6),
        SmoothedKeyControl = new SmoothedKeyControl({
      initialize: function initialize(config) {
        this.camera = GetValue(config, "camera", null), this.left = GetValue(config, "left", null), this.right = GetValue(config, "right", null), this.up = GetValue(config, "up", null), this.down = GetValue(config, "down", null), this.zoomIn = GetValue(config, "zoomIn", null), this.zoomOut = GetValue(config, "zoomOut", null), this.zoomSpeed = GetValue(config, "zoomSpeed", .01), this.minZoom = GetValue(config, "minZoom", .001), this.maxZoom = GetValue(config, "maxZoom", 1e3), this.accelX = 0, this.accelY = 0;
        var maxSpeed = GetValue(config, "acceleration", null);
        "number" == typeof maxSpeed ? (this.accelX = maxSpeed, this.accelY = maxSpeed) : (this.accelX = GetValue(config, "acceleration.x", 0), this.accelY = GetValue(config, "acceleration.y", 0)), this.dragX = 0, this.dragY = 0;
        maxSpeed = GetValue(config, "drag", null);
        "number" == typeof maxSpeed ? (this.dragX = maxSpeed, this.dragY = maxSpeed) : (this.dragX = GetValue(config, "drag.x", 0), this.dragY = GetValue(config, "drag.y", 0)), this.maxSpeedX = 0, this.maxSpeedY = 0;
        maxSpeed = GetValue(config, "maxSpeed", null);
        "number" == typeof maxSpeed ? (this.maxSpeedX = maxSpeed, this.maxSpeedY = maxSpeed) : (this.maxSpeedX = GetValue(config, "maxSpeed.x", 0), this.maxSpeedY = GetValue(config, "maxSpeed.y", 0)), this._speedX = 0, this._speedY = 0, this._zoom = 0, this.active = null !== this.camera;
      },
      start: function start() {
        return this.active = null !== this.camera, this;
      },
      stop: function stop() {
        return this.active = !1, this;
      },
      setCamera: function setCamera(camera) {
        return this.camera = camera, this;
      },
      update: function update(delta) {
        var cam;
        this.active && (void 0 === delta && (delta = 1), cam = this.camera, 0 < this._speedX ? (this._speedX -= this.dragX * delta, this._speedX < 0 && (this._speedX = 0)) : this._speedX < 0 && (this._speedX += this.dragX * delta, 0 < this._speedX && (this._speedX = 0)), 0 < this._speedY ? (this._speedY -= this.dragY * delta, this._speedY < 0 && (this._speedY = 0)) : this._speedY < 0 && (this._speedY += this.dragY * delta, 0 < this._speedY && (this._speedY = 0)), this.up && this.up.isDown ? (this._speedY += this.accelY, this._speedY > this.maxSpeedY && (this._speedY = this.maxSpeedY)) : this.down && this.down.isDown && (this._speedY -= this.accelY, this._speedY < -this.maxSpeedY && (this._speedY = -this.maxSpeedY)), this.left && this.left.isDown ? (this._speedX += this.accelX, this._speedX > this.maxSpeedX && (this._speedX = this.maxSpeedX)) : this.right && this.right.isDown && (this._speedX -= this.accelX, this._speedX < -this.maxSpeedX && (this._speedX = -this.maxSpeedX)), this.zoomIn && this.zoomIn.isDown ? this._zoom = -this.zoomSpeed : this.zoomOut && this.zoomOut.isDown ? this._zoom = this.zoomSpeed : this._zoom = 0, 0 !== this._speedX && (cam.scrollX -= this._speedX * delta | 0), 0 !== this._speedY && (cam.scrollY -= this._speedY * delta | 0), 0 !== this._zoom && (cam.zoom += this._zoom, cam.zoom < this.minZoom ? cam.zoom = this.minZoom : cam.zoom > this.maxZoom && (cam.zoom = this.maxZoom)));
      },
      destroy: function destroy() {
        this.camera = null, this.left = null, this.right = null, this.up = null, this.down = null, this.zoomIn = null, this.zoomOut = null;
      }
    });

    module.exports = SmoothedKeyControl;
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      Camera: __webpack_require__(326),
      BaseCamera: __webpack_require__(133),
      CameraManager: __webpack_require__(799),
      Effects: __webpack_require__(333),
      Events: __webpack_require__(37)
    };
  }, function (module, exports) {
    module.exports = "cameradestroy";
  }, function (module, exports) {
    module.exports = "camerafadeincomplete";
  }, function (module, exports) {
    module.exports = "camerafadeinstart";
  }, function (module, exports) {
    module.exports = "camerafadeoutcomplete";
  }, function (module, exports) {
    module.exports = "camerafadeoutstart";
  }, function (module, exports) {
    module.exports = "cameraflashcomplete";
  }, function (module, exports) {
    module.exports = "cameraflashstart";
  }, function (module, exports) {
    module.exports = "followupdate";
  }, function (module, exports) {
    module.exports = "camerapancomplete";
  }, function (module, exports) {
    module.exports = "camerapanstart";
  }, function (module, exports) {
    module.exports = "postrender";
  }, function (module, exports) {
    module.exports = "prerender";
  }, function (module, exports) {
    module.exports = "camerarotatecomplete";
  }, function (module, exports) {
    module.exports = "camerarotatestart";
  }, function (module, exports) {
    module.exports = "camerashakecomplete";
  }, function (module, exports) {
    module.exports = "camerashakestart";
  }, function (module, exports) {
    module.exports = "camerazoomcomplete";
  }, function (module, exports) {
    module.exports = "camerazoomstart";
  }, function (module, exports, __webpack_require__) {
    var Clamp = __webpack_require__(18),
        Fade = __webpack_require__(0),
        Events = __webpack_require__(37),
        Fade = new Fade({
      initialize: function initialize(camera) {
        this.camera = camera, this.isRunning = !1, this.isComplete = !1, this.direction = !0, this.duration = 0, this.red = 0, this.green = 0, this.blue = 0, this.alpha = 0, this.progress = 0, this._elapsed = 0, this._onUpdate, this._onUpdateScope;
      },
      start: function start(eventName, duration, red, green, blue, force, callback, context) {
        if (void 0 === eventName && (eventName = !0), void 0 === duration && (duration = 1e3), void 0 === red && (red = 0), void 0 === green && (green = 0), void 0 === blue && (blue = 0), void 0 === callback && (callback = null), void 0 === context && (context = this.camera.scene), !(force = void 0 === force ? !1 : force) && this.isRunning) return this.camera;
        this.isRunning = !0, this.isComplete = !1, this.duration = duration, this.direction = eventName, this.progress = 0, this.red = red, this.green = green, this.blue = blue, this.alpha = eventName ? Number.MIN_VALUE : 1, this._elapsed = 0, this._onUpdate = callback, this._onUpdateScope = context;
        eventName = eventName ? Events.FADE_OUT_START : Events.FADE_IN_START;
        return this.camera.emit(eventName, this.camera, this, duration, red, green, blue), this.camera;
      },
      update: function update(time, delta) {
        this.isRunning && (this._elapsed += delta, this.progress = Clamp(this._elapsed / this.duration, 0, 1), this._onUpdate && this._onUpdate.call(this._onUpdateScope, this.camera, this.progress), this._elapsed < this.duration ? this.alpha = this.direction ? this.progress : 1 - this.progress : (this.alpha = this.direction ? 1 : 0, this.effectComplete()));
      },
      postRenderCanvas: function postRenderCanvas(ctx) {
        if (!this.isRunning && !this.isComplete) return !1;
        var camera = this.camera;
        return ctx.fillStyle = "rgba(" + this.red + "," + this.green + "," + this.blue + "," + this.alpha + ")", ctx.fillRect(camera.x, camera.y, camera.width, camera.height), !0;
      },
      postRenderWebGL: function postRenderWebGL(pipeline, getTintFunction) {
        if (!this.isRunning && !this.isComplete) return !1;
        var camera = this.camera,
            red = this.red / 255,
            green = this.green / 255,
            blue = this.blue / 255;
        return pipeline.drawFillRect(camera.x, camera.y, camera.width, camera.height, getTintFunction(blue, green, red, 1), this.alpha), !0;
      },
      effectComplete: function effectComplete() {
        this._onUpdate = null, this._onUpdateScope = null, this.isRunning = !1, this.isComplete = !0;
        var eventName = this.direction ? Events.FADE_OUT_COMPLETE : Events.FADE_IN_COMPLETE;
        this.camera.emit(eventName, this.camera, this);
      },
      reset: function reset() {
        this.isRunning = !1, this.isComplete = !1, this._onUpdate = null, this._onUpdateScope = null;
      },
      destroy: function destroy() {
        this.reset(), this.camera = null;
      }
    });

    module.exports = Fade;
  }, function (module, exports, __webpack_require__) {
    var Clamp = __webpack_require__(18),
        Flash = __webpack_require__(0),
        Events = __webpack_require__(37),
        Flash = new Flash({
      initialize: function initialize(camera) {
        this.camera = camera, this.isRunning = !1, this.duration = 0, this.red = 0, this.green = 0, this.blue = 0, this.alpha = 0, this.progress = 0, this._elapsed = 0, this._onUpdate, this._onUpdateScope;
      },
      start: function start(duration, red, green, blue, force, callback, context) {
        return void 0 === duration && (duration = 250), void 0 === red && (red = 255), void 0 === green && (green = 255), void 0 === blue && (blue = 255), void 0 === callback && (callback = null), void 0 === context && (context = this.camera.scene), !(force = void 0 === force ? !1 : force) && this.isRunning || (this.isRunning = !0, this.duration = duration, this.progress = 0, this.red = red, this.green = green, this.blue = blue, this.alpha = 1, this._elapsed = 0, this._onUpdate = callback, this._onUpdateScope = context, this.camera.emit(Events.FLASH_START, this.camera, this, duration, red, green, blue)), this.camera;
      },
      update: function update(time, delta) {
        this.isRunning && (this._elapsed += delta, this.progress = Clamp(this._elapsed / this.duration, 0, 1), this._onUpdate && this._onUpdate.call(this._onUpdateScope, this.camera, this.progress), this._elapsed < this.duration ? this.alpha = 1 - this.progress : this.effectComplete());
      },
      postRenderCanvas: function postRenderCanvas(ctx) {
        if (!this.isRunning) return !1;
        var camera = this.camera;
        return ctx.fillStyle = "rgba(" + this.red + "," + this.green + "," + this.blue + "," + this.alpha + ")", ctx.fillRect(camera.x, camera.y, camera.width, camera.height), !0;
      },
      postRenderWebGL: function postRenderWebGL(pipeline, getTintFunction) {
        if (!this.isRunning) return !1;
        var camera = this.camera,
            red = this.red / 255,
            green = this.green / 255,
            blue = this.blue / 255;
        return pipeline.drawFillRect(camera.x, camera.y, camera.width, camera.height, getTintFunction(blue, green, red, 1), this.alpha), !0;
      },
      effectComplete: function effectComplete() {
        this._onUpdate = null, this._onUpdateScope = null, this.isRunning = !1, this.camera.emit(Events.FLASH_COMPLETE, this.camera, this);
      },
      reset: function reset() {
        this.isRunning = !1, this._onUpdate = null, this._onUpdateScope = null;
      },
      destroy: function destroy() {
        this.reset(), this.camera = null;
      }
    });

    module.exports = Flash;
  }, function (module, exports, __webpack_require__) {
    var Clamp = __webpack_require__(18),
        Pan = __webpack_require__(0),
        EaseMap = __webpack_require__(134),
        Events = __webpack_require__(37),
        Vector2 = __webpack_require__(3),
        Pan = new Pan({
      initialize: function initialize(camera) {
        this.camera = camera, this.isRunning = !1, this.duration = 0, this.source = new Vector2(), this.current = new Vector2(), this.destination = new Vector2(), this.ease, this.progress = 0, this._elapsed = 0, this._onUpdate, this._onUpdateScope;
      },
      start: function start(x, y, duration, ease, force, callback, context) {
        void 0 === duration && (duration = 1e3), void 0 === ease && (ease = EaseMap.Linear), void 0 === callback && (callback = null), void 0 === context && (context = this.camera.scene);
        var cam = this.camera;
        return !(force = void 0 === force ? !1 : force) && this.isRunning || (this.isRunning = !0, this.duration = duration, this.progress = 0, this.source.set(cam.scrollX, cam.scrollY), this.destination.set(x, y), cam.getScroll(x, y, this.current), "string" == typeof ease && EaseMap.hasOwnProperty(ease) ? this.ease = EaseMap[ease] : "function" == typeof ease && (this.ease = ease), this._elapsed = 0, this._onUpdate = callback, this._onUpdateScope = context, this.camera.emit(Events.PAN_START, this.camera, this, duration, x, y)), cam;
      },
      update: function update(time, x) {
        var progress, cam, y;
        this.isRunning && (this._elapsed += x, progress = Clamp(this._elapsed / this.duration, 0, 1), this.progress = progress, cam = this.camera, this._elapsed < this.duration ? (y = this.ease(progress), cam.getScroll(this.destination.x, this.destination.y, this.current), x = this.source.x + (this.current.x - this.source.x) * y, y = this.source.y + (this.current.y - this.source.y) * y, cam.setScroll(x, y), this._onUpdate && this._onUpdate.call(this._onUpdateScope, cam, progress, x, y)) : (cam.centerOn(this.destination.x, this.destination.y), this._onUpdate && this._onUpdate.call(this._onUpdateScope, cam, progress, cam.scrollX, cam.scrollY), this.effectComplete()));
      },
      effectComplete: function effectComplete() {
        this._onUpdate = null, this._onUpdateScope = null, this.isRunning = !1, this.camera.emit(Events.PAN_COMPLETE, this.camera, this);
      },
      reset: function reset() {
        this.isRunning = !1, this._onUpdate = null, this._onUpdateScope = null;
      },
      destroy: function destroy() {
        this.reset(), this.camera = null, this.source = null, this.destination = null;
      }
    });

    module.exports = Pan;
  }, function (module, exports) {
    module.exports = function (v, overshoot) {
      return v * v * (((overshoot = void 0 === overshoot ? 1.70158 : overshoot) + 1) * v - overshoot);
    };
  }, function (module, exports) {
    module.exports = function (v, overshoot) {
      return --v * v * (((overshoot = void 0 === overshoot ? 1.70158 : overshoot) + 1) * v + overshoot) + 1;
    };
  }, function (module, exports) {
    module.exports = function (v, s) {
      s = 1.525 * (s = void 0 === s ? 1.70158 : s);
      return (v *= 2) < 1 ? v * v * ((1 + s) * v - s) * .5 : .5 * ((v -= 2) * v * ((1 + s) * v + s) + 2);
    };
  }, function (module, exports) {
    module.exports = function (v) {
      return (v = 1 - v) < 1 / 2.75 ? 1 - 7.5625 * v * v : v < 2 / 2.75 ? 1 - (7.5625 * (v -= 1.5 / 2.75) * v + .75) : v < 2.5 / 2.75 ? 1 - (7.5625 * (v -= 2.25 / 2.75) * v + .9375) : 1 - (7.5625 * (v -= 2.625 / 2.75) * v + .984375);
    };
  }, function (module, exports) {
    module.exports = function (v) {
      return v < 1 / 2.75 ? 7.5625 * v * v : v < 2 / 2.75 ? 7.5625 * (v -= 1.5 / 2.75) * v + .75 : v < 2.5 / 2.75 ? 7.5625 * (v -= 2.25 / 2.75) * v + .9375 : 7.5625 * (v -= 2.625 / 2.75) * v + .984375;
    };
  }, function (module, exports) {
    module.exports = function (v) {
      var reverse = !1;
      return v < .5 ? (v = 1 - 2 * v, reverse = !0) : v = 2 * v - 1, v < 1 / 2.75 ? v *= 7.5625 * v : v = v < 2 / 2.75 ? 7.5625 * (v -= 1.5 / 2.75) * v + .75 : v < 2.5 / 2.75 ? 7.5625 * (v -= 2.25 / 2.75) * v + .9375 : 7.5625 * (v -= 2.625 / 2.75) * v + .984375, reverse ? .5 * (1 - v) : .5 * v + .5;
    };
  }, function (module, exports) {
    module.exports = function (v) {
      return 1 - Math.sqrt(1 - v * v);
    };
  }, function (module, exports) {
    module.exports = function (v) {
      return Math.sqrt(1 - --v * v);
    };
  }, function (module, exports) {
    module.exports = function (v) {
      return (v *= 2) < 1 ? -.5 * (Math.sqrt(1 - v * v) - 1) : .5 * (Math.sqrt(1 - (v -= 2) * v) + 1);
    };
  }, function (module, exports) {
    module.exports = function (v) {
      return v * v * v;
    };
  }, function (module, exports) {
    module.exports = function (v) {
      return --v * v * v + 1;
    };
  }, function (module, exports) {
    module.exports = function (v) {
      return (v *= 2) < 1 ? .5 * v * v * v : .5 * ((v -= 2) * v * v + 2);
    };
  }, function (module, exports) {
    module.exports = function (v, amplitude, period) {
      if (0 === v) return 0;
      if (1 === v) return 1;
      var s = (period = void 0 === period ? .1 : period) / 4;
      return (amplitude = void 0 === amplitude ? .1 : amplitude) < 1 ? amplitude = 1 : s = period * Math.asin(1 / amplitude) / (2 * Math.PI), -(amplitude * Math.pow(2, 10 * --v) * Math.sin((v - s) * (2 * Math.PI) / period));
    };
  }, function (module, exports) {
    module.exports = function (v, amplitude, period) {
      if (0 === v) return 0;
      if (1 === v) return 1;
      var s = (period = void 0 === period ? .1 : period) / 4;
      return (amplitude = void 0 === amplitude ? .1 : amplitude) < 1 ? amplitude = 1 : s = period * Math.asin(1 / amplitude) / (2 * Math.PI), amplitude * Math.pow(2, -10 * v) * Math.sin((v - s) * (2 * Math.PI) / period) + 1;
    };
  }, function (module, exports) {
    module.exports = function (v, amplitude, period) {
      if (0 === v) return 0;
      if (1 === v) return 1;
      var s = (period = void 0 === period ? .1 : period) / 4;
      return (amplitude = void 0 === amplitude ? .1 : amplitude) < 1 ? amplitude = 1 : s = period * Math.asin(1 / amplitude) / (2 * Math.PI), (v *= 2) < 1 ? amplitude * Math.pow(2, 10 * --v) * Math.sin((v - s) * (2 * Math.PI) / period) * -.5 : amplitude * Math.pow(2, -10 * --v) * Math.sin((v - s) * (2 * Math.PI) / period) * .5 + 1;
    };
  }, function (module, exports) {
    module.exports = function (v) {
      return Math.pow(2, 10 * (v - 1)) - .001;
    };
  }, function (module, exports) {
    module.exports = function (v) {
      return 1 - Math.pow(2, -10 * v);
    };
  }, function (module, exports) {
    module.exports = function (v) {
      return (v *= 2) < 1 ? .5 * Math.pow(2, 10 * (v - 1)) : .5 * (2 - Math.pow(2, -10 * (v - 1)));
    };
  }, function (module, exports) {
    module.exports = function (v) {
      return v;
    };
  }, function (module, exports) {
    module.exports = function (v) {
      return v * v;
    };
  }, function (module, exports) {
    module.exports = function (v) {
      return v * (2 - v);
    };
  }, function (module, exports) {
    module.exports = function (v) {
      return (v *= 2) < 1 ? .5 * v * v : -.5 * (--v * (v - 2) - 1);
    };
  }, function (module, exports) {
    module.exports = function (v) {
      return v * v * v * v;
    };
  }, function (module, exports) {
    module.exports = function (v) {
      return 1 - --v * v * v * v;
    };
  }, function (module, exports) {
    module.exports = function (v) {
      return (v *= 2) < 1 ? .5 * v * v * v * v : -.5 * ((v -= 2) * v * v * v - 2);
    };
  }, function (module, exports) {
    module.exports = function (v) {
      return v * v * v * v * v;
    };
  }, function (module, exports) {
    module.exports = function (v) {
      return --v * v * v * v * v + 1;
    };
  }, function (module, exports) {
    module.exports = function (v) {
      return (v *= 2) < 1 ? .5 * v * v * v * v * v : .5 * ((v -= 2) * v * v * v * v + 2);
    };
  }, function (module, exports) {
    module.exports = function (v) {
      return 0 === v ? 0 : 1 === v ? 1 : 1 - Math.cos(v * Math.PI / 2);
    };
  }, function (module, exports) {
    module.exports = function (v) {
      return 0 === v ? 0 : 1 === v ? 1 : Math.sin(v * Math.PI / 2);
    };
  }, function (module, exports) {
    module.exports = function (v) {
      return 0 === v ? 0 : 1 === v ? 1 : .5 * (1 - Math.cos(Math.PI * v));
    };
  }, function (module, exports) {
    module.exports = function (v, steps) {
      return void 0 === steps && (steps = 1), v <= 0 ? 0 : 1 <= v ? 1 : 1 / steps * (1 + (steps * v | 0));
    };
  }, function (module, exports, __webpack_require__) {
    var Clamp = __webpack_require__(18),
        Shake = __webpack_require__(0),
        Events = __webpack_require__(37),
        Vector2 = __webpack_require__(3),
        Shake = new Shake({
      initialize: function initialize(camera) {
        this.camera = camera, this.isRunning = !1, this.duration = 0, this.intensity = new Vector2(), this.progress = 0, this._elapsed = 0, this._offsetX = 0, this._offsetY = 0, this._onUpdate, this._onUpdateScope;
      },
      start: function start(duration, intensity, force, callback, context) {
        return void 0 === duration && (duration = 100), void 0 === intensity && (intensity = .05), void 0 === callback && (callback = null), void 0 === context && (context = this.camera.scene), !(force = void 0 === force ? !1 : force) && this.isRunning || (this.isRunning = !0, this.duration = duration, this.progress = 0, "number" == typeof intensity ? this.intensity.set(intensity) : this.intensity.set(intensity.x, intensity.y), this._elapsed = 0, this._offsetX = 0, this._offsetY = 0, this._onUpdate = callback, this._onUpdateScope = context, this.camera.emit(Events.SHAKE_START, this.camera, this, duration, intensity)), this.camera;
      },
      preRender: function preRender() {
        this.isRunning && this.camera.matrix.translate(this._offsetX, this._offsetY);
      },
      update: function update(time, zoom) {
        var intensity, width, height;
        this.isRunning && (this._elapsed += zoom, this.progress = Clamp(this._elapsed / this.duration, 0, 1), this._onUpdate && this._onUpdate.call(this._onUpdateScope, this.camera, this.progress), this._elapsed < this.duration ? (intensity = this.intensity, width = this.camera.width, height = this.camera.height, zoom = this.camera.zoom, this._offsetX = (Math.random() * intensity.x * width * 2 - intensity.x * width) * zoom, this._offsetY = (Math.random() * intensity.y * height * 2 - intensity.y * height) * zoom, this.camera.roundPixels && (this._offsetX = Math.round(this._offsetX), this._offsetY = Math.round(this._offsetY))) : this.effectComplete());
      },
      effectComplete: function effectComplete() {
        this._offsetX = 0, this._offsetY = 0, this._onUpdate = null, this._onUpdateScope = null, this.isRunning = !1, this.camera.emit(Events.SHAKE_COMPLETE, this.camera, this);
      },
      reset: function reset() {
        this.isRunning = !1, this._offsetX = 0, this._offsetY = 0, this._onUpdate = null, this._onUpdateScope = null;
      },
      destroy: function destroy() {
        this.reset(), this.camera = null, this.intensity = null;
      }
    });

    module.exports = Shake;
  }, function (module, exports, __webpack_require__) {
    var Clamp = __webpack_require__(18),
        RotateTo = __webpack_require__(0),
        Events = __webpack_require__(37),
        EaseMap = __webpack_require__(134),
        RotateTo = new RotateTo({
      initialize: function initialize(camera) {
        this.camera = camera, this.isRunning = !1, this.duration = 0, this.source = 0, this.current = 0, this.destination = 0, this.ease, this.progress = 0, this._elapsed = 0, this._onUpdate, this._onUpdateScope, this.clockwise = !0, this.shortestPath = !1;
      },
      start: function start(cam, maxRad, duration, ease, force, cwDist, acwDist) {
        void 0 === duration && (duration = 1e3), void 0 === ease && (ease = EaseMap.Linear), void 0 === force && (force = !1), void 0 === cwDist && (cwDist = null), void 0 === acwDist && (acwDist = this.camera.scene), this.shortestPath = maxRad = void 0 === maxRad ? !1 : maxRad;
        var tmpDestination = cam;
        cam < 0 ? (tmpDestination = -1 * cam, this.clockwise = !1) : this.clockwise = !0;
        maxRad = 360 * Math.PI / 180;
        tmpDestination -= Math.floor(tmpDestination / maxRad) * maxRad;
        cam = this.camera;
        return !force && this.isRunning || (this.isRunning = !0, this.duration = duration, this.progress = 0, this.source = cam.rotation, this.destination = tmpDestination, "string" == typeof ease && EaseMap.hasOwnProperty(ease) ? this.ease = EaseMap[ease] : "function" == typeof ease && (this.ease = ease), this._elapsed = 0, this._onUpdate = cwDist, this._onUpdateScope = acwDist, this.shortestPath && (acwDist = cwDist = 0, (cwDist = this.destination > this.source ? Math.abs(this.destination - this.source) : Math.abs(this.destination + maxRad) - this.source) < (acwDist = this.source > this.destination ? Math.abs(this.source - this.destination) : Math.abs(this.source + maxRad) - this.destination) ? this.clockwise = !0 : acwDist < cwDist && (this.clockwise = !1)), this.camera.emit(Events.ROTATE_START, this.camera, this, duration, tmpDestination)), cam;
      },
      update: function update(time, r) {
        var progress, cam, v, maxRad, target, distance;
        this.isRunning && (this._elapsed += r, progress = Clamp(this._elapsed / this.duration, 0, 1), this.progress = progress, cam = this.camera, this._elapsed < this.duration ? (v = this.ease(progress), this.current = cam.rotation, distance = 0, maxRad = 360 * Math.PI / 180, target = this.destination, r = this.current, !1 === this.clockwise && (target = this.current, r = this.destination), distance = r <= target ? Math.abs(target - r) : Math.abs(target + maxRad) - r, r = 0, r = this.clockwise ? cam.rotation + distance * v : cam.rotation - distance * v, cam.rotation = r, this._onUpdate && this._onUpdate.call(this._onUpdateScope, cam, progress, r)) : (cam.rotation = this.destination, this._onUpdate && this._onUpdate.call(this._onUpdateScope, cam, progress, this.destination), this.effectComplete()));
      },
      effectComplete: function effectComplete() {
        this._onUpdate = null, this._onUpdateScope = null, this.isRunning = !1, this.camera.emit(Events.ROTATE_COMPLETE, this.camera, this);
      },
      reset: function reset() {
        this.isRunning = !1, this._onUpdate = null, this._onUpdateScope = null;
      },
      destroy: function destroy() {
        this.reset(), this.camera = null, this.source = null, this.destination = null;
      }
    });

    module.exports = RotateTo;
  }, function (module, exports, __webpack_require__) {
    var Clamp = __webpack_require__(18),
        Zoom = __webpack_require__(0),
        EaseMap = __webpack_require__(134),
        Events = __webpack_require__(37),
        Zoom = new Zoom({
      initialize: function initialize(camera) {
        this.camera = camera, this.isRunning = !1, this.duration = 0, this.source = 1, this.destination = 1, this.ease, this.progress = 0, this._elapsed = 0, this._onUpdate, this._onUpdateScope;
      },
      start: function start(zoom, duration, ease, force, callback, context) {
        void 0 === duration && (duration = 1e3), void 0 === ease && (ease = EaseMap.Linear), void 0 === callback && (callback = null), void 0 === context && (context = this.camera.scene);
        var cam = this.camera;
        return !(force = void 0 === force ? !1 : force) && this.isRunning || (this.isRunning = !0, this.duration = duration, this.progress = 0, this.source = cam.zoom, this.destination = zoom, "string" == typeof ease && EaseMap.hasOwnProperty(ease) ? this.ease = EaseMap[ease] : "function" == typeof ease && (this.ease = ease), this._elapsed = 0, this._onUpdate = callback, this._onUpdateScope = context, this.camera.emit(Events.ZOOM_START, this.camera, this, duration, zoom)), cam;
      },
      update: function update(time, delta) {
        this.isRunning && (this._elapsed += delta, this.progress = Clamp(this._elapsed / this.duration, 0, 1), this._elapsed < this.duration ? (this.camera.zoom = this.source + (this.destination - this.source) * this.ease(this.progress), this._onUpdate && this._onUpdate.call(this._onUpdateScope, this.camera, this.progress, this.camera.zoom)) : (this.camera.zoom = this.destination, this._onUpdate && this._onUpdate.call(this._onUpdateScope, this.camera, this.progress, this.destination), this.effectComplete()));
      },
      effectComplete: function effectComplete() {
        this._onUpdate = null, this._onUpdateScope = null, this.isRunning = !1, this.camera.emit(Events.ZOOM_COMPLETE, this.camera, this);
      },
      reset: function reset() {
        this.isRunning = !1, this._onUpdate = null, this._onUpdateScope = null;
      },
      destroy: function destroy() {
        this.reset(), this.camera = null;
      }
    });

    module.exports = Zoom;
  }, function (module, exports, __webpack_require__) {
    var Camera = __webpack_require__(326),
        CameraManager = __webpack_require__(0),
        GetFastValue = __webpack_require__(2),
        PluginCache = __webpack_require__(24),
        RectangleContains = __webpack_require__(57),
        ScaleEvents = __webpack_require__(104),
        SceneEvents = __webpack_require__(20),
        CameraManager = new CameraManager({
      initialize: function initialize(scene) {
        this.scene = scene, this.systems = scene.sys, this.roundPixels = scene.sys.game.config.roundPixels, this.cameras = [], this.main, this.default, scene.sys.events.once(SceneEvents.BOOT, this.boot, this), scene.sys.events.on(SceneEvents.START, this.start, this);
      },
      boot: function boot() {
        var sys = this.systems;
        sys.settings.cameras ? this.fromJSON(sys.settings.cameras) : this.add(), this.main = this.cameras[0], this.default = new Camera(0, 0, sys.scale.width, sys.scale.height).setScene(this.scene), sys.game.scale.on(ScaleEvents.RESIZE, this.onResize, this), this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);
      },
      start: function start() {
        this.main || ((eventEmitter = this.systems).settings.cameras ? this.fromJSON(eventEmitter.settings.cameras) : this.add(), this.main = this.cameras[0]);
        var eventEmitter = this.systems.events;
        eventEmitter.on(SceneEvents.UPDATE, this.update, this), eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);
      },
      add: function add(x, y, width, camera, makeMain, name) {
        void 0 === width && (width = this.scene.sys.scale.width), void 0 === camera && (camera = this.scene.sys.scale.height), void 0 === makeMain && (makeMain = !1), void 0 === name && (name = "");
        camera = new Camera(x = void 0 === x ? 0 : x, y = void 0 === y ? 0 : y, width, camera);
        return camera.setName(name), camera.setScene(this.scene), camera.setRoundPixels(this.roundPixels), camera.id = this.getNextID(), this.cameras.push(camera), makeMain && (this.main = camera), camera;
      },
      addExisting: function addExisting(camera, makeMain) {
        return void 0 === makeMain && (makeMain = !1), -1 === this.cameras.indexOf(camera) ? (camera.id = this.getNextID(), camera.setRoundPixels(this.roundPixels), this.cameras.push(camera), makeMain && (this.main = camera), camera) : null;
      },
      getNextID: function getNextID() {
        for (var cameras = this.cameras, testID = 1, t = 0; t < 32; t++) {
          for (var found = !1, i = 0; i < cameras.length; i++) {
            var camera = cameras[i];
            camera && camera.id === testID && (found = !0);
          }

          if (!found) return testID;
          testID <<= 1;
        }

        return 0;
      },
      getTotal: function getTotal(isVisible) {
        void 0 === isVisible && (isVisible = !1);

        for (var total = 0, cameras = this.cameras, i = 0; i < cameras.length; i++) {
          var camera = cameras[i];
          isVisible && !camera.visible || total++;
        }

        return total;
      },
      fromJSON: function fromJSON(config) {
        Array.isArray(config) || (config = [config]);

        for (var gameWidth = this.scene.sys.scale.width, gameHeight = this.scene.sys.scale.height, i = 0; i < config.length; i++) {
          var bwidth = config[i],
              camera = GetFastValue(bwidth, "x", 0),
              by = GetFastValue(bwidth, "y", 0),
              bheight = GetFastValue(bwidth, "width", gameWidth),
              bx = GetFastValue(bwidth, "height", gameHeight),
              camera = this.add(camera, by, bheight, bx);
          camera.name = GetFastValue(bwidth, "name", ""), camera.zoom = GetFastValue(bwidth, "zoom", 1), camera.rotation = GetFastValue(bwidth, "rotation", 0), camera.scrollX = GetFastValue(bwidth, "scrollX", 0), camera.scrollY = GetFastValue(bwidth, "scrollY", 0), camera.roundPixels = GetFastValue(bwidth, "roundPixels", !1), camera.visible = GetFastValue(bwidth, "visible", !0);
          by = GetFastValue(bwidth, "backgroundColor", !1);
          by && camera.setBackgroundColor(by);
          var bheight = GetFastValue(bwidth, "bounds", null);
          bheight && (bx = GetFastValue(bheight, "x", 0), by = GetFastValue(bheight, "y", 0), bwidth = GetFastValue(bheight, "width", gameWidth), bheight = GetFastValue(bheight, "height", gameHeight), camera.setBounds(bx, by, bwidth, bheight));
        }

        return this;
      },
      getCamera: function getCamera(name) {
        for (var cameras = this.cameras, i = 0; i < cameras.length; i++) {
          if (cameras[i].name === name) return cameras[i];
        }

        return null;
      },
      getCamerasBelowPointer: function getCamerasBelowPointer(pointer) {
        for (var cameras = this.cameras, x = pointer.x, y = pointer.y, output = [], i = 0; i < cameras.length; i++) {
          var camera = cameras[i];
          camera.visible && camera.inputEnabled && RectangleContains(camera, x, y) && output.unshift(camera);
        }

        return output;
      },
      remove: function remove(camera, runDestroy) {
        void 0 === runDestroy && (runDestroy = !0), Array.isArray(camera) || (camera = [camera]);

        for (var total = 0, cameras = this.cameras, i = 0; i < camera.length; i++) {
          var index = cameras.indexOf(camera[i]);
          -1 !== index && (runDestroy ? cameras[index].destroy() : cameras[index].renderList = [], cameras.splice(index, 1), total++);
        }

        return !this.main && cameras[0] && (this.main = cameras[0]), total;
      },
      render: function render(renderer, displayList) {
        for (var scene = this.scene, cameras = this.cameras, i = 0; i < this.cameras.length; i++) {
          var visibleChildren,
              camera = cameras[i];
          camera.visible && 0 < camera.alpha && (camera.preRender(), visibleChildren = this.getVisibleChildren(displayList.getChildren(), camera), renderer.render(scene, visibleChildren, camera));
        }
      },
      getVisibleChildren: function getVisibleChildren(children, camera) {
        for (var visible = [], i = 0; i < children.length; i++) {
          var child = children[i];
          child.willRender(camera) && visible.push(child);
        }

        return visible;
      },
      resetAll: function resetAll() {
        for (var i = 0; i < this.cameras.length; i++) {
          this.cameras[i].destroy();
        }

        return this.cameras = [], this.main = this.add(), this.main;
      },
      update: function update(time, delta) {
        for (var i = 0; i < this.cameras.length; i++) {
          this.cameras[i].update(time, delta);
        }
      },
      onResize: function onResize(gameSize, baseSize, displaySize, previousWidth, previousHeight) {
        for (var i = 0; i < this.cameras.length; i++) {
          var cam = this.cameras[i];
          0 === cam._x && 0 === cam._y && cam._width === previousWidth && cam._height === previousHeight && cam.setSize(baseSize.width, baseSize.height);
        }
      },
      resize: function resize(width, height) {
        for (var i = 0; i < this.cameras.length; i++) {
          this.cameras[i].setSize(width, height);
        }
      },
      shutdown: function shutdown() {
        this.main = void 0;

        for (var i = 0; i < this.cameras.length; i++) {
          this.cameras[i].destroy();
        }

        this.cameras = [];
        var eventEmitter = this.systems.events;
        eventEmitter.off(SceneEvents.UPDATE, this.update, this), eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);
      },
      destroy: function destroy() {
        this.shutdown(), this.default.destroy(), this.scene.sys.events.off(SceneEvents.START, this.start, this), this.scene = null, this.systems = null;
      }
    });

    PluginCache.register("CameraManager", CameraManager, "cameras"), module.exports = CameraManager;
  }, function (module, exports) {
    module.exports = "enterfullscreen";
  }, function (module, exports) {
    module.exports = "fullscreenfailed";
  }, function (module, exports) {
    module.exports = "fullscreenunsupported";
  }, function (module, exports) {
    module.exports = "leavefullscreen";
  }, function (module, exports) {
    module.exports = "orientationchange";
  }, function (module, exports) {
    module.exports = "resize";
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      Config: __webpack_require__(346),
      CreateRenderer: __webpack_require__(366),
      DebugHeader: __webpack_require__(384),
      Events: __webpack_require__(22),
      TimeStep: __webpack_require__(385),
      VisibilityHandler: __webpack_require__(387)
    };
  }, function (process, exports) {
    var cachedSetTimeout,
        cachedClearTimeout,
        process = process.exports = {};

    function defaultSetTimout() {
      throw new Error("setTimeout has not been defined");
    }

    function defaultClearTimeout() {
      throw new Error("clearTimeout has not been defined");
    }

    function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) return setTimeout(fun, 0);
      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) return cachedSetTimeout = setTimeout, setTimeout(fun, 0);

      try {
        return cachedSetTimeout(fun, 0);
      } catch (e) {
        try {
          return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
          return cachedSetTimeout.call(this, fun, 0);
        }
      }
    }

    !function () {
      try {
        cachedSetTimeout = "function" == typeof setTimeout ? setTimeout : defaultSetTimout;
      } catch (e) {
        cachedSetTimeout = defaultSetTimout;
      }

      try {
        cachedClearTimeout = "function" == typeof clearTimeout ? clearTimeout : defaultClearTimeout;
      } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
      }
    }();
    var currentQueue,
        queue = [],
        draining = !1,
        queueIndex = -1;

    function cleanUpNextTick() {
      draining && currentQueue && (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, queue.length && drainQueue());
    }

    function drainQueue() {
      if (!draining) {
        var timeout = runTimeout(cleanUpNextTick);
        draining = !0;

        for (var len = queue.length; len;) {
          for (currentQueue = queue, queue = []; ++queueIndex < len;) {
            currentQueue && currentQueue[queueIndex].run();
          }

          queueIndex = -1, len = queue.length;
        }

        currentQueue = null, draining = !1, function (marker) {
          if (cachedClearTimeout === clearTimeout) return clearTimeout(marker);
          if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) return cachedClearTimeout = clearTimeout, clearTimeout(marker);

          try {
            cachedClearTimeout(marker);
          } catch (e) {
            try {
              return cachedClearTimeout.call(null, marker);
            } catch (e) {
              return cachedClearTimeout.call(this, marker);
            }
          }
        }(timeout);
      }
    }

    function Item(fun, array) {
      this.fun = fun, this.array = array;
    }

    function noop() {}

    process.nextTick = function (fun) {
      var args = new Array(arguments.length - 1);
      if (1 < arguments.length) for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
      queue.push(new Item(fun, args)), 1 !== queue.length || draining || runTimeout(drainQueue);
    }, Item.prototype.run = function () {
      this.fun.apply(null, this.array);
    }, process.title = "browser", process.env = {}, process.argv = [], process.version = "", process.versions = {}, process.on = noop, process.addListener = noop, process.once = noop, process.off = noop, process.removeListener = noop, process.removeAllListeners = noop, process.emit = noop, process.prependListener = noop, process.prependOnceListener = noop, process.listeners = function (name) {
      return [];
    }, process.binding = function (name) {
      throw new Error("process.binding is not supported");
    }, process.cwd = function () {
      return "/";
    }, process.chdir = function (dir) {
      throw new Error("process.chdir is not supported");
    }, process.umask = function () {
      return 0;
    };
  }, function (module, exports, Input) {
    var Browser = Input(136),
        Input = {
      gamepads: !1,
      mspointer: !1,
      touch: !1,
      wheelEvent: null
    };
    module.exports = ("function" == typeof importScripts || (("ontouchstart" in document.documentElement || navigator.maxTouchPoints && 1 <= navigator.maxTouchPoints) && (Input.touch = !0), (navigator.msPointerEnabled || navigator.pointerEnabled) && (Input.mspointer = !0), navigator.getGamepads && (Input.gamepads = !0), "onwheel" in window || Browser.ie && "WheelEvent" in window ? Input.wheelEvent = "wheel" : "onmousewheel" in window ? Input.wheelEvent = "mousewheel" : Browser.firefox && "MouseScrollEvent" in window && (Input.wheelEvent = "DOMMouseScroll")), Input);
  }, function (module, exports, __webpack_require__) {
    var Browser = __webpack_require__(136),
        Audio = {
      audioData: !1,
      dolby: !1,
      m4a: !1,
      mp3: !1,
      ogg: !1,
      opus: !1,
      wav: !1,
      webAudio: !1,
      webm: !1
    };

    module.exports = function () {
      if ("function" == typeof importScripts) return Audio;
      Audio.audioData = !!window.Audio, Audio.webAudio = !(!window.AudioContext && !window.webkitAudioContext);
      var major,
          minor,
          audioElement = document.createElement("audio"),
          result = !!audioElement.canPlayType;

      try {
        result && (audioElement.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, "") && (Audio.ogg = !0), (audioElement.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, "") || audioElement.canPlayType("audio/opus;").replace(/^no$/, "")) && (Audio.opus = !0), audioElement.canPlayType("audio/mpeg;").replace(/^no$/, "") && (Audio.mp3 = !0), audioElement.canPlayType("audio/wav").replace(/^no$/, "") && (Audio.wav = !0), (audioElement.canPlayType("audio/x-m4a;") || audioElement.canPlayType("audio/aac;").replace(/^no$/, "")) && (Audio.m4a = !0), audioElement.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "") && (Audio.webm = !0), "" !== audioElement.canPlayType('audio/mp4;codecs="ec-3"') && (Browser.edge ? Audio.dolby = !0 : Browser.safari && 9 <= Browser.safariVersion && /Mac OS X (\d+)_(\d+)/.test(navigator.userAgent) && (major = parseInt(RegExp.$1, 10), minor = parseInt(RegExp.$2, 10), (10 === major && 11 <= minor || 10 < major) && (Audio.dolby = !0))));
      } catch (e) {}

      return Audio;
    }();
  }, function (module, exports) {
    var Video = {
      h264: !1,
      hls: !1,
      mp4: !1,
      ogg: !1,
      vp9: !1,
      webm: !1
    };

    module.exports = function () {
      if ("function" == typeof importScripts) return Video;
      var videoElement = document.createElement("video"),
          result = !!videoElement.canPlayType;

      try {
        result && (videoElement.canPlayType('video/ogg; codecs="theora"').replace(/^no$/, "") && (Video.ogg = !0), videoElement.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/, "") && (Video.h264 = !0, Video.mp4 = !0), videoElement.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/, "") && (Video.webm = !0), videoElement.canPlayType('video/webm; codecs="vp9"').replace(/^no$/, "") && (Video.vp9 = !0), videoElement.canPlayType('application/x-mpegURL; codecs="avc1.42E01E"').replace(/^no$/, "") && (Video.hls = !0));
      } catch (e) {}

      return Video;
    }();
  }, function (module, exports) {
    var Fullscreen = {
      available: !1,
      cancel: "",
      keyboard: !1,
      request: ""
    };

    module.exports = function () {
      if ("function" == typeof importScripts) return Fullscreen;

      for (var suffix1 = "Fullscreen", suffix2 = "FullScreen", fs = ["request" + suffix1, "request" + suffix2, "webkitRequest" + suffix1, "webkitRequest" + suffix2, "msRequest" + suffix1, "msRequest" + suffix2, "mozRequest" + suffix2, "mozRequest" + suffix1], i = 0; i < fs.length; i++) {
        if (document.documentElement[fs[i]]) {
          Fullscreen.available = !0, Fullscreen.request = fs[i];
          break;
        }
      }

      var cfs = ["cancel" + suffix2, "exit" + suffix1, "webkitCancel" + suffix2, "webkitExit" + suffix1, "msCancel" + suffix2, "msExit" + suffix1, "mozCancel" + suffix2, "mozExit" + suffix1];
      if (Fullscreen.available) for (i = 0; i < cfs.length; i++) {
        if (document[cfs[i]]) {
          Fullscreen.cancel = cfs[i];
          break;
        }
      }
      return window.Element && Element.ALLOW_KEYBOARD_INPUT && !/ Version\/5\.1(?:\.\d+)? Safari\//.test(navigator.userAgent) && (Fullscreen.keyboard = !0), Object.defineProperty(Fullscreen, "active", {
        get: function get() {
          return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
        }
      }), Fullscreen;
    }();
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      Between: __webpack_require__(349),
      BetweenPoints: __webpack_require__(350),
      BetweenPointsY: __webpack_require__(813),
      BetweenY: __webpack_require__(814),
      CounterClockwise: __webpack_require__(815),
      Normalize: __webpack_require__(351),
      Random: __webpack_require__(816),
      RandomDegrees: __webpack_require__(817),
      Reverse: __webpack_require__(818),
      RotateTo: __webpack_require__(819),
      ShortestBetween: __webpack_require__(820),
      Wrap: __webpack_require__(269),
      WrapDegrees: __webpack_require__(270)
    };
  }, function (module, exports) {
    module.exports = function (point1, point2) {
      return Math.atan2(point2.x - point1.x, point2.y - point1.y);
    };
  }, function (module, exports) {
    module.exports = function (x1, y1, x2, y2) {
      return Math.atan2(x2 - x1, y2 - y1);
    };
  }, function (module, exports, __webpack_require__) {
    var CONST = __webpack_require__(14);

    module.exports = function (angle) {
      return angle > Math.PI && (angle -= CONST.PI2), Math.abs(((angle + CONST.TAU) % CONST.PI2 - CONST.PI2) % CONST.PI2);
    };
  }, function (module, exports, __webpack_require__) {
    var FloatBetween = __webpack_require__(137);

    module.exports = function () {
      return FloatBetween(-Math.PI, Math.PI);
    };
  }, function (module, exports, __webpack_require__) {
    var FloatBetween = __webpack_require__(137);

    module.exports = function () {
      return FloatBetween(-180, 180);
    };
  }, function (module, exports, __webpack_require__) {
    var Normalize = __webpack_require__(351);

    module.exports = function (angle) {
      return Normalize(angle + Math.PI);
    };
  }, function (module, exports, __webpack_require__) {
    var MATH_CONST = __webpack_require__(14);

    module.exports = function (currentAngle, targetAngle, lerp) {
      return void 0 === lerp && (lerp = .05), currentAngle === targetAngle || (Math.abs(targetAngle - currentAngle) <= lerp || Math.abs(targetAngle - currentAngle) >= MATH_CONST.PI2 - lerp ? currentAngle = targetAngle : (Math.abs(targetAngle - currentAngle) > Math.PI && (targetAngle < currentAngle ? targetAngle += MATH_CONST.PI2 : targetAngle -= MATH_CONST.PI2), currentAngle < targetAngle ? currentAngle += lerp : targetAngle < currentAngle && (currentAngle -= lerp))), currentAngle;
    };
  }, function (module, exports) {
    module.exports = function (difference, angle2) {
      difference = angle2 - difference;
      return 0 == difference ? 0 : difference - 360 * Math.floor((difference + 180) / 360);
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      Between: __webpack_require__(50),
      BetweenPoints: __webpack_require__(352),
      BetweenPointsSquared: __webpack_require__(822),
      Chebyshev: __webpack_require__(823),
      Power: __webpack_require__(824),
      Snake: __webpack_require__(825),
      Squared: __webpack_require__(353)
    };
  }, function (module, exports) {
    module.exports = function (a, dy) {
      var dx = a.x - dy.x,
          dy = a.y - dy.y;
      return dx * dx + dy * dy;
    };
  }, function (module, exports) {
    module.exports = function (x1, y1, x2, y2) {
      return Math.max(Math.abs(x1 - x2), Math.abs(y1 - y2));
    };
  }, function (module, exports) {
    module.exports = function (x1, y1, x2, y2, pow) {
      return void 0 === pow && (pow = 2), Math.sqrt(Math.pow(x2 - x1, pow) + Math.pow(y2 - y1, pow));
    };
  }, function (module, exports) {
    module.exports = function (x1, y1, x2, y2) {
      return Math.abs(x1 - x2) + Math.abs(y1 - y2);
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      Back: __webpack_require__(334),
      Bounce: __webpack_require__(335),
      Circular: __webpack_require__(336),
      Cubic: __webpack_require__(337),
      Elastic: __webpack_require__(338),
      Expo: __webpack_require__(339),
      Linear: __webpack_require__(340),
      Quadratic: __webpack_require__(341),
      Quartic: __webpack_require__(342),
      Quintic: __webpack_require__(343),
      Sine: __webpack_require__(344),
      Stepped: __webpack_require__(345)
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      Ceil: __webpack_require__(828),
      Equal: __webpack_require__(124),
      Floor: __webpack_require__(829),
      GreaterThan: __webpack_require__(354),
      LessThan: __webpack_require__(355)
    };
  }, function (module, exports) {
    module.exports = function (value, epsilon) {
      return void 0 === epsilon && (epsilon = 1e-4), Math.ceil(value - epsilon);
    };
  }, function (module, exports) {
    module.exports = function (value, epsilon) {
      return void 0 === epsilon && (epsilon = 1e-4), Math.floor(value + epsilon);
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      Bezier: __webpack_require__(831),
      CatmullRom: __webpack_require__(832),
      CubicBezier: __webpack_require__(358),
      Linear: __webpack_require__(833),
      QuadraticBezier: __webpack_require__(359),
      SmoothStep: __webpack_require__(360),
      SmootherStep: __webpack_require__(834)
    };
  }, function (module, exports, __webpack_require__) {
    var Bernstein = __webpack_require__(356);

    module.exports = function (v, k) {
      for (var b = 0, n = v.length - 1, i = 0; i <= n; i++) {
        b += Math.pow(1 - k, n - i) * Math.pow(k, i) * v[i] * Bernstein(n, i);
      }

      return b;
    };
  }, function (module, exports, __webpack_require__) {
    var CatmullRom = __webpack_require__(194);

    module.exports = function (v, k) {
      var m = v.length - 1,
          f = m * k,
          i = Math.floor(f);
      return v[0] === v[m] ? (k < 0 && (i = Math.floor(f = m * (1 + k))), CatmullRom(f - i, v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m])) : k < 0 ? v[0] - (CatmullRom(-f, v[0], v[0], v[1], v[1]) - v[0]) : 1 < k ? v[m] - (CatmullRom(f - m, v[m], v[m], v[m - 1], v[m - 1]) - v[m]) : CatmullRom(f - i, v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2]);
    };
  }, function (module, exports, __webpack_require__) {
    var Linear = __webpack_require__(135);

    module.exports = function (v, k) {
      var m = v.length - 1,
          f = m * k,
          i = Math.floor(f);
      return k < 0 ? Linear(v[0], v[1], f) : 1 < k ? Linear(v[m], v[m - 1], m - f) : Linear(v[i], v[m < i + 1 ? m : i + 1], f - i);
    };
  }, function (module, exports, __webpack_require__) {
    var SmootherStep = __webpack_require__(183);

    module.exports = function (t, min, max) {
      return min + (max - min) * SmootherStep(t, 0, 1);
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      GetNext: __webpack_require__(361),
      IsSize: __webpack_require__(138),
      IsValue: __webpack_require__(836)
    };
  }, function (module, exports) {
    module.exports = function (value) {
      return 0 < value && 0 == (value & value - 1);
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      Ceil: __webpack_require__(139),
      Floor: __webpack_require__(76),
      To: __webpack_require__(838)
    };
  }, function (module, exports) {
    module.exports = function (value, gap, start, divide) {
      return 0 === gap ? value : (value -= start = void 0 === start ? 0 : start, value = gap * Math.round(value / gap), divide ? (start + value) / gap : start + value);
    };
  }, function (module, exports, RandomDataGenerator) {
    RandomDataGenerator = new (RandomDataGenerator(0))({
      initialize: function initialize(seeds) {
        void 0 === seeds && (seeds = [(Date.now() * Math.random()).toString()]), this.c = 1, this.s0 = 0, this.s1 = 0, this.s2 = 0, this.n = 0, this.signs = [-1, 1], seeds && this.init(seeds);
      },
      rnd: function rnd() {
        var t = 2091639 * this.s0 + 2.3283064365386963e-10 * this.c;
        return this.c = 0 | t, this.s0 = this.s1, this.s1 = this.s2, this.s2 = t - this.c, this.s2;
      },
      hash: function hash(data) {
        var h,
            n = this.n;
        data = data.toString();

        for (var i = 0; i < data.length; i++) {
          h = .02519603282416938 * (n += data.charCodeAt(i)), h -= n = h >>> 0, n = (h *= n) >>> 0, n += 4294967296 * (h -= n);
        }

        return 2.3283064365386963e-10 * ((this.n = n) >>> 0);
      },
      init: function init(seeds) {
        "string" == typeof seeds ? this.state(seeds) : this.sow(seeds);
      },
      sow: function sow(seeds) {
        if (this.n = 4022871197, this.s0 = this.hash(" "), this.s1 = this.hash(" "), this.s2 = this.hash(" "), this.c = 1, seeds) for (var i = 0; i < seeds.length && null != seeds[i]; i++) {
          var seed = seeds[i];
          this.s0 -= this.hash(seed), this.s0 += ~~(this.s0 < 0), this.s1 -= this.hash(seed), this.s1 += ~~(this.s1 < 0), this.s2 -= this.hash(seed), this.s2 += ~~(this.s2 < 0);
        }
      },
      integer: function integer() {
        return 4294967296 * this.rnd();
      },
      frac: function frac() {
        return this.rnd() + 11102230246251565e-32 * (2097152 * this.rnd() | 0);
      },
      real: function real() {
        return this.integer() + this.frac();
      },
      integerInRange: function integerInRange(min, max) {
        return Math.floor(this.realInRange(0, max - min + 1) + min);
      },
      between: function between(min, max) {
        return Math.floor(this.realInRange(0, max - min + 1) + min);
      },
      realInRange: function realInRange(min, max) {
        return this.frac() * (max - min) + min;
      },
      normal: function normal() {
        return 1 - 2 * this.frac();
      },
      uuid: function uuid() {
        for (var a = "", b = "", b = a = ""; a++ < 36; b += ~a % 5 | 3 * a & 4 ? (15 ^ a ? 8 ^ this.frac() * (20 ^ a ? 16 : 4) : 4).toString(16) : "-") {
          ;
        }

        return b;
      },
      pick: function pick(array) {
        return array[this.integerInRange(0, array.length - 1)];
      },
      sign: function sign() {
        return this.pick(this.signs);
      },
      weightedPick: function weightedPick(array) {
        return array[~~(Math.pow(this.frac(), 2) * (array.length - 1) + .5)];
      },
      timestamp: function timestamp(min, max) {
        return this.realInRange(min || 9466848e5, max || 1577862e6);
      },
      angle: function angle() {
        return this.integerInRange(-180, 180);
      },
      rotation: function rotation() {
        return this.realInRange(-3.1415926, 3.1415926);
      },
      state: function state(_state) {
        return "string" == typeof _state && _state.match(/^!rnd/) && (_state = _state.split(","), this.c = parseFloat(_state[1]), this.s0 = parseFloat(_state[2]), this.s1 = parseFloat(_state[3]), this.s2 = parseFloat(_state[4])), ["!rnd", this.c, this.s0, this.s1, this.s2].join(",");
      },
      shuffle: function shuffle(array) {
        for (var i = array.length - 1; 0 < i; i--) {
          var randomIndex = Math.floor(this.frac() * (i + 1)),
              itemAtIndex = array[randomIndex];
          array[randomIndex] = array[i], array[i] = itemAtIndex;
        }

        return array;
      }
    });
    module.exports = RandomDataGenerator;
  }, function (module, exports) {
    module.exports = function (values) {
      for (var sum = 0, i = 0; i < values.length; i++) {
        sum += +values[i];
      }

      return sum / values.length;
    };
  }, function (module, exports) {
    module.exports = function (value, p, base) {
      void 0 === p && (p = 0), void 0 === base && (base = 10);
      p = Math.pow(base, -p);
      return Math.ceil(value * p) / p;
    };
  }, function (module, exports) {
    module.exports = function (a, b) {
      return Math.abs(a - b);
    };
  }, function (module, exports, __webpack_require__) {
    var Clamp = __webpack_require__(18),
        Euler = __webpack_require__(0),
        Matrix4 = __webpack_require__(69),
        NOOP = __webpack_require__(1),
        tempMatrix = new Matrix4(),
        Euler = new Euler({
      initialize: function Euler(x, y, z, order) {
        void 0 === y && (y = 0), void 0 === z && (z = 0), void 0 === order && (order = Euler.DefaultOrder), this._x = x = void 0 === x ? 0 : x, this._y = y, this._z = z, this._order = order, this.onChangeCallback = NOOP;
      },
      x: {
        get: function get() {
          return this._x;
        },
        set: function set(value) {
          this._x = value, this.onChangeCallback(this);
        }
      },
      y: {
        get: function get() {
          return this._y;
        },
        set: function set(value) {
          this._y = value, this.onChangeCallback(this);
        }
      },
      z: {
        get: function get() {
          return this._z;
        },
        set: function set(value) {
          this._z = value, this.onChangeCallback(this);
        }
      },
      order: {
        get: function get() {
          return this._order;
        },
        set: function set(value) {
          this._order = value, this.onChangeCallback(this);
        }
      },
      set: function set(x, y, z, order) {
        return void 0 === order && (order = this._order), this._x = x, this._y = y, this._z = z, this._order = order, this.onChangeCallback(this), this;
      },
      copy: function copy(euler) {
        return this.set(euler.x, euler.y, euler.z, euler.order);
      },
      setFromQuaternion: function setFromQuaternion(quaternion, order, update) {
        return void 0 === order && (order = this._order), void 0 === update && (update = !1), tempMatrix.fromQuat(quaternion), this.setFromRotationMatrix(tempMatrix, order, update);
      },
      setFromRotationMatrix: function setFromRotationMatrix(elements, order, update) {
        void 0 === order && (order = this._order), void 0 === update && (update = !1);
        var elements = elements.val,
            m11 = elements[0],
            m12 = elements[4],
            m13 = elements[8],
            m21 = elements[1],
            m22 = elements[5],
            m23 = elements[9],
            m31 = elements[2],
            m32 = elements[6],
            m33 = elements[10],
            x = 0,
            y = 0,
            z = 0;

        switch (order) {
          case "XYZ":
            y = Math.asin(Clamp(m13, -1, 1)), Math.abs(m13) < .99999 ? (x = Math.atan2(-m23, m33), z = Math.atan2(-m12, m11)) : x = Math.atan2(m32, m22);
            break;

          case "YXZ":
            x = Math.asin(-Clamp(m23, -1, 1)), Math.abs(m23) < .99999 ? (y = Math.atan2(m13, m33), z = Math.atan2(m21, m22)) : y = Math.atan2(-m31, m11);
            break;

          case "ZXY":
            x = Math.asin(Clamp(m32, -1, 1)), z = Math.abs(m32) < .99999 ? (y = Math.atan2(-m31, m33), Math.atan2(-m12, m22)) : Math.atan2(m21, m11);
            break;

          case "ZYX":
            y = Math.asin(-Clamp(m31, -1, 1)), z = Math.abs(m31) < .99999 ? (x = Math.atan2(m32, m33), Math.atan2(m21, m11)) : Math.atan2(-m12, m22);
            break;

          case "YZX":
            z = Math.asin(Clamp(m21, -1, 1)), y = Math.abs(m21) < .99999 ? (x = Math.atan2(-m23, m22), Math.atan2(-m31, m11)) : Math.atan2(m13, m33);
            break;

          case "XZY":
            z = Math.asin(-Clamp(m12, -1, 1)), Math.abs(m12) < .99999 ? (x = Math.atan2(m32, m22), y = Math.atan2(m13, m11)) : x = Math.atan2(-m23, m33);
        }

        return this._x = x, this._y = y, this._z = z, this._order = order, update && this.onChangeCallback(this), this;
      }
    });

    Euler.RotationOrders = ["XYZ", "YXZ", "ZXY", "ZYX", "YZX", "XZY"], Euler.DefaultOrder = "XYZ", module.exports = Euler;
  }, function (module, exports) {
    module.exports = function (value, p, base) {
      void 0 === p && (p = 0), void 0 === base && (base = 10);
      p = Math.pow(base, -p);
      return Math.floor(value * p) / p;
    };
  }, function (module, exports) {
    module.exports = function (distance, time) {
      return distance / time / 1e3;
    };
  }, function (module, exports) {
    module.exports = function (value) {
      return value == parseFloat(value) ? !(value % 2) : void 0;
    };
  }, function (module, exports) {
    module.exports = function (value) {
      return value === parseFloat(value) ? !(value % 2) : void 0;
    };
  }, function (module, exports) {
    module.exports = function (value, amount, max) {
      return Math.min(value + amount, max);
    };
  }, function (module, exports) {
    module.exports = function (values) {
      var valuesNum = values.length;
      if (0 === valuesNum) return 0;
      values.sort(function (a, b) {
        return a - b;
      });
      var halfIndex = Math.floor(valuesNum / 2);
      return valuesNum % 2 == 0 ? (values[halfIndex] + values[halfIndex - 1]) / 2 : values[halfIndex];
    };
  }, function (module, exports) {
    module.exports = function (value, amount, min) {
      return Math.max(value - amount, min);
    };
  }, function (module, exports) {
    module.exports = function (value, percentage, max, upperMax) {
      percentage = (value - percentage) / ((max = void 0 === max ? percentage + 1 : max) - percentage);
      return 1 < percentage ? void 0 !== upperMax ? (percentage = (upperMax - value) / (upperMax - max)) < 0 && (percentage = 0) : percentage = 1 : percentage < 0 && (percentage = 0), percentage;
    };
  }, function (module, exports) {
    module.exports = function (vector, scale) {
      void 0 === scale && (scale = 1);
      var r = 2 * Math.random() * Math.PI;
      return vector.x = Math.cos(r) * scale, vector.y = Math.sin(r) * scale, vector;
    };
  }, function (module, exports) {
    module.exports = function (vec3, radius) {
      void 0 === radius && (radius = 1);
      var r = 2 * Math.random() * Math.PI,
          z = 2 * Math.random() - 1,
          zScale = Math.sqrt(1 - z * z) * radius;
      return vec3.x = Math.cos(r) * zScale, vec3.y = Math.sin(r) * zScale, vec3.z = z * radius, vec3;
    };
  }, function (module, exports) {
    module.exports = function (vec4, scale) {
      return void 0 === scale && (scale = 1), vec4.x = (2 * Math.random() - 1) * scale, vec4.y = (2 * Math.random() - 1) * scale, vec4.z = (2 * Math.random() - 1) * scale, vec4.w = (2 * Math.random() - 1) * scale, vec4;
    };
  }, function (module, exports) {
    module.exports = function (point, x, y, angle, distance) {
      return point.x = x + distance * Math.cos(angle), point.y = y + distance * Math.sin(angle), point;
    };
  }, function (module, exports) {
    module.exports = function (value, p, base) {
      void 0 === p && (p = 0), void 0 === base && (base = 10);
      p = Math.pow(base, -p);
      return Math.round(value * p) / p;
    };
  }, function (module, exports) {
    module.exports = function (length, sinAmp, cosAmp, frequency) {
      void 0 === sinAmp && (sinAmp = 1), void 0 === cosAmp && (cosAmp = 1), void 0 === frequency && (frequency = 1), frequency *= Math.PI / length;

      for (var cos = [], sin = [], c = 0; c < length; c++) {
        sinAmp += (cosAmp -= sinAmp * frequency) * frequency, cos[c] = cosAmp, sin[c] = sinAmp;
      }

      return {
        sin: sin,
        cos: cos,
        length: length
      };
    };
  }, function (module, exports, __webpack_require__) {
    var Vector2 = __webpack_require__(3);

    module.exports = function (index, width, height, out) {
      void 0 === out && (out = new Vector2());
      var x = 0,
          y = 0;
      return 0 < index && index <= width * height && (x = width - 1 < index ? index - (y = Math.floor(index / width)) * width : index), out.set(x, y);
    };
  }, function (module, exports) {
    module.exports = function (a, b, tolerance) {
      return Math.abs(a - b) <= tolerance;
    };
  }, function (module, exports, Quaternion) {
    var Vector3 = Quaternion(39),
        Matrix4 = Quaternion(69),
        Quaternion = Quaternion(365),
        tmpMat4 = new Matrix4(),
        tmpQuat = new Quaternion(),
        tmpVec3 = new Vector3();

    module.exports = function (vec, axis, radians) {
      return tmpQuat.setAxisAngle(axis, radians), tmpMat4.fromRotationTranslation(tmpQuat, tmpVec3.set(0, 0, 0)), vec.transformMat4(tmpMat4);
    };
  }, function (module, exports) {
    module.exports = "addtexture";
  }, function (module, exports) {
    module.exports = "onerror";
  }, function (module, exports) {
    module.exports = "onload";
  }, function (module, exports) {
    module.exports = "ready";
  }, function (module, exports) {
    module.exports = "removetexture";
  }, function (module, exports) {
    module.exports = ["#define SHADER_NAME PHASER_BITMAP_MASK_FS", "", "precision mediump float;", "", "uniform vec2 uResolution;", "uniform sampler2D uMainSampler;", "uniform sampler2D uMaskSampler;", "uniform bool uInvertMaskAlpha;", "", "void main ()", "{", "    vec2 uv = gl_FragCoord.xy / uResolution;", "    vec4 mainColor = texture2D(uMainSampler, uv);", "    vec4 maskColor = texture2D(uMaskSampler, uv);", "    float alpha = mainColor.a;", "", "    if (!uInvertMaskAlpha)", "    {", "        alpha *= (maskColor.a);", "    }", "    else", "    {", "        alpha *= (1.0 - maskColor.a);", "    }", "", "    gl_FragColor = vec4(mainColor.rgb * alpha, alpha);", "}", ""].join("\n");
  }, function (module, exports) {
    module.exports = ["#define SHADER_NAME PHASER_BITMAP_MASK_VS", "", "precision mediump float;", "", "attribute vec2 inPosition;", "", "void main ()", "{", "    gl_Position = vec4(inPosition, 0.0, 1.0);", "}", ""].join("\n");
  }, function (module, exports) {
    module.exports = "pipelineafterflush";
  }, function (module, exports) {
    module.exports = "pipelinebeforeflush";
  }, function (module, exports) {
    module.exports = "pipelinebind";
  }, function (module, exports) {
    module.exports = "pipelineboot";
  }, function (module, exports) {
    module.exports = "pipelinedestroy";
  }, function (module, exports) {
    module.exports = "pipelinerebind";
  }, function (module, exports) {
    module.exports = "pipelineresize";
  }, function (module, exports) {
    module.exports = ["#define SHADER_NAME PHASER_GRAPHICS_FS", "", "precision mediump float;", "", "varying vec4 outColor;", "", "void main ()", "{", "    gl_FragColor = vec4(outColor.bgr * outColor.a, outColor.a);", "}", ""].join("\n");
  }, function (module, exports) {
    module.exports = ["#define SHADER_NAME PHASER_GRAPHICS_VS", "", "precision mediump float;", "", "uniform mat4 uProjectionMatrix;", "", "attribute vec2 inPosition;", "attribute vec4 inColor;", "", "varying vec4 outColor;", "", "void main ()", "{", "    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);", "", "    outColor = inColor;", "}", ""].join("\n");
  }, function (module, exports) {
    module.exports = ["#define SHADER_NAME PHASER_LIGHT_FS", "", "precision mediump float;", "", "struct Light", "{", "    vec2 position;", "    vec3 color;", "    float intensity;", "    float radius;", "};", "", "const int kMaxLights = %LIGHT_COUNT%;", "", "uniform vec4 uCamera; /* x, y, rotation, zoom */", "uniform vec2 uResolution;", "uniform sampler2D uMainSampler;", "uniform sampler2D uNormSampler;", "uniform vec3 uAmbientLightColor;", "uniform Light uLights[kMaxLights];", "uniform mat3 uInverseRotationMatrix;", "", "varying vec2 outTexCoord;", "varying vec4 outTint;", "", "void main()", "{", "    vec3 finalColor = vec3(0.0, 0.0, 0.0);", "    vec4 color = texture2D(uMainSampler, outTexCoord) * vec4(outTint.bgr * outTint.a, outTint.a);", "    vec3 normalMap = texture2D(uNormSampler, outTexCoord).rgb;", "    vec3 normal = normalize(uInverseRotationMatrix * vec3(normalMap * 2.0 - 1.0));", "    vec2 res = vec2(min(uResolution.x, uResolution.y)) * uCamera.w;", "", "    for (int index = 0; index < kMaxLights; ++index)", "    {", "        Light light = uLights[index];", "        vec3 lightDir = vec3((light.position.xy / res) - (gl_FragCoord.xy / res), 0.1);", "        vec3 lightNormal = normalize(lightDir);", "        float distToSurf = length(lightDir) * uCamera.w;", "        float diffuseFactor = max(dot(normal, lightNormal), 0.0);", "        float radius = (light.radius / res.x * uCamera.w) * uCamera.w;", "        float attenuation = clamp(1.0 - distToSurf * distToSurf / (radius * radius), 0.0, 1.0);", "        vec3 diffuse = light.color * diffuseFactor;", "        finalColor += (attenuation * diffuse) * light.intensity;", "    }", "", "    vec4 colorOutput = vec4(uAmbientLightColor + finalColor, 1.0);", "", "    gl_FragColor = color * vec4(colorOutput.rgb * colorOutput.a, colorOutput.a);", "}", ""].join("\n");
  }, function (module, exports) {
    module.exports = ["#define SHADER_NAME PHASER_MULTI_FS", "", "precision mediump float;", "", "uniform sampler2D uMainSampler[%count%];", "", "varying vec2 outTexCoord;", "varying float outTexId;", "varying float outTintEffect;", "varying vec4 outTint;", "", "void main ()", "{", "    vec4 texture;", "", "    %forloop%", "", "    vec4 texel = vec4(outTint.bgr * outTint.a, outTint.a);", "", "    //  Multiply texture tint", "    vec4 color = texture * texel;", "", "    if (outTintEffect == 1.0)", "    {", "        //  Solid color + texture alpha", "        color.rgb = mix(texture.rgb, outTint.bgr * outTint.a, texture.a);", "    }", "    else if (outTintEffect == 2.0)", "    {", "        //  Solid color, no texture", "        color = texel;", "    }", "", "    gl_FragColor = color;", "}", ""].join("\n");
  }, function (module, exports) {
    module.exports = ["#define SHADER_NAME PHASER_MULTI_VS", "", "precision mediump float;", "", "uniform mat4 uProjectionMatrix;", "", "attribute vec2 inPosition;", "attribute vec2 inTexCoord;", "attribute float inTexId;", "attribute float inTintEffect;", "attribute vec4 inTint;", "", "varying vec2 outTexCoord;", "varying float outTexId;", "varying float outTintEffect;", "varying vec4 outTint;", "", "void main ()", "{", "    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);", "", "    outTexCoord = inTexCoord;", "    outTexId = inTexId;", "    outTint = inTint;", "    outTintEffect = inTintEffect;", "}", ""].join("\n");
  }, function (module, exports) {
    module.exports = ["#define SHADER_NAME PHASER_POINTLIGHT_FS", "", "precision mediump float;", "", "uniform vec2 uResolution;", "uniform float uCameraZoom;", "", "varying vec4 lightPosition;", "varying vec4 lightColor;", "varying float lightRadius;", "varying float lightAttenuation;", "", "void main ()", "{", "    vec2 center = (lightPosition.xy + 1.0) * (uResolution.xy * 0.5);", "", "    float distToSurf = length(center - gl_FragCoord.xy);", "", "    float radius = 1.0 - distToSurf / (lightRadius * uCameraZoom);", "", "    float intensity = smoothstep(0.0, 1.0, radius * lightAttenuation);", "", "    vec4 color = vec4(intensity, intensity, intensity, 0.0) * lightColor;", "", "    gl_FragColor = vec4(color.rgb * lightColor.a, color.a);", "}", ""].join("\n");
  }, function (module, exports) {
    module.exports = ["#define SHADER_NAME PHASER_POINTLIGHT_VS", "", "precision mediump float;", "", "uniform mat4 uProjectionMatrix;", "", "attribute vec2 inPosition;", "attribute vec2 inLightPosition;", "attribute vec4 inLightColor;", "attribute float inLightRadius;", "attribute float inLightAttenuation;", "", "varying vec4 lightPosition;", "varying vec4 lightColor;", "varying float lightRadius;", "varying float lightAttenuation;", "", "void main ()", "{", "    lightColor = inLightColor;", "    lightRadius = inLightRadius;", "    lightAttenuation = inLightAttenuation;", "    lightPosition = uProjectionMatrix * vec4(inLightPosition, 1.0, 1.0);", "", "    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);", "}", ""].join("\n");
  }, function (module, exports) {
    module.exports = ["#define SHADER_NAME PHASER_SINGLE_FS", "", "precision mediump float;", "", "uniform sampler2D uMainSampler;", "", "varying vec2 outTexCoord;", "varying float outTintEffect;", "varying vec4 outTint;", "", "void main ()", "{", "    vec4 texture = texture2D(uMainSampler, outTexCoord);", "    vec4 texel = vec4(outTint.bgr * outTint.a, outTint.a);", "", "    //  Multiply texture tint", "    vec4 color = texture * texel;", "", "    if (outTintEffect == 1.0)", "    {", "        //  Solid color + texture alpha", "        color.rgb = mix(texture.rgb, outTint.bgr * outTint.a, texture.a);", "    }", "    else if (outTintEffect == 2.0)", "    {", "        //  Solid color, no texture", "        color = texel;", "    }", "", "    gl_FragColor = color;", "}", ""].join("\n");
  }, function (module, exports) {
    module.exports = ["#define SHADER_NAME PHASER_SINGLE_VS", "", "precision mediump float;", "", "uniform mat4 uProjectionMatrix;", "", "attribute vec2 inPosition;", "attribute vec2 inTexCoord;", "attribute float inTexId;", "attribute float inTintEffect;", "attribute vec4 inTint;", "", "varying vec2 outTexCoord;", "varying float outTintEffect;", "varying vec4 outTint;", "", "void main ()", "{", "    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);", "", "    outTexCoord = inTexCoord;", "    outTint = inTint;", "    outTintEffect = inTintEffect;", "}", ""].join("\n");
  }, function (module, exports) {
    module.exports = ["#define SHADER_NAME PHASER_ADD_BLEND_FS", "", "precision mediump float;", "", "uniform sampler2D uMainSampler1;", "uniform sampler2D uMainSampler2;", "uniform float uStrength;", "", "varying vec2 outTexCoord;", "", "void main ()", "{", "    vec4 frame1 = texture2D(uMainSampler1, outTexCoord);", "    vec4 frame2 = texture2D(uMainSampler2, outTexCoord);", "", "    gl_FragColor = frame1 + frame2 * uStrength;", "}", ""].join("\n");
  }, function (module, exports) {
    module.exports = ["#define SHADER_NAME PHASER_COLORMATRIX_FS", "", "precision mediump float;", "", "uniform sampler2D uMainSampler;", "uniform float uColorMatrix[20];", "uniform float uAlpha;", "", "varying vec2 outTexCoord;", "", "void main ()", "{", "    vec4 c = texture2D(uMainSampler, outTexCoord);", "", "    if (uAlpha == 0.0)", "    {", "        gl_FragColor = c;", "", "        return;", "    }", "", "    if (c.a > 0.0)", "    {", "        c.rgb /= c.a;", "    }", "", "    vec4 result;", "", "    result.r = (uColorMatrix[0] * c.r) + (uColorMatrix[1] * c.g) + (uColorMatrix[2] * c.b) + (uColorMatrix[3] * c.a) + uColorMatrix[4];", "    result.g = (uColorMatrix[5] * c.r) + (uColorMatrix[6] * c.g) + (uColorMatrix[7] * c.b) + (uColorMatrix[8] * c.a) + uColorMatrix[9];", "    result.b = (uColorMatrix[10] * c.r) + (uColorMatrix[11] * c.g) + (uColorMatrix[12] * c.b) + (uColorMatrix[13] * c.a) + uColorMatrix[14];", "    result.a = (uColorMatrix[15] * c.r) + (uColorMatrix[16] * c.g) + (uColorMatrix[17] * c.b) + (uColorMatrix[18] * c.a) + uColorMatrix[19];", "", "    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);", "", "    rgb *= result.a;", "", "    gl_FragColor = vec4(rgb, result.a);", "}", ""].join("\n");
  }, function (module, exports) {
    module.exports = ["#define SHADER_NAME PHASER_COPY_FS", "", "precision mediump float;", "", "uniform sampler2D uMainSampler;", "uniform float uBrightness;", "", "varying vec2 outTexCoord;", "", "void main ()", "{", "    gl_FragColor = texture2D(uMainSampler, outTexCoord) * uBrightness;", "}", ""].join("\n");
  }, function (module, exports) {
    module.exports = ["#define SHADER_NAME PHASER_LINEAR_BLEND_FS", "", "precision mediump float;", "", "uniform sampler2D uMainSampler1;", "uniform sampler2D uMainSampler2;", "uniform float uStrength;", "", "varying vec2 outTexCoord;", "", "void main ()", "{", "    vec4 frame1 = texture2D(uMainSampler1, outTexCoord);", "    vec4 frame2 = texture2D(uMainSampler2, outTexCoord);", "", "    gl_FragColor = mix(frame1, frame2 * uStrength, 0.5);", "}", ""].join("\n");
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      GenerateTexture: __webpack_require__(388),
      Palettes: __webpack_require__(889)
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      ARNE16: __webpack_require__(389),
      C64: __webpack_require__(890),
      CGA: __webpack_require__(891),
      JMP: __webpack_require__(892),
      MSX: __webpack_require__(893)
    };
  }, function (module, exports) {
    module.exports = {
      0: "#000",
      1: "#fff",
      2: "#8b4131",
      3: "#7bbdc5",
      4: "#8b41ac",
      5: "#6aac41",
      6: "#3931a4",
      7: "#d5de73",
      8: "#945a20",
      9: "#5a4100",
      A: "#bd736a",
      B: "#525252",
      C: "#838383",
      D: "#acee8b",
      E: "#7b73de",
      F: "#acacac"
    };
  }, function (module, exports) {
    module.exports = {
      0: "#000",
      1: "#2234d1",
      2: "#0c7e45",
      3: "#44aacc",
      4: "#8a3622",
      5: "#5c2e78",
      6: "#aa5c3d",
      7: "#b5b5b5",
      8: "#5e606e",
      9: "#4c81fb",
      A: "#6cd947",
      B: "#7be2f9",
      C: "#eb8a60",
      D: "#e23d69",
      E: "#ffd93f",
      F: "#fff"
    };
  }, function (module, exports) {
    module.exports = {
      0: "#000",
      1: "#191028",
      2: "#46af45",
      3: "#a1d685",
      4: "#453e78",
      5: "#7664fe",
      6: "#833129",
      7: "#9ec2e8",
      8: "#dc534b",
      9: "#e18d79",
      A: "#d6b97b",
      B: "#e9d8a1",
      C: "#216c4b",
      D: "#d365c8",
      E: "#afaab9",
      F: "#f5f4eb"
    };
  }, function (module, exports) {
    module.exports = {
      0: "#000",
      1: "#191028",
      2: "#46af45",
      3: "#a1d685",
      4: "#453e78",
      5: "#7664fe",
      6: "#833129",
      7: "#9ec2e8",
      8: "#dc534b",
      9: "#e18d79",
      A: "#d6b97b",
      B: "#e9d8a1",
      C: "#216c4b",
      D: "#d365c8",
      E: "#afaab9",
      F: "#fff"
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      Path: __webpack_require__(895),
      MoveTo: __webpack_require__(393),
      CubicBezier: __webpack_require__(390),
      Curve: __webpack_require__(94),
      Ellipse: __webpack_require__(391),
      Line: __webpack_require__(392),
      QuadraticBezier: __webpack_require__(394),
      Spline: __webpack_require__(395)
    };
  }, function (module, exports, __webpack_require__) {
    var Class = __webpack_require__(0),
        CubicBezierCurve = __webpack_require__(390),
        EllipseCurve = __webpack_require__(391),
        GameObjectFactory = __webpack_require__(5),
        LineCurve = __webpack_require__(392),
        MovePathTo = __webpack_require__(393),
        QuadraticBezierCurve = __webpack_require__(394),
        Rectangle = __webpack_require__(10),
        SplineCurve = __webpack_require__(395),
        Vector2 = __webpack_require__(3),
        MATH_CONST = __webpack_require__(14),
        Path = new Class({
      initialize: function initialize(x, y) {
        void 0 === x && (x = 0), void 0 === y && (y = 0), this.name = "", this.curves = [], this.cacheLengths = [], this.autoClose = !1, this.startPoint = new Vector2(), this._tmpVec2A = new Vector2(), this._tmpVec2B = new Vector2(), "object" == _typeof(x) ? this.fromJSON(x) : this.startPoint.set(x, y);
      },
      add: function add(curve) {
        return this.curves.push(curve), this;
      },
      circleTo: function circleTo(radius, clockwise, rotation) {
        return this.ellipseTo(radius, radius, 0, 360, clockwise = void 0 === clockwise ? !1 : clockwise, rotation);
      },
      closePath: function closePath() {
        var startPoint = this.curves[0].getPoint(0),
            endPoint = this.curves[this.curves.length - 1].getPoint(1);
        return startPoint.equals(endPoint) || this.curves.push(new LineCurve(endPoint, startPoint)), this;
      },
      cubicBezierTo: function cubicBezierTo(x, p3, control1X, control1Y, control2X, control2Y) {
        var p1,
            p2,
            p0 = this.getEndPoint(),
            p3 = x instanceof Vector2 ? (p1 = x, p2 = p3, control1X) : (p1 = new Vector2(control1X, control1Y), p2 = new Vector2(control2X, control2Y), new Vector2(x, p3));
        return this.add(new CubicBezierCurve(p0, p1, p2, p3));
      },
      quadraticBezierTo: function quadraticBezierTo(x, p2, controlX, controlY) {
        var p1,
            p0 = this.getEndPoint(),
            p2 = x instanceof Vector2 ? (p1 = x, p2) : (p1 = new Vector2(controlX, controlY), new Vector2(x, p2));
        return this.add(new QuadraticBezierCurve(p0, p1, p2));
      },
      draw: function draw(graphics, pointsTotal) {
        for (var i = 0; i < this.curves.length; i++) {
          var curve = this.curves[i];
          curve.active && curve.draw(graphics, pointsTotal);
        }

        return graphics;
      },
      ellipseTo: function ellipseTo(xRadius, yRadius, startAngle, ellipse, end, start) {
        ellipse = new EllipseCurve(0, 0, xRadius, yRadius, startAngle, ellipse, end, start), end = this.getEndPoint(this._tmpVec2A), start = ellipse.getStartPoint(this._tmpVec2B);
        return end.subtract(start), ellipse.x = end.x, ellipse.y = end.y, this.add(ellipse);
      },
      fromJSON: function fromJSON(data) {
        this.curves = [], this.cacheLengths = [], this.startPoint.set(data.x, data.y), this.autoClose = data.autoClose;

        for (var i = 0; i < data.curves.length; i++) {
          var curve = data.curves[i];

          switch (curve.type) {
            case "LineCurve":
              this.add(LineCurve.fromJSON(curve));
              break;

            case "EllipseCurve":
              this.add(EllipseCurve.fromJSON(curve));
              break;

            case "SplineCurve":
              this.add(SplineCurve.fromJSON(curve));
              break;

            case "CubicBezierCurve":
              this.add(CubicBezierCurve.fromJSON(curve));
              break;

            case "QuadraticBezierCurve":
              this.add(QuadraticBezierCurve.fromJSON(curve));
          }
        }

        return this;
      },
      getBounds: function getBounds(out, accuracy) {
        void 0 === accuracy && (accuracy = 16), (out = void 0 === out ? new Rectangle() : out).x = Number.MAX_VALUE, out.y = Number.MAX_VALUE;

        for (var bounds = new Rectangle(), maxRight = MATH_CONST.MIN_SAFE_INTEGER, maxBottom = MATH_CONST.MIN_SAFE_INTEGER, i = 0; i < this.curves.length; i++) {
          var curve = this.curves[i];
          curve.active && (curve.getBounds(bounds, accuracy), out.x = Math.min(out.x, bounds.x), out.y = Math.min(out.y, bounds.y), maxRight = Math.max(maxRight, bounds.right), maxBottom = Math.max(maxBottom, bounds.bottom));
        }

        return out.right = maxRight, out.bottom = maxBottom, out;
      },
      getCurveLengths: function getCurveLengths() {
        if (this.cacheLengths.length === this.curves.length) return this.cacheLengths;

        for (var lengths = [], sums = 0, i = 0; i < this.curves.length; i++) {
          sums += this.curves[i].getLength(), lengths.push(sums);
        }

        return this.cacheLengths = lengths;
      },
      getEndPoint: function getEndPoint(out) {
        return void 0 === out && (out = new Vector2()), 0 < this.curves.length ? this.curves[this.curves.length - 1].getPoint(1, out) : out.copy(this.startPoint), out;
      },
      getLength: function getLength() {
        var lens = this.getCurveLengths();
        return lens[lens.length - 1];
      },
      getPoint: function getPoint(t, out) {
        void 0 === out && (out = new Vector2());

        for (var d = t * this.getLength(), curveLengths = this.getCurveLengths(), i = 0; i < curveLengths.length;) {
          if (curveLengths[i] >= d) {
            var diff = curveLengths[i] - d,
                curve = this.curves[i],
                segmentLength = curve.getLength();
            return curve.getPointAt(0 === segmentLength ? 0 : 1 - diff / segmentLength, out);
          }

          i++;
        }

        return null;
      },
      getPoints: function getPoints(divisions) {
        void 0 === divisions && (divisions = 12);

        for (var last, points = [], i = 0; i < this.curves.length; i++) {
          var curve = this.curves[i];
          if (curve.active) for (var resolution = curve.getResolution(divisions), pts = curve.getPoints(resolution), j = 0; j < pts.length; j++) {
            var point = pts[j];
            last && last.equals(point) || (points.push(point), last = point);
          }
        }

        return this.autoClose && 1 < points.length && !points[points.length - 1].equals(points[0]) && points.push(points[0]), points;
      },
      getRandomPoint: function getRandomPoint(out) {
        return void 0 === out && (out = new Vector2()), this.getPoint(Math.random(), out);
      },
      getSpacedPoints: function getSpacedPoints(divisions) {
        void 0 === divisions && (divisions = 40);

        for (var points = [], i = 0; i <= divisions; i++) {
          points.push(this.getPoint(i / divisions));
        }

        return this.autoClose && points.push(points[0]), points;
      },
      getStartPoint: function getStartPoint(out) {
        return (out = void 0 === out ? new Vector2() : out).copy(this.startPoint);
      },
      getTangent: function getTangent(t, out) {
        void 0 === out && (out = new Vector2());

        for (var d = t * this.getLength(), curveLengths = this.getCurveLengths(), i = 0; i < curveLengths.length;) {
          if (curveLengths[i] >= d) {
            var diff = curveLengths[i] - d,
                curve = this.curves[i],
                segmentLength = curve.getLength();
            return curve.getTangentAt(0 === segmentLength ? 0 : 1 - diff / segmentLength, out);
          }

          i++;
        }

        return null;
      },
      lineTo: function lineTo(x, end) {
        x instanceof Vector2 ? this._tmpVec2B.copy(x) : this._tmpVec2B.set(x, end);
        end = this.getEndPoint(this._tmpVec2A);
        return this.add(new LineCurve([end.x, end.y, this._tmpVec2B.x, this._tmpVec2B.y]));
      },
      splineTo: function splineTo(points) {
        return points.unshift(this.getEndPoint()), this.add(new SplineCurve(points));
      },
      moveTo: function moveTo(x, y) {
        return x instanceof Vector2 ? this.add(new MovePathTo(x.x, x.y)) : this.add(new MovePathTo(x, y));
      },
      toJSON: function toJSON() {
        for (var out = [], i = 0; i < this.curves.length; i++) {
          out.push(this.curves[i].toJSON());
        }

        return {
          type: "Path",
          x: this.startPoint.x,
          y: this.startPoint.y,
          autoClose: this.autoClose,
          curves: out
        };
      },
      updateArcLengths: function updateArcLengths() {
        this.cacheLengths = [], this.getCurveLengths();
      },
      destroy: function destroy() {
        this.curves.length = 0, this.cacheLengths.length = 0, this.startPoint = void 0;
      }
    });

    GameObjectFactory.register("path", function (x, y) {
      return new Path(x, y);
    }), module.exports = Path;
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      DataManager: __webpack_require__(101),
      DataManagerPlugin: __webpack_require__(897),
      Events: __webpack_require__(315)
    };
  }, function (module, exports, __webpack_require__) {
    var DataManagerPlugin = __webpack_require__(0),
        DataManager = __webpack_require__(101),
        PluginCache = __webpack_require__(24),
        SceneEvents = __webpack_require__(20),
        DataManagerPlugin = new DataManagerPlugin({
      Extends: DataManager,
      initialize: function initialize(scene) {
        DataManager.call(this, scene, scene.sys.events), this.scene = scene, this.systems = scene.sys, scene.sys.events.once(SceneEvents.BOOT, this.boot, this), scene.sys.events.on(SceneEvents.START, this.start, this);
      },
      boot: function boot() {
        this.events = this.systems.events, this.events.once(SceneEvents.DESTROY, this.destroy, this);
      },
      start: function start() {
        this.events.once(SceneEvents.SHUTDOWN, this.shutdown, this);
      },
      shutdown: function shutdown() {
        this.systems.events.off(SceneEvents.SHUTDOWN, this.shutdown, this);
      },
      destroy: function destroy() {
        DataManager.prototype.destroy.call(this), this.events.off(SceneEvents.START, this.start, this), this.scene = null, this.systems = null;
      }
    });

    PluginCache.register("DataManagerPlugin", DataManagerPlugin, "data"), module.exports = DataManagerPlugin;
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      Align: __webpack_require__(899),
      BaseShader: __webpack_require__(396),
      Bounds: __webpack_require__(902),
      Canvas: __webpack_require__(906),
      Color: __webpack_require__(397),
      ColorMatrix: __webpack_require__(198),
      Masks: __webpack_require__(916),
      RGB: __webpack_require__(200)
    };
  }, function (module, exports, Align) {
    var CONST = Align(123),
        Align = Align(17)(!1, Align = {
      In: Align(900),
      To: Align(901)
    }, CONST);
    module.exports = Align;
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      BottomCenter: __webpack_require__(290),
      BottomLeft: __webpack_require__(291),
      BottomRight: __webpack_require__(292),
      Center: __webpack_require__(293),
      LeftCenter: __webpack_require__(295),
      QuickSet: __webpack_require__(289),
      RightCenter: __webpack_require__(296),
      TopCenter: __webpack_require__(297),
      TopLeft: __webpack_require__(298),
      TopRight: __webpack_require__(299)
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      BottomCenter: __webpack_require__(277),
      BottomLeft: __webpack_require__(278),
      BottomRight: __webpack_require__(279),
      LeftBottom: __webpack_require__(280),
      LeftCenter: __webpack_require__(281),
      LeftTop: __webpack_require__(282),
      QuickSet: __webpack_require__(276),
      RightBottom: __webpack_require__(283),
      RightCenter: __webpack_require__(284),
      RightTop: __webpack_require__(285),
      TopCenter: __webpack_require__(286),
      TopLeft: __webpack_require__(287),
      TopRight: __webpack_require__(288)
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      CenterOn: __webpack_require__(294),
      GetBottom: __webpack_require__(42),
      GetBounds: __webpack_require__(903),
      GetCenterX: __webpack_require__(87),
      GetCenterY: __webpack_require__(89),
      GetLeft: __webpack_require__(43),
      GetOffsetX: __webpack_require__(904),
      GetOffsetY: __webpack_require__(905),
      GetRight: __webpack_require__(44),
      GetTop: __webpack_require__(45),
      SetBottom: __webpack_require__(55),
      SetCenterX: __webpack_require__(88),
      SetCenterY: __webpack_require__(90),
      SetLeft: __webpack_require__(53),
      SetRight: __webpack_require__(54),
      SetTop: __webpack_require__(52)
    };
  }, function (module, exports, __webpack_require__) {
    var GetBottom = __webpack_require__(42),
        GetLeft = __webpack_require__(43),
        GetRight = __webpack_require__(44),
        GetTop = __webpack_require__(45);

    module.exports = function (gameObject, output) {
      void 0 === output && (output = {});
      var left = GetLeft(gameObject),
          top = GetTop(gameObject);
      return output.x = left, output.y = top, output.width = GetRight(gameObject) - left, output.height = GetBottom(gameObject) - top, output;
    };
  }, function (module, exports) {
    module.exports = function (gameObject) {
      return gameObject.width * gameObject.originX;
    };
  }, function (module, exports) {
    module.exports = function (gameObject) {
      return gameObject.height * gameObject.originY;
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      CanvasInterpolation: __webpack_require__(367),
      CanvasPool: __webpack_require__(31),
      Smoothing: __webpack_require__(192),
      TouchAction: __webpack_require__(907),
      UserSelect: __webpack_require__(908)
    };
  }, function (module, exports) {
    module.exports = function (canvas, value) {
      return canvas.style.msTouchAction = value = void 0 === value ? "none" : value, canvas.style["ms-touch-action"] = value, canvas.style["touch-action"] = value, canvas;
    };
  }, function (module, exports) {
    module.exports = function (canvas, value) {
      void 0 === value && (value = "none");
      return ["-webkit-", "-khtml-", "-moz-", "-ms-", ""].forEach(function (vendor) {
        canvas.style[vendor + "user-select"] = value;
      }), canvas.style["-webkit-touch-callout"] = value, canvas.style["-webkit-tap-highlight-color"] = "rgba(0, 0, 0, 0)", canvas;
    };
  }, function (module, exports, __webpack_require__) {
    var GetColor = __webpack_require__(103);

    module.exports = function (limit) {
      void 0 === limit && (limit = 1024);
      var colors = [],
          r = 255,
          g = 0,
          b = 0;

      for (i = 0; i <= 255; i++) {
        colors.push({
          r: r,
          g: i,
          b: b,
          color: GetColor(r, i, b)
        });
      }

      for (i = g = 255; 0 <= i; i--) {
        colors.push({
          r: i,
          g: g,
          b: b,
          color: GetColor(i, g, b)
        });
      }

      for (i = r = 0; i <= 255; i++, g--) {
        colors.push({
          r: r,
          g: g,
          b: i,
          color: GetColor(r, g, i)
        });
      }

      for (b = 255, i = g = 0; i <= 255; i++, b--, r++) {
        colors.push({
          r: r,
          g: g,
          b: b,
          color: GetColor(r, g, b)
        });
      }

      if (1024 === limit) return colors;

      for (var out = [], t = 0, inc = 1024 / limit, i = 0; i < limit; i++) {
        out.push(colors[Math.floor(t)]), t += inc;
      }

      return out;
    };
  }, function (module, exports) {
    module.exports = function (color) {
      var output = {
        r: color >> 16 & 255,
        g: color >> 8 & 255,
        b: 255 & color,
        a: 255
      };
      return 16777215 < color && (output.a = color >>> 24), output;
    };
  }, function (module, exports, __webpack_require__) {
    var Color = __webpack_require__(38),
        HueToComponent = __webpack_require__(399);

    module.exports = function (h, p, q) {
      var r = q,
          g = q,
          b = q;
      return 0 !== p && (r = HueToComponent(p = 2 * q - (q = q < .5 ? q * (1 + p) : q + p - q * p), q, h + 1 / 3), g = HueToComponent(p, q, h), b = HueToComponent(p, q, h - 1 / 3)), new Color().setGLTo(r, g, b, 1);
    };
  }, function (module, exports, __webpack_require__) {
    var HSVToRGB = __webpack_require__(188);

    module.exports = function (s, v) {
      void 0 === s && (s = 1), void 0 === v && (v = 1);

      for (var colors = [], c = 0; c <= 359; c++) {
        colors.push(HSVToRGB(c / 359, s, v));
      }

      return colors;
    };
  }, function (module, exports, __webpack_require__) {
    function RGBWithRGB(r1, g1, b1, r2, g2, b2, t, index) {
      return t = (index = void 0 === index ? 0 : index) / (t = void 0 === t ? 100 : t), {
        r: Linear(r1, r2, t),
        g: Linear(g1, g2, t),
        b: Linear(b1, b2, t)
      };
    }

    var Linear = __webpack_require__(135);

    module.exports = {
      RGBWithRGB: RGBWithRGB,
      ColorWithRGB: function ColorWithRGB(color, r, g, b, length, index) {
        return RGBWithRGB(color.r, color.g, color.b, r, g, b, length = void 0 === length ? 100 : length, index = void 0 === index ? 0 : index);
      },
      ColorWithColor: function ColorWithColor(color1, color2, length, index) {
        return RGBWithRGB(color1.r, color1.g, color1.b, color2.r, color2.g, color2.b, length = void 0 === length ? 100 : length, index = void 0 === index ? 0 : index);
      }
    };
  }, function (module, exports, __webpack_require__) {
    var Between = __webpack_require__(195),
        Color = __webpack_require__(38);

    module.exports = function (min, max) {
      return new Color(Between(min = void 0 === min ? 0 : min, max = void 0 === max ? 255 : max), Between(min, max), Between(min, max));
    };
  }, function (module, exports, __webpack_require__) {
    var ComponentToHex = __webpack_require__(398);

    module.exports = function (r, g, b, a, prefix) {
      return void 0 === a && (a = 255), "#" === (prefix = void 0 === prefix ? "#" : prefix) ? "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1, 7) : "0x" + ComponentToHex(a) + ComponentToHex(r) + ComponentToHex(g) + ComponentToHex(b);
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      BitmapMask: __webpack_require__(310),
      GeometryMask: __webpack_require__(311)
    };
  }, function (module, exports, Dom) {
    Dom = {
      AddToDOM: Dom(142),
      DOMContentLoaded: Dom(400),
      GetInnerHeight: Dom(401),
      GetScreenOrientation: Dom(402),
      GetTarget: Dom(407),
      ParseXML: Dom(408),
      RemoveFromDOM: Dom(202),
      RequestAnimationFrame: Dom(386)
    };
    module.exports = Dom;
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      EventEmitter: __webpack_require__(919)
    };
  }, function (module, exports, PluginCache) {
    var EventEmitter = PluginCache(0),
        EE = PluginCache(9),
        PluginCache = PluginCache(24),
        EventEmitter = new EventEmitter({
      Extends: EE,
      initialize: function initialize() {
        EE.call(this);
      },
      shutdown: function shutdown() {
        this.removeAllListeners();
      },
      destroy: function destroy() {
        this.removeAllListeners();
      }
    });
    PluginCache.register("EventEmitter", EventEmitter, "events"), module.exports = EventEmitter;
  }, function (module, exports, __webpack_require__) {
    var AddToDOM = __webpack_require__(142),
        AnimationManager = __webpack_require__(321),
        CacheManager = __webpack_require__(325),
        CanvasPool = __webpack_require__(31),
        Game = __webpack_require__(0),
        Config = __webpack_require__(346),
        CreateDOMContainer = __webpack_require__(921),
        CreateRenderer = __webpack_require__(366),
        DataManager = __webpack_require__(101),
        DebugHeader = __webpack_require__(384),
        Device = __webpack_require__(347),
        DOMContentLoaded = __webpack_require__(400),
        EventEmitter = __webpack_require__(9),
        Events = __webpack_require__(22),
        InputManager = __webpack_require__(409),
        PluginCache = __webpack_require__(24),
        PluginManager = __webpack_require__(414),
        ScaleManager = __webpack_require__(415),
        SceneManager = __webpack_require__(417),
        TextureEvents = __webpack_require__(106),
        TextureManager = __webpack_require__(422),
        TimeStep = __webpack_require__(385),
        VisibilityHandler = __webpack_require__(387),
        SoundManagerCreator = __webpack_require__(426),
        Game = new Game({
      initialize: function initialize(config) {
        this.config = new Config(config), this.renderer = null, this.domContainer = null, this.canvas = null, this.context = null, this.isBooted = !1, this.isRunning = !1, this.events = new EventEmitter(), this.anims = new AnimationManager(this), this.textures = new TextureManager(this), this.cache = new CacheManager(this), this.registry = new DataManager(this), this.input = new InputManager(this, this.config), this.scene = new SceneManager(this, this.config.sceneConfig), this.device = Device, this.scale = new ScaleManager(this, this.config), this.sound = null, this.sound = SoundManagerCreator.create(this), this.loop = new TimeStep(this, this.config.fps), this.plugins = new PluginManager(this, this.config), this.pendingDestroy = !1, this.removeCanvas = !1, this.noReturn = !1, this.hasFocus = !1, DOMContentLoaded(this.boot.bind(this));
      },
      boot: function boot() {
        PluginCache.hasCore("EventEmitter") ? (this.isBooted = !0, this.config.preBoot(this), this.scale.preBoot(), CreateRenderer(this), CreateDOMContainer(this), DebugHeader(this), AddToDOM(this.canvas, this.config.parent), this.textures.once(TextureEvents.READY, this.texturesReady, this), this.events.emit(Events.BOOT)) : console.warn("Aborting. Core Plugins missing.");
      },
      texturesReady: function texturesReady() {
        this.events.emit(Events.READY), this.start();
      },
      start: function start() {
        this.isRunning = !0, this.config.postBoot(this), this.renderer ? this.loop.start(this.step.bind(this)) : this.loop.start(this.headlessStep.bind(this)), VisibilityHandler(this);
        var eventEmitter = this.events;
        eventEmitter.on(Events.HIDDEN, this.onHidden, this), eventEmitter.on(Events.VISIBLE, this.onVisible, this), eventEmitter.on(Events.BLUR, this.onBlur, this), eventEmitter.on(Events.FOCUS, this.onFocus, this);
      },
      step: function step(time, delta) {
        if (this.pendingDestroy) return this.runDestroy();
        var eventEmitter = this.events;
        eventEmitter.emit(Events.PRE_STEP, time, delta), eventEmitter.emit(Events.STEP, time, delta), this.scene.update(time, delta), eventEmitter.emit(Events.POST_STEP, time, delta);
        var renderer = this.renderer;
        renderer.preRender(), eventEmitter.emit(Events.PRE_RENDER, renderer, time, delta), this.scene.render(renderer), renderer.postRender(), eventEmitter.emit(Events.POST_RENDER, renderer, time, delta);
      },
      headlessStep: function headlessStep(time, delta) {
        if (this.pendingDestroy) return this.runDestroy();
        var eventEmitter = this.events;
        eventEmitter.emit(Events.PRE_STEP, time, delta), eventEmitter.emit(Events.STEP, time, delta), this.scene.update(time, delta), eventEmitter.emit(Events.POST_STEP, time, delta), eventEmitter.emit(Events.PRE_RENDER), eventEmitter.emit(Events.POST_RENDER);
      },
      onHidden: function onHidden() {
        this.loop.pause(), this.events.emit(Events.PAUSE);
      },
      onVisible: function onVisible() {
        this.loop.resume(), this.events.emit(Events.RESUME);
      },
      onBlur: function onBlur() {
        this.hasFocus = !1, this.loop.blur();
      },
      onFocus: function onFocus() {
        this.hasFocus = !0, this.loop.focus();
      },
      getFrame: function getFrame() {
        return this.loop.frame;
      },
      getTime: function getTime() {
        return this.loop.now;
      },
      destroy: function destroy(removeCanvas, noReturn) {
        void 0 === noReturn && (noReturn = !1), this.pendingDestroy = !0, this.removeCanvas = removeCanvas, this.noReturn = noReturn;
      },
      runDestroy: function runDestroy() {
        this.scene.destroy(), this.events.emit(Events.DESTROY), this.events.removeAllListeners(), this.renderer && this.renderer.destroy(), this.removeCanvas && this.canvas && (CanvasPool.remove(this.canvas), this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas)), this.domContainer && this.domContainer.parentNode.removeChild(this.domContainer), this.loop.destroy(), this.pendingDestroy = !1;
      }
    });

    module.exports = Game;
  }, function (module, exports, __webpack_require__) {
    var AddToDOM = __webpack_require__(142);

    module.exports = function (game) {
      var div,
          config = game.config;
      config.parent && config.domCreateContainer && ((div = document.createElement("div")).style.cssText = ["display: block;", "width: " + game.scale.width + "px;", "height: " + game.scale.height + "px;", "padding: 0; margin: 0;", "position: absolute;", "overflow: hidden;", "pointer-events: " + config.domPointerEvents + ";", "transform: scale(1);", "transform-origin: left top;"].join(" "), game.domContainer = div, AddToDOM(div, config.parent));
    };
  }, function (module, exports) {
    module.exports = "boot";
  }, function (module, exports) {
    module.exports = "destroy";
  }, function (module, exports) {
    module.exports = "dragend";
  }, function (module, exports) {
    module.exports = "dragenter";
  }, function (module, exports) {
    module.exports = "drag";
  }, function (module, exports) {
    module.exports = "dragleave";
  }, function (module, exports) {
    module.exports = "dragover";
  }, function (module, exports) {
    module.exports = "dragstart";
  }, function (module, exports) {
    module.exports = "drop";
  }, function (module, exports) {
    module.exports = "gameout";
  }, function (module, exports) {
    module.exports = "gameover";
  }, function (module, exports) {
    module.exports = "gameobjectdown";
  }, function (module, exports) {
    module.exports = "dragend";
  }, function (module, exports) {
    module.exports = "dragenter";
  }, function (module, exports) {
    module.exports = "drag";
  }, function (module, exports) {
    module.exports = "dragleave";
  }, function (module, exports) {
    module.exports = "dragover";
  }, function (module, exports) {
    module.exports = "dragstart";
  }, function (module, exports) {
    module.exports = "drop";
  }, function (module, exports) {
    module.exports = "gameobjectmove";
  }, function (module, exports) {
    module.exports = "gameobjectout";
  }, function (module, exports) {
    module.exports = "gameobjectover";
  }, function (module, exports) {
    module.exports = "pointerdown";
  }, function (module, exports) {
    module.exports = "pointermove";
  }, function (module, exports) {
    module.exports = "pointerout";
  }, function (module, exports) {
    module.exports = "pointerover";
  }, function (module, exports) {
    module.exports = "pointerup";
  }, function (module, exports) {
    module.exports = "wheel";
  }, function (module, exports) {
    module.exports = "gameobjectup";
  }, function (module, exports) {
    module.exports = "gameobjectwheel";
  }, function (module, exports) {
    module.exports = "boot";
  }, function (module, exports) {
    module.exports = "process";
  }, function (module, exports) {
    module.exports = "update";
  }, function (module, exports) {
    module.exports = "pointerdown";
  }, function (module, exports) {
    module.exports = "pointerdownoutside";
  }, function (module, exports) {
    module.exports = "pointermove";
  }, function (module, exports) {
    module.exports = "pointerout";
  }, function (module, exports) {
    module.exports = "pointerover";
  }, function (module, exports) {
    module.exports = "pointerup";
  }, function (module, exports) {
    module.exports = "pointerupoutside";
  }, function (module, exports) {
    module.exports = "wheel";
  }, function (module, exports) {
    module.exports = "pointerlockchange";
  }, function (module, exports) {
    module.exports = "preupdate";
  }, function (module, exports) {
    module.exports = "shutdown";
  }, function (module, exports) {
    module.exports = "start";
  }, function (module, exports) {
    module.exports = "update";
  }, function (module, exports) {
    module.exports = "addfile";
  }, function (module, exports) {
    module.exports = "complete";
  }, function (module, exports) {
    module.exports = "filecomplete";
  }, function (module, exports) {
    module.exports = "filecomplete-";
  }, function (module, exports) {
    module.exports = "loaderror";
  }, function (module, exports) {
    module.exports = "load";
  }, function (module, exports) {
    module.exports = "fileprogress";
  }, function (module, exports) {
    module.exports = "postprocess";
  }, function (module, exports) {
    module.exports = "progress";
  }, function (module, exports) {
    module.exports = "start";
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      game: "game",
      renderer: "renderer",
      anims: "anims",
      cache: "cache",
      plugins: "plugins",
      registry: "registry",
      scale: "scale",
      sound: "sound",
      textures: "textures",
      events: "events",
      cameras: "cameras",
      add: "add",
      make: "make",
      scenePlugin: "scene",
      displayList: "children",
      lights: "lights",
      data: "data",
      input: "input",
      load: "load",
      time: "time",
      tweens: "tweens",
      arcadePhysics: "physics",
      impactPhysics: "impact",
      matterPhysics: "matter"
    };
  }, function (module, exports) {
    module.exports = function (texture, sourceIndex, xml) {
      if (xml.getElementsByTagName("TextureAtlas")) {
        var source = texture.source[sourceIndex];
        texture.add("__BASE", sourceIndex, 0, 0, source.width, source.height);

        for (var frames = xml.getElementsByTagName("SubTexture"), i = 0; i < frames.length; i++) {
          var frameHeight = frames[i].attributes,
              frameX = frameHeight.name.value,
              frameY = parseInt(frameHeight.x.value, 10),
              frameWidth = parseInt(frameHeight.y.value, 10),
              width = parseInt(frameHeight.width.value, 10),
              height = parseInt(frameHeight.height.value, 10),
              newFrame = texture.add(frameX, sourceIndex, frameY, frameWidth, width, height);
          frameHeight.frameX && (frameX = Math.abs(parseInt(frameHeight.frameX.value, 10)), frameY = Math.abs(parseInt(frameHeight.frameY.value, 10)), frameWidth = parseInt(frameHeight.frameWidth.value, 10), frameHeight = parseInt(frameHeight.frameHeight.value, 10), newFrame.setTrim(width, height, frameX, frameY, frameWidth, frameHeight));
        }

        return texture;
      }

      console.warn("Invalid Texture Atlas XML given");
    };
  }, function (module, exports) {
    module.exports = function (texture, sourceIndex) {
      var source = texture.source[sourceIndex];
      return texture.add("__BASE", sourceIndex, 0, 0, source.width, source.height), texture;
    };
  }, function (module, exports) {
    module.exports = function (texture, sourceIndex) {
      var source = texture.source[sourceIndex];
      return texture.add("__BASE", sourceIndex, 0, 0, source.width, source.height), texture;
    };
  }, function (module, exports, __webpack_require__) {
    var Clone = __webpack_require__(77);

    module.exports = function (texture, sourceIndex, json) {
      if (json.frames || json.textures) {
        var source = texture.source[sourceIndex];
        texture.add("__BASE", sourceIndex, 0, 0, source.width, source.height);

        for (var dataKey, frames = (Array.isArray(json.textures) ? json.textures[sourceIndex] : json).frames, i = 0; i < frames.length; i++) {
          var src = frames[i],
              newFrame = texture.add(src.filename, sourceIndex, src.frame.x, src.frame.y, src.frame.w, src.frame.h);
          src.trimmed && newFrame.setTrim(src.sourceSize.w, src.sourceSize.h, src.spriteSourceSize.x, src.spriteSourceSize.y, src.spriteSourceSize.w, src.spriteSourceSize.h), src.rotated && (newFrame.rotated = !0, newFrame.updateUVsInverted());
          var pivot = src.anchor || src.pivot;
          pivot && (newFrame.customPivot = !0, newFrame.pivotX = pivot.x, newFrame.pivotY = pivot.y), newFrame.customData = Clone(src);
        }

        for (dataKey in json) {
          "frames" !== dataKey && (Array.isArray(json[dataKey]) ? texture.customData[dataKey] = json[dataKey].slice(0) : texture.customData[dataKey] = json[dataKey]);
        }

        return texture;
      }

      console.warn("Invalid Texture Atlas JSON Array");
    };
  }, function (module, exports, __webpack_require__) {
    var Clone = __webpack_require__(77);

    module.exports = function (texture, sourceIndex, json) {
      if (json.frames) {
        var source = texture.source[sourceIndex];
        texture.add("__BASE", sourceIndex, 0, 0, source.width, source.height);
        var key,
            src,
            newFrame,
            pivot,
            dataKey,
            frames = json.frames;

        for (key in frames) {
          frames.hasOwnProperty(key) && (src = frames[key], newFrame = texture.add(key, sourceIndex, src.frame.x, src.frame.y, src.frame.w, src.frame.h), src.trimmed && newFrame.setTrim(src.sourceSize.w, src.sourceSize.h, src.spriteSourceSize.x, src.spriteSourceSize.y, src.spriteSourceSize.w, src.spriteSourceSize.h), src.rotated && (newFrame.rotated = !0, newFrame.updateUVsInverted()), (pivot = src.anchor || src.pivot) && (newFrame.customPivot = !0, newFrame.pivotX = pivot.x, newFrame.pivotY = pivot.y), newFrame.customData = Clone(src));
        }

        for (dataKey in json) {
          "frames" !== dataKey && (Array.isArray(json[dataKey]) ? texture.customData[dataKey] = json[dataKey].slice(0) : texture.customData[dataKey] = json[dataKey]);
        }

        return texture;
      }

      console.warn("Invalid Texture Atlas JSON Hash given, missing 'frames' Object");
    };
  }, function (module, exports, __webpack_require__) {
    var GetFastValue = __webpack_require__(2);

    module.exports = function (texture, sourceIndex, x, y, width, height, config) {
      var frameWidth = GetFastValue(config, "frameWidth", null),
          frameHeight = GetFastValue(config, "frameHeight", frameWidth);
      if (null === frameWidth) throw new Error("TextureManager.SpriteSheet: Invalid frameWidth given.");
      var endFrame = texture.source[sourceIndex];
      texture.add("__BASE", sourceIndex, 0, 0, endFrame.width, endFrame.height);
      var startFrame = GetFastValue(config, "startFrame", 0),
          endFrame = GetFastValue(config, "endFrame", -1),
          margin = GetFastValue(config, "margin", 0),
          spacing = GetFastValue(config, "spacing", 0),
          total = Math.floor((width - margin + spacing) / (frameWidth + spacing)) * Math.floor((height - margin + spacing) / (frameHeight + spacing));
      0 === total && console.warn("SpriteSheet frame dimensions will result in zero frames for texture:", texture.key), (startFrame = total < startFrame || startFrame < -total ? 0 : startFrame) < 0 && (startFrame = total + startFrame), -1 !== endFrame && (total = startFrame + (endFrame + 1));

      for (var fx = margin, fy = margin, ax = 0, ay = 0, i = 0; i < total; i++) {
        var ax = 0,
            ay = 0,
            w = fx + frameWidth,
            h = fy + frameHeight;
        texture.add(i, sourceIndex, x + fx, y + fy, frameWidth - (ax = width < w ? w - width : ax), frameHeight - (ay = height < h ? h - height : ay)), width < (fx += frameWidth + spacing) + frameWidth && (fx = margin, fy += frameHeight + spacing);
      }

      return texture;
    };
  }, function (module, exports, __webpack_require__) {
    var GetFastValue = __webpack_require__(2);

    module.exports = function (texture, frame, total) {
      var frameWidth = GetFastValue(total, "frameWidth", null),
          frameHeight = GetFastValue(total, "frameHeight", frameWidth);
      if (!frameWidth) throw new Error("TextureManager.SpriteSheetFromAtlas: Invalid frameWidth given.");
      var sheetHeight = texture.source[0];
      texture.add("__BASE", 0, 0, 0, sheetHeight.width, sheetHeight.height);
      var startFrame = GetFastValue(total, "startFrame", 0),
          endFrame = GetFastValue(total, "endFrame", -1),
          margin = GetFastValue(total, "margin", 0),
          spacing = GetFastValue(total, "spacing", 0),
          x = frame.cutX,
          y = frame.cutY,
          cutWidth = frame.cutWidth,
          cutHeight = frame.cutHeight,
          sheetWidth = frame.realWidth,
          sheetHeight = frame.realHeight,
          row = Math.floor((sheetWidth - margin + spacing) / (frameWidth + spacing)),
          column = Math.floor((sheetHeight - margin + spacing) / (frameHeight + spacing)),
          total = row * column,
          leftPad = frame.x,
          leftWidth = frameWidth - leftPad,
          rightWidth = frameWidth - (sheetWidth - cutWidth - leftPad),
          topPad = frame.y,
          topHeight = frameHeight - topPad,
          bottomHeight = frameHeight - (sheetHeight - cutHeight - topPad);
      (startFrame = total < startFrame || startFrame < -total ? 0 : startFrame) < 0 && (startFrame = total + startFrame), -1 !== endFrame && (total = startFrame + (endFrame + 1));

      for (var frameX = margin, frameY = margin, frameIndex = 0, sourceIndex = frame.sourceIndex, sheetY = 0; sheetY < column; sheetY++) {
        for (var topRow = 0 === sheetY, bottomRow = sheetY === column - 1, sheetX = 0; sheetX < row; sheetX++) {
          var destX,
              destY,
              destWidth,
              destHeight,
              leftRow = 0 === sheetX,
              rightRow = sheetX === row - 1,
              sheetFrame = texture.add(frameIndex, sourceIndex, x + frameX, y + frameY, frameWidth, frameHeight);
          (leftRow || topRow || rightRow || bottomRow) && (destX = leftRow ? leftPad : 0, destY = topRow ? topPad : 0, destHeight = destWidth = 0, leftRow && (destWidth += frameWidth - leftWidth), rightRow && (destWidth += frameWidth - rightWidth), topRow && (destHeight += frameHeight - topHeight), bottomRow && (destHeight += frameHeight - bottomHeight), destHeight = frameHeight - destHeight, sheetFrame.cutWidth = destWidth = frameWidth - destWidth, sheetFrame.cutHeight = destHeight, sheetFrame.setTrim(frameWidth, frameHeight, destX, destY, destWidth, destHeight)), frameX += spacing, frameX += leftRow ? leftWidth : rightRow ? rightWidth : frameWidth, frameIndex++;
        }

        frameX = margin, frameY += spacing, frameY += topRow ? topHeight : bottomRow ? bottomHeight : frameHeight;
      }

      return texture;
    };
  }, function (module, exports) {
    function addFrame(texture, sourceIndex, name, frame) {
      var y = imageHeight - frame.y - frame.height;
      texture.add(name, sourceIndex, frame.x, y, frame.width, frame.height);
    }

    var imageHeight = 0;

    module.exports = function (texture, sourceIndex, yaml) {
      var source = texture.source[sourceIndex];
      texture.add("__BASE", sourceIndex, 0, 0, source.width, source.height), imageHeight = source.height;

      for (var data = yaml.split("\n"), lineRegExp = /^[ ]*(- )*(\w+)+[: ]+(.*)/, prevSprite = "", currentSprite = "", rect = {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      }, i = 0; i < data.length; i++) {
        var results = data[i].match(lineRegExp);

        if (results) {
          var isList = "- " === results[1],
              key = results[2],
              value = results[3];
          if (isList && (currentSprite !== prevSprite && (addFrame(texture, sourceIndex, currentSprite, rect), prevSprite = currentSprite), rect = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
          }), "name" !== key) switch (key) {
            case "x":
            case "y":
            case "width":
            case "height":
              rect[key] = parseInt(value, 10);
          } else currentSprite = value;
        }
      }

      return currentSprite !== prevSprite && addFrame(texture, sourceIndex, currentSprite, rect), texture;
    };
  }, function (module, exports) {
    module.exports = "complete";
  }, function (module, exports) {
    module.exports = "decoded";
  }, function (module, exports) {
    module.exports = "decodedall";
  }, function (module, exports) {
    module.exports = "destroy";
  }, function (module, exports) {
    module.exports = "detune";
  }, function (module, exports) {
    module.exports = "detune";
  }, function (module, exports) {
    module.exports = "mute";
  }, function (module, exports) {
    module.exports = "rate";
  }, function (module, exports) {
    module.exports = "volume";
  }, function (module, exports) {
    module.exports = "loop";
  }, function (module, exports) {
    module.exports = "looped";
  }, function (module, exports) {
    module.exports = "mute";
  }, function (module, exports) {
    module.exports = "pan";
  }, function (module, exports) {
    module.exports = "pauseall";
  }, function (module, exports) {
    module.exports = "pause";
  }, function (module, exports) {
    module.exports = "play";
  }, function (module, exports) {
    module.exports = "rate";
  }, function (module, exports) {
    module.exports = "resumeall";
  }, function (module, exports) {
    module.exports = "resume";
  }, function (module, exports) {
    module.exports = "seek";
  }, function (module, exports) {
    module.exports = "stopall";
  }, function (module, exports) {
    module.exports = "stop";
  }, function (module, exports) {
    module.exports = "unlocked";
  }, function (module, exports) {
    module.exports = "volume";
  }, function (module, exports, __webpack_require__) {
    var GameObjects = {
      Events: __webpack_require__(75),
      DisplayList: __webpack_require__(1012),
      GameObjectCreator: __webpack_require__(16),
      GameObjectFactory: __webpack_require__(5),
      UpdateList: __webpack_require__(1040),
      Components: __webpack_require__(11),
      GetCalcMatrix: __webpack_require__(19),
      BuildGameObject: __webpack_require__(28),
      BuildGameObjectAnimation: __webpack_require__(439),
      GameObject: __webpack_require__(15),
      BitmapText: __webpack_require__(148),
      Blitter: __webpack_require__(213),
      Bob: __webpack_require__(440),
      Container: __webpack_require__(214),
      DOMElement: __webpack_require__(442),
      DynamicBitmapText: __webpack_require__(215),
      Extern: __webpack_require__(444),
      Graphics: __webpack_require__(216),
      Group: __webpack_require__(113),
      Image: __webpack_require__(125),
      Layer: __webpack_require__(219),
      Particles: __webpack_require__(1074),
      PathFollower: __webpack_require__(457),
      RenderTexture: __webpack_require__(221),
      RetroFont: __webpack_require__(1082),
      Rope: __webpack_require__(223),
      Sprite: __webpack_require__(73),
      Text: __webpack_require__(224),
      GetTextSize: __webpack_require__(458),
      MeasureText: __webpack_require__(460),
      TextStyle: __webpack_require__(459),
      TileSprite: __webpack_require__(225),
      Zone: __webpack_require__(129),
      Video: __webpack_require__(226),
      Shape: __webpack_require__(34),
      Arc: __webpack_require__(461),
      Curve: __webpack_require__(462),
      Ellipse: __webpack_require__(463),
      Grid: __webpack_require__(464),
      IsoBox: __webpack_require__(465),
      IsoTriangle: __webpack_require__(466),
      Line: __webpack_require__(467),
      Polygon: __webpack_require__(468),
      Rectangle: __webpack_require__(473),
      Star: __webpack_require__(474),
      Triangle: __webpack_require__(475),
      Factories: {
        Blitter: __webpack_require__(1130),
        Container: __webpack_require__(1131),
        DOMElement: __webpack_require__(1132),
        DynamicBitmapText: __webpack_require__(1133),
        Extern: __webpack_require__(1134),
        Graphics: __webpack_require__(1135),
        Group: __webpack_require__(1136),
        Image: __webpack_require__(1137),
        Layer: __webpack_require__(1138),
        Particles: __webpack_require__(1139),
        PathFollower: __webpack_require__(1140),
        RenderTexture: __webpack_require__(1141),
        Rope: __webpack_require__(1142),
        Sprite: __webpack_require__(1143),
        StaticBitmapText: __webpack_require__(1144),
        Text: __webpack_require__(1145),
        TileSprite: __webpack_require__(1146),
        Zone: __webpack_require__(1147),
        Video: __webpack_require__(1148),
        Arc: __webpack_require__(1149),
        Curve: __webpack_require__(1150),
        Ellipse: __webpack_require__(1151),
        Grid: __webpack_require__(1152),
        IsoBox: __webpack_require__(1153),
        IsoTriangle: __webpack_require__(1154),
        Line: __webpack_require__(1155),
        Polygon: __webpack_require__(1156),
        Rectangle: __webpack_require__(1157),
        Star: __webpack_require__(1158),
        Triangle: __webpack_require__(1159)
      },
      Creators: {
        Blitter: __webpack_require__(1160),
        Container: __webpack_require__(1161),
        DynamicBitmapText: __webpack_require__(1162),
        Graphics: __webpack_require__(1163),
        Group: __webpack_require__(1164),
        Image: __webpack_require__(1165),
        Layer: __webpack_require__(1166),
        Particles: __webpack_require__(1167),
        RenderTexture: __webpack_require__(1168),
        Rope: __webpack_require__(1169),
        Sprite: __webpack_require__(1170),
        StaticBitmapText: __webpack_require__(1171),
        Text: __webpack_require__(1172),
        TileSprite: __webpack_require__(1173),
        Zone: __webpack_require__(1174),
        Video: __webpack_require__(1175)
      }
    };
    GameObjects.Shader = __webpack_require__(229), GameObjects.Mesh = __webpack_require__(230), GameObjects.PointLight = __webpack_require__(150), GameObjects.Factories.Shader = __webpack_require__(1184), GameObjects.Factories.Mesh = __webpack_require__(1185), GameObjects.Factories.PointLight = __webpack_require__(1186), GameObjects.Creators.Shader = __webpack_require__(1187), GameObjects.Creators.Mesh = __webpack_require__(1188), GameObjects.Creators.PointLight = __webpack_require__(1189), GameObjects.Light = __webpack_require__(481), GameObjects.LightsManager = __webpack_require__(482), GameObjects.LightsPlugin = __webpack_require__(1190), module.exports = GameObjects;
  }, function (module, exports, __webpack_require__) {
    var DisplayList = __webpack_require__(0),
        List = __webpack_require__(110),
        PluginCache = __webpack_require__(24),
        GameObjectEvents = __webpack_require__(75),
        SceneEvents = __webpack_require__(20),
        StableSort = __webpack_require__(79),
        DisplayList = new DisplayList({
      Extends: List,
      initialize: function initialize(scene) {
        List.call(this, scene), this.sortChildrenFlag = !1, this.scene = scene, this.systems = scene.sys, this.events = scene.sys.events, this.addCallback = this.addChildCallback, this.removeCallback = this.removeChildCallback, this.events.once(SceneEvents.BOOT, this.boot, this), this.events.on(SceneEvents.START, this.start, this);
      },
      boot: function boot() {
        this.events.once(SceneEvents.DESTROY, this.destroy, this);
      },
      addChildCallback: function addChildCallback(gameObject) {
        gameObject.displayList && gameObject.displayList !== this && gameObject.removeFromDisplayList(), gameObject.displayList || (this.queueDepthSort(), gameObject.displayList = this, gameObject.emit(GameObjectEvents.ADDED_TO_SCENE, gameObject, this.scene), this.events.emit(SceneEvents.ADDED_TO_SCENE, gameObject, this.scene));
      },
      removeChildCallback: function removeChildCallback(gameObject) {
        this.queueDepthSort(), gameObject.displayList = null, gameObject.emit(GameObjectEvents.REMOVED_FROM_SCENE, gameObject, this.scene), this.events.emit(SceneEvents.REMOVED_FROM_SCENE, gameObject, this.scene);
      },
      start: function start() {
        this.events.once(SceneEvents.SHUTDOWN, this.shutdown, this);
      },
      queueDepthSort: function queueDepthSort() {
        this.sortChildrenFlag = !0;
      },
      depthSort: function depthSort() {
        this.sortChildrenFlag && (StableSort(this.list, this.sortByDepth), this.sortChildrenFlag = !1);
      },
      sortByDepth: function sortByDepth(childA, childB) {
        return childA._depth - childB._depth;
      },
      getChildren: function getChildren() {
        return this.list;
      },
      shutdown: function shutdown() {
        for (var list = this.list, i = list.length; i--;) {
          list[i].destroy(!0);
        }

        list.length = 0, this.events.off(SceneEvents.SHUTDOWN, this.shutdown, this);
      },
      destroy: function destroy() {
        this.shutdown(), this.events.off(SceneEvents.START, this.start, this), this.scene = null, this.systems = null, this.events = null;
      }
    });

    PluginCache.register("DisplayList", DisplayList, "displayList"), module.exports = DisplayList;
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      CheckMatrix: __webpack_require__(209),
      MatrixToString: __webpack_require__(1014),
      ReverseColumns: __webpack_require__(1015),
      ReverseRows: __webpack_require__(1016),
      Rotate180: __webpack_require__(1017),
      RotateLeft: __webpack_require__(1018),
      RotateMatrix: __webpack_require__(147),
      RotateRight: __webpack_require__(1019),
      Translate: __webpack_require__(1020),
      TransposeMatrix: __webpack_require__(435)
    };
  }, function (module, exports, __webpack_require__) {
    var Pad = __webpack_require__(186),
        CheckMatrix = __webpack_require__(209);

    module.exports = function (matrix) {
      var str = "";
      if (!CheckMatrix(matrix)) return str;

      for (var r = 0; r < matrix.length; r++) {
        for (var c = 0; c < matrix[r].length; c++) {
          var cell = matrix[r][c].toString();
          str += "undefined" !== cell ? Pad(cell, 2) : "?", c < matrix[r].length - 1 && (str += " |");
        }

        if (r < matrix.length - 1) {
          str += "\n";

          for (var i = 0; i < matrix[r].length; i++) {
            str += "---", i < matrix[r].length - 1 && (str += "+");
          }

          str += "\n";
        }
      }

      return str;
    };
  }, function (module, exports) {
    module.exports = function (matrix) {
      return matrix.reverse();
    };
  }, function (module, exports) {
    module.exports = function (matrix) {
      for (var i = 0; i < matrix.length; i++) {
        matrix[i].reverse();
      }

      return matrix;
    };
  }, function (module, exports, __webpack_require__) {
    var RotateMatrix = __webpack_require__(147);

    module.exports = function (matrix) {
      return RotateMatrix(matrix, 180);
    };
  }, function (module, exports, __webpack_require__) {
    var RotateMatrix = __webpack_require__(147);

    module.exports = function (matrix) {
      return RotateMatrix(matrix, 90);
    };
  }, function (module, exports, __webpack_require__) {
    var RotateMatrix = __webpack_require__(147);

    module.exports = function (matrix) {
      return RotateMatrix(matrix, -90);
    };
  }, function (module, exports, __webpack_require__) {
    var RotateLeft = __webpack_require__(178),
        RotateRight = __webpack_require__(179);

    module.exports = function (matrix, x, y) {
      if (void 0 === x && (x = 0), 0 !== (y = void 0 === y ? 0 : y) && (y < 0 ? RotateLeft(matrix, Math.abs(y)) : RotateRight(matrix, y)), 0 !== x) for (var i = 0; i < matrix.length; i++) {
        var row = matrix[i];
        x < 0 ? RotateLeft(row, Math.abs(x)) : RotateRight(row, x);
      }
      return matrix;
    };
  }, function (module, exports) {
    module.exports = function (array, item, limit, callback, context) {
      if (void 0 === context && (context = array), 0 < limit) {
        var remaining = limit - array.length;
        if (remaining <= 0) return null;
      }

      if (!Array.isArray(item)) return -1 === array.indexOf(item) ? (array.push(item), callback && callback.call(context, item), item) : null;

      for (var itemLength = item.length - 1; 0 <= itemLength;) {
        -1 !== array.indexOf(item[itemLength]) && item.splice(itemLength, 1), itemLength--;
      }

      if (0 === (itemLength = item.length)) return null;
      0 < limit && remaining < itemLength && (item.splice(remaining), itemLength = remaining);

      for (var i = 0; i < itemLength; i++) {
        var entry = item[i];
        array.push(entry), callback && callback.call(context, entry);
      }

      return item;
    };
  }, function (module, exports) {
    module.exports = function (array, item, index, limit, callback, context) {
      if (void 0 === index && (index = 0), void 0 === context && (context = array), 0 < limit) {
        var remaining = limit - array.length;
        if (remaining <= 0) return null;
      }

      if (!Array.isArray(item)) return -1 === array.indexOf(item) ? (array.splice(index, 0, item), callback && callback.call(context, item), item) : null;

      for (var itemLength = item.length - 1; 0 <= itemLength;) {
        -1 !== array.indexOf(item[itemLength]) && item.pop(), itemLength--;
      }

      if (0 === (itemLength = item.length)) return null;
      0 < limit && remaining < itemLength && (item.splice(remaining), itemLength = remaining);

      for (var i = itemLength - 1; 0 <= i; i--) {
        var entry = item[i];
        array.splice(index, 0, entry), callback && callback.call(context, entry);
      }

      return item;
    };
  }, function (module, exports) {
    module.exports = function (array, item) {
      var currentIndex = array.indexOf(item);
      return -1 !== currentIndex && currentIndex < array.length && (array.splice(currentIndex, 1), array.push(item)), item;
    };
  }, function (module, exports, __webpack_require__) {
    var SafeRange = __webpack_require__(78);

    module.exports = function (array, property, value, startIndex, endIndex) {
      void 0 === endIndex && (endIndex = array.length);
      var total = 0;
      if (SafeRange(array, startIndex = void 0 === startIndex ? 0 : startIndex, endIndex)) for (var i = startIndex; i < endIndex; i++) {
        array[i][property] === value && total++;
      }
      return total;
    };
  }, function (module, exports) {
    module.exports = function (array, callback, context) {
      for (var args = [null], i = 3; i < arguments.length; i++) {
        args.push(arguments[i]);
      }

      for (i = 0; i < array.length; i++) {
        args[0] = array[i], callback.apply(context, args);
      }

      return array;
    };
  }, function (module, exports, __webpack_require__) {
    var SafeRange = __webpack_require__(78);

    module.exports = function (array, callback, context, startIndex, endIndex) {
      if (void 0 === endIndex && (endIndex = array.length), SafeRange(array, startIndex = void 0 === startIndex ? 0 : startIndex, endIndex)) {
        for (var args = [null], i = 5; i < arguments.length; i++) {
          args.push(arguments[i]);
        }

        for (i = startIndex; i < endIndex; i++) {
          args[0] = array[i], callback.apply(context, args);
        }
      }

      return array;
    };
  }, function (module, exports) {
    module.exports = function (array, item) {
      var item2,
          index2,
          currentIndex = array.indexOf(item);
      return 0 < currentIndex && (item2 = array[currentIndex - 1], index2 = array.indexOf(item2), array[currentIndex] = item2, array[index2] = item), array;
    };
  }, function (module, exports) {
    module.exports = function (array, item, index) {
      var currentIndex = array.indexOf(item);
      if (-1 === currentIndex || index < 0 || index >= array.length) throw new Error("Supplied index out of bounds");
      return currentIndex !== index && (array.splice(currentIndex, 1), array.splice(index, 0, item)), item;
    };
  }, function (module, exports) {
    module.exports = function (array, item) {
      var item2,
          index2,
          currentIndex = array.indexOf(item);
      return -1 !== currentIndex && currentIndex < array.length - 1 && (item2 = array[currentIndex + 1], index2 = array.indexOf(item2), array[currentIndex] = item2, array[index2] = item), array;
    };
  }, function (module, exports) {
    module.exports = function (array, item1, baseIndex) {
      if (item1 === baseIndex) return array;
      var currentIndex = array.indexOf(item1),
          baseIndex = array.indexOf(baseIndex);
      if (currentIndex < 0 || baseIndex < 0) throw new Error("Supplied items must be elements of the same array");
      return baseIndex < currentIndex || (array.splice(currentIndex, 1), baseIndex === array.length - 1 ? array.push(item1) : array.splice(baseIndex, 0, item1)), array;
    };
  }, function (module, exports) {
    module.exports = function (array, item1, baseIndex) {
      if (item1 === baseIndex) return array;
      var currentIndex = array.indexOf(item1),
          baseIndex = array.indexOf(baseIndex);
      if (currentIndex < 0 || baseIndex < 0) throw new Error("Supplied items must be elements of the same array");
      return currentIndex < baseIndex || (array.splice(currentIndex, 1), 0 === baseIndex ? array.unshift(item1) : array.splice(baseIndex, 0, item1)), array;
    };
  }, function (module, exports, __webpack_require__) {
    var RoundAwayFromZero = __webpack_require__(363);

    module.exports = function (start, end, step) {
      void 0 === start && (start = 0), void 0 === step && (step = 1), null === (end = void 0 === end ? null : end) && (end = start, start = 0);

      for (var result = [], total = Math.max(RoundAwayFromZero((end - start) / (step || 1)), 0), i = 0; i < total; i++) {
        result.push(start), start += step;
      }

      return result;
    };
  }, function (module, exports, __webpack_require__) {
    var SpliceOne = __webpack_require__(74);

    module.exports = function (array, item, callback, context) {
      if (void 0 === context && (context = array), item < 0 || item > array.length - 1) throw new Error("Index out of bounds");
      item = SpliceOne(array, item);
      return callback && callback.call(context, item), item;
    };
  }, function (module, exports, __webpack_require__) {
    var SafeRange = __webpack_require__(78);

    module.exports = function (array, startIndex, endIndex, callback, context) {
      if (void 0 === endIndex && (endIndex = array.length), void 0 === context && (context = array), SafeRange(array, startIndex = void 0 === startIndex ? 0 : startIndex, endIndex)) {
        var removed = array.splice(startIndex, endIndex - startIndex);
        if (callback) for (var i = 0; i < removed.length; i++) {
          var entry = removed[i];
          callback.call(context, entry);
        }
        return removed;
      }

      return [];
    };
  }, function (module, exports, __webpack_require__) {
    var SpliceOne = __webpack_require__(74);

    module.exports = function (array, start, randomIndex) {
      void 0 === randomIndex && (randomIndex = array.length);
      randomIndex = (start = void 0 === start ? 0 : start) + Math.floor(Math.random() * randomIndex);
      return SpliceOne(array, randomIndex);
    };
  }, function (module, exports) {
    module.exports = function (array, index2, newChild) {
      var index1 = array.indexOf(index2),
          index2 = array.indexOf(newChild);
      return -1 !== index1 && -1 === index2 && (array[index1] = newChild, !0);
    };
  }, function (module, exports) {
    module.exports = function (array, item) {
      var currentIndex = array.indexOf(item);
      return -1 !== currentIndex && 0 < currentIndex && (array.splice(currentIndex, 1), array.unshift(item)), item;
    };
  }, function (module, exports, __webpack_require__) {
    var SafeRange = __webpack_require__(78);

    module.exports = function (array, property, value, startIndex, endIndex) {
      if (void 0 === endIndex && (endIndex = array.length), SafeRange(array, startIndex = void 0 === startIndex ? 0 : startIndex, endIndex)) for (var i = startIndex; i < endIndex; i++) {
        var entry = array[i];
        entry.hasOwnProperty(property) && (entry[property] = value);
      }
      return array;
    };
  }, function (module, exports) {
    module.exports = function (array, item1, item2) {
      if (item1 === item2) return array;
      var index1 = array.indexOf(item1),
          index2 = array.indexOf(item2);
      if (index1 < 0 || index2 < 0) throw new Error("Supplied items must be elements of the same array");
      return array[index1] = item2, array[index2] = item1, array;
    };
  }, function (module, exports, __webpack_require__) {
    var UpdateList = __webpack_require__(0),
        ProcessQueue = __webpack_require__(211),
        PluginCache = __webpack_require__(24),
        SceneEvents = __webpack_require__(20),
        UpdateList = new UpdateList({
      Extends: ProcessQueue,
      initialize: function initialize(scene) {
        ProcessQueue.call(this), this.checkQueue = !0, this.scene = scene, this.systems = scene.sys, scene.sys.events.once(SceneEvents.BOOT, this.boot, this), scene.sys.events.on(SceneEvents.START, this.start, this);
      },
      boot: function boot() {
        this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);
      },
      start: function start() {
        var eventEmitter = this.systems.events;
        eventEmitter.on(SceneEvents.PRE_UPDATE, this.update, this), eventEmitter.on(SceneEvents.UPDATE, this.sceneUpdate, this), eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);
      },
      sceneUpdate: function sceneUpdate(time, delta) {
        for (var list = this._active, length = list.length, i = 0; i < length; i++) {
          var gameObject = list[i];
          gameObject.active && gameObject.preUpdate.call(gameObject, time, delta);
        }
      },
      shutdown: function shutdown() {
        for (var i = this._active.length; i--;) {
          this._active[i].destroy(!0);
        }

        for (i = this._pending.length; i--;) {
          this._pending[i].destroy(!0);
        }

        for (i = this._destroy.length; i--;) {
          this._destroy[i].destroy(!0);
        }

        this._toProcess = 0, this._pending = [], this._active = [], this._destroy = [], this.removeAllListeners();
        var eventEmitter = this.systems.events;
        eventEmitter.off(SceneEvents.PRE_UPDATE, this.update, this), eventEmitter.off(SceneEvents.UPDATE, this.sceneUpdate, this), eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);
      },
      destroy: function destroy() {
        this.shutdown(), this.systems.events.off(SceneEvents.START, this.start, this), this.scene = null, this.systems = null;
      }
    });

    PluginCache.register("UpdateList", UpdateList, "updateList"), module.exports = UpdateList;
  }, function (module, exports) {
    module.exports = "add";
  }, function (module, exports) {
    module.exports = "remove";
  }, function (module, exports) {
    module.exports = function (src, round, updateOrigin, out) {
      if (void 0 === updateOrigin && (updateOrigin = !1), void 0 === out) return out = {
        local: {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        },
        global: {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        },
        lines: {
          shortest: 0,
          longest: 0,
          lengths: null,
          height: 0
        },
        wrappedText: "",
        words: [],
        characters: [],
        scaleX: 0,
        scaleY: 0
      };
      var glyphKerningOffset,
          str,
          index,
          value,
          text = src.text,
          textLength = text.length,
          maxWidth = src.maxWidth,
          wordWrapCharCode = src.wordWrapCharCode,
          bx = Number.MAX_VALUE,
          by = Number.MAX_VALUE,
          bw = 0,
          bh = 0,
          chars = src.fontData.chars,
          lineHeight = src.fontData.lineHeight,
          letterSpacing = src.letterSpacing,
          xAdvance = 0,
          yAdvance = 0,
          charCode = 0,
          glyph = null,
          align = src._align,
          x = 0,
          y = 0,
          scale = src.fontSize / src.fontData.size,
          sx = scale * src.scaleX,
          sy = scale * src.scaleY,
          lastGlyph = null,
          lastCharCode = 0,
          lineWidths = [],
          shortestLine = Number.MAX_VALUE,
          longestLine = 0,
          currentLine = 0,
          currentLineWidth = 0,
          words = [],
          characters = [],
          current = null;

      if (0 < maxWidth) {
        for (i = 0; i < textLength; i++) {
          10 !== (charCode = text.charCodeAt(i)) ? (glyph = chars[charCode]) && (null !== lastGlyph && (glyphKerningOffset = glyph.kerning[lastCharCode]), charCode === wordWrapCharCode ? null !== current && (words.push({
            word: current.word,
            i: current.i,
            x: current.x * sx,
            y: current.y * sy,
            w: current.w * sx,
            h: current.h * sy,
            cr: !1
          }), current = null) : ((current = null === current ? {
            word: "",
            i: i,
            x: xAdvance,
            y: yAdvance,
            w: 0,
            h: lineHeight,
            cr: !1
          } : current).word = current.word.concat(text[i]), current.w += glyph.xOffset + glyph.xAdvance + (void 0 !== glyphKerningOffset ? glyphKerningOffset : 0)), xAdvance += glyph.xAdvance + letterSpacing, lastGlyph = glyph, lastCharCode = charCode) : (null !== current && (words.push({
            word: current.word,
            i: current.i,
            x: current.x * sx,
            y: current.y * sy,
            w: current.w * sx,
            h: current.h * sy,
            cr: !0
          }), current = null), xAdvance = 0, yAdvance += lineHeight, lastGlyph = null);
        }

        null !== current && words.push({
          word: current.word,
          i: current.i,
          x: current.x * sx,
          y: current.y * sy,
          w: current.w * sx,
          h: current.h * sy,
          cr: !1
        });

        for (var xAdvance = 0, yAdvance = 0, lastGlyph = null, lastCharCode = 0, offset = 0, crs = [], i = 0; i < words.length; i++) {
          var prev,
              entry = words[i],
              left = entry.x,
              right = entry.x + entry.w;
          prev && (offset = left - (left - (prev.x + prev.w) + prev.w), prev = null), maxWidth < left - offset || maxWidth < right - offset ? (crs.push(entry.i - 1), prev = entry.cr ? (crs.push(entry.i + entry.word.length), offset = 0, null) : entry) : entry.cr && (crs.push(entry.i + entry.word.length), offset = 0, prev = null);
        }

        for (i = crs.length - 1; 0 <= i; i--) {
          str = text, index = crs[i], value = "\n", text = str.substr(0, index) + value + str.substr(index + 1);
        }

        textLength = (out.wrappedText = text).length, words = [], current = null;
      }

      var kerningOffset,
          gw,
          charWidth,
          charIndex = 0;

      for (i = 0; i < textLength; i++) {
        10 !== (charCode = text.charCodeAt(i)) ? (glyph = chars[charCode]) && (x = xAdvance, y = yAdvance, null !== lastGlyph && (x += void 0 !== (kerningOffset = glyph.kerning[lastCharCode]) ? kerningOffset : 0), x < bx && (bx = x), y < by && (by = y), bw < (gw = x + glyph.xAdvance) && (bw = gw), bh < (charWidth = y + lineHeight) && (bh = charWidth), charWidth = glyph.xOffset + glyph.xAdvance + (void 0 !== kerningOffset ? kerningOffset : 0), charCode === wordWrapCharCode ? null !== current && (words.push({
          word: current.word,
          i: current.i,
          x: current.x * sx,
          y: current.y * sy,
          w: current.w * sx,
          h: current.h * sy
        }), current = null) : ((current = null === current ? {
          word: "",
          i: charIndex,
          x: xAdvance,
          y: yAdvance,
          w: 0,
          h: lineHeight
        } : current).word = current.word.concat(text[i]), current.w += charWidth), characters.push({
          i: charIndex,
          char: text[i],
          code: charCode,
          x: (glyph.xOffset + xAdvance) * scale,
          y: (glyph.yOffset + yAdvance) * scale,
          w: glyph.width * scale,
          h: glyph.height * scale,
          t: yAdvance * scale,
          r: gw * scale,
          b: lineHeight * scale,
          line: currentLine,
          glyph: glyph
        }), xAdvance += glyph.xAdvance + letterSpacing, lastGlyph = glyph, lastCharCode = charCode, currentLineWidth = gw * scale, charIndex++) : (null !== current && (words.push({
          word: current.word,
          i: current.i,
          x: current.x * sx,
          y: current.y * sy,
          w: current.w * sx,
          h: current.h * sy
        }), current = null), xAdvance = 0, yAdvance += lineHeight, lastGlyph = null, longestLine < (lineWidths[currentLine] = currentLineWidth) && (longestLine = currentLineWidth), currentLineWidth < shortestLine && (shortestLine = currentLineWidth), currentLine++, currentLineWidth = 0);
      }

      if (null !== current && words.push({
        word: current.word,
        i: current.i,
        x: current.x * sx,
        y: current.y * sy,
        w: current.w * sx,
        h: current.h * sy
      }), longestLine < (lineWidths[currentLine] = currentLineWidth) && (longestLine = currentLineWidth), currentLineWidth < shortestLine && (shortestLine = currentLineWidth), 0 < align) for (var c = 0; c < characters.length; c++) {
        var ax2,
            currentChar = characters[c];
        1 === align ? (ax2 = (longestLine - lineWidths[currentChar.line]) / 2, currentChar.x += ax2, currentChar.r += ax2) : 2 === align && (ax2 = longestLine - lineWidths[currentChar.line], currentChar.x += ax2, currentChar.r += ax2);
      }
      var local = out.local,
          global = out.global,
          lines = out.lines;
      return local.x = bx * scale, local.y = by * scale, local.width = bw * scale, local.height = bh * scale, global.x = src.x - src._displayOriginX + bx * sx, global.y = src.y - src._displayOriginY + by * sy, global.width = bw * sx, global.height = bh * sy, lines.shortest = shortestLine, lines.longest = longestLine, lines.lengths = lineWidths, round && (local.x = Math.ceil(local.x), local.y = Math.ceil(local.y), local.width = Math.ceil(local.width), local.height = Math.ceil(local.height), global.x = Math.ceil(global.x), global.y = Math.ceil(global.y), global.width = Math.ceil(global.width), global.height = Math.ceil(global.height), lines.shortest = Math.ceil(shortestLine), lines.longest = Math.ceil(longestLine)), updateOrigin && (src._displayOriginX = src.originX * local.width, src._displayOriginY = src.originY * local.height, global.x = src.x - src._displayOriginX * src.scaleX, global.y = src.y - src._displayOriginY * src.scaleY, round && (global.x = Math.ceil(global.x), global.y = Math.ceil(global.y))), out.words = words, out.characters = characters, out.lines.height = lineHeight, out.scale = scale, out.scaleX = src.scaleX, out.scaleY = src.scaleY, out;
    };
  }, function (module, exports, __webpack_require__) {
    var ParseXMLBitmapFont = __webpack_require__(212);

    module.exports = function (scene, fontName, textureKey, frameKey, xml, xSpacing, ySpacing) {
      var data = scene.sys.textures.get(textureKey),
          frame = data.get(frameKey),
          xml = scene.sys.cache.xml.get(xml);

      if (frame && xml) {
        data = ParseXMLBitmapFont(xml, frame, xSpacing, ySpacing, data);
        return scene.sys.cache.bitmapFont.add(fontName, {
          data: data,
          texture: textureKey,
          frame: frameKey,
          fromAtlas: !0
        }), !0;
      }

      return !1;
    };
  }, function (module, exports, __webpack_require__) {
    var renderWebGL = __webpack_require__(1),
        renderCanvas = __webpack_require__(1),
        renderWebGL = __webpack_require__(1046),
        renderCanvas = __webpack_require__(1048);

    module.exports = {
      renderWebGL: renderWebGL,
      renderCanvas: renderCanvas
    };
  }, function (module, exports, __webpack_require__) {
    var BatchChar = __webpack_require__(1047),
        GetCalcMatrix = __webpack_require__(19),
        Utils = __webpack_require__(12);

    module.exports = function (renderer, src, srcShadowColor, srcShadowAlpha) {
      if (0 !== src._text.length) {
        srcShadowColor.addToRenderList(src);
        var char,
            pipeline = renderer.pipelines.set(src.pipeline, src),
            calcMatrix = GetCalcMatrix(src, srcShadowColor, srcShadowAlpha).calc,
            roundPixels = srcShadowColor.roundPixels,
            cameraAlpha = srcShadowColor.alpha,
            charColors = src.charColors,
            tintEffect = src.tintFill,
            getTint = Utils.getTintAppendFloatAlpha,
            tintTL = getTint(src.tintTopLeft, cameraAlpha * src._alphaTL),
            tintTR = getTint(src.tintTopRight, cameraAlpha * src._alphaTR),
            tintBL = getTint(src.tintBottomLeft, cameraAlpha * src._alphaBL),
            tintBR = getTint(src.tintBottomRight, cameraAlpha * src._alphaBR),
            texture = src.frame.glTexture,
            textureUnit = pipeline.setGameObject(src),
            characters = src.getTextBounds(!1).characters,
            dropShadowX = src.dropShadowX,
            dropShadowY = src.dropShadowY,
            srcShadowAlpha = 0 !== dropShadowX || 0 !== dropShadowY;
        if (renderer.pipelines.preBatch(src), srcShadowAlpha) for (var srcShadowColor = src.dropShadowColor, srcShadowAlpha = src.dropShadowAlpha, shadowTL = getTint(srcShadowColor, cameraAlpha * srcShadowAlpha * src._alphaTL), shadowTR = getTint(srcShadowColor, cameraAlpha * srcShadowAlpha * src._alphaTR), shadowBL = getTint(srcShadowColor, cameraAlpha * srcShadowAlpha * src._alphaBL), shadowBR = getTint(srcShadowColor, cameraAlpha * srcShadowAlpha * src._alphaBR), i = 0; i < characters.length; i++) {
          glyph = (char = characters[i]).glyph, 32 !== char.code && 0 !== glyph.width && 0 !== glyph.height && BatchChar(pipeline, src, char, glyph, dropShadowX, dropShadowY, calcMatrix, roundPixels, shadowTL, shadowTR, shadowBL, shadowBR, 1, texture, textureUnit);
        }

        for (i = 0; i < characters.length; i++) {
          var charTintEffect,
              charTintTL,
              charTintTR,
              charTintBL,
              charTintBR,
              glyph = (char = characters[i]).glyph;
          32 !== char.code && 0 !== glyph.width && 0 !== glyph.height && (charColors[char.i] ? (charTintEffect = (charTintBR = charColors[char.i]).tintEffect, charTintTL = getTint(charTintBR.tintTL, cameraAlpha * src._alphaTL), charTintTR = getTint(charTintBR.tintTR, cameraAlpha * src._alphaTR), charTintBL = getTint(charTintBR.tintBL, cameraAlpha * src._alphaBL), charTintBR = getTint(charTintBR.tintBR, cameraAlpha * src._alphaBR), BatchChar(pipeline, src, char, glyph, 0, 0, calcMatrix, roundPixels, charTintTL, charTintTR, charTintBL, charTintBR, charTintEffect, texture, textureUnit)) : BatchChar(pipeline, src, char, glyph, 0, 0, calcMatrix, roundPixels, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, textureUnit));
        }

        renderer.pipelines.postBatch(src);
      }
    };
  }, function (module, exports) {
    module.exports = function (pipeline, src, tx2, glyph, tx1, ty1, calcMatrix, ty3, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, textureUnit) {
      var ty2 = tx2.x - src.displayOriginX + tx1,
          y = tx2.y - src.displayOriginY + ty1,
          xw = ty2 + tx2.w,
          tx3 = y + tx2.h,
          tx0 = calcMatrix.getXRound(ty2, y, ty3),
          ty0 = calcMatrix.getYRound(ty2, y, ty3),
          tx1 = calcMatrix.getXRound(ty2, tx3, ty3),
          ty1 = calcMatrix.getYRound(ty2, tx3, ty3),
          tx2 = calcMatrix.getXRound(xw, tx3, ty3),
          ty2 = calcMatrix.getYRound(xw, tx3, ty3),
          tx3 = calcMatrix.getXRound(xw, y, ty3),
          ty3 = calcMatrix.getYRound(xw, y, ty3);
      pipeline.batchQuad(src, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, glyph.u0, glyph.v0, glyph.u1, glyph.v1, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, textureUnit);
    };
  }, function (module, exports, __webpack_require__) {
    var SetTransform = __webpack_require__(30);

    module.exports = function (renderer, src, camera, bounds) {
      var text = src._text,
          textLength = text.length,
          ctx = renderer.currentContext;

      if (0 !== textLength && SetTransform(renderer, ctx, src, camera, bounds)) {
        camera.addToRenderList(src);
        var bounds = src.fromAtlas ? src.frame : src.texture.frames.__BASE,
            chars = src.fontData.chars,
            lineHeight = src.fontData.lineHeight,
            letterSpacing = src._letterSpacing,
            xAdvance = 0,
            yAdvance = 0,
            charCode = 0,
            glyph = null,
            glyphX = 0,
            glyphY = 0,
            glyphW = 0,
            glyphH = 0,
            x = 0,
            y = 0,
            lastGlyph = null,
            lastCharCode = 0,
            image = bounds.source.image,
            textureX = bounds.cutX,
            textureY = bounds.cutY,
            scale = src._fontSize / src.fontData.size,
            align = src._align,
            currentLine = 0,
            lineOffsetX = 0,
            bounds = src.getTextBounds(!1);
        0 < src.maxWidth && (textLength = (text = bounds.wrappedText).length);
        var lineData = src._bounds.lines;
        1 === align ? lineOffsetX = (lineData.longest - lineData.lengths[0]) / 2 : 2 === align && (lineOffsetX = lineData.longest - lineData.lengths[0]), ctx.translate(-src.displayOriginX, -src.displayOriginY);

        for (var kerningOffset, roundPixels = camera.roundPixels, i = 0; i < textLength; i++) {
          10 !== (charCode = text.charCodeAt(i)) ? (glyph = chars[charCode]) && (glyphX = textureX + glyph.x, glyphY = textureY + glyph.y, glyphW = glyph.width, glyphH = glyph.height, x = glyph.xOffset + xAdvance, y = glyph.yOffset + yAdvance, null !== lastGlyph && (x += void 0 !== (kerningOffset = glyph.kerning[lastCharCode]) ? kerningOffset : 0), x *= scale, y *= scale, x += lineOffsetX, xAdvance += glyph.xAdvance + letterSpacing, lastGlyph = glyph, lastCharCode = charCode, 0 !== glyphW && 0 !== glyphH && 32 !== charCode && (roundPixels && (x = Math.round(x), y = Math.round(y)), ctx.save(), ctx.translate(x, y), ctx.scale(scale, scale), ctx.drawImage(image, glyphX, glyphY, glyphW, glyphH, 0, 0, glyphW, glyphH), ctx.restore())) : (currentLine++, 1 === align ? lineOffsetX = (lineData.longest - lineData.lengths[currentLine]) / 2 : 2 === align && (lineOffsetX = lineData.longest - lineData.lengths[currentLine]), xAdvance = 0, yAdvance += lineHeight, lastGlyph = null);
        }

        ctx.restore();
      }
    };
  }, function (module, exports, __webpack_require__) {
    var renderWebGL = __webpack_require__(1),
        renderCanvas = __webpack_require__(1),
        renderWebGL = __webpack_require__(1050),
        renderCanvas = __webpack_require__(1051);

    module.exports = {
      renderWebGL: renderWebGL,
      renderCanvas: renderCanvas
    };
  }, function (module, exports, __webpack_require__) {
    var TransformMatrix = __webpack_require__(25),
        Utils = __webpack_require__(12),
        tempMatrix = new TransformMatrix();

    module.exports = function (renderer, src, camera, parentMatrix) {
      var list = src.getRenderList();

      if (0 !== list.length) {
        var alpha = camera.alpha * src.alpha;

        if (0 != alpha) {
          camera.addToRenderList(src);
          var pipeline = renderer.pipelines.set(this.pipeline, src),
              cameraScrollX = camera.scrollX * src.scrollFactorX,
              cameraScrollY = camera.scrollY * src.scrollFactorY,
              calcMatrix = tempMatrix.copyFrom(camera.matrix);
          parentMatrix && (calcMatrix.multiplyWithOffset(parentMatrix, -cameraScrollX, -cameraScrollY), cameraScrollY = cameraScrollX = 0);
          var blitterX = src.x - cameraScrollX,
              blitterY = src.y - cameraScrollY,
              prevTextureSourceIndex = -1,
              roundPixels = camera.roundPixels;
          renderer.pipelines.preBatch(src);

          for (var index = 0; index < list.length; index++) {
            var xw,
                tx0,
                ty0,
                tx1,
                ty1,
                textureUnit,
                bob = list[index],
                frame = bob.frame,
                tint = bob.alpha * alpha;
            0 != tint && (ty1 = frame.width, tx0 = frame.height, ty0 = blitterX + bob.x + frame.x, tx1 = blitterY + bob.y + frame.y, bob.flipX && (ty1 *= -1, ty0 += frame.width), bob.flipY && (tx0 *= -1, tx1 += frame.height), xw = ty0 + ty1, ty1 = tx1 + tx0, tx0 = calcMatrix.getX(ty0, tx1), ty0 = calcMatrix.getY(ty0, tx1), tx1 = calcMatrix.getX(xw, ty1), ty1 = calcMatrix.getY(xw, ty1), tint = Utils.getTintAppendFloatAlpha(bob.tint, tint), frame.sourceIndex !== prevTextureSourceIndex && (textureUnit = pipeline.setGameObject(src, frame), prevTextureSourceIndex = frame.sourceIndex), roundPixels && (tx0 = Math.round(tx0), ty0 = Math.round(ty0), tx1 = Math.round(tx1), ty1 = Math.round(ty1)), pipeline.batchQuad(src, tx0, ty0, tx0, ty1, tx1, ty1, tx1, ty0, frame.u0, frame.v0, frame.u1, frame.v1, tint, tint, tint, tint, !1, frame.glTexture, textureUnit) && (prevTextureSourceIndex = -1));
          }

          renderer.pipelines.postBatch(src);
        }
      }
    };
  }, function (module, exports) {
    module.exports = function (renderer, src, camera, parentMatrix) {
      var list = src.getRenderList();

      if (0 !== list.length) {
        var ctx = renderer.currentContext,
            alpha = camera.alpha * src.alpha;

        if (0 != alpha) {
          camera.addToRenderList(src), ctx.globalCompositeOperation = renderer.blendModes[src.blendMode], ctx.imageSmoothingEnabled = !(!renderer.antialias || src.frame.source.scaleMode);
          var cameraScrollX = src.x - camera.scrollX * src.scrollFactorX,
              cameraScrollY = src.y - camera.scrollY * src.scrollFactorY;
          ctx.save(), parentMatrix && parentMatrix.copyToContext(ctx);

          for (var roundPixels = camera.roundPixels, i = 0; i < list.length; i++) {
            var bob = list[i],
                flip = bob.flipX || bob.flipY,
                frame = bob.frame,
                cd = frame.canvasData,
                dx = frame.x,
                dy = frame.y,
                fx = 1,
                fy = 1,
                bobAlpha = bob.alpha * alpha;
            0 != bobAlpha && (ctx.globalAlpha = bobAlpha, flip ? (bob.flipX && (fx = -1, dx -= cd.width), bob.flipY && (fy = -1, dy -= cd.height), ctx.save(), ctx.translate(bob.x + cameraScrollX, bob.y + cameraScrollY), ctx.scale(fx, fy), ctx.drawImage(frame.source.image, cd.x, cd.y, cd.width, cd.height, dx, dy, cd.width, cd.height), ctx.restore()) : (roundPixels && (dx = Math.round(dx), dy = Math.round(dy)), ctx.drawImage(frame.source.image, cd.x, cd.y, cd.width, cd.height, dx + bob.x + cameraScrollX, dy + bob.y + cameraScrollY, cd.width, cd.height)));
          }

          ctx.restore();
        }
      }
    };
  }, function (module, exports, __webpack_require__) {
    var renderWebGL = __webpack_require__(1),
        renderCanvas = __webpack_require__(1),
        renderWebGL = __webpack_require__(1053),
        renderCanvas = __webpack_require__(1054);

    module.exports = {
      renderWebGL: renderWebGL,
      renderCanvas: renderCanvas
    };
  }, function (module, exports) {
    module.exports = function (renderer, container, camera, parentMatrix) {
      camera.addToRenderList(container);
      var children = container.list,
          childCount = children.length;

      if (0 !== childCount) {
        var transformMatrix = container.localTransform;
        parentMatrix ? (transformMatrix.loadIdentity(), transformMatrix.multiply(parentMatrix), transformMatrix.translate(container.x, container.y), transformMatrix.rotate(container.rotation), transformMatrix.scale(container.scaleX, container.scaleY)) : transformMatrix.applyITRS(container.x, container.y, container.rotation, container.scaleX, container.scaleY), renderer.pipelines.preBatch(container);
        var containerHasBlendMode = -1 !== container.blendMode;
        containerHasBlendMode || renderer.setBlendMode(0);

        for (var alpha = container.alpha, scrollFactorX = container.scrollFactorX, scrollFactorY = container.scrollFactorY, i = 0; i < childCount; i++) {
          var childAlphaTopLeft,
              childAlphaTopRight,
              childAlphaBottomLeft,
              childAlphaBottomRight,
              childScrollFactorX,
              childScrollFactorY,
              mask,
              type,
              child = children[i];
          child.willRender(camera) && (childAlphaBottomRight = void 0 !== child.alphaTopLeft ? (childAlphaTopLeft = child.alphaTopLeft, childAlphaTopRight = child.alphaTopRight, childAlphaBottomLeft = child.alphaBottomLeft, child.alphaBottomRight) : childAlphaBottomLeft = childAlphaTopRight = childAlphaTopLeft = child.alpha, childScrollFactorX = child.scrollFactorX, childScrollFactorY = child.scrollFactorY, containerHasBlendMode || child.blendMode === renderer.currentBlendMode || renderer.setBlendMode(child.blendMode), (mask = child.mask) && mask.preRenderWebGL(renderer, child, camera), (type = child.type) !== renderer.currentType && (renderer.newType = !0, renderer.currentType = type), renderer.nextTypeMatch = i < childCount - 1 && children[i + 1].type === renderer.currentType, child.setScrollFactor(childScrollFactorX * scrollFactorX, childScrollFactorY * scrollFactorY), child.setAlpha(childAlphaTopLeft * alpha, childAlphaTopRight * alpha, childAlphaBottomLeft * alpha, childAlphaBottomRight * alpha), child.renderWebGL(renderer, child, camera, transformMatrix), child.setAlpha(childAlphaTopLeft, childAlphaTopRight, childAlphaBottomLeft, childAlphaBottomRight), child.setScrollFactor(childScrollFactorX, childScrollFactorY), mask && mask.postRenderWebGL(renderer, camera), renderer.newType = !1);
        }

        renderer.pipelines.postBatch(container);
      }
    };
  }, function (module, exports) {
    module.exports = function (renderer, container, camera, parentMatrix) {
      camera.addToRenderList(container);
      var children = container.list;

      if (0 !== children.length) {
        var transformMatrix = container.localTransform;
        parentMatrix ? (transformMatrix.loadIdentity(), transformMatrix.multiply(parentMatrix), transformMatrix.translate(container.x, container.y), transformMatrix.rotate(container.rotation), transformMatrix.scale(container.scaleX, container.scaleY)) : transformMatrix.applyITRS(container.x, container.y, container.rotation, container.scaleX, container.scaleY);
        var containerHasBlendMode = -1 !== container.blendMode;
        containerHasBlendMode || renderer.setBlendMode(0);
        var alpha = container._alpha,
            scrollFactorX = container.scrollFactorX,
            scrollFactorY = container.scrollFactorY;
        container.mask && container.mask.preRenderCanvas(renderer, null, camera);

        for (var i = 0; i < children.length; i++) {
          var childAlpha,
              childScrollFactorX,
              childScrollFactorY,
              child = children[i];
          child.willRender(camera) && (childAlpha = child.alpha, childScrollFactorX = child.scrollFactorX, childScrollFactorY = child.scrollFactorY, containerHasBlendMode || child.blendMode === renderer.currentBlendMode || renderer.setBlendMode(child.blendMode), child.setScrollFactor(childScrollFactorX * scrollFactorX, childScrollFactorY * scrollFactorY), child.setAlpha(childAlpha * alpha), child.renderCanvas(renderer, child, camera, transformMatrix), child.setAlpha(childAlpha), child.setScrollFactor(childScrollFactorX, childScrollFactorY));
        }

        container.mask && container.mask.postRenderCanvas(renderer);
      }
    };
  }, function (module, exports, __webpack_require__) {
    var renderWebGL = __webpack_require__(1),
        renderCanvas = __webpack_require__(1),
        renderWebGL = __webpack_require__(443),
        renderCanvas = __webpack_require__(443);

    module.exports = {
      renderWebGL: renderWebGL,
      renderCanvas: renderCanvas
    };
  }, function (module, exports) {
    module.exports = ["normal", "multiply", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"];
  }, function (module, exports, __webpack_require__) {
    var renderWebGL = __webpack_require__(1),
        renderCanvas = __webpack_require__(1),
        renderWebGL = __webpack_require__(1058),
        renderCanvas = __webpack_require__(1059);

    module.exports = {
      renderWebGL: renderWebGL,
      renderCanvas: renderCanvas
    };
  }, function (module, exports, __webpack_require__) {
    var GetCalcMatrix = __webpack_require__(19),
        TransformMatrix = __webpack_require__(25),
        Utils = __webpack_require__(12),
        tempMatrix = new TransformMatrix();

    module.exports = function (renderer, src, camera, crop) {
      var text = src.text,
          textLength = text.length;

      if (0 !== textLength) {
        camera.addToRenderList(src);
        var pipeline = renderer.pipelines.set(src.pipeline, src),
            bounds = GetCalcMatrix(src, camera, crop),
            spriteMatrix = bounds.sprite,
            calcMatrix = bounds.calc,
            fontMatrix = tempMatrix,
            crop = 0 < src.cropWidth || 0 < src.cropHeight;
        crop && (pipeline.flush(), renderer.pushScissor(calcMatrix.tx, calcMatrix.ty, src.cropWidth * calcMatrix.scaleX, src.cropHeight * calcMatrix.scaleY));
        var lastGlyph,
            texture = src.frame.glTexture,
            tintEffect = src.tintFill,
            tintTL = Utils.getTintAppendFloatAlpha(src.tintTopLeft, camera.alpha * src._alphaTL),
            tintTR = Utils.getTintAppendFloatAlpha(src.tintTopRight, camera.alpha * src._alphaTR),
            tintBL = Utils.getTintAppendFloatAlpha(src.tintBottomLeft, camera.alpha * src._alphaBL),
            tintBR = Utils.getTintAppendFloatAlpha(src.tintBottomRight, camera.alpha * src._alphaBR),
            textureUnit = pipeline.setGameObject(src),
            xAdvance = 0,
            yAdvance = 0,
            charCode = 0,
            lastCharCode = 0,
            letterSpacing = src.letterSpacing,
            glyphW = 0,
            glyphH = 0,
            scrollX = src.scrollX,
            scrollY = src.scrollY,
            bounds = src.fontData,
            chars = bounds.chars,
            lineHeight = bounds.lineHeight,
            scale = src.fontSize / bounds.size,
            rotation = 0,
            align = src._align,
            currentLine = 0,
            lineOffsetX = 0,
            bounds = src.getTextBounds(!1);
        0 < src.maxWidth && (textLength = (text = bounds.wrappedText).length);
        var lineData = src._bounds.lines;
        1 === align ? lineOffsetX = (lineData.longest - lineData.lengths[0]) / 2 : 2 === align && (lineOffsetX = lineData.longest - lineData.lengths[0]);
        var roundPixels = camera.roundPixels,
            displayCallback = src.displayCallback,
            callbackData = src.callbackData;
        renderer.pipelines.preBatch(src);

        for (var u0, v0, u1, v1, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, i = 0; i < textLength; i++) {
          10 !== (charCode = text.charCodeAt(i)) ? (ty3 = chars[charCode]) && (glyphW = ty3.width, glyphH = ty3.height, ty2 = ty3.xOffset + xAdvance - scrollX, tx3 = ty3.yOffset + yAdvance - scrollY, null !== lastGlyph && (ty2 += void 0 !== (ty1 = ty3.kerning[lastCharCode]) ? ty1 : 0), xAdvance += ty3.xAdvance + letterSpacing, lastGlyph = ty3, lastCharCode = charCode, 0 !== glyphW && 0 !== glyphH && 32 !== charCode && (scale = src.fontSize / src.fontData.size, rotation = 0, displayCallback && (callbackData.color = 0, callbackData.tint.topLeft = tintTL, callbackData.tint.topRight = tintTR, callbackData.tint.bottomLeft = tintBL, callbackData.tint.bottomRight = tintBR, callbackData.index = i, callbackData.charCode = charCode, callbackData.x = ty2, callbackData.y = tx3, callbackData.scale = scale, callbackData.rotation = rotation, callbackData.data = ty3.data, ty2 = (tx2 = displayCallback(callbackData)).x, tx3 = tx2.y, scale = tx2.scale, rotation = tx2.rotation, tintBR = tx2.color ? (tintTL = tx2.color, tintTR = tx2.color, tintBL = tx2.color, tx2.color) : (tintTL = tx2.tint.topLeft, tintTR = tx2.tint.topRight, tintBL = tx2.tint.bottomLeft, tx2.tint.bottomRight), tintTL = Utils.getTintAppendFloatAlpha(tintTL, camera.alpha * src._alphaTL), tintTR = Utils.getTintAppendFloatAlpha(tintTR, camera.alpha * src._alphaTR), tintBL = Utils.getTintAppendFloatAlpha(tintBL, camera.alpha * src._alphaBL), tintBR = Utils.getTintAppendFloatAlpha(tintBR, camera.alpha * src._alphaBR)), ty2 *= scale, tx3 *= scale, ty2 -= src.displayOriginX, tx3 -= src.displayOriginY, ty2 += lineOffsetX, fontMatrix.applyITRS(ty2, tx3, rotation, scale, scale), calcMatrix.multiply(fontMatrix, spriteMatrix), u0 = ty3.u0, v0 = ty3.v0, u1 = ty3.u1, v1 = ty3.v1, tx0 = spriteMatrix.e, ty0 = spriteMatrix.f, tx1 = glyphH * spriteMatrix.c + spriteMatrix.e, ty1 = glyphH * spriteMatrix.d + spriteMatrix.f, tx2 = glyphW * spriteMatrix.a + glyphH * spriteMatrix.c + spriteMatrix.e, ty2 = glyphW * spriteMatrix.b + glyphH * spriteMatrix.d + spriteMatrix.f, tx3 = glyphW * spriteMatrix.a + spriteMatrix.e, ty3 = glyphW * spriteMatrix.b + spriteMatrix.f, roundPixels && (tx0 = Math.round(tx0), ty0 = Math.round(ty0), tx1 = Math.round(tx1), ty1 = Math.round(ty1), tx2 = Math.round(tx2), ty2 = Math.round(ty2), tx3 = Math.round(tx3), ty3 = Math.round(ty3)), pipeline.batchQuad(src, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, u0, v0, u1, v1, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, textureUnit))) : (currentLine++, 1 === align ? lineOffsetX = (lineData.longest - lineData.lengths[currentLine]) / 2 : 2 === align && (lineOffsetX = lineData.longest - lineData.lengths[currentLine]), xAdvance = 0, yAdvance += lineHeight, lastGlyph = null);
        }

        crop && (pipeline.flush(), renderer.popScissor()), renderer.pipelines.postBatch(src);
      }
    };
  }, function (module, exports, __webpack_require__) {
    var SetTransform = __webpack_require__(30);

    module.exports = function (renderer, src, camera, textureFrame) {
      var text = src._text,
          textLength = text.length,
          ctx = renderer.currentContext;

      if (0 !== textLength && SetTransform(renderer, ctx, src, camera, textureFrame)) {
        camera.addToRenderList(src);
        var charCode,
            textureFrame = src.fromAtlas ? src.frame : src.texture.frames.__BASE,
            displayCallback = src.displayCallback,
            callbackData = src.callbackData,
            chars = src.fontData.chars,
            lineHeight = src.fontData.lineHeight,
            letterSpacing = src._letterSpacing,
            xAdvance = 0,
            yAdvance = 0,
            glyph = null,
            glyphX = 0,
            glyphY = 0,
            glyphW = 0,
            glyphH = 0,
            x = 0,
            y = 0,
            lastGlyph = null,
            lastCharCode = 0,
            image = src.frame.source.image,
            textureX = textureFrame.cutX,
            textureY = textureFrame.cutY,
            rotation = 0,
            scale = 0,
            baseScale = src._fontSize / src.fontData.size,
            align = src._align,
            currentLine = 0,
            lineOffsetX = 0;
        src.getTextBounds(!1);
        var lineData = src._bounds.lines;
        1 === align ? lineOffsetX = (lineData.longest - lineData.lengths[0]) / 2 : 2 === align && (lineOffsetX = lineData.longest - lineData.lengths[0]), ctx.translate(-src.displayOriginX, -src.displayOriginY);
        var roundPixels = camera.roundPixels;
        0 < src.cropWidth && 0 < src.cropHeight && (ctx.beginPath(), ctx.rect(0, 0, src.cropWidth, src.cropHeight), ctx.clip());

        for (var output, i = 0; i < textLength; i++) {
          scale = baseScale, rotation = 0, 10 !== (charCode = text.charCodeAt(i)) ? (glyph = chars[charCode]) && (glyphX = textureX + glyph.x, glyphY = textureY + glyph.y, glyphW = glyph.width, glyphH = glyph.height, x = glyph.xOffset + xAdvance - src.scrollX, y = glyph.yOffset + yAdvance - src.scrollY, null !== lastGlyph && (x += void 0 !== (output = glyph.kerning[lastCharCode]) ? output : 0), displayCallback && (callbackData.index = i, callbackData.charCode = charCode, callbackData.x = x, callbackData.y = y, callbackData.scale = scale, callbackData.rotation = rotation, callbackData.data = glyph.data, x = (output = displayCallback(callbackData)).x, y = output.y, scale = output.scale, rotation = output.rotation), x *= scale, y *= scale, x += lineOffsetX, xAdvance += glyph.xAdvance + letterSpacing, lastGlyph = glyph, lastCharCode = charCode, 0 !== glyphW && 0 !== glyphH && 32 !== charCode && (roundPixels && (x = Math.round(x), y = Math.round(y)), ctx.save(), ctx.translate(x, y), ctx.rotate(rotation), ctx.scale(scale, scale), ctx.drawImage(image, glyphX, glyphY, glyphW, glyphH, 0, 0, glyphW, glyphH), ctx.restore())) : (currentLine++, 1 === align ? lineOffsetX = (lineData.longest - lineData.lengths[currentLine]) / 2 : 2 === align && (lineOffsetX = lineData.longest - lineData.lengths[currentLine]), xAdvance = 0, yAdvance += lineHeight, lastGlyph = null);
        }

        ctx.restore();
      }
    };
  }, function (module, exports, __webpack_require__) {
    var renderWebGL = __webpack_require__(1),
        renderCanvas = __webpack_require__(1),
        renderWebGL = __webpack_require__(1061),
        renderCanvas = __webpack_require__(1062);

    module.exports = {
      renderWebGL: renderWebGL,
      renderCanvas: renderCanvas
    };
  }, function (module, exports, __webpack_require__) {
    var GetCalcMatrix = __webpack_require__(19);

    module.exports = function (renderer, src, camera, calcMatrix) {
      renderer.pipelines.clear();
      calcMatrix = GetCalcMatrix(src, camera, calcMatrix).calc;
      src.render.call(src, renderer, camera, calcMatrix), renderer.pipelines.rebind();
    };
  }, function (module, exports) {}, function (module, exports, __webpack_require__) {
    var renderWebGL = __webpack_require__(1),
        renderCanvas = __webpack_require__(1),
        renderWebGL = __webpack_require__(1064),
        renderCanvas = __webpack_require__(448);

    renderCanvas = __webpack_require__(448), module.exports = {
      renderWebGL: renderWebGL,
      renderCanvas: renderCanvas
    };
  }, function (module, exports, __webpack_require__) {
    function Path(x, y, width) {
      this.points = [], this.pointsLength = 1, this.points[0] = new Point(x, y, width);
    }

    var Commands = __webpack_require__(217),
        GetCalcMatrix = __webpack_require__(19),
        TransformMatrix = __webpack_require__(25),
        Utils = __webpack_require__(12),
        Point = function Point(x, y, width) {
      this.x = x, this.y = y, this.width = width;
    },
        matrixStack = [],
        tempMatrix = new TransformMatrix();

    module.exports = function (renderer, src, camera, parentMatrix) {
      if (0 !== src.commandBuffer.length) {
        camera.addToRenderList(src);
        var pipeline = renderer.pipelines.set(src.pipeline, src);
        renderer.pipelines.preBatch(src);

        for (var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc, currentMatrix = tempMatrix.loadIdentity(), commands = src.commandBuffer, alpha = camera.alpha * src.alpha, lineWidth = 1, fillTint = pipeline.fillTint, strokeTint = pipeline.strokeTint, tx = 0, ty = 0, ta = 0, PI2 = 2 * Math.PI, path = [], pathIndex = 0, pathOpen = !0, lastPath = null, getTint = Utils.getTintAppendFloatAlpha, cmdIndex = 0; cmdIndex < commands.length; cmdIndex++) {
          switch (commands[cmdIndex]) {
            case Commands.BEGIN_PATH:
              path.length = 0, pathOpen = !(lastPath = null);
              break;

            case Commands.CLOSE_PATH:
              pathOpen = !1, lastPath && lastPath.points.length && lastPath.points.push(lastPath.points[0]);
              break;

            case Commands.FILL_PATH:
              for (pathIndex = 0; pathIndex < path.length; pathIndex++) {
                pipeline.batchFillPath(path[pathIndex].points, currentMatrix, calcMatrix);
              }

              break;

            case Commands.STROKE_PATH:
              for (pathIndex = 0; pathIndex < path.length; pathIndex++) {
                pipeline.batchStrokePath(path[pathIndex].points, lineWidth, pathOpen, currentMatrix, calcMatrix);
              }

              break;

            case Commands.LINE_STYLE:
              var lineWidth = commands[++cmdIndex],
                  alphaBL = getTint(commands[++cmdIndex], commands[++cmdIndex] * alpha);
              strokeTint.TL = alphaBL, strokeTint.TR = alphaBL, strokeTint.BL = alphaBL, strokeTint.BR = alphaBL;
              break;

            case Commands.FILL_STYLE:
              var alphaBR = getTint(commands[++cmdIndex], commands[++cmdIndex] * alpha);
              fillTint.TL = alphaBR, fillTint.TR = alphaBR, fillTint.BL = alphaBR, fillTint.BR = alphaBR;
              break;

            case Commands.GRADIENT_FILL_STYLE:
              var alphaTL = commands[++cmdIndex] * alpha,
                  alphaTR = commands[++cmdIndex] * alpha,
                  alphaBL = commands[++cmdIndex] * alpha,
                  alphaBR = commands[++cmdIndex] * alpha;
              fillTint.TL = getTint(commands[++cmdIndex], alphaTL), fillTint.TR = getTint(commands[++cmdIndex], alphaTR), fillTint.BL = getTint(commands[++cmdIndex], alphaBL), fillTint.BR = getTint(commands[++cmdIndex], alphaBR);
              break;

            case Commands.GRADIENT_LINE_STYLE:
              lineWidth = commands[++cmdIndex];
              var anticlockwise = commands[++cmdIndex] * alpha;
              strokeTint.TL = getTint(commands[++cmdIndex], anticlockwise), strokeTint.TR = getTint(commands[++cmdIndex], anticlockwise), strokeTint.BL = getTint(commands[++cmdIndex], anticlockwise), strokeTint.BR = getTint(commands[++cmdIndex], anticlockwise);
              break;

            case Commands.ARC:
              var iteration = 0,
                  x = commands[++cmdIndex],
                  y = commands[++cmdIndex],
                  radius = commands[++cmdIndex],
                  startAngle = commands[++cmdIndex],
                  endAngle = commands[++cmdIndex],
                  anticlockwise = commands[++cmdIndex],
                  overshoot = commands[++cmdIndex];

              for (endAngle -= startAngle, anticlockwise ? endAngle < -PI2 ? endAngle = -PI2 : 0 < endAngle && (endAngle = endAngle % PI2 - PI2) : PI2 < endAngle ? endAngle = PI2 : endAngle < 0 && (endAngle = PI2 + endAngle % PI2), null === lastPath && (lastPath = new Path(x + Math.cos(startAngle) * radius, y + Math.sin(startAngle) * radius, lineWidth), path.push(lastPath), iteration += .01); iteration < 1 + overshoot;) {
                ta = endAngle * iteration + startAngle, tx = x + Math.cos(ta) * radius, ty = y + Math.sin(ta) * radius, lastPath.points.push(new Point(tx, ty, lineWidth)), iteration += .01;
              }

              ta = endAngle + startAngle, tx = x + Math.cos(ta) * radius, ty = y + Math.sin(ta) * radius, lastPath.points.push(new Point(tx, ty, lineWidth));
              break;

            case Commands.FILL_RECT:
              pipeline.batchFillRect(commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], currentMatrix, calcMatrix);
              break;

            case Commands.FILL_TRIANGLE:
              pipeline.batchFillTriangle(commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], currentMatrix, calcMatrix);
              break;

            case Commands.STROKE_TRIANGLE:
              pipeline.batchStrokeTriangle(commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], lineWidth, currentMatrix, calcMatrix);
              break;

            case Commands.LINE_TO:
              null !== lastPath ? lastPath.points.push(new Point(commands[++cmdIndex], commands[++cmdIndex], lineWidth)) : (lastPath = new Path(commands[++cmdIndex], commands[++cmdIndex], lineWidth), path.push(lastPath));
              break;

            case Commands.MOVE_TO:
              lastPath = new Path(commands[++cmdIndex], commands[++cmdIndex], lineWidth), path.push(lastPath);
              break;

            case Commands.SAVE:
              matrixStack.push(currentMatrix.copyToArray());
              break;

            case Commands.RESTORE:
              currentMatrix.copyFromArray(matrixStack.pop());
              break;

            case Commands.TRANSLATE:
              x = commands[++cmdIndex], y = commands[++cmdIndex], currentMatrix.translate(x, y);
              break;

            case Commands.SCALE:
              x = commands[++cmdIndex], y = commands[++cmdIndex], currentMatrix.scale(x, y);
              break;

            case Commands.ROTATE:
              currentMatrix.rotate(commands[++cmdIndex]);
          }
        }

        renderer.pipelines.postBatch(src);
      }
    };
  }, function (module, exports, __webpack_require__) {
    var renderWebGL = __webpack_require__(1),
        renderCanvas = __webpack_require__(1),
        renderWebGL = __webpack_require__(1066),
        renderCanvas = __webpack_require__(1067);

    module.exports = {
      renderWebGL: renderWebGL,
      renderCanvas: renderCanvas
    };
  }, function (module, exports) {
    module.exports = function (renderer, src, camera, parentMatrix) {
      camera.addToRenderList(src), src.pipeline.batchSprite(src, camera, parentMatrix);
    };
  }, function (module, exports) {
    module.exports = function (renderer, src, camera, parentMatrix) {
      camera.addToRenderList(src), renderer.batchSprite(src, src.frame, camera, parentMatrix);
    };
  }, function (module, exports, __webpack_require__) {
    var renderWebGL = __webpack_require__(1),
        renderCanvas = __webpack_require__(1),
        renderWebGL = __webpack_require__(1069),
        renderCanvas = __webpack_require__(1070);

    module.exports = {
      renderWebGL: renderWebGL,
      renderCanvas: renderCanvas
    };
  }, function (module, exports) {
    module.exports = function (renderer, src, camera, parentMatrix) {
      camera.addToRenderList(src), this.pipeline.batchSprite(src, camera, parentMatrix);
    };
  }, function (module, exports) {
    module.exports = function (renderer, src, camera, parentMatrix) {
      camera.addToRenderList(src), renderer.batchSprite(src, src.frame, camera, parentMatrix);
    };
  }, function (module, exports, __webpack_require__) {
    var renderWebGL = __webpack_require__(1),
        renderCanvas = __webpack_require__(1),
        renderWebGL = __webpack_require__(1072),
        renderCanvas = __webpack_require__(1073);

    module.exports = {
      renderWebGL: renderWebGL,
      renderCanvas: renderCanvas
    };
  }, function (module, exports) {
    module.exports = function (renderer, layer, camera) {
      var children = layer.list,
          childCount = children.length;

      if (0 !== childCount) {
        layer.depthSort(), renderer.pipelines.preBatch(layer);
        var layerHasBlendMode = -1 !== layer.blendMode;
        layerHasBlendMode || renderer.setBlendMode(0);

        for (var alpha = layer.alpha, i = 0; i < childCount; i++) {
          var childAlphaTopLeft,
              childAlphaTopRight,
              childAlphaBottomLeft,
              childAlphaBottomRight,
              mask,
              type,
              child = children[i];
          child.willRender(camera) && (childAlphaBottomRight = void 0 !== child.alphaTopLeft ? (childAlphaTopLeft = child.alphaTopLeft, childAlphaTopRight = child.alphaTopRight, childAlphaBottomLeft = child.alphaBottomLeft, child.alphaBottomRight) : childAlphaBottomLeft = childAlphaTopRight = childAlphaTopLeft = child.alpha, layerHasBlendMode || child.blendMode === renderer.currentBlendMode || renderer.setBlendMode(child.blendMode), (mask = child.mask) && mask.preRenderWebGL(renderer, child, camera), (type = child.type) !== renderer.currentType && (renderer.newType = !0, renderer.currentType = type), renderer.nextTypeMatch = i < childCount - 1 && children[i + 1].type === renderer.currentType, child.setAlpha(childAlphaTopLeft * alpha, childAlphaTopRight * alpha, childAlphaBottomLeft * alpha, childAlphaBottomRight * alpha), child.renderWebGL(renderer, child, camera), child.setAlpha(childAlphaTopLeft, childAlphaTopRight, childAlphaBottomLeft, childAlphaBottomRight), mask && mask.postRenderWebGL(renderer, camera), renderer.newType = !1);
        }

        renderer.pipelines.postBatch(layer);
      }
    };
  }, function (module, exports) {
    module.exports = function (renderer, layer, camera) {
      var children = layer.list;

      if (0 !== children.length) {
        layer.depthSort();
        var layerHasBlendMode = -1 !== layer.blendMode;
        layerHasBlendMode || renderer.setBlendMode(0);
        var alpha = layer._alpha;
        layer.mask && layer.mask.preRenderCanvas(renderer, null, camera);

        for (var i = 0; i < children.length; i++) {
          var childAlpha,
              child = children[i];
          child.willRender(camera) && (childAlpha = child.alpha, layerHasBlendMode || child.blendMode === renderer.currentBlendMode || renderer.setBlendMode(child.blendMode), child.setAlpha(childAlpha * alpha), child.renderCanvas(renderer, child, camera), child.setAlpha(childAlpha));
        }

        layer.mask && layer.mask.postRenderCanvas(renderer);
      }
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      EmitterOp: __webpack_require__(449),
      GravityWell: __webpack_require__(450),
      Particle: __webpack_require__(451),
      ParticleEmitter: __webpack_require__(452),
      ParticleEmitterManager: __webpack_require__(220),
      Zones: __webpack_require__(1078)
    };
  }, function (module, exports, __webpack_require__) {
    var renderWebGL = __webpack_require__(1),
        renderCanvas = __webpack_require__(1),
        renderWebGL = __webpack_require__(1076),
        renderCanvas = __webpack_require__(1077);

    module.exports = {
      renderWebGL: renderWebGL,
      renderCanvas: renderCanvas
    };
  }, function (module, exports, __webpack_require__) {
    var TransformMatrix = __webpack_require__(25),
        Utils = __webpack_require__(12),
        tempMatrix1 = new TransformMatrix(),
        tempMatrix2 = new TransformMatrix(),
        tempMatrix3 = new TransformMatrix(),
        tempMatrix4 = new TransformMatrix();

    module.exports = function (renderer, emitterManager, camera, parentMatrix) {
      var emitters = emitterManager.emitters.list,
          emittersLength = emitters.length;

      if (0 !== emittersLength) {
        var pipeline = renderer.pipelines.set(emitterManager.pipeline),
            camMatrix = tempMatrix1,
            calcMatrix = tempMatrix2,
            particleMatrix = tempMatrix3,
            managerMatrix = tempMatrix4;
        parentMatrix ? (managerMatrix.loadIdentity(), managerMatrix.multiply(parentMatrix), managerMatrix.translate(emitterManager.x, emitterManager.y), managerMatrix.rotate(emitterManager.rotation), managerMatrix.scale(emitterManager.scaleX, emitterManager.scaleY)) : managerMatrix.applyITRS(emitterManager.x, emitterManager.y, emitterManager.rotation, emitterManager.scaleX, emitterManager.scaleY);
        var roundPixels = camera.roundPixels,
            texture = emitterManager.defaultFrame.glTexture,
            getTint = Utils.getTintAppendFloatAlpha,
            textureUnit = pipeline.setGameObject(emitterManager, emitterManager.defaultFrame);
        renderer.pipelines.preBatch(emitterManager);

        for (var e = 0; e < emittersLength; e++) {
          var emitter = emitters[e],
              particles = emitter.alive,
              particleCount = particles.length;

          if (emitter.visible && 0 !== particleCount) {
            camera.addToRenderList(emitter);
            var scrollFactorX = emitter.scrollFactorX,
                scrollFactorY = emitter.scrollFactorY;
            renderer.setBlendMode(emitter.blendMode), emitter.mask && (emitter.mask.preRenderWebGL(renderer, emitter, camera), renderer.pipelines.set(emitterManager.pipeline));

            for (var i = 0; i < particleCount; i++) {
              var frame,
                  xw,
                  tx0,
                  ty0,
                  tx1,
                  ty1,
                  tx2,
                  ty2,
                  tx3,
                  ty3,
                  particle = particles[i],
                  tint = particle.alpha * camera.alpha;
              tint <= 0 || (particleMatrix.applyITRS(particle.x, particle.y, particle.rotation, particle.scaleX, particle.scaleY), camMatrix.copyFrom(camera.matrix), camMatrix.multiplyWithOffset(managerMatrix, -camera.scrollX * scrollFactorX, -camera.scrollY * scrollFactorY), particleMatrix.e = particle.x, particleMatrix.f = particle.y, camMatrix.multiply(particleMatrix, calcMatrix), ty2 = -(frame = particle.frame).halfWidth, ty3 = -frame.halfHeight, xw = ty2 + frame.width, tx3 = ty3 + frame.height, tx0 = calcMatrix.getXRound(ty2, ty3, roundPixels), ty0 = calcMatrix.getYRound(ty2, ty3, roundPixels), tx1 = calcMatrix.getXRound(ty2, tx3, roundPixels), ty1 = calcMatrix.getYRound(ty2, tx3, roundPixels), tx2 = calcMatrix.getXRound(xw, tx3, roundPixels), ty2 = calcMatrix.getYRound(xw, tx3, roundPixels), tx3 = calcMatrix.getXRound(xw, ty3, roundPixels), ty3 = calcMatrix.getYRound(xw, ty3, roundPixels), tint = getTint(particle.tint, tint), pipeline.batchQuad(emitter, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, frame.u0, frame.v0, frame.u1, frame.v1, tint, tint, tint, tint, 0, texture, textureUnit));
            }

            emitter.mask && emitter.mask.postRenderWebGL(renderer, camera);
          }
        }

        renderer.pipelines.postBatch(emitterManager);
      }
    };
  }, function (module, exports, TransformMatrix) {
    var TransformMatrix = TransformMatrix(25),
        tempMatrix1 = new TransformMatrix(),
        tempMatrix2 = new TransformMatrix(),
        tempMatrix3 = new TransformMatrix(),
        tempMatrix4 = new TransformMatrix();

    module.exports = function (renderer, emitterManager, camera, parentMatrix) {
      var emitters = emitterManager.emitters.list,
          emittersLength = emitters.length;

      if (0 !== emittersLength) {
        var camMatrix = tempMatrix1.copyFrom(camera.matrix),
            calcMatrix = tempMatrix2,
            particleMatrix = tempMatrix3,
            managerMatrix = tempMatrix4;
        parentMatrix ? (managerMatrix.loadIdentity(), managerMatrix.multiply(parentMatrix), managerMatrix.translate(emitterManager.x, emitterManager.y), managerMatrix.rotate(emitterManager.rotation), managerMatrix.scale(emitterManager.scaleX, emitterManager.scaleY)) : managerMatrix.applyITRS(emitterManager.x, emitterManager.y, emitterManager.rotation, emitterManager.scaleX, emitterManager.scaleY);

        for (var ctx = renderer.currentContext, roundPixels = camera.roundPixels, e = 0; e < emittersLength; e++) {
          var emitter = emitters[e],
              particles = emitter.alive,
              particleCount = particles.length;

          if (emitter.visible && 0 !== particleCount) {
            camera.addToRenderList(emitter);
            var scrollFactorX = emitter.scrollFactorX,
                scrollFactorY = emitter.scrollFactorY;
            ctx.save(), ctx.globalCompositeOperation = renderer.blendModes[emitter.blendMode];

            for (var i = 0; i < particleCount; i++) {
              var frame,
                  cd,
                  x,
                  y = particles[i],
                  alpha = y.alpha * camera.alpha;
              alpha <= 0 || (particleMatrix.applyITRS(y.x, y.y, y.rotation, y.scaleX, y.scaleY), camMatrix.copyFrom(camera.matrix), camMatrix.multiplyWithOffset(managerMatrix, -camera.scrollX * scrollFactorX, -camera.scrollY * scrollFactorY), particleMatrix.e = y.x, particleMatrix.f = y.y, camMatrix.multiply(particleMatrix, calcMatrix), cd = (frame = y.frame).canvasData, x = -frame.halfWidth, y = -frame.halfHeight, ctx.globalAlpha = alpha, ctx.save(), calcMatrix.setToContext(ctx), roundPixels && (x = Math.round(x), y = Math.round(y)), ctx.imageSmoothingEnabled = !(!renderer.antialias || frame.source.scaleMode), ctx.drawImage(frame.source.image, cd.x, cd.y, cd.width, cd.height, x, y, cd.width, cd.height), ctx.restore());
            }

            ctx.restore();
          }
        }
      }
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      DeathZone: __webpack_require__(453),
      EdgeZone: __webpack_require__(454),
      RandomZone: __webpack_require__(456)
    };
  }, function (module, exports, __webpack_require__) {
    var renderWebGL = __webpack_require__(1),
        renderCanvas = __webpack_require__(1),
        renderWebGL = __webpack_require__(1080),
        renderCanvas = __webpack_require__(1081);

    module.exports = {
      renderWebGL: renderWebGL,
      renderCanvas: renderCanvas
    };
  }, function (module, exports, __webpack_require__) {
    var Utils = __webpack_require__(12);

    module.exports = function (renderer, src, camera, parentMatrix) {
      camera.addToRenderList(src);
      var cameraAlpha = camera.alpha,
          renderTarget = src.renderTarget,
          width = renderTarget.width,
          height = renderTarget.height,
          getTint = Utils.getTintAppendFloatAlpha,
          pipeline = renderer.pipelines.set(src.pipeline),
          textureUnit = pipeline.setTexture2D(renderTarget.texture);
      renderer.pipelines.preBatch(src), pipeline.batchTexture(src, renderTarget.texture, width, height, src.x, src.y, width, height, src.scaleX, src.scaleY, src.rotation, src.flipX, !src.flipY, src.scrollFactorX, src.scrollFactorY, src.displayOriginX, src.displayOriginY, 0, 0, width, height, getTint(src.tintTopLeft, cameraAlpha * src._alphaTL), getTint(src.tintTopRight, cameraAlpha * src._alphaTR), getTint(src.tintBottomLeft, cameraAlpha * src._alphaBL), getTint(src.tintBottomRight, cameraAlpha * src._alphaBR), src.tintFill, 0, 0, camera, parentMatrix, !0, textureUnit), renderer.resetTextures(), renderer.pipelines.postBatch(src);
    };
  }, function (module, exports) {
    module.exports = function (renderer, src, camera, parentMatrix) {
      camera.addToRenderList(src), renderer.batchSprite(src, src.frame, camera, parentMatrix);
    };
  }, function (module, exports, RetroFont) {
    var RETRO_FONT_CONST = RetroFont(1083),
        RetroFont = RetroFont(17)(!1, RetroFont = {
      Parse: RetroFont(1084)
    }, RETRO_FONT_CONST);
    module.exports = RetroFont;
  }, function (module, exports) {
    module.exports = {
      TEXT_SET1: " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~",
      TEXT_SET2: " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ",
      TEXT_SET3: "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ",
      TEXT_SET4: "ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789",
      TEXT_SET5: "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789",
      TEXT_SET6: "ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789\"(),-.' ",
      TEXT_SET7: "AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW\")28FLRX-'39",
      TEXT_SET8: "0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ",
      TEXT_SET9: "ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,'\"?!",
      TEXT_SET10: "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
      TEXT_SET11: "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,\"-+!?()':;0123456789"
    };
  }, function (module, exports, __webpack_require__) {
    var GetValue = __webpack_require__(6);

    module.exports = function (offsetY, config) {
      var w = config.width,
          h = config.height,
          cx = Math.floor(w / 2),
          cy = Math.floor(h / 2),
          letters = GetValue(config, "chars", "");

      if ("" !== letters) {
        var key = GetValue(config, "image", ""),
            lineSpacing = offsetY.sys.textures.getFrame(key),
            textureX = lineSpacing.cutX,
            textureY = lineSpacing.cutY,
            textureWidth = lineSpacing.source.width,
            textureHeight = lineSpacing.source.height,
            offsetX = GetValue(config, "offset.x", 0),
            offsetY = GetValue(config, "offset.y", 0),
            spacingX = GetValue(config, "spacing.x", 0),
            spacingY = GetValue(config, "spacing.y", 0),
            lineSpacing = GetValue(config, "lineSpacing", 0),
            charsPerRow = GetValue(config, "charsPerRow", null);
        null === charsPerRow && (charsPerRow = textureWidth / w) > letters.length && (charsPerRow = letters.length);

        for (var x = offsetX, y = offsetY, data = {
          retroFont: !0,
          font: key,
          size: w,
          lineHeight: h + lineSpacing,
          chars: {}
        }, r = 0, i = 0; i < letters.length; i++) {
          var charCode = letters.charCodeAt(i);
          data.chars[charCode] = {
            x: x,
            y: y,
            width: w,
            height: h,
            centerX: cx,
            centerY: cy,
            xOffset: 0,
            yOffset: 0,
            xAdvance: w,
            data: {},
            kerning: {},
            u0: (textureX + x) / textureWidth,
            v0: (textureY + y) / textureHeight,
            u1: (textureX + x + w) / textureWidth,
            v1: (textureY + y + h) / textureHeight
          }, ++r === charsPerRow ? (r = 0, x = offsetX, y += h + spacingY) : x += w + spacingX;
        }

        return {
          data: data,
          frame: null,
          texture: key
        };
      }
    };
  }, function (module, exports, __webpack_require__) {
    var renderWebGL = __webpack_require__(1),
        renderCanvas = __webpack_require__(1),
        renderWebGL = __webpack_require__(1086),
        renderCanvas = __webpack_require__(1087);

    module.exports = {
      renderWebGL: renderWebGL,
      renderCanvas: renderCanvas
    };
  }, function (module, exports, __webpack_require__) {
    var GetCalcMatrix = __webpack_require__(19),
        Utils = __webpack_require__(12);

    module.exports = function (renderer, src, camera, vertexCount) {
      camera.addToRenderList(src);
      var pipeline = renderer.pipelines.set(src.pipeline, src),
          calcMatrix = GetCalcMatrix(src, camera, vertexCount).calc,
          vertices = src.vertices,
          uvs = src.uv,
          colors = src.colors,
          alphas = src.alphas,
          alpha = src.alpha,
          getTint = Utils.getTintAppendFloatAlpha,
          roundPixels = camera.roundPixels,
          meshVerticesLength = vertices.length,
          vertexCount = Math.floor(.5 * meshVerticesLength);
      pipeline.flush(), renderer.pipelines.preBatch(src);
      var textureUnit = pipeline.setGameObject(src),
          vertexViewF32 = pipeline.vertexViewF32,
          vertexViewU32 = pipeline.vertexViewU32,
          vertexOffset = pipeline.vertexCount * pipeline.currentShader.vertexComponentCount - 1,
          colorIndex = 0,
          tintEffect = src.tintFill;
      src.dirty && src.updateVertices();

      for (var debugCallback = src.debugCallback, debugVerts = [], i = 0; i < meshVerticesLength; i += 2) {
        var x = vertices[i + 0],
            ty = vertices[i + 1],
            tx = x * calcMatrix.a + ty * calcMatrix.c + calcMatrix.e,
            ty = x * calcMatrix.b + ty * calcMatrix.d + calcMatrix.f;
        roundPixels && (tx = Math.round(tx), ty = Math.round(ty)), vertexViewF32[++vertexOffset] = tx, vertexViewF32[++vertexOffset] = ty, vertexViewF32[++vertexOffset] = uvs[i + 0], vertexViewF32[++vertexOffset] = uvs[i + 1], vertexViewF32[++vertexOffset] = textureUnit, vertexViewF32[++vertexOffset] = tintEffect, vertexViewU32[++vertexOffset] = getTint(colors[colorIndex], camera.alpha * (alphas[colorIndex] * alpha)), colorIndex++, debugCallback && (debugVerts[i + 0] = tx, debugVerts[i + 1] = ty);
      }

      debugCallback && debugCallback.call(src, src, meshVerticesLength, debugVerts), pipeline.vertexCount += vertexCount, renderer.pipelines.postBatch(src);
    };
  }, function (module, exports) {
    module.exports = function () {};
  }, function (module, exports, __webpack_require__) {
    var renderWebGL = __webpack_require__(1),
        renderCanvas = __webpack_require__(1),
        renderWebGL = __webpack_require__(1089),
        renderCanvas = __webpack_require__(1090);

    module.exports = {
      renderWebGL: renderWebGL,
      renderCanvas: renderCanvas
    };
  }, function (module, exports, __webpack_require__) {
    var Utils = __webpack_require__(12);

    module.exports = function (renderer, src, camera, parentMatrix) {
      var frame, width, height, getTint, pipeline, textureUnit;
      0 !== src.width && 0 !== src.height && (camera.addToRenderList(src), width = (frame = src.frame).width, height = frame.height, getTint = Utils.getTintAppendFloatAlpha, textureUnit = (pipeline = renderer.pipelines.set(src.pipeline, src)).setTexture2D(frame.glTexture, src), renderer.pipelines.preBatch(src), pipeline.batchTexture(src, frame.glTexture, width, height, src.x, src.y, width / src.style.resolution, height / src.style.resolution, src.scaleX, src.scaleY, src.rotation, src.flipX, src.flipY, src.scrollFactorX, src.scrollFactorY, src.displayOriginX, src.displayOriginY, 0, 0, width, height, getTint(src.tintTopLeft, camera.alpha * src._alphaTL), getTint(src.tintTopRight, camera.alpha * src._alphaTR), getTint(src.tintBottomLeft, camera.alpha * src._alphaBL), getTint(src.tintBottomRight, camera.alpha * src._alphaBR), src.tintFill, 0, 0, camera, parentMatrix, !1, textureUnit), renderer.pipelines.postBatch(src));
    };
  }, function (module, exports) {
    module.exports = function (renderer, src, camera, parentMatrix) {
      0 !== src.width && 0 !== src.height && (camera.addToRenderList(src), renderer.batchSprite(src, src.frame, camera, parentMatrix));
    };
  }, function (module, exports, __webpack_require__) {
    var renderWebGL = __webpack_require__(1),
        renderCanvas = __webpack_require__(1),
        renderWebGL = __webpack_require__(1092),
        renderCanvas = __webpack_require__(1093);

    module.exports = {
      renderWebGL: renderWebGL,
      renderCanvas: renderCanvas
    };
  }, function (module, exports, __webpack_require__) {
    var Utils = __webpack_require__(12);

    module.exports = function (renderer, src, camera, parentMatrix) {
      src.updateCanvas();
      var getTint,
          pipeline,
          textureUnit,
          width = src.width,
          height = src.height;
      0 !== width && 0 !== height && (camera.addToRenderList(src), renderer.pipelines.preBatch(src), getTint = Utils.getTintAppendFloatAlpha, textureUnit = (pipeline = renderer.pipelines.set(src.pipeline, src)).setTexture2D(src.fillPattern, src), pipeline.batchTexture(src, src.fillPattern, src.displayFrame.width * src.tileScaleX, src.displayFrame.height * src.tileScaleY, src.x, src.y, width, height, src.scaleX, src.scaleY, src.rotation, src.flipX, src.flipY, src.scrollFactorX, src.scrollFactorY, src.originX * width, src.originY * height, 0, 0, width, height, getTint(src.tintTopLeft, camera.alpha * src._alphaTL), getTint(src.tintTopRight, camera.alpha * src._alphaTR), getTint(src.tintBottomLeft, camera.alpha * src._alphaBL), getTint(src.tintBottomRight, camera.alpha * src._alphaBR), src.tintFill, src.tilePositionX % src.displayFrame.width / src.displayFrame.width, src.tilePositionY % src.displayFrame.height / src.displayFrame.height, camera, parentMatrix, !1, textureUnit), renderer.pipelines.postBatch(src));
    };
  }, function (module, exports) {
    module.exports = function (renderer, src, camera, parentMatrix) {
      src.updateCanvas(), camera.addToRenderList(src), renderer.batchSprite(src, src.frame, camera, parentMatrix);
    };
  }, function (module, exports, __webpack_require__) {
    var renderWebGL = __webpack_require__(1),
        renderCanvas = __webpack_require__(1),
        renderWebGL = __webpack_require__(1095),
        renderCanvas = __webpack_require__(1096);

    module.exports = {
      renderWebGL: renderWebGL,
      renderCanvas: renderCanvas
    };
  }, function (module, exports) {
    module.exports = function (renderer, src, camera, parentMatrix) {
      src.videoTexture && (camera.addToRenderList(src), src.pipeline.batchSprite(src, camera, parentMatrix));
    };
  }, function (module, exports) {
    module.exports = function (renderer, src, camera, parentMatrix) {
      src.videoTexture && (camera.addToRenderList(src), renderer.batchSprite(src, src.frame, camera, parentMatrix));
    };
  }, function (module, exports, __webpack_require__) {
    var renderWebGL = __webpack_require__(1),
        renderCanvas = __webpack_require__(1),
        renderWebGL = __webpack_require__(1098),
        renderCanvas = __webpack_require__(1099);

    module.exports = {
      renderWebGL: renderWebGL,
      renderCanvas: renderCanvas
    };
  }, function (module, exports, __webpack_require__) {
    var GetCalcMatrix = __webpack_require__(19),
        FillPathWebGL = __webpack_require__(114),
        StrokePathWebGL = __webpack_require__(81);

    module.exports = function (renderer, src, alpha, dx) {
      alpha.addToRenderList(src);
      var pipeline = renderer.pipelines.set(src.pipeline),
          dy = GetCalcMatrix(src, alpha, dx),
          calcMatrix = pipeline.calcMatrix.copyFrom(dy.calc),
          dx = src._displayOriginX,
          dy = src._displayOriginY,
          alpha = alpha.alpha * src.alpha;
      renderer.pipelines.preBatch(src), src.isFilled && FillPathWebGL(pipeline, calcMatrix, src, alpha, dx, dy), src.isStroked && StrokePathWebGL(pipeline, src, alpha, dx, dy), renderer.pipelines.postBatch(src);
    };
  }, function (module, exports, __webpack_require__) {
    var DegToRad = __webpack_require__(36),
        FillStyleCanvas = __webpack_require__(48),
        LineStyleCanvas = __webpack_require__(60),
        SetTransform = __webpack_require__(30);

    module.exports = function (renderer, src, camera, radius) {
      camera.addToRenderList(src);
      var ctx = renderer.currentContext;
      SetTransform(renderer, ctx, src, camera, radius) && (radius = src.radius, ctx.beginPath(), ctx.arc(radius - src.originX * (2 * radius), radius - src.originY * (2 * radius), radius, DegToRad(src._startAngle), DegToRad(src._endAngle), src.anticlockwise), src.closePath && ctx.closePath(), src.isFilled && (FillStyleCanvas(ctx, src), ctx.fill()), src.isStroked && (LineStyleCanvas(ctx, src), ctx.stroke()), ctx.restore());
    };
  }, function (module, exports, __webpack_require__) {
    var renderWebGL = __webpack_require__(1),
        renderCanvas = __webpack_require__(1),
        renderWebGL = __webpack_require__(1101),
        renderCanvas = __webpack_require__(1102);

    module.exports = {
      renderWebGL: renderWebGL,
      renderCanvas: renderCanvas
    };
  }, function (module, exports, __webpack_require__) {
    var FillPathWebGL = __webpack_require__(114),
        GetCalcMatrix = __webpack_require__(19),
        StrokePathWebGL = __webpack_require__(81);

    module.exports = function (renderer, src, alpha, dx) {
      alpha.addToRenderList(src);
      var pipeline = renderer.pipelines.set(src.pipeline),
          dy = GetCalcMatrix(src, alpha, dx),
          calcMatrix = pipeline.calcMatrix.copyFrom(dy.calc),
          dx = src._displayOriginX + src._curveBounds.x,
          dy = src._displayOriginY + src._curveBounds.y,
          alpha = alpha.alpha * src.alpha;
      renderer.pipelines.preBatch(src), src.isFilled && FillPathWebGL(pipeline, calcMatrix, src, alpha, dx, dy), src.isStroked && StrokePathWebGL(pipeline, src, alpha, dx, dy), renderer.pipelines.postBatch(src);
    };
  }, function (module, exports, __webpack_require__) {
    var FillStyleCanvas = __webpack_require__(48),
        LineStyleCanvas = __webpack_require__(60),
        SetTransform = __webpack_require__(30);

    module.exports = function (renderer, src, px1, py1) {
      px1.addToRenderList(src);
      var ctx = renderer.currentContext;

      if (SetTransform(renderer, ctx, src, px1, py1)) {
        var dx = src._displayOriginX + src._curveBounds.x,
            dy = src._displayOriginY + src._curveBounds.y,
            path = src.pathData,
            pathLength = path.length - 1,
            px1 = path[0] - dx,
            py1 = path[1] - dy;
        ctx.beginPath(), ctx.moveTo(px1, py1), src.closePath || (pathLength -= 2);

        for (var i = 2; i < pathLength; i += 2) {
          var px2 = path[i] - dx,
              py2 = path[i + 1] - dy;
          ctx.lineTo(px2, py2);
        }

        src.closePath && ctx.closePath(), src.isFilled && (FillStyleCanvas(ctx, src), ctx.fill()), src.isStroked && (LineStyleCanvas(ctx, src), ctx.stroke()), ctx.restore();
      }
    };
  }, function (module, exports, __webpack_require__) {
    var renderWebGL = __webpack_require__(1),
        renderCanvas = __webpack_require__(1),
        renderWebGL = __webpack_require__(1104),
        renderCanvas = __webpack_require__(1105);

    module.exports = {
      renderWebGL: renderWebGL,
      renderCanvas: renderCanvas
    };
  }, function (module, exports, __webpack_require__) {
    var FillPathWebGL = __webpack_require__(114),
        GetCalcMatrix = __webpack_require__(19),
        StrokePathWebGL = __webpack_require__(81);

    module.exports = function (renderer, src, alpha, dx) {
      alpha.addToRenderList(src);
      var pipeline = renderer.pipelines.set(src.pipeline),
          dy = GetCalcMatrix(src, alpha, dx),
          calcMatrix = pipeline.calcMatrix.copyFrom(dy.calc),
          dx = src._displayOriginX,
          dy = src._displayOriginY,
          alpha = alpha.alpha * src.alpha;
      renderer.pipelines.preBatch(src), src.isFilled && FillPathWebGL(pipeline, calcMatrix, src, alpha, dx, dy), src.isStroked && StrokePathWebGL(pipeline, src, alpha, dx, dy), renderer.pipelines.postBatch(src);
    };
  }, function (module, exports, __webpack_require__) {
    var FillStyleCanvas = __webpack_require__(48),
        LineStyleCanvas = __webpack_require__(60),
        SetTransform = __webpack_require__(30);

    module.exports = function (renderer, src, px1, py1) {
      px1.addToRenderList(src);
      var ctx = renderer.currentContext;

      if (SetTransform(renderer, ctx, src, px1, py1)) {
        var dx = src._displayOriginX,
            dy = src._displayOriginY,
            path = src.pathData,
            pathLength = path.length - 1,
            px1 = path[0] - dx,
            py1 = path[1] - dy;
        ctx.beginPath(), ctx.moveTo(px1, py1), src.closePath || (pathLength -= 2);

        for (var i = 2; i < pathLength; i += 2) {
          var px2 = path[i] - dx,
              py2 = path[i + 1] - dy;
          ctx.lineTo(px2, py2);
        }

        ctx.closePath(), src.isFilled && (FillStyleCanvas(ctx, src), ctx.fill()), src.isStroked && (LineStyleCanvas(ctx, src), ctx.stroke()), ctx.restore();
      }
    };
  }, function (module, exports, __webpack_require__) {
    var renderWebGL = __webpack_require__(1),
        renderCanvas = __webpack_require__(1),
        renderWebGL = __webpack_require__(1107),
        renderCanvas = __webpack_require__(1108);

    module.exports = {
      renderWebGL: renderWebGL,
      renderCanvas: renderCanvas
    };
  }, function (module, exports, __webpack_require__) {
    var GetCalcMatrix = __webpack_require__(19),
        Utils = __webpack_require__(12);

    module.exports = function (renderer, src, strokeTint, color) {
      strokeTint.addToRenderList(src);
      var pipeline = renderer.pipelines.set(src.pipeline),
          showCells = GetCalcMatrix(src, strokeTint, color);
      pipeline.calcMatrix.copyFrom(showCells.calc).translate(-src._displayOriginX, -src._displayOriginY);
      var fillTint,
          fillTintColor,
          color = strokeTint.alpha * src.alpha,
          width = src.width,
          height = src.height,
          cellWidth = src.cellWidth,
          cellHeight = src.cellHeight,
          gridWidth = Math.ceil(width / cellWidth),
          gridHeight = Math.ceil(height / cellHeight),
          cellWidthA = cellWidth,
          cellHeightA = cellHeight,
          cellWidthB = cellWidth - (gridWidth * cellWidth - width),
          cellHeightB = cellHeight - (gridHeight * cellHeight - height),
          showCells = src.showCells,
          showAltCells = src.showAltCells,
          strokeTint = src.showOutline,
          x = 0,
          y = 0,
          r = 0;
      if (strokeTint && (cellWidthA--, cellHeightA--, cellWidthB === cellWidth && cellWidthB--, cellHeightB === cellHeight && cellHeightB--), renderer.pipelines.preBatch(src), showCells && 0 < src.fillAlpha) for (fillTint = pipeline.fillTint, fillTintColor = Utils.getTintAppendFloatAlpha(src.fillColor, src.fillAlpha * color), fillTint.TL = fillTintColor, fillTint.TR = fillTintColor, fillTint.BL = fillTintColor, fillTint.BR = fillTintColor, y = 0; y < gridHeight; y++) {
        for (showAltCells && (r = y % 2), x = 0; x < gridWidth; x++) {
          showAltCells && r ? r = 0 : (r++, pipeline.batchFillRect(x * cellWidth, y * cellHeight, x < gridWidth - 1 ? cellWidthA : cellWidthB, y < gridHeight - 1 ? cellHeightA : cellHeightB));
        }
      }
      if (showAltCells && 0 < src.altFillAlpha) for (fillTint = pipeline.fillTint, fillTintColor = Utils.getTintAppendFloatAlpha(src.altFillColor, src.altFillAlpha * color), fillTint.TL = fillTintColor, fillTint.TR = fillTintColor, fillTint.BL = fillTintColor, fillTint.BR = fillTintColor, y = 0; y < gridHeight; y++) {
        for (showAltCells && (r = y % 2), x = 0; x < gridWidth; x++) {
          !showAltCells || r ? (r = 0, pipeline.batchFillRect(x * cellWidth, y * cellHeight, x < gridWidth - 1 ? cellWidthA : cellWidthB, y < gridHeight - 1 ? cellHeightA : cellHeightB)) : r = 1;
        }
      }

      if (strokeTint && 0 < src.outlineFillAlpha) {
        strokeTint = pipeline.strokeTint, color = Utils.getTintAppendFloatAlpha(src.outlineFillColor, src.outlineFillAlpha * color);

        for (strokeTint.TL = color, strokeTint.TR = color, strokeTint.BL = color, strokeTint.BR = color, x = 1; x < gridWidth; x++) {
          var x1 = x * cellWidth;
          pipeline.batchLine(x1, 0, x1, height, 1, 1, 1, 0, !1);
        }

        for (y = 1; y < gridHeight; y++) {
          var y1 = y * cellHeight;
          pipeline.batchLine(0, y1, width, y1, 1, 1, 1, 0, !1);
        }
      }

      renderer.pipelines.postBatch(src);
    };
  }, function (module, exports, __webpack_require__) {
    var FillStyleCanvas = __webpack_require__(48),
        LineStyleCanvas = __webpack_require__(60),
        SetTransform = __webpack_require__(30);

    module.exports = function (alpha, src, showOutline, showCells) {
      showOutline.addToRenderList(src);
      var ctx = alpha.currentContext;

      if (SetTransform(alpha, ctx, src, showOutline, showCells)) {
        var dx = -src._displayOriginX,
            dy = -src._displayOriginY,
            alpha = showOutline.alpha * src.alpha,
            width = src.width,
            height = src.height,
            cellWidth = src.cellWidth,
            cellHeight = src.cellHeight,
            gridWidth = Math.ceil(width / cellWidth),
            gridHeight = Math.ceil(height / cellHeight),
            cellWidthA = cellWidth,
            cellHeightA = cellHeight,
            cellWidthB = cellWidth - (gridWidth * cellWidth - width),
            cellHeightB = cellHeight - (gridHeight * cellHeight - height),
            showCells = src.showCells,
            showAltCells = src.showAltCells,
            showOutline = src.showOutline,
            x = 0,
            y = 0,
            r = 0;
        if (showOutline && (cellWidthA--, cellHeightA--, cellWidthB === cellWidth && cellWidthB--, cellHeightB === cellHeight && cellHeightB--), showCells && 0 < src.fillAlpha) for (FillStyleCanvas(ctx, src), y = 0; y < gridHeight; y++) {
          for (showAltCells && (r = y % 2), x = 0; x < gridWidth; x++) {
            showAltCells && r ? r = 0 : (r++, ctx.fillRect(dx + x * cellWidth, dy + y * cellHeight, x < gridWidth - 1 ? cellWidthA : cellWidthB, y < gridHeight - 1 ? cellHeightA : cellHeightB));
          }
        }
        if (showAltCells && 0 < src.altFillAlpha) for (FillStyleCanvas(ctx, src, src.altFillColor, src.altFillAlpha * alpha), y = 0; y < gridHeight; y++) {
          for (showAltCells && (r = y % 2), x = 0; x < gridWidth; x++) {
            !showAltCells || r ? (r = 0, ctx.fillRect(dx + x * cellWidth, dy + y * cellHeight, x < gridWidth - 1 ? cellWidthA : cellWidthB, y < gridHeight - 1 ? cellHeightA : cellHeightB)) : r = 1;
          }
        }

        if (showOutline && 0 < src.outlineFillAlpha) {
          for (LineStyleCanvas(ctx, src, src.outlineFillColor, src.outlineFillAlpha * alpha), x = 1; x < gridWidth; x++) {
            var x1 = x * cellWidth;
            ctx.beginPath(), ctx.moveTo(x1 + dx, dy), ctx.lineTo(x1 + dx, height + dy), ctx.stroke();
          }

          for (y = 1; y < gridHeight; y++) {
            var y1 = y * cellHeight;
            ctx.beginPath(), ctx.moveTo(dx, y1 + dy), ctx.lineTo(dx + width, y1 + dy), ctx.stroke();
          }
        }

        ctx.restore();
      }
    };
  }, function (module, exports, __webpack_require__) {
    var renderWebGL = __webpack_require__(1),
        renderCanvas = __webpack_require__(1),
        renderWebGL = __webpack_require__(1110),
        renderCanvas = __webpack_require__(1111);

    module.exports = {
      renderWebGL: renderWebGL,
      renderCanvas: renderCanvas
    };
  }, function (module, exports, __webpack_require__) {
    var GetCalcMatrix = __webpack_require__(19),
        Utils = __webpack_require__(12);

    module.exports = function (renderer, src, alpha, height) {
      alpha.addToRenderList(src);
      var tint,
          x0,
          y0,
          x1,
          y1,
          x2,
          y2,
          x3,
          y3,
          pipeline = renderer.pipelines.set(src.pipeline),
          sizeA = GetCalcMatrix(src, alpha, height),
          calcMatrix = pipeline.calcMatrix.copyFrom(sizeA.calc),
          sizeB = src.width,
          height = src.height,
          sizeA = sizeB / 2,
          sizeB = sizeB / src.projection,
          alpha = alpha.alpha * src.alpha;
      src.isFilled && (renderer.pipelines.preBatch(src), src.showTop && (tint = Utils.getTintAppendFloatAlpha(src.fillTop, alpha), x0 = calcMatrix.getX(-sizeA, -height), y0 = calcMatrix.getY(-sizeA, -height), x1 = calcMatrix.getX(0, -sizeB - height), y1 = calcMatrix.getY(0, -sizeB - height), x2 = calcMatrix.getX(sizeA, -height), y2 = calcMatrix.getY(sizeA, -height), x3 = calcMatrix.getX(0, sizeB - height), y3 = calcMatrix.getY(0, sizeB - height), pipeline.batchQuad(src, x0, y0, x1, y1, x2, y2, x3, y3, 0, 0, 1, 1, tint, tint, tint, tint, 2)), src.showLeft && (tint = Utils.getTintAppendFloatAlpha(src.fillLeft, alpha), x0 = calcMatrix.getX(-sizeA, 0), y0 = calcMatrix.getY(-sizeA, 0), x1 = calcMatrix.getX(0, sizeB), y1 = calcMatrix.getY(0, sizeB), x2 = calcMatrix.getX(0, sizeB - height), y2 = calcMatrix.getY(0, sizeB - height), x3 = calcMatrix.getX(-sizeA, -height), y3 = calcMatrix.getY(-sizeA, -height), pipeline.batchQuad(src, x0, y0, x1, y1, x2, y2, x3, y3, 0, 0, 1, 1, tint, tint, tint, tint, 2)), src.showRight && (tint = Utils.getTintAppendFloatAlpha(src.fillRight, alpha), x0 = calcMatrix.getX(sizeA, 0), y0 = calcMatrix.getY(sizeA, 0), x1 = calcMatrix.getX(0, sizeB), y1 = calcMatrix.getY(0, sizeB), x2 = calcMatrix.getX(0, sizeB - height), y2 = calcMatrix.getY(0, sizeB - height), x3 = calcMatrix.getX(sizeA, -height), y3 = calcMatrix.getY(sizeA, -height), pipeline.batchQuad(src, x0, y0, x1, y1, x2, y2, x3, y3, 0, 0, 1, 1, tint, tint, tint, tint, 2)), renderer.pipelines.postBatch(src));
    };
  }, function (module, exports, __webpack_require__) {
    var FillStyleCanvas = __webpack_require__(48),
        SetTransform = __webpack_require__(30);

    module.exports = function (sizeB, src, height, sizeA) {
      height.addToRenderList(src);
      var ctx = sizeB.currentContext;
      SetTransform(sizeB, ctx, src, height, sizeA) && src.isFilled && (sizeB = src.width, height = src.height, sizeA = sizeB / 2, sizeB = sizeB / src.projection, src.showTop && (FillStyleCanvas(ctx, src, src.fillTop), ctx.beginPath(), ctx.moveTo(-sizeA, -height), ctx.lineTo(0, -sizeB - height), ctx.lineTo(sizeA, -height), ctx.lineTo(sizeA, -1), ctx.lineTo(0, sizeB - 1), ctx.lineTo(-sizeA, -1), ctx.lineTo(-sizeA, -height), ctx.fill()), src.showLeft && (FillStyleCanvas(ctx, src, src.fillLeft), ctx.beginPath(), ctx.moveTo(-sizeA, 0), ctx.lineTo(0, sizeB), ctx.lineTo(0, sizeB - height), ctx.lineTo(-sizeA, -height), ctx.lineTo(-sizeA, 0), ctx.fill()), src.showRight && (FillStyleCanvas(ctx, src, src.fillRight), ctx.beginPath(), ctx.moveTo(sizeA, 0), ctx.lineTo(0, sizeB), ctx.lineTo(0, sizeB - height), ctx.lineTo(sizeA, -height), ctx.lineTo(sizeA, 0), ctx.fill()), ctx.restore());
    };
  }, function (module, exports, __webpack_require__) {
    var renderWebGL = __webpack_require__(1),
        renderCanvas = __webpack_require__(1),
        renderWebGL = __webpack_require__(1113),
        renderCanvas = __webpack_require__(1114);

    module.exports = {
      renderWebGL: renderWebGL,
      renderCanvas: renderCanvas
    };
  }, function (module, exports, __webpack_require__) {
    var GetCalcMatrix = __webpack_require__(19),
        Utils = __webpack_require__(12);

    module.exports = function (renderer, src, y3, reversed) {
      y3.addToRenderList(src);
      var tint,
          x0,
          y0,
          x1,
          y1,
          x2,
          y2,
          pipeline = renderer.pipelines.set(src.pipeline),
          alpha = GetCalcMatrix(src, y3, reversed),
          calcMatrix = pipeline.calcMatrix.copyFrom(alpha.calc),
          x3 = src.width,
          height = src.height,
          sizeA = x3 / 2,
          sizeB = x3 / src.projection,
          reversed = src.isReversed,
          alpha = y3.alpha * src.alpha;
      src.isFilled && (renderer.pipelines.preBatch(src), src.showTop && reversed && (tint = Utils.getTintAppendFloatAlpha(src.fillTop, alpha), x0 = calcMatrix.getX(-sizeA, -height), y0 = calcMatrix.getY(-sizeA, -height), x1 = calcMatrix.getX(0, -sizeB - height), y1 = calcMatrix.getY(0, -sizeB - height), x2 = calcMatrix.getX(sizeA, -height), y2 = calcMatrix.getY(sizeA, -height), x3 = calcMatrix.getX(0, sizeB - height), y3 = calcMatrix.getY(0, sizeB - height), pipeline.batchQuad(src, x0, y0, x1, y1, x2, y2, x3, y3, 0, 0, 1, 1, tint, tint, tint, tint, 2)), src.showLeft && (tint = Utils.getTintAppendFloatAlpha(src.fillLeft, alpha), y2 = (x2 = (y1 = (x1 = (y0 = reversed ? (x0 = calcMatrix.getX(-sizeA, -height), calcMatrix.getY(-sizeA, -height)) : (x0 = calcMatrix.getX(-sizeA, 0), calcMatrix.getY(-sizeA, 0)), calcMatrix.getX(0, sizeB)), calcMatrix.getY(0, sizeB)), calcMatrix.getX(0, sizeB - height)), calcMatrix.getY(0, sizeB - height)), pipeline.batchTri(src, x0, y0, x1, y1, x2, y2, 0, 0, 1, 1, tint, tint, tint, 2)), src.showRight && (tint = Utils.getTintAppendFloatAlpha(src.fillRight, alpha), y2 = (x2 = (y1 = (x1 = (y0 = reversed ? (x0 = calcMatrix.getX(sizeA, -height), calcMatrix.getY(sizeA, -height)) : (x0 = calcMatrix.getX(sizeA, 0), calcMatrix.getY(sizeA, 0)), calcMatrix.getX(0, sizeB)), calcMatrix.getY(0, sizeB)), calcMatrix.getX(0, sizeB - height)), calcMatrix.getY(0, sizeB - height)), pipeline.batchTri(src, x0, y0, x1, y1, x2, y2, 0, 0, 1, 1, tint, tint, tint, 2)), renderer.pipelines.postBatch(src));
    };
  }, function (module, exports, __webpack_require__) {
    var FillStyleCanvas = __webpack_require__(48),
        SetTransform = __webpack_require__(30);

    module.exports = function (height, src, sizeA, sizeB) {
      sizeA.addToRenderList(src);
      var reversed,
          ctx = height.currentContext;
      SetTransform(height, ctx, src, sizeA, sizeB) && src.isFilled && (reversed = src.width, height = src.height, sizeA = reversed / 2, sizeB = reversed / src.projection, reversed = src.isReversed, src.showTop && reversed && (FillStyleCanvas(ctx, src, src.fillTop), ctx.beginPath(), ctx.moveTo(-sizeA, -height), ctx.lineTo(0, -sizeB - height), ctx.lineTo(sizeA, -height), ctx.lineTo(0, sizeB - height), ctx.fill()), src.showLeft && (FillStyleCanvas(ctx, src, src.fillLeft), ctx.beginPath(), reversed ? ctx.moveTo(-sizeA, -height) : ctx.moveTo(-sizeA, 0), ctx.lineTo(0, sizeB), ctx.lineTo(0, sizeB - height), ctx.fill()), src.showRight && (FillStyleCanvas(ctx, src, src.fillRight), ctx.beginPath(), reversed ? ctx.moveTo(sizeA, -height) : ctx.moveTo(sizeA, 0), ctx.lineTo(0, sizeB), ctx.lineTo(0, sizeB - height), ctx.fill()), ctx.restore());
    };
  }, function (module, exports, __webpack_require__) {
    var renderWebGL = __webpack_require__(1),
        renderCanvas = __webpack_require__(1),
        renderWebGL = __webpack_require__(1116),
        renderCanvas = __webpack_require__(1117);

    module.exports = {
      renderWebGL: renderWebGL,
      renderCanvas: renderCanvas
    };
  }, function (module, exports, __webpack_require__) {
    var GetCalcMatrix = __webpack_require__(19),
        Utils = __webpack_require__(12);

    module.exports = function (renderer, src, startWidth, endWidth) {
      startWidth.addToRenderList(src);
      var pipeline = renderer.pipelines.set(src.pipeline),
          result = GetCalcMatrix(src, startWidth, endWidth);
      pipeline.calcMatrix.copyFrom(result.calc);
      var dx = src._displayOriginX,
          dy = src._displayOriginY,
          endWidth = startWidth.alpha * src.alpha;
      renderer.pipelines.preBatch(src), src.isStroked && (startWidth = pipeline.strokeTint, endWidth = Utils.getTintAppendFloatAlpha(src.strokeColor, src.strokeAlpha * endWidth), startWidth.TL = endWidth, startWidth.TR = endWidth, startWidth.BL = endWidth, startWidth.BR = endWidth, startWidth = src._startWidth, endWidth = src._endWidth, pipeline.batchLine(src.geom.x1 - dx, src.geom.y1 - dy, src.geom.x2 - dx, src.geom.y2 - dy, startWidth, endWidth, 1, 0, !1, result.sprite, result.camera)), renderer.pipelines.postBatch(src);
    };
  }, function (module, exports, __webpack_require__) {
    var LineStyleCanvas = __webpack_require__(60),
        SetTransform = __webpack_require__(30);

    module.exports = function (renderer, src, dx, dy) {
      dx.addToRenderList(src);
      var ctx = renderer.currentContext;
      SetTransform(renderer, ctx, src, dx, dy) && (dx = src._displayOriginX, dy = src._displayOriginY, src.isStroked && (LineStyleCanvas(ctx, src), ctx.beginPath(), ctx.moveTo(src.geom.x1 - dx, src.geom.y1 - dy), ctx.lineTo(src.geom.x2 - dx, src.geom.y2 - dy), ctx.stroke()), ctx.restore());
    };
  }, function (module, exports, __webpack_require__) {
    var renderWebGL = __webpack_require__(1),
        renderCanvas = __webpack_require__(1),
        renderWebGL = __webpack_require__(1119),
        renderCanvas = __webpack_require__(1120);

    module.exports = {
      renderWebGL: renderWebGL,
      renderCanvas: renderCanvas
    };
  }, function (module, exports, __webpack_require__) {
    var FillPathWebGL = __webpack_require__(114),
        GetCalcMatrix = __webpack_require__(19),
        StrokePathWebGL = __webpack_require__(81);

    module.exports = function (renderer, src, alpha, dx) {
      alpha.addToRenderList(src);
      var pipeline = renderer.pipelines.set(src.pipeline),
          dy = GetCalcMatrix(src, alpha, dx),
          calcMatrix = pipeline.calcMatrix.copyFrom(dy.calc),
          dx = src._displayOriginX,
          dy = src._displayOriginY,
          alpha = alpha.alpha * src.alpha;
      renderer.pipelines.preBatch(src), src.isFilled && FillPathWebGL(pipeline, calcMatrix, src, alpha, dx, dy), src.isStroked && StrokePathWebGL(pipeline, src, alpha, dx, dy), renderer.pipelines.postBatch(src);
    };
  }, function (module, exports, __webpack_require__) {
    var FillStyleCanvas = __webpack_require__(48),
        LineStyleCanvas = __webpack_require__(60),
        SetTransform = __webpack_require__(30);

    module.exports = function (renderer, src, px1, py1) {
      px1.addToRenderList(src);
      var ctx = renderer.currentContext;

      if (SetTransform(renderer, ctx, src, px1, py1)) {
        var dx = src._displayOriginX,
            dy = src._displayOriginY,
            path = src.pathData,
            pathLength = path.length - 1,
            px1 = path[0] - dx,
            py1 = path[1] - dy;
        ctx.beginPath(), ctx.moveTo(px1, py1), src.closePath || (pathLength -= 2);

        for (var i = 2; i < pathLength; i += 2) {
          var px2 = path[i] - dx,
              py2 = path[i + 1] - dy;
          ctx.lineTo(px2, py2);
        }

        ctx.closePath(), src.isFilled && (FillStyleCanvas(ctx, src), ctx.fill()), src.isStroked && (LineStyleCanvas(ctx, src), ctx.stroke()), ctx.restore();
      }
    };
  }, function (module, exports, __webpack_require__) {
    var renderWebGL = __webpack_require__(1),
        renderCanvas = __webpack_require__(1),
        renderWebGL = __webpack_require__(1122),
        renderCanvas = __webpack_require__(1123);

    module.exports = {
      renderWebGL: renderWebGL,
      renderCanvas: renderCanvas
    };
  }, function (module, exports, __webpack_require__) {
    var GetCalcMatrix = __webpack_require__(19),
        StrokePathWebGL = __webpack_require__(81),
        Utils = __webpack_require__(12);

    module.exports = function (renderer, src, fillTintColor, alpha) {
      fillTintColor.addToRenderList(src);
      var pipeline = renderer.pipelines.set(src.pipeline),
          fillTint = GetCalcMatrix(src, fillTintColor, alpha);
      pipeline.calcMatrix.copyFrom(fillTint.calc);
      var dx = src._displayOriginX,
          dy = src._displayOriginY,
          alpha = fillTintColor.alpha * src.alpha;
      renderer.pipelines.preBatch(src), src.isFilled && (fillTint = pipeline.fillTint, fillTintColor = Utils.getTintAppendFloatAlpha(src.fillColor, src.fillAlpha * alpha), fillTint.TL = fillTintColor, fillTint.TR = fillTintColor, fillTint.BL = fillTintColor, fillTint.BR = fillTintColor, pipeline.batchFillRect(-dx, -dy, src.width, src.height)), src.isStroked && StrokePathWebGL(pipeline, src, alpha, dx, dy), renderer.pipelines.postBatch(src);
    };
  }, function (module, exports, __webpack_require__) {
    var FillStyleCanvas = __webpack_require__(48),
        LineStyleCanvas = __webpack_require__(60),
        SetTransform = __webpack_require__(30);

    module.exports = function (renderer, src, dx, dy) {
      dx.addToRenderList(src);
      var ctx = renderer.currentContext;
      SetTransform(renderer, ctx, src, dx, dy) && (dx = src._displayOriginX, dy = src._displayOriginY, src.isFilled && (FillStyleCanvas(ctx, src), ctx.fillRect(-dx, -dy, src.width, src.height)), src.isStroked && (LineStyleCanvas(ctx, src), ctx.beginPath(), ctx.rect(-dx, -dy, src.width, src.height), ctx.stroke()), ctx.restore());
    };
  }, function (module, exports, __webpack_require__) {
    var renderWebGL = __webpack_require__(1),
        renderCanvas = __webpack_require__(1),
        renderWebGL = __webpack_require__(1125),
        renderCanvas = __webpack_require__(1126);

    module.exports = {
      renderWebGL: renderWebGL,
      renderCanvas: renderCanvas
    };
  }, function (module, exports, __webpack_require__) {
    var FillPathWebGL = __webpack_require__(114),
        GetCalcMatrix = __webpack_require__(19),
        StrokePathWebGL = __webpack_require__(81);

    module.exports = function (renderer, src, alpha, dx) {
      alpha.addToRenderList(src);
      var pipeline = renderer.pipelines.set(src.pipeline),
          dy = GetCalcMatrix(src, alpha, dx),
          calcMatrix = pipeline.calcMatrix.copyFrom(dy.calc),
          dx = src._displayOriginX,
          dy = src._displayOriginY,
          alpha = alpha.alpha * src.alpha;
      renderer.pipelines.preBatch(src), src.isFilled && FillPathWebGL(pipeline, calcMatrix, src, alpha, dx, dy), src.isStroked && StrokePathWebGL(pipeline, src, alpha, dx, dy), renderer.pipelines.postBatch(src);
    };
  }, function (module, exports, __webpack_require__) {
    var FillStyleCanvas = __webpack_require__(48),
        LineStyleCanvas = __webpack_require__(60),
        SetTransform = __webpack_require__(30);

    module.exports = function (renderer, src, px1, py1) {
      px1.addToRenderList(src);
      var ctx = renderer.currentContext;

      if (SetTransform(renderer, ctx, src, px1, py1)) {
        var dx = src._displayOriginX,
            dy = src._displayOriginY,
            path = src.pathData,
            pathLength = path.length - 1,
            px1 = path[0] - dx,
            py1 = path[1] - dy;
        ctx.beginPath(), ctx.moveTo(px1, py1), src.closePath || (pathLength -= 2);

        for (var i = 2; i < pathLength; i += 2) {
          var px2 = path[i] - dx,
              py2 = path[i + 1] - dy;
          ctx.lineTo(px2, py2);
        }

        ctx.closePath(), src.isFilled && (FillStyleCanvas(ctx, src), ctx.fill()), src.isStroked && (LineStyleCanvas(ctx, src), ctx.stroke()), ctx.restore();
      }
    };
  }, function (module, exports, __webpack_require__) {
    var renderWebGL = __webpack_require__(1),
        renderCanvas = __webpack_require__(1),
        renderWebGL = __webpack_require__(1128),
        renderCanvas = __webpack_require__(1129);

    module.exports = {
      renderWebGL: renderWebGL,
      renderCanvas: renderCanvas
    };
  }, function (module, exports, __webpack_require__) {
    var GetCalcMatrix = __webpack_require__(19),
        StrokePathWebGL = __webpack_require__(81),
        Utils = __webpack_require__(12);

    module.exports = function (renderer, src, y2, x2) {
      y2.addToRenderList(src);
      var pipeline = renderer.pipelines.set(src.pipeline),
          result = GetCalcMatrix(src, y2, x2);
      pipeline.calcMatrix.copyFrom(result.calc);
      var x1,
          y1,
          x3,
          y3,
          dx = src._displayOriginX,
          dy = src._displayOriginY,
          alpha = y2.alpha * src.alpha;
      renderer.pipelines.preBatch(src), src.isFilled && (x3 = pipeline.fillTint, y3 = Utils.getTintAppendFloatAlpha(src.fillColor, src.fillAlpha * alpha), x3.TL = y3, x3.TR = y3, x3.BL = y3, x3.BR = y3, x1 = src.geom.x1 - dx, y1 = src.geom.y1 - dy, x2 = src.geom.x2 - dx, y2 = src.geom.y2 - dy, x3 = src.geom.x3 - dx, y3 = src.geom.y3 - dy, pipeline.batchFillTriangle(x1, y1, x2, y2, x3, y3, result.sprite, result.camera)), src.isStroked && StrokePathWebGL(pipeline, src, alpha, dx, dy), renderer.pipelines.postBatch(src);
    };
  }, function (module, exports, __webpack_require__) {
    var FillStyleCanvas = __webpack_require__(48),
        LineStyleCanvas = __webpack_require__(60),
        SetTransform = __webpack_require__(30);

    module.exports = function (y1, src, x2, y2) {
      x2.addToRenderList(src);
      var x1,
          x3,
          y3,
          ctx = y1.currentContext;
      SetTransform(y1, ctx, src, x2, y2) && (x3 = src._displayOriginX, y3 = src._displayOriginY, x1 = src.geom.x1 - x3, y1 = src.geom.y1 - y3, x2 = src.geom.x2 - x3, y2 = src.geom.y2 - y3, x3 = src.geom.x3 - x3, y3 = src.geom.y3 - y3, ctx.beginPath(), ctx.moveTo(x1, y1), ctx.lineTo(x2, y2), ctx.lineTo(x3, y3), ctx.closePath(), src.isFilled && (FillStyleCanvas(ctx, src), ctx.fill()), src.isStroked && (LineStyleCanvas(ctx, src), ctx.stroke()), ctx.restore());
    };
  }, function (module, exports, __webpack_require__) {
    var Blitter = __webpack_require__(213);

    __webpack_require__(5).register("blitter", function (x, y, key, frame) {
      return this.displayList.add(new Blitter(this.scene, x, y, key, frame));
    });
  }, function (module, exports, __webpack_require__) {
    var Container = __webpack_require__(214);

    __webpack_require__(5).register("container", function (x, y, children) {
      return this.displayList.add(new Container(this.scene, x, y, children));
    });
  }, function (module, exports, __webpack_require__) {
    var DOMElement = __webpack_require__(442);

    __webpack_require__(5).register("dom", function (x, y, element, style, gameObject) {
      gameObject = new DOMElement(this.scene, x, y, element, style, gameObject);
      return this.displayList.add(gameObject), gameObject;
    });
  }, function (module, exports, __webpack_require__) {
    var DynamicBitmapText = __webpack_require__(215);

    __webpack_require__(5).register("dynamicBitmapText", function (x, y, font, text, size) {
      return this.displayList.add(new DynamicBitmapText(this.scene, x, y, font, text, size));
    });
  }, function (module, exports, __webpack_require__) {
    var Extern = __webpack_require__(444);

    __webpack_require__(5).register("extern", function () {
      var extern = new Extern(this.scene);
      return this.displayList.add(extern), extern;
    });
  }, function (module, exports, __webpack_require__) {
    var Graphics = __webpack_require__(216);

    __webpack_require__(5).register("graphics", function (config) {
      return this.displayList.add(new Graphics(this.scene, config));
    });
  }, function (module, exports, __webpack_require__) {
    var Group = __webpack_require__(113);

    __webpack_require__(5).register("group", function (children, config) {
      return this.updateList.add(new Group(this.scene, children, config));
    });
  }, function (module, exports, __webpack_require__) {
    var Image = __webpack_require__(125);

    __webpack_require__(5).register("image", function (x, y, key, frame) {
      return this.displayList.add(new Image(this.scene, x, y, key, frame));
    });
  }, function (module, exports, __webpack_require__) {
    var Layer = __webpack_require__(219);

    __webpack_require__(5).register("layer", function (children) {
      return this.displayList.add(new Layer(this.scene, children));
    });
  }, function (module, exports, __webpack_require__) {
    var GameObjectFactory = __webpack_require__(5),
        ParticleEmitterManager = __webpack_require__(220);

    GameObjectFactory.register("particles", function (key, frame, emitters) {
      return this.displayList.add(new ParticleEmitterManager(this.scene, key, frame, emitters));
    });
  }, function (module, exports, __webpack_require__) {
    var GameObjectFactory = __webpack_require__(5),
        PathFollower = __webpack_require__(457);

    GameObjectFactory.register("follower", function (path, x, y, key, sprite) {
      sprite = new PathFollower(this.scene, path, x, y, key, sprite);
      return this.displayList.add(sprite), this.updateList.add(sprite), sprite;
    });
  }, function (module, exports, __webpack_require__) {
    var GameObjectFactory = __webpack_require__(5),
        RenderTexture = __webpack_require__(221);

    GameObjectFactory.register("renderTexture", function (x, y, width, height, key, frame) {
      return this.displayList.add(new RenderTexture(this.scene, x, y, width, height, key, frame));
    });
  }, function (module, exports, __webpack_require__) {
    var Rope = __webpack_require__(223);

    __webpack_require__(5).register("rope", function (x, y, texture, frame, points, horizontal, colors, alphas) {
      return this.displayList.add(new Rope(this.scene, x, y, texture, frame, points, horizontal, colors, alphas));
    });
  }, function (module, exports, __webpack_require__) {
    var GameObjectFactory = __webpack_require__(5),
        Sprite = __webpack_require__(73);

    GameObjectFactory.register("sprite", function (x, y, key, sprite) {
      sprite = new Sprite(this.scene, x, y, key, sprite);
      return this.displayList.add(sprite), sprite;
    });
  }, function (module, exports, __webpack_require__) {
    var BitmapText = __webpack_require__(148);

    __webpack_require__(5).register("bitmapText", function (x, y, font, text, size, align) {
      return this.displayList.add(new BitmapText(this.scene, x, y, font, text, size, align));
    });
  }, function (module, exports, __webpack_require__) {
    var Text = __webpack_require__(224);

    __webpack_require__(5).register("text", function (x, y, text, style) {
      return this.displayList.add(new Text(this.scene, x, y, text, style));
    });
  }, function (module, exports, __webpack_require__) {
    var TileSprite = __webpack_require__(225);

    __webpack_require__(5).register("tileSprite", function (x, y, width, height, key, frame) {
      return this.displayList.add(new TileSprite(this.scene, x, y, width, height, key, frame));
    });
  }, function (module, exports, __webpack_require__) {
    var Zone = __webpack_require__(129);

    __webpack_require__(5).register("zone", function (x, y, width, height) {
      return this.displayList.add(new Zone(this.scene, x, y, width, height));
    });
  }, function (module, exports, __webpack_require__) {
    var Video = __webpack_require__(226);

    __webpack_require__(5).register("video", function (x, y, key) {
      return this.displayList.add(new Video(this.scene, x, y, key));
    });
  }, function (module, exports, GameObjectFactory) {
    var Arc = GameObjectFactory(461),
        GameObjectFactory = GameObjectFactory(5);
    GameObjectFactory.register("arc", function (x, y, radius, startAngle, endAngle, anticlockwise, fillColor, fillAlpha) {
      return this.displayList.add(new Arc(this.scene, x, y, radius, startAngle, endAngle, anticlockwise, fillColor, fillAlpha));
    }), GameObjectFactory.register("circle", function (x, y, radius, fillColor, fillAlpha) {
      return this.displayList.add(new Arc(this.scene, x, y, radius, 0, 360, !1, fillColor, fillAlpha));
    });
  }, function (module, exports, __webpack_require__) {
    var GameObjectFactory = __webpack_require__(5),
        Curve = __webpack_require__(462);

    GameObjectFactory.register("curve", function (x, y, curve, fillColor, fillAlpha) {
      return this.displayList.add(new Curve(this.scene, x, y, curve, fillColor, fillAlpha));
    });
  }, function (module, exports, __webpack_require__) {
    var Ellipse = __webpack_require__(463);

    __webpack_require__(5).register("ellipse", function (x, y, width, height, fillColor, fillAlpha) {
      return this.displayList.add(new Ellipse(this.scene, x, y, width, height, fillColor, fillAlpha));
    });
  }, function (module, exports, __webpack_require__) {
    var GameObjectFactory = __webpack_require__(5),
        Grid = __webpack_require__(464);

    GameObjectFactory.register("grid", function (x, y, width, height, cellWidth, cellHeight, fillColor, fillAlpha, outlineFillColor, outlineFillAlpha) {
      return this.displayList.add(new Grid(this.scene, x, y, width, height, cellWidth, cellHeight, fillColor, fillAlpha, outlineFillColor, outlineFillAlpha));
    });
  }, function (module, exports, __webpack_require__) {
    var GameObjectFactory = __webpack_require__(5),
        IsoBox = __webpack_require__(465);

    GameObjectFactory.register("isobox", function (x, y, size, height, fillTop, fillLeft, fillRight) {
      return this.displayList.add(new IsoBox(this.scene, x, y, size, height, fillTop, fillLeft, fillRight));
    });
  }, function (module, exports, __webpack_require__) {
    var GameObjectFactory = __webpack_require__(5),
        IsoTriangle = __webpack_require__(466);

    GameObjectFactory.register("isotriangle", function (x, y, size, height, reversed, fillTop, fillLeft, fillRight) {
      return this.displayList.add(new IsoTriangle(this.scene, x, y, size, height, reversed, fillTop, fillLeft, fillRight));
    });
  }, function (module, exports, __webpack_require__) {
    var GameObjectFactory = __webpack_require__(5),
        Line = __webpack_require__(467);

    GameObjectFactory.register("line", function (x, y, x1, y1, x2, y2, strokeColor, strokeAlpha) {
      return this.displayList.add(new Line(this.scene, x, y, x1, y1, x2, y2, strokeColor, strokeAlpha));
    });
  }, function (module, exports, __webpack_require__) {
    var GameObjectFactory = __webpack_require__(5),
        Polygon = __webpack_require__(468);

    GameObjectFactory.register("polygon", function (x, y, points, fillColor, fillAlpha) {
      return this.displayList.add(new Polygon(this.scene, x, y, points, fillColor, fillAlpha));
    });
  }, function (module, exports, __webpack_require__) {
    var GameObjectFactory = __webpack_require__(5),
        Rectangle = __webpack_require__(473);

    GameObjectFactory.register("rectangle", function (x, y, width, height, fillColor, fillAlpha) {
      return this.displayList.add(new Rectangle(this.scene, x, y, width, height, fillColor, fillAlpha));
    });
  }, function (module, exports, __webpack_require__) {
    var Star = __webpack_require__(474);

    __webpack_require__(5).register("star", function (x, y, points, innerRadius, outerRadius, fillColor, fillAlpha) {
      return this.displayList.add(new Star(this.scene, x, y, points, innerRadius, outerRadius, fillColor, fillAlpha));
    });
  }, function (module, exports, __webpack_require__) {
    var GameObjectFactory = __webpack_require__(5),
        Triangle = __webpack_require__(475);

    GameObjectFactory.register("triangle", function (x, y, x1, y1, x2, y2, x3, y3, fillColor, fillAlpha) {
      return this.displayList.add(new Triangle(this.scene, x, y, x1, y1, x2, y2, x3, y3, fillColor, fillAlpha));
    });
  }, function (module, exports, __webpack_require__) {
    var Blitter = __webpack_require__(213),
        BuildGameObject = __webpack_require__(28),
        GameObjectCreator = __webpack_require__(16),
        GetAdvancedValue = __webpack_require__(13);

    GameObjectCreator.register("blitter", function (config, addToScene) {
      var key = GetAdvancedValue(config = void 0 === config ? {} : config, "key", null),
          blitter = GetAdvancedValue(config, "frame", null),
          blitter = new Blitter(this.scene, 0, 0, key, blitter);
      return void 0 !== addToScene && (config.add = addToScene), BuildGameObject(this.scene, blitter, config), blitter;
    });
  }, function (module, exports, __webpack_require__) {
    var BuildGameObject = __webpack_require__(28),
        Container = __webpack_require__(214),
        GameObjectCreator = __webpack_require__(16),
        GetAdvancedValue = __webpack_require__(13);

    GameObjectCreator.register("container", function (config, addToScene) {
      var x = GetAdvancedValue(config = void 0 === config ? {} : config, "x", 0),
          y = GetAdvancedValue(config, "y", 0),
          container = GetAdvancedValue(config, "children", null),
          container = new Container(this.scene, x, y, container);
      return void 0 !== addToScene && (config.add = addToScene), BuildGameObject(this.scene, container, config), container;
    });
  }, function (module, exports, __webpack_require__) {
    var BitmapText = __webpack_require__(215),
        BuildGameObject = __webpack_require__(28),
        GameObjectCreator = __webpack_require__(16),
        GetAdvancedValue = __webpack_require__(13);

    GameObjectCreator.register("dynamicBitmapText", function (config, addToScene) {
      var font = GetAdvancedValue(config = void 0 === config ? {} : config, "font", ""),
          text = GetAdvancedValue(config, "text", ""),
          bitmapText = GetAdvancedValue(config, "size", !1),
          bitmapText = new BitmapText(this.scene, 0, 0, font, text, bitmapText);
      return void 0 !== addToScene && (config.add = addToScene), BuildGameObject(this.scene, bitmapText, config), bitmapText;
    });
  }, function (module, exports, __webpack_require__) {
    var GameObjectCreator = __webpack_require__(16),
        Graphics = __webpack_require__(216);

    GameObjectCreator.register("graphics", function (config, graphics) {
      void 0 === config && (config = {}), void 0 !== graphics && (config.add = graphics);
      graphics = new Graphics(this.scene, config);
      return config.add && this.scene.sys.displayList.add(graphics), graphics;
    });
  }, function (module, exports, __webpack_require__) {
    var GameObjectCreator = __webpack_require__(16),
        Group = __webpack_require__(113);

    GameObjectCreator.register("group", function (config) {
      return new Group(this.scene, null, config);
    });
  }, function (module, exports, __webpack_require__) {
    var BuildGameObject = __webpack_require__(28),
        GameObjectCreator = __webpack_require__(16),
        GetAdvancedValue = __webpack_require__(13),
        Image = __webpack_require__(125);

    GameObjectCreator.register("image", function (config, addToScene) {
      var key = GetAdvancedValue(config = void 0 === config ? {} : config, "key", null),
          image = GetAdvancedValue(config, "frame", null),
          image = new Image(this.scene, 0, 0, key, image);
      return void 0 !== addToScene && (config.add = addToScene), BuildGameObject(this.scene, image, config), image;
    });
  }, function (module, exports, __webpack_require__) {
    var BuildGameObject = __webpack_require__(28),
        Layer = __webpack_require__(219),
        GameObjectCreator = __webpack_require__(16),
        GetAdvancedValue = __webpack_require__(13);

    GameObjectCreator.register("layer", function (config, addToScene) {
      var layer = GetAdvancedValue(config = void 0 === config ? {} : config, "children", null),
          layer = new Layer(this.scene, layer);
      return void 0 !== addToScene && (config.add = addToScene), BuildGameObject(this.scene, layer, config), layer;
    });
  }, function (module, exports, __webpack_require__) {
    var GameObjectCreator = __webpack_require__(16),
        GetAdvancedValue = __webpack_require__(13),
        GetFastValue = __webpack_require__(2),
        ParticleEmitterManager = __webpack_require__(220);

    GameObjectCreator.register("particles", function (config, addToScene) {
      var key = GetAdvancedValue(config = void 0 === config ? {} : config, "key", null),
          frame = GetAdvancedValue(config, "frame", null),
          manager = GetFastValue(config, "emitters", null),
          manager = new ParticleEmitterManager(this.scene, key, frame, manager);
      return void 0 !== addToScene && (config.add = addToScene), (GetFastValue(config, "add", !1) ? this.displayList : this.updateList).add(manager), manager;
    });
  }, function (module, exports, __webpack_require__) {
    var BuildGameObject = __webpack_require__(28),
        GameObjectCreator = __webpack_require__(16),
        GetAdvancedValue = __webpack_require__(13),
        RenderTexture = __webpack_require__(221);

    GameObjectCreator.register("renderTexture", function (config, addToScene) {
      var x = GetAdvancedValue(config = void 0 === config ? {} : config, "x", 0),
          y = GetAdvancedValue(config, "y", 0),
          width = GetAdvancedValue(config, "width", 32),
          height = GetAdvancedValue(config, "height", 32),
          key = GetAdvancedValue(config, "key", void 0),
          renderTexture = GetAdvancedValue(config, "frame", void 0),
          renderTexture = new RenderTexture(this.scene, x, y, width, height, key, renderTexture);
      return void 0 !== addToScene && (config.add = addToScene), BuildGameObject(this.scene, renderTexture, config), renderTexture;
    });
  }, function (module, exports, __webpack_require__) {
    var BuildGameObject = __webpack_require__(28),
        GameObjectCreator = __webpack_require__(16),
        GetAdvancedValue = __webpack_require__(13),
        GetValue = __webpack_require__(6),
        Rope = __webpack_require__(223);

    GameObjectCreator.register("rope", function (config, addToScene) {
      var key = GetAdvancedValue(config = void 0 === config ? {} : config, "key", null),
          frame = GetAdvancedValue(config, "frame", null),
          horizontal = GetAdvancedValue(config, "horizontal", !0),
          points = GetValue(config, "points", void 0),
          colors = GetValue(config, "colors", void 0),
          rope = GetValue(config, "alphas", void 0),
          rope = new Rope(this.scene, 0, 0, key, frame, points, horizontal, colors, rope);
      return void 0 !== addToScene && (config.add = addToScene), BuildGameObject(this.scene, rope, config), config.add || this.updateList.add(rope), rope;
    });
  }, function (module, exports, __webpack_require__) {
    var BuildGameObject = __webpack_require__(28),
        BuildGameObjectAnimation = __webpack_require__(439),
        GameObjectCreator = __webpack_require__(16),
        GetAdvancedValue = __webpack_require__(13),
        Sprite = __webpack_require__(73);

    GameObjectCreator.register("sprite", function (config, addToScene) {
      var key = GetAdvancedValue(config = void 0 === config ? {} : config, "key", null),
          sprite = GetAdvancedValue(config, "frame", null),
          sprite = new Sprite(this.scene, 0, 0, key, sprite);
      return void 0 !== addToScene && (config.add = addToScene), BuildGameObject(this.scene, sprite, config), BuildGameObjectAnimation(sprite, config), sprite;
    });
  }, function (module, exports, __webpack_require__) {
    var BitmapText = __webpack_require__(148),
        BuildGameObject = __webpack_require__(28),
        GameObjectCreator = __webpack_require__(16),
        GetAdvancedValue = __webpack_require__(13),
        GetValue = __webpack_require__(6);

    GameObjectCreator.register("bitmapText", function (config, addToScene) {
      var font = GetValue(config = void 0 === config ? {} : config, "font", ""),
          text = GetAdvancedValue(config, "text", ""),
          size = GetAdvancedValue(config, "size", !1),
          bitmapText = GetValue(config, "align", 0),
          bitmapText = new BitmapText(this.scene, 0, 0, font, text, size, bitmapText);
      return void 0 !== addToScene && (config.add = addToScene), BuildGameObject(this.scene, bitmapText, config), bitmapText;
    });
  }, function (module, exports, __webpack_require__) {
    var BuildGameObject = __webpack_require__(28),
        GameObjectCreator = __webpack_require__(16),
        GetAdvancedValue = __webpack_require__(13),
        Text = __webpack_require__(224);

    GameObjectCreator.register("text", function (config, addToScene) {
      var content = GetAdvancedValue(config = void 0 === config ? {} : config, "text", ""),
          text = GetAdvancedValue(config, "style", null),
          padding = GetAdvancedValue(config, "padding", null);
      null !== padding && (text.padding = padding);
      text = new Text(this.scene, 0, 0, content, text);
      return void 0 !== addToScene && (config.add = addToScene), BuildGameObject(this.scene, text, config), text.autoRound = GetAdvancedValue(config, "autoRound", !0), text.resolution = GetAdvancedValue(config, "resolution", 1), text;
    });
  }, function (module, exports, __webpack_require__) {
    var BuildGameObject = __webpack_require__(28),
        GameObjectCreator = __webpack_require__(16),
        GetAdvancedValue = __webpack_require__(13),
        TileSprite = __webpack_require__(225);

    GameObjectCreator.register("tileSprite", function (config, addToScene) {
      var x = GetAdvancedValue(config = void 0 === config ? {} : config, "x", 0),
          y = GetAdvancedValue(config, "y", 0),
          width = GetAdvancedValue(config, "width", 512),
          height = GetAdvancedValue(config, "height", 512),
          key = GetAdvancedValue(config, "key", ""),
          tile = GetAdvancedValue(config, "frame", ""),
          tile = new TileSprite(this.scene, x, y, width, height, key, tile);
      return void 0 !== addToScene && (config.add = addToScene), BuildGameObject(this.scene, tile, config), tile;
    });
  }, function (module, exports, __webpack_require__) {
    var GameObjectCreator = __webpack_require__(16),
        GetAdvancedValue = __webpack_require__(13),
        Zone = __webpack_require__(129);

    GameObjectCreator.register("zone", function (height) {
      var x = GetAdvancedValue(height, "x", 0),
          y = GetAdvancedValue(height, "y", 0),
          width = GetAdvancedValue(height, "width", 1),
          height = GetAdvancedValue(height, "height", width);
      return new Zone(this.scene, x, y, width, height);
    });
  }, function (module, exports, __webpack_require__) {
    var BuildGameObject = __webpack_require__(28),
        GameObjectCreator = __webpack_require__(16),
        GetAdvancedValue = __webpack_require__(13),
        Video = __webpack_require__(226);

    GameObjectCreator.register("video", function (config, addToScene) {
      var video = GetAdvancedValue(config = void 0 === config ? {} : config, "key", null),
          video = new Video(this.scene, 0, 0, video);
      return void 0 !== addToScene && (config.add = addToScene), BuildGameObject(this.scene, video, config), config.add || this.updateList.add(video), video;
    });
  }, function (module, exports, __webpack_require__) {
    var renderWebGL = __webpack_require__(1),
        renderCanvas = __webpack_require__(1),
        renderWebGL = __webpack_require__(1177),
        renderCanvas = __webpack_require__(1178);

    module.exports = {
      renderWebGL: renderWebGL,
      renderCanvas: renderCanvas
    };
  }, function (module, exports, __webpack_require__) {
    var GetCalcMatrix = __webpack_require__(19);

    module.exports = function (renderer, src, camera, calcMatrix) {
      src.shader && (camera.addToRenderList(src), renderer.pipelines.clear(), src.renderToTexture ? src.load() : (calcMatrix = GetCalcMatrix(src, camera, calcMatrix).calc, renderer.width === src._rendererWidth && renderer.height === src._rendererHeight || src.projOrtho(0, renderer.width, renderer.height, 0), src.load(calcMatrix.matrix)), src.flush(), renderer.pipelines.rebind());
    };
  }, function (module, exports) {
    module.exports = function () {};
  }, function (module, exports, __webpack_require__) {
    var renderWebGL = __webpack_require__(1),
        renderCanvas = __webpack_require__(1),
        renderWebGL = __webpack_require__(1180),
        renderCanvas = __webpack_require__(1181);

    module.exports = {
      renderWebGL: renderWebGL,
      renderCanvas: renderCanvas
    };
  }, function (module, exports, __webpack_require__) {
    var GetCalcMatrix = __webpack_require__(19);

    module.exports = function (renderer, src, camera, calcMatrix) {
      var faces = src.faces,
          totalFaces = faces.length;

      if (0 !== totalFaces) {
        camera.addToRenderList(src);
        var pipeline = renderer.pipelines.set(src.pipeline, src),
            calcMatrix = GetCalcMatrix(src, camera, calcMatrix).calc,
            textureUnit = pipeline.setGameObject(src),
            F32 = pipeline.vertexViewF32,
            U32 = pipeline.vertexViewU32,
            vertexOffset = pipeline.vertexCount * pipeline.currentShader.vertexComponentCount - 1,
            tintEffect = src.tintFill,
            debugFaces = [],
            debugCallback = src.debugCallback,
            a = calcMatrix.a,
            b = calcMatrix.b,
            c = calcMatrix.c,
            d = calcMatrix.d,
            e = calcMatrix.e,
            f = calcMatrix.f,
            z = src.viewPosition.z,
            hideCCW = src.hideCCW,
            roundPixels = camera.roundPixels,
            alpha = camera.alpha * src.alpha,
            totalFacesRendered = 0;
        renderer.pipelines.preBatch(src);

        for (var i = 0; i < totalFaces; i++) {
          var face = faces[i];
          face.isInView(camera, hideCCW, z, alpha, a, b, c, d, e, f, roundPixels) && (pipeline.shouldFlush(3) && (pipeline.flush(), vertexOffset = 0), vertexOffset = face.load(F32, U32, vertexOffset, textureUnit, tintEffect), totalFacesRendered++, pipeline.vertexCount += 3, debugCallback && debugFaces.push(face));
        }

        src.totalFrame += totalFacesRendered, debugCallback && debugCallback.call(src, src, debugFaces), renderer.pipelines.postBatch(src);
      }
    };
  }, function (module, exports) {
    module.exports = function () {};
  }, function (module, exports, __webpack_require__) {
    var renderWebGL = __webpack_require__(1),
        renderCanvas = __webpack_require__(1),
        renderWebGL = __webpack_require__(1183);

    module.exports = {
      renderWebGL: renderWebGL,
      renderCanvas: renderCanvas
    };
  }, function (module, exports, __webpack_require__) {
    var GetCalcMatrix = __webpack_require__(19);

    module.exports = function (renderer, src, camera, tx1) {
      camera.addToRenderList(src);
      var pipeline = renderer.pipelines.set(src.pipeline),
          calcMatrix = GetCalcMatrix(src, camera, tx1).calc,
          ty1 = src.width,
          tx2 = src.height,
          ty2 = -src._radius,
          ty3 = -src._radius,
          xw = ty2 + ty1,
          tx3 = ty3 + tx2,
          lightX = calcMatrix.getX(0, 0),
          lightY = calcMatrix.getY(0, 0),
          tx0 = calcMatrix.getX(ty2, ty3),
          ty0 = calcMatrix.getY(ty2, ty3),
          tx1 = calcMatrix.getX(ty2, tx3),
          ty1 = calcMatrix.getY(ty2, tx3),
          tx2 = calcMatrix.getX(xw, tx3),
          ty2 = calcMatrix.getY(xw, tx3),
          tx3 = calcMatrix.getX(xw, ty3),
          ty3 = calcMatrix.getY(xw, ty3);
      renderer.pipelines.preBatch(src), pipeline.batchPointLight(src, camera, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, lightX, lightY), renderer.pipelines.postBatch(src);
    };
  }, function (module, exports, __webpack_require__) {
    var Shader = __webpack_require__(229);

    __webpack_require__(5).register("shader", function (key, x, y, width, height, textures, textureData) {
      return this.displayList.add(new Shader(this.scene, key, x, y, width, height, textures, textureData));
    });
  }, function (module, exports, __webpack_require__) {
    var Mesh = __webpack_require__(230);

    __webpack_require__(5).register("mesh", function (x, y, texture, frame, vertices, uvs, indicies, containsZ, normals, colors, alphas) {
      return this.displayList.add(new Mesh(this.scene, x, y, texture, frame, vertices, uvs, indicies, containsZ, normals, colors, alphas));
    });
  }, function (module, exports, __webpack_require__) {
    var GameObjectFactory = __webpack_require__(5),
        PointLight = __webpack_require__(150);

    GameObjectFactory.register("pointlight", function (x, y, color, radius, intensity, attenuation) {
      return this.displayList.add(new PointLight(this.scene, x, y, color, radius, intensity, attenuation));
    });
  }, function (module, exports, __webpack_require__) {
    var BuildGameObject = __webpack_require__(28),
        GameObjectCreator = __webpack_require__(16),
        GetAdvancedValue = __webpack_require__(13),
        Shader = __webpack_require__(229);

    GameObjectCreator.register("shader", function (config, addToScene) {
      var key = GetAdvancedValue(config = void 0 === config ? {} : config, "key", null),
          x = GetAdvancedValue(config, "x", 0),
          y = GetAdvancedValue(config, "y", 0),
          width = GetAdvancedValue(config, "width", 128),
          shader = GetAdvancedValue(config, "height", 128),
          shader = new Shader(this.scene, key, x, y, width, shader);
      return void 0 !== addToScene && (config.add = addToScene), BuildGameObject(this.scene, shader, config), shader;
    });
  }, function (module, exports, __webpack_require__) {
    var BuildGameObject = __webpack_require__(28),
        GameObjectCreator = __webpack_require__(16),
        GetAdvancedValue = __webpack_require__(13),
        GetValue = __webpack_require__(6),
        Mesh = __webpack_require__(230);

    GameObjectCreator.register("mesh", function (config, addToScene) {
      var key = GetAdvancedValue(config = void 0 === config ? {} : config, "key", null),
          frame = GetAdvancedValue(config, "frame", null),
          vertices = GetValue(config, "vertices", []),
          uvs = GetValue(config, "uvs", []),
          indicies = GetValue(config, "indicies", []),
          containsZ = GetValue(config, "containsZ", !1),
          normals = GetValue(config, "normals", []),
          colors = GetValue(config, "colors", 16777215),
          mesh = GetValue(config, "alphas", 1),
          mesh = new Mesh(this.scene, 0, 0, key, frame, vertices, uvs, indicies, containsZ, normals, colors, mesh);
      return void 0 !== addToScene && (config.add = addToScene), BuildGameObject(this.scene, mesh, config), mesh;
    });
  }, function (module, exports, __webpack_require__) {
    var BuildGameObject = __webpack_require__(28),
        GameObjectCreator = __webpack_require__(16),
        GetAdvancedValue = __webpack_require__(13),
        PointLight = __webpack_require__(150);

    GameObjectCreator.register("pointlight", function (config, addToScene) {
      var color = GetAdvancedValue(config = void 0 === config ? {} : config, "color", 16777215),
          radius = GetAdvancedValue(config, "radius", 128),
          intensity = GetAdvancedValue(config, "intensity", 1),
          layer = GetAdvancedValue(config, "attenuation", .1),
          layer = new PointLight(this.scene, 0, 0, color, radius, intensity, layer);
      return void 0 !== addToScene && (config.add = addToScene), BuildGameObject(this.scene, layer, config), layer;
    });
  }, function (module, exports, __webpack_require__) {
    var LightsPlugin = __webpack_require__(0),
        LightsManager = __webpack_require__(482),
        PluginCache = __webpack_require__(24),
        SceneEvents = __webpack_require__(20),
        LightsPlugin = new LightsPlugin({
      Extends: LightsManager,
      initialize: function initialize(scene) {
        this.scene = scene, this.systems = scene.sys, scene.sys.settings.isBooted || scene.sys.events.once(SceneEvents.BOOT, this.boot, this), LightsManager.call(this);
      },
      boot: function boot() {
        var eventEmitter = this.systems.events;
        eventEmitter.on(SceneEvents.SHUTDOWN, this.shutdown, this), eventEmitter.on(SceneEvents.DESTROY, this.destroy, this);
      },
      destroy: function destroy() {
        this.shutdown(), this.scene = void 0, this.systems = void 0;
      }
    });

    PluginCache.register("LightsPlugin", LightsPlugin, "lights"), module.exports = LightsPlugin;
  }, function (module, exports, __webpack_require__) {
    var Circle = __webpack_require__(65);

    Circle.Area = __webpack_require__(1192), Circle.Circumference = __webpack_require__(302), Circle.CircumferencePoint = __webpack_require__(169), Circle.Clone = __webpack_require__(1193), Circle.Contains = __webpack_require__(66), Circle.ContainsPoint = __webpack_require__(1194), Circle.ContainsRect = __webpack_require__(1195), Circle.CopyFrom = __webpack_require__(1196), Circle.Equals = __webpack_require__(1197), Circle.GetBounds = __webpack_require__(1198), Circle.GetPoint = __webpack_require__(300), Circle.GetPoints = __webpack_require__(301), Circle.Offset = __webpack_require__(1199), Circle.OffsetPoint = __webpack_require__(1200), Circle.Random = __webpack_require__(170), module.exports = Circle;
  }, function (module, exports) {
    module.exports = function (circle) {
      return 0 < circle.radius ? Math.PI * circle.radius * circle.radius : 0;
    };
  }, function (module, exports, __webpack_require__) {
    var Circle = __webpack_require__(65);

    module.exports = function (source) {
      return new Circle(source.x, source.y, source.radius);
    };
  }, function (module, exports, __webpack_require__) {
    var Contains = __webpack_require__(66);

    module.exports = function (circle, point) {
      return Contains(circle, point.x, point.y);
    };
  }, function (module, exports, __webpack_require__) {
    var Contains = __webpack_require__(66);

    module.exports = function (circle, rect) {
      return Contains(circle, rect.x, rect.y) && Contains(circle, rect.right, rect.y) && Contains(circle, rect.x, rect.bottom) && Contains(circle, rect.right, rect.bottom);
    };
  }, function (module, exports) {
    module.exports = function (source, dest) {
      return dest.setTo(source.x, source.y, source.radius);
    };
  }, function (module, exports) {
    module.exports = function (circle, toCompare) {
      return circle.x === toCompare.x && circle.y === toCompare.y && circle.radius === toCompare.radius;
    };
  }, function (module, exports, __webpack_require__) {
    var Rectangle = __webpack_require__(10);

    module.exports = function (circle, out) {
      return (out = void 0 === out ? new Rectangle() : out).x = circle.left, out.y = circle.top, out.width = circle.diameter, out.height = circle.diameter, out;
    };
  }, function (module, exports) {
    module.exports = function (circle, x, y) {
      return circle.x += x, circle.y += y, circle;
    };
  }, function (module, exports) {
    module.exports = function (circle, point) {
      return circle.x += point.x, circle.y += point.y, circle;
    };
  }, function (module, exports, __webpack_require__) {
    var Ellipse = __webpack_require__(111);

    Ellipse.Area = __webpack_require__(1202), Ellipse.Circumference = __webpack_require__(447), Ellipse.CircumferencePoint = __webpack_require__(218), Ellipse.Clone = __webpack_require__(1203), Ellipse.Contains = __webpack_require__(112), Ellipse.ContainsPoint = __webpack_require__(1204), Ellipse.ContainsRect = __webpack_require__(1205), Ellipse.CopyFrom = __webpack_require__(1206), Ellipse.Equals = __webpack_require__(1207), Ellipse.GetBounds = __webpack_require__(1208), Ellipse.GetPoint = __webpack_require__(445), Ellipse.GetPoints = __webpack_require__(446), Ellipse.Offset = __webpack_require__(1209), Ellipse.OffsetPoint = __webpack_require__(1210), Ellipse.Random = __webpack_require__(180), module.exports = Ellipse;
  }, function (module, exports) {
    module.exports = function (ellipse) {
      return ellipse.isEmpty() ? 0 : ellipse.getMajorRadius() * ellipse.getMinorRadius() * Math.PI;
    };
  }, function (module, exports, __webpack_require__) {
    var Ellipse = __webpack_require__(111);

    module.exports = function (source) {
      return new Ellipse(source.x, source.y, source.width, source.height);
    };
  }, function (module, exports, __webpack_require__) {
    var Contains = __webpack_require__(112);

    module.exports = function (ellipse, point) {
      return Contains(ellipse, point.x, point.y);
    };
  }, function (module, exports, __webpack_require__) {
    var Contains = __webpack_require__(112);

    module.exports = function (ellipse, rect) {
      return Contains(ellipse, rect.x, rect.y) && Contains(ellipse, rect.right, rect.y) && Contains(ellipse, rect.x, rect.bottom) && Contains(ellipse, rect.right, rect.bottom);
    };
  }, function (module, exports) {
    module.exports = function (source, dest) {
      return dest.setTo(source.x, source.y, source.width, source.height);
    };
  }, function (module, exports) {
    module.exports = function (ellipse, toCompare) {
      return ellipse.x === toCompare.x && ellipse.y === toCompare.y && ellipse.width === toCompare.width && ellipse.height === toCompare.height;
    };
  }, function (module, exports, __webpack_require__) {
    var Rectangle = __webpack_require__(10);

    module.exports = function (ellipse, out) {
      return (out = void 0 === out ? new Rectangle() : out).x = ellipse.left, out.y = ellipse.top, out.width = ellipse.width, out.height = ellipse.height, out;
    };
  }, function (module, exports) {
    module.exports = function (ellipse, x, y) {
      return ellipse.x += x, ellipse.y += y, ellipse;
    };
  }, function (module, exports) {
    module.exports = function (ellipse, point) {
      return ellipse.x += point.x, ellipse.y += point.y, ellipse;
    };
  }, function (module, exports, __webpack_require__) {
    var Point = __webpack_require__(4),
        CircleToCircle = __webpack_require__(231);

    module.exports = function (r1, v1, out) {
      var x0, y0, r0, x1, x, n, coefficientA, coefficientB, lambda;
      return void 0 === out && (out = []), CircleToCircle(r1, v1) && (x0 = r1.x, y0 = r1.y, r0 = r1.radius, x1 = v1.x, n = v1.y, r1 = v1.radius, y0 === n ? 0 === (lambda = (coefficientB = -2 * n) * coefficientB - 4 * (coefficientA = 1) * (x1 * x1 + (x = (r1 * r1 - r0 * r0 - x1 * x1 + x0 * x0) / (2 * (x0 - x1))) * x - 2 * x1 * x + n * n - r1 * r1)) ? out.push(new Point(x, -coefficientB / (2 * coefficientA))) : 0 < lambda && (out.push(new Point(x, (-coefficientB + Math.sqrt(lambda)) / (2 * coefficientA))), out.push(new Point(x, (-coefficientB - Math.sqrt(lambda)) / (2 * coefficientA)))) : 0 === (lambda = (coefficientB = 2 * y0 * (v1 = (x0 - x1) / (y0 - n)) - 2 * (n = (r1 * r1 - r0 * r0 - x1 * x1 + x0 * x0 - n * n + y0 * y0) / (2 * (y0 - n))) * v1 - 2 * x0) * coefficientB - 4 * (coefficientA = v1 * v1 + 1) * (x0 * x0 + y0 * y0 + n * n - r0 * r0 - 2 * y0 * n)) ? out.push(new Point(x = -coefficientB / (2 * coefficientA), n - x * v1)) : 0 < lambda && (x = (-coefficientB + Math.sqrt(lambda)) / (2 * coefficientA), out.push(new Point(x, n - x * v1)), x = (-coefficientB - Math.sqrt(lambda)) / (2 * coefficientA), out.push(new Point(x, n - x * v1)))), out;
    };
  }, function (module, exports, __webpack_require__) {
    var GetLineToCircle = __webpack_require__(232),
        CircleToRectangle = __webpack_require__(151);

    module.exports = function (circle, lineD, out) {
      var lineA, lineB, lineC;
      return void 0 === out && (out = []), CircleToRectangle(circle, lineD) && (lineA = lineD.getLineA(), lineB = lineD.getLineB(), lineC = lineD.getLineC(), lineD = lineD.getLineD(), GetLineToCircle(lineA, circle, out), GetLineToCircle(lineB, circle, out), GetLineToCircle(lineC, circle, out), GetLineToCircle(lineD, circle, out)), out;
    };
  }, function (module, exports, __webpack_require__) {
    var Vector4 = __webpack_require__(140),
        GetLineToPolygon = __webpack_require__(487),
        segment = new (__webpack_require__(47))();

    function CheckIntersects(angle, x, y, closestIntersect, intersects) {
      var dx = Math.cos(angle),
          dy = Math.sin(angle);
      segment.setTo(x, y, x + dx, y + dy);
      closestIntersect = GetLineToPolygon(segment, closestIntersect);
      closestIntersect && intersects.push(new Vector4(closestIntersect.x, closestIntersect.y, angle, closestIntersect.w));
    }

    function SortIntersects(a, b) {
      return a.z - b.z;
    }

    module.exports = function (x, y, polygons) {
      Array.isArray(polygons) || (polygons = [polygons]);

      for (var intersects = [], angles = [], i = 0; i < polygons.length; i++) {
        for (var points = polygons[i].points, p = 0; p < points.length; p++) {
          var angle = Math.atan2(points[p].y - y, points[p].x - x);
          -1 === angles.indexOf(angle) && (CheckIntersects(angle, x, y, polygons, intersects), CheckIntersects(angle - 1e-5, x, y, polygons, intersects), CheckIntersects(angle + 1e-5, x, y, polygons, intersects), angles.push(angle));
        }
      }

      return intersects.sort(SortIntersects);
    };
  }, function (module, exports, __webpack_require__) {
    var Rectangle = __webpack_require__(10),
        RectangleToRectangle = __webpack_require__(152);

    module.exports = function (rectA, rectB, output) {
      return void 0 === output && (output = new Rectangle()), RectangleToRectangle(rectA, rectB) && (output.x = Math.max(rectA.x, rectB.x), output.y = Math.max(rectA.y, rectB.y), output.width = Math.min(rectA.right, rectB.right) - output.x, output.height = Math.min(rectA.bottom, rectB.bottom) - output.y), output;
    };
  }, function (module, exports, __webpack_require__) {
    var GetLineToRectangle = __webpack_require__(234),
        RectangleToRectangle = __webpack_require__(152);

    module.exports = function (lineD, rectB, out) {
      var lineA, lineB, lineC;
      return void 0 === out && (out = []), RectangleToRectangle(lineD, rectB) && (lineA = lineD.getLineA(), lineB = lineD.getLineB(), lineC = lineD.getLineC(), lineD = lineD.getLineD(), GetLineToRectangle(lineA, rectB, out), GetLineToRectangle(lineB, rectB, out), GetLineToRectangle(lineC, rectB, out), GetLineToRectangle(lineD, rectB, out)), out;
    };
  }, function (module, exports, __webpack_require__) {
    var RectangleToTriangle = __webpack_require__(489),
        GetLineToRectangle = __webpack_require__(234);

    module.exports = function (rect, lineC, out) {
      var lineA, lineB;
      return void 0 === out && (out = []), RectangleToTriangle(rect, lineC) && (lineA = lineC.getLineA(), lineB = lineC.getLineB(), lineC = lineC.getLineC(), GetLineToRectangle(lineA, rect, out), GetLineToRectangle(lineB, rect, out), GetLineToRectangle(lineC, rect, out)), out;
    };
  }, function (module, exports, __webpack_require__) {
    var GetLineToCircle = __webpack_require__(232),
        TriangleToCircle = __webpack_require__(491);

    module.exports = function (lineC, circle, out) {
      var lineA, lineB;
      return void 0 === out && (out = []), TriangleToCircle(lineC, circle) && (lineA = lineC.getLineA(), lineB = lineC.getLineB(), lineC = lineC.getLineC(), GetLineToCircle(lineA, circle, out), GetLineToCircle(lineB, circle, out), GetLineToCircle(lineC, circle, out)), out;
    };
  }, function (module, exports, __webpack_require__) {
    var TriangleToTriangle = __webpack_require__(494),
        GetTriangleToLine = __webpack_require__(492);

    module.exports = function (triangleA, lineC, out) {
      var lineA, lineB;
      return void 0 === out && (out = []), TriangleToTriangle(triangleA, lineC) && (lineA = lineC.getLineA(), lineB = lineC.getLineB(), lineC = lineC.getLineC(), GetTriangleToLine(triangleA, lineA, out), GetTriangleToLine(triangleA, lineB, out), GetTriangleToLine(triangleA, lineC, out)), out;
    };
  }, function (module, exports, __webpack_require__) {
    var PointToLine = __webpack_require__(496);

    module.exports = function (point, yMax) {
      if (!PointToLine(point, yMax)) return !1;
      var xMin = Math.min(yMax.x1, yMax.x2),
          xMax = Math.max(yMax.x1, yMax.x2),
          yMin = Math.min(yMax.y1, yMax.y2),
          yMax = Math.max(yMax.y1, yMax.y2);
      return point.x >= xMin && point.x <= xMax && point.y >= yMin && point.y <= yMax;
    };
  }, function (module, exports) {
    module.exports = function (rect, left, right, top, bottom, tolerance) {
      return !(left > rect.right + (tolerance = void 0 === tolerance ? 0 : tolerance) || right < rect.left - tolerance || top > rect.bottom + tolerance || bottom < rect.top - tolerance);
    };
  }, function (module, exports, __webpack_require__) {
    var Line = __webpack_require__(47);

    Line.Angle = __webpack_require__(97), Line.BresenhamPoints = __webpack_require__(317), Line.CenterOn = __webpack_require__(1222), Line.Clone = __webpack_require__(1223), Line.CopyFrom = __webpack_require__(1224), Line.Equals = __webpack_require__(1225), Line.Extend = __webpack_require__(1226), Line.GetEasedPoints = __webpack_require__(1227), Line.GetMidPoint = __webpack_require__(1228), Line.GetNearestPoint = __webpack_require__(1229), Line.GetNormal = __webpack_require__(1230), Line.GetPoint = __webpack_require__(307), Line.GetPoints = __webpack_require__(172), Line.GetShortestDistance = __webpack_require__(1231), Line.Height = __webpack_require__(1232), Line.Length = __webpack_require__(67), Line.NormalAngle = __webpack_require__(497), Line.NormalX = __webpack_require__(1233), Line.NormalY = __webpack_require__(1234), Line.Offset = __webpack_require__(1235), Line.PerpSlope = __webpack_require__(1236), Line.Random = __webpack_require__(173), Line.ReflectAngle = __webpack_require__(1237), Line.Rotate = __webpack_require__(1238), Line.RotateAroundPoint = __webpack_require__(1239), Line.RotateAroundXY = __webpack_require__(236), Line.SetToAngle = __webpack_require__(1240), Line.Slope = __webpack_require__(1241), Line.Width = __webpack_require__(1242), module.exports = Line;
  }, function (module, exports) {
    module.exports = function (line, tx, ty) {
      tx -= (line.x1 + line.x2) / 2, ty -= (line.y1 + line.y2) / 2;
      return line.x1 += tx, line.y1 += ty, line.x2 += tx, line.y2 += ty, line;
    };
  }, function (module, exports, __webpack_require__) {
    var Line = __webpack_require__(47);

    module.exports = function (source) {
      return new Line(source.x1, source.y1, source.x2, source.y2);
    };
  }, function (module, exports) {
    module.exports = function (source, dest) {
      return dest.setTo(source.x1, source.y1, source.x2, source.y2);
    };
  }, function (module, exports) {
    module.exports = function (line, toCompare) {
      return line.x1 === toCompare.x1 && line.y1 === toCompare.y1 && line.x2 === toCompare.x2 && line.y2 === toCompare.y2;
    };
  }, function (module, exports, __webpack_require__) {
    var Length = __webpack_require__(67);

    module.exports = function (line, left, right) {
      void 0 === right && (right = left);
      var length = Length(line),
          slopX = line.x2 - line.x1,
          slopY = line.y2 - line.y1;
      return left && (line.x1 = line.x1 - slopX / length * left, line.y1 = line.y1 - slopY / length * left), right && (line.x2 = line.x2 + slopX / length * right, line.y2 = line.y2 + slopY / length * right), line;
    };
  }, function (module, exports, __webpack_require__) {
    var DistanceBetweenPoints = __webpack_require__(352),
        GetEaseFunction = __webpack_require__(80),
        Point = __webpack_require__(4);

    module.exports = function (line, ease, endPoint, collinearThreshold, easeParams) {
      void 0 === collinearThreshold && (collinearThreshold = 0);
      var v,
          results = [],
          x1 = line.x1,
          y1 = line.y1,
          spaceX = line.x2 - x1,
          spaceY = line.y2 - y1,
          easeFunc = GetEaseFunction(ease, easeParams = void 0 === easeParams ? [] : easeParams),
          q = endPoint - 1;

      for (i = 0; i < q; i++) {
        v = easeFunc(i / q), results.push(new Point(x1 + spaceX * v, y1 + spaceY * v));
      }

      if (v = easeFunc(1), results.push(new Point(x1 + spaceX * v, y1 + spaceY * v)), 0 < collinearThreshold) {
        for (var prevPoint = results[0], sortedResults = [prevPoint], i = 1; i < results.length - 1; i++) {
          var point = results[i];
          DistanceBetweenPoints(prevPoint, point) >= collinearThreshold && (sortedResults.push(point), prevPoint = point);
        }

        endPoint = results[results.length - 1];
        return DistanceBetweenPoints(prevPoint, endPoint) < collinearThreshold && sortedResults.pop(), sortedResults.push(endPoint), sortedResults;
      }

      return results;
    };
  }, function (module, exports, __webpack_require__) {
    var Point = __webpack_require__(4);

    module.exports = function (line, out) {
      return (out = void 0 === out ? new Point() : out).x = (line.x1 + line.x2) / 2, out.y = (line.y1 + line.y2) / 2, out;
    };
  }, function (module, exports, __webpack_require__) {
    var Point = __webpack_require__(4);

    module.exports = function (r, point, out) {
      void 0 === out && (out = new Point());
      var x1 = r.x1,
          y1 = r.y1,
          x2 = r.x2,
          y2 = r.y2,
          r = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
      if (0 == r) return out;
      r = ((point.x - x1) * (x2 - x1) + (point.y - y1) * (y2 - y1)) / r;
      return out.x = x1 + r * (x2 - x1), out.y = y1 + r * (y2 - y1), out;
    };
  }, function (module, exports, __webpack_require__) {
    var MATH_CONST = __webpack_require__(14),
        Angle = __webpack_require__(97),
        Point = __webpack_require__(4);

    module.exports = function (a, out) {
      void 0 === out && (out = new Point());
      a = Angle(a) - MATH_CONST.TAU;
      return out.x = Math.cos(a), out.y = Math.sin(a), out;
    };
  }, function (module, exports) {
    module.exports = function (L2, point) {
      var x1 = L2.x1,
          s = L2.y1,
          x2 = L2.x2,
          y2 = L2.y2,
          L2 = (x2 - x1) * (x2 - x1) + (y2 - s) * (y2 - s);
      if (0 == L2) return !1;
      s = ((s - point.y) * (x2 - x1) - (x1 - point.x) * (y2 - s)) / L2;
      return Math.abs(s) * Math.sqrt(L2);
    };
  }, function (module, exports) {
    module.exports = function (line) {
      return Math.abs(line.y1 - line.y2);
    };
  }, function (module, exports, __webpack_require__) {
    var MATH_CONST = __webpack_require__(14),
        Angle = __webpack_require__(97);

    module.exports = function (line) {
      return Math.cos(Angle(line) - MATH_CONST.TAU);
    };
  }, function (module, exports, __webpack_require__) {
    var MATH_CONST = __webpack_require__(14),
        Angle = __webpack_require__(97);

    module.exports = function (line) {
      return Math.sin(Angle(line) - MATH_CONST.TAU);
    };
  }, function (module, exports) {
    module.exports = function (line, x, y) {
      return line.x1 += x, line.y1 += y, line.x2 += x, line.y2 += y, line;
    };
  }, function (module, exports) {
    module.exports = function (line) {
      return -((line.x2 - line.x1) / (line.y2 - line.y1));
    };
  }, function (module, exports, __webpack_require__) {
    var Angle = __webpack_require__(97),
        NormalAngle = __webpack_require__(497);

    module.exports = function (lineA, lineB) {
      return 2 * NormalAngle(lineB) - Math.PI - Angle(lineA);
    };
  }, function (module, exports, __webpack_require__) {
    var RotateAroundXY = __webpack_require__(236);

    module.exports = function (line, angle) {
      var x = (line.x1 + line.x2) / 2,
          y = (line.y1 + line.y2) / 2;
      return RotateAroundXY(line, x, y, angle);
    };
  }, function (module, exports, __webpack_require__) {
    var RotateAroundXY = __webpack_require__(236);

    module.exports = function (line, point, angle) {
      return RotateAroundXY(line, point.x, point.y, angle);
    };
  }, function (module, exports) {
    module.exports = function (line, x, y, angle, length) {
      return line.x1 = x, line.y1 = y, line.x2 = x + Math.cos(angle) * length, line.y2 = y + Math.sin(angle) * length, line;
    };
  }, function (module, exports) {
    module.exports = function (line) {
      return (line.y2 - line.y1) / (line.x2 - line.x1);
    };
  }, function (module, exports) {
    module.exports = function (line) {
      return Math.abs(line.x1 - line.x2);
    };
  }, function (module, exports, Mesh) {
    Mesh = {
      Face: Mesh(116),
      GenerateGridVerts: Mesh(1244),
      GenerateObjVerts: Mesh(480),
      GenerateVerts: Mesh(479),
      ParseObj: Mesh(498),
      ParseObjMaterial: Mesh(499),
      RotateFace: Mesh(1245),
      Vertex: Mesh(117)
    };
    module.exports = Mesh;
  }, function (module, exports, __webpack_require__) {
    var Face = __webpack_require__(116),
        GetFastValue = __webpack_require__(2),
        Matrix4 = __webpack_require__(69),
        Vector3 = __webpack_require__(39),
        Vertex = __webpack_require__(117),
        tempPosition = new Vector3(),
        tempRotation = new Vector3(),
        tempMatrix = new Matrix4();

    module.exports = function (widthSet) {
      var mesh = GetFastValue(widthSet, "mesh"),
          texture = GetFastValue(widthSet, "texture", null),
          textureFrame = GetFastValue(widthSet, "frame"),
          width = GetFastValue(widthSet, "width", 1),
          height = GetFastValue(widthSet, "height", width),
          widthSegments = GetFastValue(widthSet, "widthSegments", 1),
          heightSegments = GetFastValue(widthSet, "heightSegments", widthSegments),
          posX = GetFastValue(widthSet, "x", 0),
          posY = GetFastValue(widthSet, "y", 0),
          posZ = GetFastValue(widthSet, "z", 0),
          rotateX = GetFastValue(widthSet, "rotateX", 0),
          rotateY = GetFastValue(widthSet, "rotateY", 0),
          rotateZ = GetFastValue(widthSet, "rotateZ", 0),
          zIsUp = GetFastValue(widthSet, "zIsUp", !0),
          isOrtho = GetFastValue(widthSet, "isOrtho", !!mesh && mesh.dirtyCache[11]),
          colors = GetFastValue(widthSet, "colors", [16777215]),
          alphas = GetFastValue(widthSet, "alphas", [1]),
          tile = GetFastValue(widthSet, "tile", !1),
          flipY = GetFastValue(widthSet, "flipY", !1),
          widthSet = GetFastValue(widthSet, "width", null),
          result = {
        faces: [],
        verts: []
      };
      if (tempPosition.set(posX, posY, posZ), tempRotation.set(rotateX, rotateY, rotateZ), tempMatrix.fromRotationXYTranslation(tempRotation, tempPosition, zIsUp), !texture && mesh) texture = mesh.texture;else {
        if (!mesh || "string" != typeof texture) return result;
        texture = mesh.scene.sys.textures.get(texture);
      }
      textureFrame = texture.get(textureFrame);
      !widthSet && isOrtho && texture && mesh && (width = textureFrame.width / mesh.height, height = textureFrame.height / mesh.height);
      var halfWidth = width / 2,
          halfHeight = height / 2,
          gridX = Math.floor(widthSegments),
          gridY = Math.floor(heightSegments),
          gridX1 = gridX + 1,
          gridY1 = gridY + 1,
          segmentWidth = width / gridX,
          segmentHeight = height / gridY,
          uvs = [],
          vertices = [],
          frameU0 = 0,
          frameU1 = 1,
          frameV0 = 0,
          frameV1 = 1;
      textureFrame && (frameU0 = textureFrame.u0, frameU1 = textureFrame.u1, frameV1 = flipY ? (frameV0 = textureFrame.v1, textureFrame.v0) : (frameV0 = textureFrame.v0, textureFrame.v1));

      for (var frameU = frameU1 - frameU0, frameV = frameV1 - frameV0, iy = 0; iy < gridY1; iy++) {
        for (var y = iy * segmentHeight - halfHeight, ix = 0; ix < gridX1; ix++) {
          vertices.push(ix * segmentWidth - halfWidth, -y), uvs.push(frameU0 + ix / gridX * frameU, frameV0 + iy / gridY * frameV);
        }
      }

      Array.isArray(colors) || (colors = [colors]), Array.isArray(alphas) || (alphas = [alphas]);
      var alphaIndex = 0,
          colorIndex = 0;

      for (iy = 0; iy < gridY; iy++) {
        for (ix = 0; ix < gridX; ix++) {
          var vert3 = 2 * (ix + gridX1 * iy),
              vert4 = 2 * (ix + gridX1 * (iy + 1)),
              vert5 = 2 * (ix + 1 + gridX1 * (iy + 1)),
              d = 2 * (ix + 1 + gridX1 * iy),
              color = colors[colorIndex],
              vert6 = alphas[alphaIndex],
              vert1 = new Vertex(vertices[vert3], vertices[1 + vert3], 0, uvs[vert3], uvs[1 + vert3], color, vert6).transformMat4(tempMatrix),
              vert2 = new Vertex(vertices[vert4], vertices[1 + vert4], 0, uvs[vert4], uvs[1 + vert4], color, vert6).transformMat4(tempMatrix),
              vert3 = new Vertex(vertices[d], vertices[1 + d], 0, uvs[d], uvs[1 + d], color, vert6).transformMat4(tempMatrix),
              vert4 = new Vertex(vertices[vert4], vertices[1 + vert4], 0, uvs[vert4], uvs[1 + vert4], color, vert6).transformMat4(tempMatrix),
              vert5 = new Vertex(vertices[vert5], vertices[1 + vert5], 0, uvs[vert5], uvs[1 + vert5], color, vert6).transformMat4(tempMatrix),
              vert6 = new Vertex(vertices[d], vertices[1 + d], 0, uvs[d], uvs[1 + d], color, vert6).transformMat4(tempMatrix);
          tile && (vert1.setUVs(frameU0, frameV1), vert2.setUVs(frameU0, frameV0), vert3.setUVs(frameU1, frameV1), vert4.setUVs(frameU0, frameV0), vert5.setUVs(frameU1, frameV0), vert6.setUVs(frameU1, frameV1)), ++colorIndex === colors.length && (colorIndex = 0), ++alphaIndex === alphas.length && (alphaIndex = 0), result.verts.push(vert1, vert2, vert3, vert4, vert5, vert6), result.faces.push(new Face(vert1, vert2, vert3), new Face(vert4, vert5, vert6));
        }
      }

      return mesh && (mesh.faces = mesh.faces.concat(result.faces), mesh.vertices = mesh.vertices.concat(result.verts)), result;
    };
  }, function (module, exports) {
    module.exports = function (ty, tx, v1, v2) {
      var x, y;
      void 0 === v1 && void 0 === v2 && (x = (v3 = ty.getInCenter()).x, y = v3.y);
      var c = Math.cos(tx),
          s = Math.sin(tx),
          v1 = ty.vertex1,
          v2 = ty.vertex2,
          v3 = ty.vertex3,
          tx = v1.x - x,
          ty = v1.y - y;
      v1.set(tx * c - ty * s + x, tx * s + ty * c + y), tx = v2.x - x, ty = v2.y - y, v2.set(tx * c - ty * s + x, tx * s + ty * c + y), tx = v3.x - x, ty = v3.y - y, v3.set(tx * c - ty * s + x, tx * s + ty * c + y);
    };
  }, function (module, exports, __webpack_require__) {
    var Point = __webpack_require__(4);

    Point.Ceil = __webpack_require__(1247), Point.Clone = __webpack_require__(1248), Point.CopyFrom = __webpack_require__(1249), Point.Equals = __webpack_require__(1250), Point.Floor = __webpack_require__(1251), Point.GetCentroid = __webpack_require__(1252), Point.GetMagnitude = __webpack_require__(500), Point.GetMagnitudeSq = __webpack_require__(501), Point.GetRectangleFromPoints = __webpack_require__(1253), Point.Interpolate = __webpack_require__(1254), Point.Invert = __webpack_require__(1255), Point.Negative = __webpack_require__(1256), Point.Project = __webpack_require__(1257), Point.ProjectUnit = __webpack_require__(1258), Point.SetMagnitude = __webpack_require__(1259), module.exports = Point;
  }, function (module, exports) {
    module.exports = function (point) {
      return point.setTo(Math.ceil(point.x), Math.ceil(point.y));
    };
  }, function (module, exports, __webpack_require__) {
    var Point = __webpack_require__(4);

    module.exports = function (source) {
      return new Point(source.x, source.y);
    };
  }, function (module, exports) {
    module.exports = function (source, dest) {
      return dest.setTo(source.x, source.y);
    };
  }, function (module, exports) {
    module.exports = function (point, toCompare) {
      return point.x === toCompare.x && point.y === toCompare.y;
    };
  }, function (module, exports) {
    module.exports = function (point) {
      return point.setTo(Math.floor(point.x), Math.floor(point.y));
    };
  }, function (module, exports, __webpack_require__) {
    var Point = __webpack_require__(4);

    module.exports = function (points, out) {
      if (void 0 === out && (out = new Point()), !Array.isArray(points)) throw new Error("GetCentroid points argument must be an array");
      var len = points.length;
      if (len < 1) throw new Error("GetCentroid points array must not be empty");
      if (1 === len) out.x = points[0].x, out.y = points[0].y;else {
        for (var i = 0; i < len; i++) {
          out.x += points[i].x, out.y += points[i].y;
        }

        out.x /= len, out.y /= len;
      }
      return out;
    };
  }, function (module, exports, __webpack_require__) {
    var Rectangle = __webpack_require__(10);

    module.exports = function (points, out) {
      void 0 === out && (out = new Rectangle());

      for (var xMax = Number.NEGATIVE_INFINITY, xMin = Number.POSITIVE_INFINITY, yMax = Number.NEGATIVE_INFINITY, yMin = Number.POSITIVE_INFINITY, i = 0; i < points.length; i++) {
        var point = points[i];
        point.x > xMax && (xMax = point.x), point.x < xMin && (xMin = point.x), point.y > yMax && (yMax = point.y), point.y < yMin && (yMin = point.y);
      }

      return out.x = xMin, out.y = yMin, out.width = xMax - xMin, out.height = yMax - yMin, out;
    };
  }, function (module, exports, __webpack_require__) {
    var Point = __webpack_require__(4);

    module.exports = function (pointA, pointB, t, out) {
      return void 0 === t && (t = 0), (out = void 0 === out ? new Point() : out).x = pointA.x + (pointB.x - pointA.x) * t, out.y = pointA.y + (pointB.y - pointA.y) * t, out;
    };
  }, function (module, exports) {
    module.exports = function (point) {
      return point.setTo(point.y, point.x);
    };
  }, function (module, exports, __webpack_require__) {
    var Point = __webpack_require__(4);

    module.exports = function (point, out) {
      return (out = void 0 === out ? new Point() : out).setTo(-point.x, -point.y);
    };
  }, function (module, exports, __webpack_require__) {
    var Point = __webpack_require__(4),
        GetMagnitudeSq = __webpack_require__(501);

    module.exports = function (amt, pointB, out) {
      void 0 === out && (out = new Point());
      amt = (amt.x * pointB.x + amt.y * pointB.y) / GetMagnitudeSq(pointB);
      return 0 != amt && (out.x = amt * pointB.x, out.y = amt * pointB.y), out;
    };
  }, function (module, exports, __webpack_require__) {
    var Point = __webpack_require__(4);

    module.exports = function (amt, pointB, out) {
      void 0 === out && (out = new Point());
      amt = amt.x * pointB.x + amt.y * pointB.y;
      return 0 != amt && (out.x = amt * pointB.x, out.y = amt * pointB.y), out;
    };
  }, function (module, exports, __webpack_require__) {
    var GetMagnitude = __webpack_require__(500);

    module.exports = function (point, magnitude) {
      var m;
      return 0 === point.x && 0 === point.y || (m = GetMagnitude(point), point.x /= m, point.y /= m), point.x *= magnitude, point.y *= magnitude, point;
    };
  }, function (module, exports, __webpack_require__) {
    var Polygon = __webpack_require__(227);

    Polygon.Clone = __webpack_require__(1261), Polygon.Contains = __webpack_require__(228), Polygon.ContainsPoint = __webpack_require__(1262), Polygon.Earcut = __webpack_require__(59), Polygon.GetAABB = __webpack_require__(469), Polygon.GetNumberArray = __webpack_require__(1263), Polygon.GetPoints = __webpack_require__(470), Polygon.Perimeter = __webpack_require__(471), Polygon.Reverse = __webpack_require__(1264), Polygon.Simplify = __webpack_require__(1265), Polygon.Smooth = __webpack_require__(472), Polygon.Translate = __webpack_require__(1266), module.exports = Polygon;
  }, function (module, exports, __webpack_require__) {
    var Polygon = __webpack_require__(227);

    module.exports = function (polygon) {
      return new Polygon(polygon.points);
    };
  }, function (module, exports, __webpack_require__) {
    var Contains = __webpack_require__(228);

    module.exports = function (polygon, point) {
      return Contains(polygon, point.x, point.y);
    };
  }, function (module, exports) {
    module.exports = function (polygon, output) {
      void 0 === output && (output = []);

      for (var i = 0; i < polygon.points.length; i++) {
        output.push(polygon.points[i].x), output.push(polygon.points[i].y);
      }

      return output;
    };
  }, function (module, exports) {
    module.exports = function (polygon) {
      return polygon.points.reverse(), polygon;
    };
  }, function (module, exports) {
    function simplifyDouglasPeucker(points, sqTolerance) {
      var last = points.length - 1,
          simplified = [points[0]];
      return function simplifyDPStep(points, first, last, sqTolerance, simplified) {
        for (var index, p, t, p2, x, y, dx, maxSqDist = sqTolerance, i = first + 1; i < last; i++) {
          var sqDist = (p = points[i], t = points[first], p2 = points[last], sqDist = dx = y = x = void 0, x = t.x, y = t.y, dx = p2.x - x, sqDist = p2.y - y, 0 === dx && 0 === sqDist || (1 < (t = ((p.x - x) * dx + (p.y - y) * sqDist) / (dx * dx + sqDist * sqDist)) ? (x = p2.x, y = p2.y) : 0 < t && (x += dx * t, y += sqDist * t)), (dx = p.x - x) * dx + (sqDist = p.y - y) * sqDist);
          maxSqDist < sqDist && (index = i, maxSqDist = sqDist);
        }

        sqTolerance < maxSqDist && (1 < index - first && simplifyDPStep(points, first, index, sqTolerance, simplified), simplified.push(points[index]), 1 < last - index && simplifyDPStep(points, index, last, sqTolerance, simplified));
      }(points, 0, last, sqTolerance, simplified), simplified.push(points[last]), simplified;
    }

    module.exports = function (polygon, sqTolerance, highestQuality) {
      void 0 === sqTolerance && (sqTolerance = 1), void 0 === highestQuality && (highestQuality = !1);
      var points = polygon.points;
      return 2 < points.length && (sqTolerance = sqTolerance * sqTolerance, highestQuality || (points = function (points, sqTolerance) {
        for (var point, p1, dy, dx, prevPoint = points[0], newPoints = [prevPoint], i = 1, len = points.length; i < len; i++) {
          point = points[i], dy = prevPoint, dx = void 0, dx = (p1 = point).x - dy.x, dy = p1.y - dy.y, sqTolerance < dx * dx + dy * dy && (newPoints.push(point), prevPoint = point);
        }

        return prevPoint !== point && newPoints.push(point), newPoints;
      }(points, sqTolerance)), polygon.setTo(simplifyDouglasPeucker(points, sqTolerance))), polygon;
    };
  }, function (module, exports) {
    module.exports = function (polygon, x, y) {
      for (var points = polygon.points, i = 0; i < points.length; i++) {
        points[i].x += x, points[i].y += y;
      }

      return polygon;
    };
  }, function (module, exports) {
    module.exports = function (rect) {
      return rect.width * rect.height;
    };
  }, function (module, exports) {
    module.exports = function (rect) {
      return rect.x = Math.ceil(rect.x), rect.y = Math.ceil(rect.y), rect;
    };
  }, function (module, exports) {
    module.exports = function (rect) {
      return rect.x = Math.ceil(rect.x), rect.y = Math.ceil(rect.y), rect.width = Math.ceil(rect.width), rect.height = Math.ceil(rect.height), rect;
    };
  }, function (module, exports, __webpack_require__) {
    var Rectangle = __webpack_require__(10);

    module.exports = function (source) {
      return new Rectangle(source.x, source.y, source.width, source.height);
    };
  }, function (module, exports, __webpack_require__) {
    var Contains = __webpack_require__(57);

    module.exports = function (rect, point) {
      return Contains(rect, point.x, point.y);
    };
  }, function (module, exports) {
    module.exports = function (source, dest) {
      return dest.setTo(source.x, source.y, source.width, source.height);
    };
  }, function (module, exports) {
    module.exports = function (rect, toCompare) {
      return rect.x === toCompare.x && rect.y === toCompare.y && rect.width === toCompare.width && rect.height === toCompare.height;
    };
  }, function (module, exports, __webpack_require__) {
    var GetAspectRatio = __webpack_require__(237);

    module.exports = function (target, source) {
      var ratio = GetAspectRatio(target);
      return ratio < GetAspectRatio(source) ? target.setSize(source.height * ratio, source.height) : target.setSize(source.width, source.width / ratio), target.setPosition(source.centerX - target.width / 2, source.centerY - target.height / 2);
    };
  }, function (module, exports, __webpack_require__) {
    var GetAspectRatio = __webpack_require__(237);

    module.exports = function (target, source) {
      var ratio = GetAspectRatio(target);
      return ratio > GetAspectRatio(source) ? target.setSize(source.height * ratio, source.height) : target.setSize(source.width, source.width / ratio), target.setPosition(source.centerX - target.width / 2, source.centerY - target.height / 2);
    };
  }, function (module, exports) {
    module.exports = function (rect) {
      return rect.x = Math.floor(rect.x), rect.y = Math.floor(rect.y), rect;
    };
  }, function (module, exports) {
    module.exports = function (rect) {
      return rect.x = Math.floor(rect.x), rect.y = Math.floor(rect.y), rect.width = Math.floor(rect.width), rect.height = Math.floor(rect.height), rect;
    };
  }, function (module, exports, __webpack_require__) {
    var Rectangle = __webpack_require__(10);

    module.exports = function (x1, y1, x2, y2, out) {
      return (out = void 0 === out ? new Rectangle() : out).setTo(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x1 - x2), Math.abs(y1 - y2));
    };
  }, function (module, exports, __webpack_require__) {
    var Point = __webpack_require__(4);

    module.exports = function (rect, out) {
      return (out = void 0 === out ? new Point() : out).x = rect.centerX, out.y = rect.centerY, out;
    };
  }, function (module, exports, __webpack_require__) {
    var Point = __webpack_require__(4);

    module.exports = function (rect, out) {
      return (out = void 0 === out ? new Point() : out).x = rect.width, out.y = rect.height, out;
    };
  }, function (module, exports, __webpack_require__) {
    var CenterOn = __webpack_require__(190);

    module.exports = function (rect, x, y) {
      var cx = rect.centerX,
          cy = rect.centerY;
      return rect.setSize(rect.width + 2 * x, rect.height + 2 * y), CenterOn(rect, cx, cy);
    };
  }, function (module, exports, __webpack_require__) {
    var Rectangle = __webpack_require__(10),
        Intersects = __webpack_require__(152);

    module.exports = function (rectA, rectB, out) {
      return void 0 === out && (out = new Rectangle()), Intersects(rectA, rectB) ? (out.x = Math.max(rectA.x, rectB.x), out.y = Math.max(rectA.y, rectB.y), out.width = Math.min(rectA.right, rectB.right) - out.x, out.height = Math.min(rectA.bottom, rectB.bottom) - out.y) : out.setEmpty(), out;
    };
  }, function (module, exports) {
    module.exports = function (target, points) {
      for (var minX = target.x, maxX = target.right, minY = target.y, maxY = target.bottom, i = 0; i < points.length; i++) {
        minX = Math.min(minX, points[i].x), maxX = Math.max(maxX, points[i].x), minY = Math.min(minY, points[i].y), maxY = Math.max(maxY, points[i].y);
      }

      return target.x = minX, target.y = minY, target.width = maxX - minX, target.height = maxY - minY, target;
    };
  }, function (module, exports) {
    module.exports = function (target, maxY) {
      var minY = Math.min(target.x, maxY.x),
          maxX = Math.max(target.right, maxY.right);
      target.x = minY, target.width = maxX - minY;
      minY = Math.min(target.y, maxY.y), maxY = Math.max(target.bottom, maxY.bottom);
      return target.y = minY, target.height = maxY - minY, target;
    };
  }, function (module, exports) {
    module.exports = function (target, maxX, maxY) {
      var minY = Math.min(target.x, maxX),
          maxX = Math.max(target.right, maxX);
      target.x = minY, target.width = maxX - minY;
      minY = Math.min(target.y, maxY), maxY = Math.max(target.bottom, maxY);
      return target.y = minY, target.height = maxY - minY, target;
    };
  }, function (module, exports) {
    module.exports = function (rect, x, y) {
      return rect.x += x, rect.y += y, rect;
    };
  }, function (module, exports) {
    module.exports = function (rect, point) {
      return rect.x += point.x, rect.y += point.y, rect;
    };
  }, function (module, exports) {
    module.exports = function (rectA, rectB) {
      return rectA.x < rectB.right && rectA.right > rectB.x && rectA.y < rectB.bottom && rectA.bottom > rectB.y;
    };
  }, function (module, exports, __webpack_require__) {
    var Point = __webpack_require__(4),
        DegToRad = __webpack_require__(36);

    module.exports = function (rectangle, dy, out) {
      void 0 === out && (out = new Point()), dy = DegToRad(dy);
      var s = Math.sin(dy),
          c = Math.cos(dy),
          dx = 0 < c ? rectangle.width / 2 : rectangle.width / -2,
          dy = 0 < s ? rectangle.height / 2 : rectangle.height / -2;
      return Math.abs(dx * s) < Math.abs(dy * c) ? dy = dx * s / c : dx = dy * c / s, out.x = dx + rectangle.centerX, out.y = dy + rectangle.centerY, out;
    };
  }, function (module, exports, __webpack_require__) {
    var Between = __webpack_require__(195),
        ContainsRect = __webpack_require__(503),
        Point = __webpack_require__(4);

    module.exports = function (outer, inner, out) {
      if (void 0 === out && (out = new Point()), ContainsRect(outer, inner)) switch (Between(0, 3)) {
        case 0:
          out.x = outer.x + Math.random() * (inner.right - outer.x), out.y = outer.y + Math.random() * (inner.top - outer.y);
          break;

        case 1:
          out.x = inner.x + Math.random() * (outer.right - inner.x), out.y = inner.bottom + Math.random() * (outer.bottom - inner.bottom);
          break;

        case 2:
          out.x = outer.x + Math.random() * (inner.x - outer.x), out.y = inner.y + Math.random() * (outer.bottom - inner.y);
          break;

        case 3:
          out.x = inner.right + Math.random() * (outer.right - inner.right), out.y = outer.y + Math.random() * (inner.bottom - outer.y);
      }
      return out;
    };
  }, function (module, exports) {
    module.exports = function (rect, toCompare) {
      return rect.width === toCompare.width && rect.height === toCompare.height;
    };
  }, function (module, exports) {
    module.exports = function (rect, x, y) {
      return void 0 === y && (y = x), rect.width *= x, rect.height *= y, rect;
    };
  }, function (module, exports, __webpack_require__) {
    var Triangle = __webpack_require__(82);

    Triangle.Area = __webpack_require__(1294), Triangle.BuildEquilateral = __webpack_require__(1295), Triangle.BuildFromPolygon = __webpack_require__(1296), Triangle.BuildRight = __webpack_require__(1297), Triangle.CenterOn = __webpack_require__(1298), Triangle.Centroid = __webpack_require__(504), Triangle.CircumCenter = __webpack_require__(1299), Triangle.CircumCircle = __webpack_require__(1300), Triangle.Clone = __webpack_require__(1301), Triangle.Contains = __webpack_require__(115), Triangle.ContainsArray = __webpack_require__(235), Triangle.ContainsPoint = __webpack_require__(1302), Triangle.CopyFrom = __webpack_require__(1303), Triangle.Decompose = __webpack_require__(495), Triangle.Equals = __webpack_require__(1304), Triangle.GetPoint = __webpack_require__(476), Triangle.GetPoints = __webpack_require__(477), Triangle.InCenter = __webpack_require__(506), Triangle.Perimeter = __webpack_require__(1305), Triangle.Offset = __webpack_require__(505), Triangle.Random = __webpack_require__(181), Triangle.Rotate = __webpack_require__(1306), Triangle.RotateAroundPoint = __webpack_require__(1307), Triangle.RotateAroundXY = __webpack_require__(238), module.exports = Triangle;
  }, function (module, exports) {
    module.exports = function (y3) {
      var x1 = y3.x1,
          y1 = y3.y1,
          x2 = y3.x2,
          y2 = y3.y2,
          x3 = y3.x3,
          y3 = y3.y3;
      return Math.abs(((x3 - x1) * (y2 - y1) - (x2 - x1) * (y3 - y1)) / 2);
    };
  }, function (module, exports, __webpack_require__) {
    var Triangle = __webpack_require__(82);

    module.exports = function (x, y, length) {
      var height = length * (Math.sqrt(3) / 2);
      return new Triangle(x, y, x + length / 2, y + height, x - length / 2, y + height);
    };
  }, function (module, exports, __webpack_require__) {
    var EarCut = __webpack_require__(59),
        Triangle = __webpack_require__(82);

    module.exports = function (data, holes, scaleX, scaleY, out) {
      void 0 === scaleX && (scaleX = 1), void 0 === scaleY && (scaleY = 1), void 0 === out && (out = []);

      for (var x1, y1, x2, y2, x3, y3, tris = EarCut(data, holes = void 0 === holes ? null : holes), i = 0; i < tris.length; i += 3) {
        y2 = tris[i], x3 = tris[i + 1], y3 = tris[i + 2], x1 = data[2 * y2] * scaleX, y1 = data[2 * y2 + 1] * scaleY, x2 = data[2 * x3] * scaleX, y2 = data[2 * x3 + 1] * scaleY, x3 = data[2 * y3] * scaleX, y3 = data[2 * y3 + 1] * scaleY, out.push(new Triangle(x1, y1, x2, y2, x3, y3));
      }

      return out;
    };
  }, function (module, exports, __webpack_require__) {
    var Triangle = __webpack_require__(82);

    module.exports = function (x, y, width, height) {
      return new Triangle(x, y, x, y - (height = void 0 === height ? width : height), x + width, y);
    };
  }, function (module, exports, __webpack_require__) {
    var Centroid = __webpack_require__(504),
        Offset = __webpack_require__(505);

    module.exports = function (triangle, diffX, y, diffY) {
      diffY = (diffY = void 0 === diffY ? Centroid : diffY)(triangle), diffX -= diffY.x, diffY = y - diffY.y;
      return Offset(triangle, diffX, diffY);
    };
  }, function (module, exports, __webpack_require__) {
    var Vector2 = __webpack_require__(3);

    module.exports = function (numy, out) {
      void 0 === out && (out = new Vector2());
      var cx = numy.x3,
          cy = numy.y3,
          ax = numy.x1 - cx,
          ay = numy.y1 - cy,
          bx = numy.x2 - cx,
          by = numy.y2 - cy,
          denom = 2 * (ax * by - ay * bx),
          numy = ax * (bx * bx + by * by) - (ax * ax + ay * ay) * bx;
      return out.x = cx - (ay * (bx * bx + by * by) - (ax * ax + ay * ay) * by) / denom, out.y = cy + numy / denom, out;
    };
  }, function (module, exports, __webpack_require__) {
    var Circle = __webpack_require__(65);

    module.exports = function (minY, out) {
      void 0 === out && (out = new Circle());
      var minX,
          dx,
          dy,
          x1 = minY.x1,
          y1 = minY.y1,
          x2 = minY.x2,
          y2 = minY.y2,
          x3 = minY.x3,
          y3 = minY.y3,
          A = x2 - x1,
          B = y2 - y1,
          C = x3 - x1,
          D = y3 - y1,
          E = A * (x1 + x2) + B * (y1 + y2),
          F = C * (x1 + x3) + D * (y1 + y3),
          G = 2 * (A * (y3 - y2) - B * (x3 - x2));
      return Math.abs(G) < 1e-6 ? (minX = Math.min(x1, x2, x3), minY = Math.min(y1, y2, y3), dx = .5 * (Math.max(x1, x2, x3) - minX), dy = .5 * (Math.max(y1, y2, y3) - minY), out.x = minX + dx, out.y = minY + dy) : (out.x = (D * E - B * F) / G, out.y = (A * F - C * E) / G, dx = out.x - x1, dy = out.y - y1), out.radius = Math.sqrt(dx * dx + dy * dy), out;
    };
  }, function (module, exports, __webpack_require__) {
    var Triangle = __webpack_require__(82);

    module.exports = function (source) {
      return new Triangle(source.x1, source.y1, source.x2, source.y2, source.x3, source.y3);
    };
  }, function (module, exports, __webpack_require__) {
    var Contains = __webpack_require__(115);

    module.exports = function (triangle, point) {
      return Contains(triangle, point.x, point.y);
    };
  }, function (module, exports) {
    module.exports = function (source, dest) {
      return dest.setTo(source.x1, source.y1, source.x2, source.y2, source.x3, source.y3);
    };
  }, function (module, exports) {
    module.exports = function (triangle, toCompare) {
      return triangle.x1 === toCompare.x1 && triangle.y1 === toCompare.y1 && triangle.x2 === toCompare.x2 && triangle.y2 === toCompare.y2 && triangle.x3 === toCompare.x3 && triangle.y3 === toCompare.y3;
    };
  }, function (module, exports, __webpack_require__) {
    var Length = __webpack_require__(67);

    module.exports = function (line3) {
      var line1 = line3.getLineA(),
          line2 = line3.getLineB(),
          line3 = line3.getLineC();
      return Length(line1) + Length(line2) + Length(line3);
    };
  }, function (module, exports, __webpack_require__) {
    var RotateAroundXY = __webpack_require__(238),
        InCenter = __webpack_require__(506);

    module.exports = function (triangle, angle) {
      var point = InCenter(triangle);
      return RotateAroundXY(triangle, point.x, point.y, angle);
    };
  }, function (module, exports, __webpack_require__) {
    var RotateAroundXY = __webpack_require__(238);

    module.exports = function (triangle, point, angle) {
      return RotateAroundXY(triangle, point.x, point.y, angle);
    };
  }, function (module, exports, Input) {
    var CONST = Input(203),
        Input = Input(17)(!1, Input = {
      CreatePixelPerfectHandler: Input(507),
      CreateInteractiveObject: Input(508),
      Events: Input(51),
      Gamepad: Input(1309),
      InputManager: Input(409),
      InputPlugin: Input(1321),
      InputPluginCache: Input(153),
      Keyboard: Input(1322),
      Mouse: Input(1336),
      Pointer: Input(412),
      Touch: Input(1337)
    }, CONST);
    module.exports = Input;
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      Axis: __webpack_require__(509),
      Button: __webpack_require__(510),
      Events: __webpack_require__(239),
      Gamepad: __webpack_require__(511),
      GamepadPlugin: __webpack_require__(1316),
      Configs: __webpack_require__(1317)
    };
  }, function (module, exports) {
    module.exports = "down";
  }, function (module, exports) {
    module.exports = "up";
  }, function (module, exports) {
    module.exports = "connected";
  }, function (module, exports) {
    module.exports = "disconnected";
  }, function (module, exports) {
    module.exports = "down";
  }, function (module, exports) {
    module.exports = "up";
  }, function (module, exports, __webpack_require__) {
    var GamepadPlugin = __webpack_require__(0),
        EventEmitter = __webpack_require__(9),
        Events = __webpack_require__(239),
        Gamepad = __webpack_require__(511),
        GetValue = __webpack_require__(6),
        InputPluginCache = __webpack_require__(153),
        InputEvents = __webpack_require__(51),
        GamepadPlugin = new GamepadPlugin({
      Extends: EventEmitter,
      initialize: function initialize(sceneInputPlugin) {
        EventEmitter.call(this), this.scene = sceneInputPlugin.scene, this.settings = this.scene.sys.settings, this.sceneInputPlugin = sceneInputPlugin, this.enabled = !0, this.target, this.gamepads = [], this.queue = [], this.onGamepadHandler, this._pad1, this._pad2, this._pad3, this._pad4, sceneInputPlugin.pluginEvents.once(InputEvents.BOOT, this.boot, this), sceneInputPlugin.pluginEvents.on(InputEvents.START, this.start, this);
      },
      boot: function boot() {
        var game = this.scene.sys.game,
            settings = this.settings.input,
            config = game.config;
        this.enabled = GetValue(settings, "gamepad", config.inputGamepad) && game.device.input.gamepads, this.target = GetValue(settings, "gamepad.target", config.inputGamepadEventTarget), this.sceneInputPlugin.pluginEvents.once(InputEvents.DESTROY, this.destroy, this);
      },
      start: function start() {
        this.enabled && (this.startListeners(), this.refreshPads()), this.sceneInputPlugin.pluginEvents.once(InputEvents.SHUTDOWN, this.shutdown, this);
      },
      isActive: function isActive() {
        return this.enabled && this.scene.sys.isActive();
      },
      startListeners: function startListeners() {
        function handler(event) {
          !event.defaultPrevented && _this.isActive() && (_this.refreshPads(), _this.queue.push(event));
        }

        var _this = this,
            target = this.target;

        this.onGamepadHandler = handler, target.addEventListener("gamepadconnected", handler, !1), target.addEventListener("gamepaddisconnected", handler, !1), this.sceneInputPlugin.pluginEvents.on(InputEvents.UPDATE, this.update, this);
      },
      stopListeners: function stopListeners() {
        this.target.removeEventListener("gamepadconnected", this.onGamepadHandler), this.target.removeEventListener("gamepaddisconnected", this.onGamepadHandler), this.sceneInputPlugin.pluginEvents.off(InputEvents.UPDATE, this.update);

        for (var i = 0; i < this.gamepads.length; i++) {
          this.gamepads[i].removeAllListeners();
        }
      },
      disconnectAll: function disconnectAll() {
        for (var i = 0; i < this.gamepads.length; i++) {
          this.gamepads[i].pad.connected = !1;
        }
      },
      refreshPads: function refreshPads() {
        var connectedPads = navigator.getGamepads();
        if (connectedPads) for (var currentPads = this.gamepads, i = 0; i < connectedPads.length; i++) {
          var id,
              index,
              currentPad,
              newPad = connectedPads[i];
          newPad && (id = newPad.id, (currentPad = currentPads[index = newPad.index]) ? currentPad.id !== id ? (currentPad.destroy(), currentPads[index] = new Gamepad(this, newPad)) : currentPad.update(newPad) : (newPad = new Gamepad(this, newPad), currentPads[index] = newPad, this._pad1 ? this._pad2 ? this._pad3 ? this._pad4 || (this._pad4 = newPad) : this._pad3 = newPad : this._pad2 = newPad : this._pad1 = newPad));
        } else this.disconnectAll();
      },
      getAll: function getAll() {
        for (var out = [], pads = this.gamepads, i = 0; i < pads.length; i++) {
          pads[i] && out.push(pads[i]);
        }

        return out;
      },
      getPad: function getPad(index) {
        for (var pads = this.gamepads, i = 0; i < pads.length; i++) {
          if (pads[i] && pads[i].index === index) return pads[i];
        }
      },
      update: function update() {
        if (this.enabled) {
          this.refreshPads();
          var len = this.queue.length;
          if (0 !== len) for (var queue = this.queue.splice(0, len), i = 0; i < len; i++) {
            var event = queue[i],
                pad = this.getPad(event.gamepad.index);
            "gamepadconnected" === event.type ? this.emit(Events.CONNECTED, pad, event) : "gamepaddisconnected" === event.type && this.emit(Events.DISCONNECTED, pad, event);
          }
        }
      },
      shutdown: function shutdown() {
        this.stopListeners(), this.removeAllListeners();
      },
      destroy: function destroy() {
        this.shutdown();

        for (var i = 0; i < this.gamepads.length; i++) {
          this.gamepads[i] && this.gamepads[i].destroy();
        }

        this.gamepads = [], this.scene = null, this.settings = null, this.sceneInputPlugin = null, this.target = null;
      },
      total: {
        get: function get() {
          return this.gamepads.length;
        }
      },
      pad1: {
        get: function get() {
          return this._pad1;
        }
      },
      pad2: {
        get: function get() {
          return this._pad2;
        }
      },
      pad3: {
        get: function get() {
          return this._pad3;
        }
      },
      pad4: {
        get: function get() {
          return this._pad4;
        }
      }
    });

    InputPluginCache.register("GamepadPlugin", GamepadPlugin, "gamepad", "gamepad", "inputGamepad"), module.exports = GamepadPlugin;
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      DUALSHOCK_4: __webpack_require__(1318),
      SNES_USB: __webpack_require__(1319),
      XBOX_360: __webpack_require__(1320)
    };
  }, function (module, exports) {
    module.exports = {
      UP: 12,
      DOWN: 13,
      LEFT: 14,
      RIGHT: 15,
      SHARE: 8,
      OPTIONS: 9,
      PS: 16,
      TOUCHBAR: 17,
      X: 0,
      CIRCLE: 1,
      SQUARE: 2,
      TRIANGLE: 3,
      L1: 4,
      R1: 5,
      L2: 6,
      R2: 7,
      L3: 10,
      R3: 11,
      LEFT_STICK_H: 0,
      LEFT_STICK_V: 1,
      RIGHT_STICK_H: 2,
      RIGHT_STICK_V: 3
    };
  }, function (module, exports) {
    module.exports = {
      UP: 12,
      DOWN: 13,
      LEFT: 14,
      RIGHT: 15,
      SELECT: 8,
      START: 9,
      B: 0,
      A: 1,
      Y: 2,
      X: 3,
      LEFT_SHOULDER: 4,
      RIGHT_SHOULDER: 5
    };
  }, function (module, exports) {
    module.exports = {
      UP: 12,
      DOWN: 13,
      LEFT: 14,
      RIGHT: 15,
      MENU: 16,
      A: 0,
      B: 1,
      X: 2,
      Y: 3,
      LB: 4,
      RB: 5,
      LT: 6,
      RT: 7,
      BACK: 8,
      START: 9,
      LS: 10,
      RS: 11,
      LEFT_STICK_H: 0,
      LEFT_STICK_V: 1,
      RIGHT_STICK_H: 2,
      RIGHT_STICK_V: 3
    };
  }, function (module, exports, __webpack_require__) {
    var Circle = __webpack_require__(65),
        CircleContains = __webpack_require__(66),
        InputPlugin = __webpack_require__(0),
        CONST = __webpack_require__(203),
        CreateInteractiveObject = __webpack_require__(508),
        CreatePixelPerfectHandler = __webpack_require__(507),
        DistanceBetween = __webpack_require__(50),
        Ellipse = __webpack_require__(111),
        EllipseContains = __webpack_require__(112),
        Events = __webpack_require__(51),
        EventEmitter = __webpack_require__(9),
        GetFastValue = __webpack_require__(2),
        GEOM_CONST = __webpack_require__(56),
        InputPluginCache = __webpack_require__(153),
        IsPlainObject = __webpack_require__(7),
        PluginCache = __webpack_require__(24),
        Rectangle = __webpack_require__(10),
        RectangleContains = __webpack_require__(57),
        SceneEvents = __webpack_require__(20),
        Triangle = __webpack_require__(82),
        TriangleContains = __webpack_require__(115),
        InputPlugin = new InputPlugin({
      Extends: EventEmitter,
      initialize: function initialize(scene) {
        EventEmitter.call(this), this.scene = scene, this.systems = scene.sys, this.settings = scene.sys.settings, this.manager = scene.sys.game.input, this.pluginEvents = new EventEmitter(), this.enabled = !0, this.displayList, this.cameras, InputPluginCache.install(this), this.mouse = this.manager.mouse, this.topOnly = !0, this.pollRate = -1, this._pollTimer = 0;
        var _eventData = {
          cancelled: !1
        };
        this._eventContainer = {
          stopPropagation: function stopPropagation() {
            _eventData.cancelled = !0;
          }
        }, this._eventData = _eventData, this.dragDistanceThreshold = 0, this.dragTimeThreshold = 0, this._temp = [], this._tempZones = [], this._list = [], this._pendingInsertion = [], this._pendingRemoval = [], this._draggable = [], this._drag = {
          0: [],
          1: [],
          2: [],
          3: [],
          4: [],
          5: [],
          6: [],
          7: [],
          8: [],
          9: [],
          10: []
        }, this._dragState = [], this._over = {
          0: [],
          1: [],
          2: [],
          3: [],
          4: [],
          5: [],
          6: [],
          7: [],
          8: [],
          9: [],
          10: []
        }, this._validTypes = ["onDown", "onUp", "onOver", "onOut", "onMove", "onDragStart", "onDrag", "onDragEnd", "onDragEnter", "onDragLeave", "onDragOver", "onDrop"], this._updatedThisFrame = !1, scene.sys.events.once(SceneEvents.BOOT, this.boot, this), scene.sys.events.on(SceneEvents.START, this.start, this);
      },
      boot: function boot() {
        this.cameras = this.systems.cameras, this.displayList = this.systems.displayList, this.systems.events.once(SceneEvents.DESTROY, this.destroy, this), this.pluginEvents.emit(Events.BOOT);
      },
      start: function start() {
        var eventEmitter = this.systems.events;
        eventEmitter.on(SceneEvents.TRANSITION_START, this.transitionIn, this), eventEmitter.on(SceneEvents.TRANSITION_OUT, this.transitionOut, this), eventEmitter.on(SceneEvents.TRANSITION_COMPLETE, this.transitionComplete, this), eventEmitter.on(SceneEvents.PRE_UPDATE, this.preUpdate, this), eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this), this.manager.events.on(Events.GAME_OUT, this.onGameOut, this), this.manager.events.on(Events.GAME_OVER, this.onGameOver, this), this.enabled = !0, this._dragState = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], this.pluginEvents.emit(Events.START);
      },
      onGameOver: function onGameOver(event) {
        this.isActive() && this.emit(Events.GAME_OVER, event.timeStamp, event);
      },
      onGameOut: function onGameOut(event) {
        this.isActive() && this.emit(Events.GAME_OUT, event.timeStamp, event);
      },
      preUpdate: function preUpdate() {
        this.pluginEvents.emit(Events.PRE_UPDATE);
        var removeList = this._pendingRemoval,
            insertList = this._pendingInsertion,
            toRemove = removeList.length,
            toInsert = insertList.length;

        if (0 !== toRemove || 0 !== toInsert) {
          for (var current = this._list, i = 0; i < toRemove; i++) {
            var gameObject = removeList[i],
                index = current.indexOf(gameObject);
            -1 < index && (current.splice(index, 1), this.clear(gameObject, !0));
          }

          removeList.length = 0, this._pendingRemoval.length = 0, this._list = current.concat(insertList.splice(0));
        }
      },
      isActive: function isActive() {
        return this.enabled && this.scene.sys.isActive();
      },
      updatePoll: function updatePoll(time, delta) {
        if (!this.isActive()) return !1;
        if (this.pluginEvents.emit(Events.UPDATE, time, delta), this._updatedThisFrame) return this._updatedThisFrame = !1;

        for (var rate = this.manager, pointers = rate.pointers, pointersTotal = rate.pointersTotal, i = 0; i < pointersTotal; i++) {
          pointers[i].updateMotion();
        }

        if (0 === this._list.length) return !1;
        rate = this.pollRate;
        if (-1 === rate) return !1;

        if (0 < rate) {
          if (this._pollTimer -= delta, !(this._pollTimer < 0)) return !1;
          this._pollTimer = this.pollRate;
        }

        var captured = !1;

        for (i = 0; i < pointersTotal; i++) {
          var total = 0,
              pointer = pointers[i];
          this._tempZones = [], this._temp = this.hitTestPointer(pointer), this.sortGameObjects(this._temp, pointer), this.sortDropZones(this._tempZones), this.topOnly && (this._temp.length && this._temp.splice(1), this._tempZones.length && this._tempZones.splice(1)), total += this.processOverOutEvents(pointer), 2 === this.getDragState(pointer) && this.processDragThresholdEvent(pointer, time), 0 < total && (captured = !0);
        }

        return captured;
      },
      update: function update(type, pointers) {
        if (!this.isActive()) return !1;

        for (var pointersTotal = pointers.length, captured = !1, i = 0; i < pointersTotal; i++) {
          var total = 0,
              pointer = pointers[i];

          switch (this._tempZones = [], this._temp = this.hitTestPointer(pointer), this.sortGameObjects(this._temp, pointer), this.sortDropZones(this._tempZones), this.topOnly && (this._temp.length && this._temp.splice(1), this._tempZones.length && this._tempZones.splice(1)), type) {
            case CONST.MOUSE_DOWN:
              total += this.processDragDownEvent(pointer), total += this.processDownEvents(pointer), total += this.processOverOutEvents(pointer);
              break;

            case CONST.MOUSE_UP:
              total += this.processDragUpEvent(pointer), total += this.processUpEvents(pointer), total += this.processOverOutEvents(pointer);
              break;

            case CONST.TOUCH_START:
              total += this.processDragDownEvent(pointer), total += this.processDownEvents(pointer), total += this.processOverEvents(pointer);
              break;

            case CONST.TOUCH_END:
            case CONST.TOUCH_CANCEL:
              total += this.processDragUpEvent(pointer), total += this.processUpEvents(pointer), total += this.processOutEvents(pointer);
              break;

            case CONST.MOUSE_MOVE:
            case CONST.TOUCH_MOVE:
              total += this.processDragMoveEvent(pointer), total += this.processMoveEvents(pointer), total += this.processOverOutEvents(pointer);
              break;

            case CONST.MOUSE_WHEEL:
              total += this.processWheelEvent(pointer);
          }

          0 < total && (captured = !0);
        }

        return this._updatedThisFrame = !0, captured;
      },
      clear: function clear(gameObject, index) {
        void 0 === index && (index = !1);
        var input = gameObject.input;

        if (input) {
          index || this.queueForRemoval(gameObject), input.gameObject = void 0, input.target = void 0, input.hitArea = void 0, input.hitAreaCallback = void 0, input.callbackContext = void 0, gameObject.input = null;
          index = this._draggable.indexOf(gameObject);
          return -1 < index && this._draggable.splice(index, 1), -1 < (index = this._drag[0].indexOf(gameObject)) && this._drag[0].splice(index, 1), -1 < (index = this._over[0].indexOf(gameObject)) && (this._over[0].splice(index, 1), this.manager.resetCursor(input)), gameObject;
        }
      },
      disable: function disable(gameObject) {
        gameObject.input.enabled = !1;
      },
      enable: function enable(gameObject, hitArea, hitAreaCallback, dropZone) {
        return void 0 === dropZone && (dropZone = !1), gameObject.input ? gameObject.input.enabled = !0 : this.setHitArea(gameObject, hitArea, hitAreaCallback), gameObject.input && dropZone && !gameObject.input.dropZone && (gameObject.input.dropZone = dropZone), this;
      },
      hitTestPointer: function hitTestPointer(pointer) {
        for (var cameras = this.cameras.getCamerasBelowPointer(pointer), c = 0; c < cameras.length; c++) {
          for (var camera = cameras[c], over = this.manager.hitTest(pointer, this._list, camera), i = 0; i < over.length; i++) {
            var obj = over[i];
            obj.input.dropZone && this._tempZones.push(obj);
          }

          if (0 < over.length) return pointer.camera = camera, over;
        }

        return pointer.camera = cameras[0], [];
      },
      processDownEvents: function processDownEvents(pointer) {
        for (var total = 0, currentlyOver = this._temp, _eventData = this._eventData, _eventContainer = this._eventContainer, aborted = _eventData.cancelled = !1, i = 0; i < currentlyOver.length; i++) {
          var gameObject = currentlyOver[i];

          if (gameObject.input) {
            if (total++, gameObject.emit(Events.GAMEOBJECT_POINTER_DOWN, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer), _eventData.cancelled || !gameObject.input) {
              aborted = !0;
              break;
            }

            if (this.emit(Events.GAMEOBJECT_DOWN, pointer, gameObject, _eventContainer), _eventData.cancelled || !gameObject.input) {
              aborted = !0;
              break;
            }
          }
        }

        return !aborted && this.manager && (pointer.downElement === this.manager.game.canvas ? this.emit(Events.POINTER_DOWN, pointer, currentlyOver) : this.emit(Events.POINTER_DOWN_OUTSIDE, pointer)), total;
      },
      getDragState: function getDragState(pointer) {
        return this._dragState[pointer.id];
      },
      setDragState: function setDragState(pointer, state) {
        this._dragState[pointer.id] = state;
      },
      processDragThresholdEvent: function processDragThresholdEvent(pointer, time) {
        var passed = !1,
            timeThreshold = this.dragTimeThreshold,
            distanceThreshold = this.dragDistanceThreshold;
        if (passed = 0 < distanceThreshold && DistanceBetween(pointer.x, pointer.y, pointer.downX, pointer.downY) >= distanceThreshold || 0 < timeThreshold && time >= pointer.downTime + timeThreshold ? !0 : passed) return this.setDragState(pointer, 3), this.processDragStartList(pointer);
      },
      processDragStartList: function processDragStartList(pointer) {
        if (3 !== this.getDragState(pointer)) return 0;

        for (var list = this._drag[pointer.id], i = 0; i < list.length; i++) {
          var gameObject = list[i],
              input = gameObject.input;
          input.dragState = 2, input.dragStartX = gameObject.x, input.dragStartY = gameObject.y, input.dragStartXGlobal = pointer.worldX, input.dragStartYGlobal = pointer.worldY, input.dragX = input.dragStartXGlobal - input.dragStartX, input.dragY = input.dragStartYGlobal - input.dragStartY, gameObject.emit(Events.GAMEOBJECT_DRAG_START, pointer, input.dragX, input.dragY), this.emit(Events.DRAG_START, pointer, gameObject);
        }

        return this.setDragState(pointer, 4), list.length;
      },
      processDragDownEvent: function processDragDownEvent(pointer) {
        var currentlyOver = this._temp;
        if (0 === this._draggable.length || 0 === currentlyOver.length || !pointer.primaryDown || 0 !== this.getDragState(pointer)) return 0;
        this.setDragState(pointer, 1);

        for (var draglist = [], i = 0; i < currentlyOver.length; i++) {
          var gameObject = currentlyOver[i];
          gameObject.input.draggable && 0 === gameObject.input.dragState && draglist.push(gameObject);
        }

        return 0 === draglist.length ? (this.setDragState(pointer, 0), 0) : (1 < draglist.length && (this.sortGameObjects(draglist, pointer), this.topOnly && draglist.splice(1)), this._drag[pointer.id] = draglist, 0 === this.dragDistanceThreshold && 0 === this.dragTimeThreshold ? (this.setDragState(pointer, 3), this.processDragStartList(pointer)) : (this.setDragState(pointer, 2), 0));
      },
      processDragMoveEvent: function processDragMoveEvent(pointer) {
        if (2 === this.getDragState(pointer) && this.processDragThresholdEvent(pointer, this.manager.game.loop.now), 4 !== this.getDragState(pointer)) return 0;

        for (var dropZones = this._tempZones, list = this._drag[pointer.id], i = 0; i < list.length; i++) {
          var dx,
              dy,
              dragX,
              gameObject = list[i],
              dragY = gameObject.input,
              dyRotated = dragY.target;
          dyRotated ? 0 === (dy = dropZones.indexOf(dyRotated)) ? (gameObject.emit(Events.GAMEOBJECT_DRAG_OVER, pointer, dyRotated), this.emit(Events.DRAG_OVER, pointer, gameObject, dyRotated)) : 0 < dy ? (gameObject.emit(Events.GAMEOBJECT_DRAG_LEAVE, pointer, dyRotated), this.emit(Events.DRAG_LEAVE, pointer, gameObject, dyRotated), dragY.target = dropZones[0], dyRotated = dragY.target, gameObject.emit(Events.GAMEOBJECT_DRAG_ENTER, pointer, dyRotated), this.emit(Events.DRAG_ENTER, pointer, gameObject, dyRotated)) : (gameObject.emit(Events.GAMEOBJECT_DRAG_LEAVE, pointer, dyRotated), this.emit(Events.DRAG_LEAVE, pointer, gameObject, dyRotated), dropZones[0] ? (dragY.target = dropZones[0], dyRotated = dragY.target, gameObject.emit(Events.GAMEOBJECT_DRAG_ENTER, pointer, dyRotated), this.emit(Events.DRAG_ENTER, pointer, gameObject, dyRotated)) : dragY.target = null) : !dyRotated && dropZones[0] && (dragY.target = dropZones[0], dyRotated = dragY.target, gameObject.emit(Events.GAMEOBJECT_DRAG_ENTER, pointer, dyRotated), this.emit(Events.DRAG_ENTER, pointer, gameObject, dyRotated)), dragY = gameObject.parentContainer ? (dx = pointer.worldX - dragY.dragStartXGlobal, dy = pointer.worldY - dragY.dragStartYGlobal, dyRotated = gameObject.getParentRotation(), dragX = dx * Math.cos(dyRotated) + dy * Math.sin(dyRotated), dyRotated = dy * Math.cos(dyRotated) - dx * Math.sin(dyRotated), dragX *= 1 / gameObject.parentContainer.scaleX, dyRotated *= 1 / gameObject.parentContainer.scaleY, dragX = dragX + dragY.dragStartX, dyRotated + dragY.dragStartY) : (dragX = pointer.worldX - dragY.dragX, pointer.worldY - dragY.dragY), gameObject.emit(Events.GAMEOBJECT_DRAG, pointer, dragX, dragY), this.emit(Events.DRAG, pointer, gameObject, dragX, dragY);
        }

        return list.length;
      },
      processDragUpEvent: function processDragUpEvent(pointer) {
        for (var list = this._drag[pointer.id], i = 0; i < list.length; i++) {
          var dropped,
              target,
              gameObject = list[i],
              input = gameObject.input;
          input && 2 === input.dragState && (input.dragState = 0, input.dragX = input.localX - gameObject.displayOriginX, input.dragY = input.localY - gameObject.displayOriginY, dropped = !1, (target = input.target) && (gameObject.emit(Events.GAMEOBJECT_DROP, pointer, target), this.emit(Events.DROP, pointer, gameObject, target), dropped = !(input.target = null)), gameObject.input && (gameObject.emit(Events.GAMEOBJECT_DRAG_END, pointer, input.dragX, input.dragY, dropped), this.emit(Events.DRAG_END, pointer, gameObject, dropped)));
        }

        return this.setDragState(pointer, 0), list.splice(0), 0;
      },
      processMoveEvents: function processMoveEvents(pointer) {
        for (var total = 0, currentlyOver = this._temp, _eventData = this._eventData, _eventContainer = this._eventContainer, aborted = _eventData.cancelled = !1, i = 0; i < currentlyOver.length; i++) {
          var gameObject = currentlyOver[i];

          if (gameObject.input) {
            if (total++, gameObject.emit(Events.GAMEOBJECT_POINTER_MOVE, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer), _eventData.cancelled || !gameObject.input) {
              aborted = !0;
              break;
            }

            if (this.emit(Events.GAMEOBJECT_MOVE, pointer, gameObject, _eventContainer), _eventData.cancelled || !gameObject.input) {
              aborted = !0;
              break;
            }

            if (this.topOnly) break;
          }
        }

        return aborted || this.emit(Events.POINTER_MOVE, pointer, currentlyOver), total;
      },
      processWheelEvent: function processWheelEvent(pointer) {
        for (var total = 0, currentlyOver = this._temp, _eventData = this._eventData, _eventContainer = this._eventContainer, aborted = _eventData.cancelled = !1, dx = pointer.deltaX, dy = pointer.deltaY, dz = pointer.deltaZ, i = 0; i < currentlyOver.length; i++) {
          var gameObject = currentlyOver[i];

          if (gameObject.input) {
            if (total++, gameObject.emit(Events.GAMEOBJECT_POINTER_WHEEL, pointer, dx, dy, dz, _eventContainer), _eventData.cancelled || !gameObject.input) {
              aborted = !0;
              break;
            }

            if (this.emit(Events.GAMEOBJECT_WHEEL, pointer, gameObject, dx, dy, dz, _eventContainer), _eventData.cancelled || !gameObject.input) {
              aborted = !0;
              break;
            }
          }
        }

        return aborted || this.emit(Events.POINTER_WHEEL, pointer, currentlyOver, dx, dy, dz), total;
      },
      processOverEvents: function processOverEvents(pointer) {
        var currentlyOver = this._temp,
            totalInteracted = 0,
            total = currentlyOver.length,
            justOver = [];

        if (0 < total) {
          for (var manager = this.manager, _eventData = this._eventData, _eventContainer = this._eventContainer, aborted = _eventData.cancelled = !1, i = 0; i < total; i++) {
            var gameObject = currentlyOver[i];

            if (gameObject.input) {
              if (justOver.push(gameObject), manager.setCursor(gameObject.input), gameObject.emit(Events.GAMEOBJECT_POINTER_OVER, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer), totalInteracted++, _eventData.cancelled || !gameObject.input) {
                aborted = !0;
                break;
              }

              if (this.emit(Events.GAMEOBJECT_OVER, pointer, gameObject, _eventContainer), _eventData.cancelled || !gameObject.input) {
                aborted = !0;
                break;
              }
            }
          }

          aborted || this.emit(Events.POINTER_OVER, pointer, justOver);
        }

        return this._over[pointer.id] = justOver, totalInteracted;
      },
      processOutEvents: function processOutEvents(pointer) {
        var previouslyOver = this._over[pointer.id],
            totalInteracted = 0,
            total = previouslyOver.length;

        if (0 < total) {
          var manager = this.manager,
              _eventData = this._eventData,
              _eventContainer = this._eventContainer,
              aborted = _eventData.cancelled = !1;
          this.sortGameObjects(previouslyOver, pointer);

          for (var i = 0; i < total; i++) {
            var gameObject = previouslyOver[i];

            if ((gameObject = previouslyOver[i]).input) {
              if (manager.resetCursor(gameObject.input), gameObject.emit(Events.GAMEOBJECT_POINTER_OUT, pointer, _eventContainer), totalInteracted++, _eventData.cancelled || !gameObject.input) {
                aborted = !0;
                break;
              }

              if (this.emit(Events.GAMEOBJECT_OUT, pointer, gameObject, _eventContainer), _eventData.cancelled || !gameObject.input) {
                aborted = !0;
                break;
              }

              aborted || this.emit(Events.POINTER_OUT, pointer, previouslyOver);
            }
          }

          this._over[pointer.id] = [];
        }

        return totalInteracted;
      },
      processOverOutEvents: function processOverOutEvents(pointer) {
        for (var gameObject, currentlyOver = this._temp, justOut = [], justOver = [], stillOver = [], previouslyOver = this._over[pointer.id], currentlyDragging = this._drag[pointer.id], manager = this.manager, i = 0; i < previouslyOver.length; i++) {
          gameObject = previouslyOver[i], (-1 === currentlyOver.indexOf(gameObject) && -1 === currentlyDragging.indexOf(gameObject) ? justOut : stillOver).push(gameObject);
        }

        for (i = 0; i < currentlyOver.length; i++) {
          gameObject = currentlyOver[i], -1 === previouslyOver.indexOf(gameObject) && justOver.push(gameObject);
        }

        var total = justOut.length,
            totalInteracted = 0,
            _eventData = this._eventData,
            _eventContainer = this._eventContainer,
            aborted = _eventData.cancelled = !1;

        if (0 < total) {
          for (this.sortGameObjects(justOut, pointer), i = 0; i < total; i++) {
            if ((gameObject = justOut[i]).input) {
              if (manager.resetCursor(gameObject.input), gameObject.emit(Events.GAMEOBJECT_POINTER_OUT, pointer, _eventContainer), totalInteracted++, _eventData.cancelled || !gameObject.input) {
                aborted = !0;
                break;
              }

              if (this.emit(Events.GAMEOBJECT_OUT, pointer, gameObject, _eventContainer), _eventData.cancelled || !gameObject.input) {
                aborted = !0;
                break;
              }
            }
          }

          aborted || this.emit(Events.POINTER_OUT, pointer, justOut);
        }

        if (total = justOver.length, aborted = _eventData.cancelled = !1, 0 < total) {
          for (this.sortGameObjects(justOver, pointer), i = 0; i < total; i++) {
            if ((gameObject = justOver[i]).input) {
              if (manager.setCursor(gameObject.input), gameObject.emit(Events.GAMEOBJECT_POINTER_OVER, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer), totalInteracted++, _eventData.cancelled || !gameObject.input) {
                aborted = !0;
                break;
              }

              if (this.emit(Events.GAMEOBJECT_OVER, pointer, gameObject, _eventContainer), _eventData.cancelled || !gameObject.input) {
                aborted = !0;
                break;
              }
            }
          }

          aborted || this.emit(Events.POINTER_OVER, pointer, justOver);
        }

        return previouslyOver = stillOver.concat(justOver), this._over[pointer.id] = this.sortGameObjects(previouslyOver, pointer), totalInteracted;
      },
      processUpEvents: function processUpEvents(pointer) {
        for (var currentlyOver = this._temp, _eventData = this._eventData, _eventContainer = this._eventContainer, aborted = _eventData.cancelled = !1, i = 0; i < currentlyOver.length; i++) {
          var gameObject = currentlyOver[i];

          if (gameObject.input) {
            if (gameObject.emit(Events.GAMEOBJECT_POINTER_UP, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer), _eventData.cancelled || !gameObject.input) {
              aborted = !0;
              break;
            }

            if (this.emit(Events.GAMEOBJECT_UP, pointer, gameObject, _eventContainer), _eventData.cancelled || !gameObject.input) {
              aborted = !0;
              break;
            }
          }
        }

        return !aborted && this.manager && (pointer.upElement === this.manager.game.canvas ? this.emit(Events.POINTER_UP, pointer, currentlyOver) : this.emit(Events.POINTER_UP_OUTSIDE, pointer)), currentlyOver.length;
      },
      queueForInsertion: function queueForInsertion(child) {
        return -1 === this._pendingInsertion.indexOf(child) && -1 === this._list.indexOf(child) && this._pendingInsertion.push(child), this;
      },
      queueForRemoval: function queueForRemoval(child) {
        return this._pendingRemoval.push(child), this;
      },
      setDraggable: function setDraggable(gameObjects, value) {
        void 0 === value && (value = !0), Array.isArray(gameObjects) || (gameObjects = [gameObjects]);

        for (var i = 0; i < gameObjects.length; i++) {
          var gameObject = gameObjects[i];
          gameObject.input.draggable = value;

          var index = this._draggable.indexOf(gameObject);

          value && -1 === index ? this._draggable.push(gameObject) : !value && -1 < index && this._draggable.splice(index, 1);
        }

        return this;
      },
      makePixelPerfect: function makePixelPerfect(alphaTolerance) {
        var textureManager = this.systems.textures;
        return CreatePixelPerfectHandler(textureManager, alphaTolerance = void 0 === alphaTolerance ? 1 : alphaTolerance);
      },
      setHitArea: function setHitArea(gameObjects, hitArea, hitAreaCallback) {
        if (void 0 === hitArea) return this.setHitAreaFromTexture(gameObjects);
        Array.isArray(gameObjects) || (gameObjects = [gameObjects]);
        var alphaTolerance,
            draggable = !1,
            dropZone = !1,
            cursor = !1,
            useHandCursor = !1,
            pixelPerfect = !1,
            customHitArea = !0;
        IsPlainObject(hitArea) ? (hitArea = GetFastValue(alphaTolerance = hitArea, "hitArea", null), hitAreaCallback = GetFastValue(alphaTolerance, "hitAreaCallback", null), draggable = GetFastValue(alphaTolerance, "draggable", !1), dropZone = GetFastValue(alphaTolerance, "dropZone", !1), cursor = GetFastValue(alphaTolerance, "cursor", !1), useHandCursor = GetFastValue(alphaTolerance, "useHandCursor", !1), pixelPerfect = GetFastValue(alphaTolerance, "pixelPerfect", !1), alphaTolerance = GetFastValue(alphaTolerance, "alphaTolerance", 1), pixelPerfect && (hitArea = {}, hitAreaCallback = this.makePixelPerfect(alphaTolerance)), hitArea && hitAreaCallback || (this.setHitAreaFromTexture(gameObjects), customHitArea = !1)) : "function" != typeof hitArea || hitAreaCallback || (hitAreaCallback = hitArea, hitArea = {});

        for (var i = 0; i < gameObjects.length; i++) {
          var io,
              gameObject = gameObjects[i];
          pixelPerfect && "Container" === gameObject.type ? console.warn("Cannot pixelPerfect test a Container. Use a custom callback.") : ((io = gameObject.input || CreateInteractiveObject(gameObject, hitArea, hitAreaCallback)).customHitArea = customHitArea, io.dropZone = dropZone, io.cursor = useHandCursor ? "pointer" : cursor, gameObject.input = io, draggable && this.setDraggable(gameObject), this.queueForInsertion(gameObject));
        }

        return this;
      },
      setHitAreaCircle: function setHitAreaCircle(gameObjects, x, y, shape, callback) {
        void 0 === callback && (callback = CircleContains);
        shape = new Circle(x, y, shape);
        return this.setHitArea(gameObjects, shape, callback);
      },
      setHitAreaEllipse: function setHitAreaEllipse(gameObjects, x, y, width, shape, callback) {
        void 0 === callback && (callback = EllipseContains);
        shape = new Ellipse(x, y, width, shape);
        return this.setHitArea(gameObjects, shape, callback);
      },
      setHitAreaFromTexture: function setHitAreaFromTexture(gameObjects, callback) {
        void 0 === callback && (callback = RectangleContains), Array.isArray(gameObjects) || (gameObjects = [gameObjects]);

        for (var i = 0; i < gameObjects.length; i++) {
          var gameObject = gameObjects[i],
              frame = gameObject.frame,
              width = 0,
              height = 0;
          gameObject.width ? (width = gameObject.width, height = gameObject.height) : frame && (width = frame.realWidth, height = frame.realHeight), "Container" !== gameObject.type || 0 !== width && 0 !== height ? 0 !== width && 0 !== height && (gameObject.input = CreateInteractiveObject(gameObject, new Rectangle(0, 0, width, height), callback), this.queueForInsertion(gameObject)) : console.warn("Container.setInteractive must specify a Shape or call setSize() first");
        }

        return this;
      },
      setHitAreaRectangle: function setHitAreaRectangle(gameObjects, x, y, width, shape, callback) {
        void 0 === callback && (callback = RectangleContains);
        shape = new Rectangle(x, y, width, shape);
        return this.setHitArea(gameObjects, shape, callback);
      },
      setHitAreaTriangle: function setHitAreaTriangle(gameObjects, x1, y1, x2, y2, x3, shape, callback) {
        void 0 === callback && (callback = TriangleContains);
        shape = new Triangle(x1, y1, x2, y2, x3, shape);
        return this.setHitArea(gameObjects, shape, callback);
      },
      enableDebug: function enableDebug(gameObject, color) {
        void 0 === color && (color = 65280);
        var input = gameObject.input;
        if (!input || !input.hitArea) return this;
        var shape = input.hitArea,
            shapeType = shape.type,
            debug = input.hitAreaDebug,
            factory = this.systems.add,
            updateList = this.systems.updateList;
        debug && (updateList.remove(debug), debug.destroy(), debug = null);
        var offsetx = 0,
            offsety = 0;

        switch (shapeType) {
          case GEOM_CONST.CIRCLE:
            debug = factory.arc(0, 0, shape.radius), offsetx = shape.x - shape.radius, offsety = shape.y - shape.radius;
            break;

          case GEOM_CONST.ELLIPSE:
            debug = factory.ellipse(0, 0, shape.width, shape.height), offsetx = shape.x - shape.width / 2, offsety = shape.y - shape.height / 2;
            break;

          case GEOM_CONST.LINE:
            debug = factory.line(0, 0, shape.x1, shape.y1, shape.x2, shape.y2);
            break;

          case GEOM_CONST.POLYGON:
            debug = factory.polygon(0, 0, shape.points);
            break;

          case GEOM_CONST.RECTANGLE:
            debug = factory.rectangle(0, 0, shape.width, shape.height), offsetx = shape.x, offsety = shape.y;
            break;

          case GEOM_CONST.TRIANGLE:
            debug = factory.triangle(0, 0, shape.x1, shape.y1, shape.x2, shape.y2, shape.x3, shape.y3);
        }

        return debug && (debug.isFilled = !1, debug.preUpdate = function () {
          debug.setStrokeStyle(1 / gameObject.scale, color), debug.setDisplayOrigin(gameObject.displayOriginX, gameObject.displayOriginY);
          var matrix,
              x = gameObject.x,
              y = gameObject.y,
              rotation = gameObject.rotation,
              scaleX = gameObject.scaleX,
              scaleY = gameObject.scaleY;
          gameObject.parentContainer && (x = (matrix = gameObject.getWorldTransformMatrix()).tx, y = matrix.ty, rotation = matrix.rotation, scaleX = matrix.scaleX, scaleY = matrix.scaleY), debug.setRotation(rotation), debug.setScale(scaleX, scaleY), debug.setPosition(x + offsetx, y + offsety), debug.setScrollFactor(gameObject.scrollFactorX, gameObject.scrollFactorY), debug.setDepth(gameObject.depth);
        }, updateList.add(debug), input.hitAreaDebug = debug), this;
      },
      removeDebug: function removeDebug(debug) {
        var input = debug.input;
        return input && input.hitAreaDebug && (debug = input.hitAreaDebug, this.systems.updateList.remove(debug), debug.destroy(), input.hitAreaDebug = null), this;
      },
      setPollAlways: function setPollAlways() {
        return this.setPollRate(0);
      },
      setPollOnMove: function setPollOnMove() {
        return this.setPollRate(-1);
      },
      setPollRate: function setPollRate(value) {
        return this.pollRate = value, this._pollTimer = 0, this;
      },
      setGlobalTopOnly: function setGlobalTopOnly(value) {
        return this.manager.globalTopOnly = value, this;
      },
      setTopOnly: function setTopOnly(value) {
        return this.topOnly = value, this;
      },
      sortGameObjects: function sortGameObjects(gameObjects, pointer) {
        if (gameObjects.length < 2) return gameObjects;
        var list = pointer.camera.renderList;
        return gameObjects.sort(function (childA, childB) {
          return list.indexOf(childB) - list.indexOf(childA);
        });
      },
      sortDropZones: function sortDropZones(gameObjects) {
        return gameObjects.length < 2 ? gameObjects : (this.scene.sys.depthSort(), gameObjects.sort(this.sortDropZoneHandler.bind(this)));
      },
      sortDropZoneHandler: function sortDropZoneHandler(childA, childB) {
        if (childA.parentContainer || childB.parentContainer) {
          if (childA.parentContainer === childB.parentContainer) return childB.parentContainer.getIndex(childB) - childA.parentContainer.getIndex(childA);
          if (childA.parentContainer === childB) return -1;
          if (childB.parentContainer === childA) return 1;

          for (var listA = childA.getIndexList(), listB = childB.getIndexList(), len = Math.min(listA.length, listB.length), i = 0; i < len; i++) {
            var indexA = listA[i],
                indexB = listB[i];
            if (indexA !== indexB) return indexB - indexA;
          }

          return listB.length - listA.length;
        }

        return this.displayList.getIndex(childB) - this.displayList.getIndex(childA);
      },
      stopPropagation: function stopPropagation() {
        return this.manager._tempSkip = !0, this;
      },
      addPointer: function addPointer(quantity) {
        return this.manager.addPointer(quantity);
      },
      setDefaultCursor: function setDefaultCursor(cursor) {
        return this.manager.setDefaultCursor(cursor), this;
      },
      transitionIn: function transitionIn() {
        this.enabled = this.settings.transitionAllowInput;
      },
      transitionComplete: function transitionComplete() {
        this.settings.transitionAllowInput || (this.enabled = !0);
      },
      transitionOut: function transitionOut() {
        this.enabled = this.settings.transitionAllowInput;
      },
      shutdown: function shutdown() {
        this.pluginEvents.emit(Events.SHUTDOWN), this._temp.length = 0, this._list.length = 0, this._draggable.length = 0, this._pendingRemoval.length = 0, this._pendingInsertion.length = 0;

        for (var i = this._dragState.length = 0; i < 10; i++) {
          this._drag[i] = [], this._over[i] = [];
        }

        this.removeAllListeners();
        var manager = this.manager;
        manager.canvas.style.cursor = manager.defaultCursor;
        var eventEmitter = this.systems.events;
        eventEmitter.off(SceneEvents.TRANSITION_START, this.transitionIn, this), eventEmitter.off(SceneEvents.TRANSITION_OUT, this.transitionOut, this), eventEmitter.off(SceneEvents.TRANSITION_COMPLETE, this.transitionComplete, this), eventEmitter.off(SceneEvents.PRE_UPDATE, this.preUpdate, this), manager.events.off(Events.GAME_OUT, this.onGameOut, this), manager.events.off(Events.GAME_OVER, this.onGameOver, this), eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);
      },
      destroy: function destroy() {
        this.shutdown(), this.pluginEvents.emit(Events.DESTROY), this.pluginEvents.removeAllListeners(), this.scene.sys.events.off(SceneEvents.START, this.start, this), this.scene = null, this.cameras = null, this.manager = null, this.events = null, this.mouse = null;
      },
      x: {
        get: function get() {
          return this.manager.activePointer.x;
        }
      },
      y: {
        get: function get() {
          return this.manager.activePointer.y;
        }
      },
      isOver: {
        get: function get() {
          return this.manager.isOver;
        }
      },
      mousePointer: {
        get: function get() {
          return this.manager.mousePointer;
        }
      },
      activePointer: {
        get: function get() {
          return this.manager.activePointer;
        }
      },
      pointer1: {
        get: function get() {
          return this.manager.pointers[1];
        }
      },
      pointer2: {
        get: function get() {
          return this.manager.pointers[2];
        }
      },
      pointer3: {
        get: function get() {
          return this.manager.pointers[3];
        }
      },
      pointer4: {
        get: function get() {
          return this.manager.pointers[4];
        }
      },
      pointer5: {
        get: function get() {
          return this.manager.pointers[5];
        }
      },
      pointer6: {
        get: function get() {
          return this.manager.pointers[6];
        }
      },
      pointer7: {
        get: function get() {
          return this.manager.pointers[7];
        }
      },
      pointer8: {
        get: function get() {
          return this.manager.pointers[8];
        }
      },
      pointer9: {
        get: function get() {
          return this.manager.pointers[9];
        }
      },
      pointer10: {
        get: function get() {
          return this.manager.pointers[10];
        }
      }
    });

    PluginCache.register("InputPlugin", InputPlugin, "input"), module.exports = InputPlugin;
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      Events: __webpack_require__(154),
      KeyboardManager: __webpack_require__(410),
      KeyboardPlugin: __webpack_require__(1330),
      Key: __webpack_require__(512),
      KeyCodes: __webpack_require__(143),
      KeyCombo: __webpack_require__(513),
      AdvanceKeyCombo: __webpack_require__(515),
      ProcessKeyCombo: __webpack_require__(514),
      ResetKeyCombo: __webpack_require__(516),
      JustDown: __webpack_require__(1332),
      JustUp: __webpack_require__(1333),
      DownDuration: __webpack_require__(1334),
      UpDuration: __webpack_require__(1335)
    };
  }, function (module, exports) {
    module.exports = "keydown";
  }, function (module, exports) {
    module.exports = "keyup";
  }, function (module, exports) {
    module.exports = "keycombomatch";
  }, function (module, exports) {
    module.exports = "down";
  }, function (module, exports) {
    module.exports = "keydown-";
  }, function (module, exports) {
    module.exports = "keyup-";
  }, function (module, exports) {
    module.exports = "up";
  }, function (module, exports, __webpack_require__) {
    var KeyboardPlugin = __webpack_require__(0),
        EventEmitter = __webpack_require__(9),
        Events = __webpack_require__(154),
        GameEvents = __webpack_require__(22),
        GetValue = __webpack_require__(6),
        InputEvents = __webpack_require__(51),
        InputPluginCache = __webpack_require__(153),
        Key = __webpack_require__(512),
        KeyCodes = __webpack_require__(143),
        KeyCombo = __webpack_require__(513),
        KeyMap = __webpack_require__(1331),
        SceneEvents = __webpack_require__(20),
        SnapFloor = __webpack_require__(76),
        KeyboardPlugin = new KeyboardPlugin({
      Extends: EventEmitter,
      initialize: function initialize(sceneInputPlugin) {
        EventEmitter.call(this), this.game = sceneInputPlugin.systems.game, this.scene = sceneInputPlugin.scene, this.settings = this.scene.sys.settings, this.sceneInputPlugin = sceneInputPlugin, this.manager = sceneInputPlugin.manager.keyboard, this.enabled = !0, this.keys = [], this.combos = [], this.prevCode = null, this.prevTime = 0, this.prevType = null, sceneInputPlugin.pluginEvents.once(InputEvents.BOOT, this.boot, this), sceneInputPlugin.pluginEvents.on(InputEvents.START, this.start, this);
      },
      boot: function boot() {
        var captures = this.settings.input;
        this.enabled = GetValue(captures, "keyboard", !0);
        captures = GetValue(captures, "keyboard.capture", null);
        captures && this.addCaptures(captures), this.sceneInputPlugin.pluginEvents.once(InputEvents.DESTROY, this.destroy, this);
      },
      start: function start() {
        this.sceneInputPlugin.manager.events.on(InputEvents.MANAGER_PROCESS, this.update, this), this.sceneInputPlugin.pluginEvents.once(InputEvents.SHUTDOWN, this.shutdown, this), this.game.events.on(GameEvents.BLUR, this.resetKeys, this), this.scene.sys.events.on(SceneEvents.PAUSE, this.resetKeys, this), this.scene.sys.events.on(SceneEvents.SLEEP, this.resetKeys, this);
      },
      isActive: function isActive() {
        return this.enabled && this.scene.sys.isActive();
      },
      addCapture: function addCapture(keycode) {
        return this.manager.addCapture(keycode), this;
      },
      removeCapture: function removeCapture(keycode) {
        return this.manager.removeCapture(keycode), this;
      },
      getCaptures: function getCaptures() {
        return this.manager.captures;
      },
      enableGlobalCapture: function enableGlobalCapture() {
        return this.manager.preventDefault = !0, this;
      },
      disableGlobalCapture: function disableGlobalCapture() {
        return this.manager.preventDefault = !1, this;
      },
      clearCaptures: function clearCaptures() {
        return this.manager.clearCaptures(), this;
      },
      createCursorKeys: function createCursorKeys() {
        return this.addKeys({
          up: KeyCodes.UP,
          down: KeyCodes.DOWN,
          left: KeyCodes.LEFT,
          right: KeyCodes.RIGHT,
          space: KeyCodes.SPACE,
          shift: KeyCodes.SHIFT
        });
      },
      addKeys: function addKeys(keys, enableCapture, emitOnRepeat) {
        void 0 === enableCapture && (enableCapture = !0), void 0 === emitOnRepeat && (emitOnRepeat = !1);
        var output = {};

        if ("string" == typeof keys) {
          keys = keys.split(",");

          for (var i = 0; i < keys.length; i++) {
            var currentKey = keys[i].trim();
            currentKey && (output[currentKey] = this.addKey(currentKey, enableCapture, emitOnRepeat));
          }
        } else for (var key in keys) {
          output[key] = this.addKey(keys[key], enableCapture, emitOnRepeat);
        }

        return output;
      },
      addKey: function addKey(key, enableCapture, emitOnRepeat) {
        void 0 === enableCapture && (enableCapture = !0), void 0 === emitOnRepeat && (emitOnRepeat = !1);
        var keys = this.keys;

        if (key instanceof Key) {
          var idx = keys.indexOf(key);
          return -1 < idx ? keys[idx] = key : keys[key.keyCode] = key, enableCapture && this.addCapture(key.keyCode), key.setEmitOnRepeat(emitOnRepeat), key;
        }

        return keys[key = "string" == typeof key ? KeyCodes[key.toUpperCase()] : key] || (keys[key] = new Key(this, key), enableCapture && this.addCapture(key), keys[key].setEmitOnRepeat(emitOnRepeat)), keys[key];
      },
      removeKey: function removeKey(key, destroy) {
        void 0 === destroy && (destroy = !1);
        var ref,
            idx,
            keys = this.keys;
        return key instanceof Key ? -1 < (idx = keys.indexOf(key)) && (ref = this.keys[idx], this.keys[idx] = void 0) : "string" == typeof key && (key = KeyCodes[key.toUpperCase()]), keys[key] && (ref = keys[key], keys[key] = void 0), ref && (ref.plugin = null, destroy && ref.destroy()), this;
      },
      removeAllKeys: function removeAllKeys(destroy) {
        for (var keys = this.keys, i = 0; i < keys.length; i++) {
          var key = keys[i];
          key && (keys[i] = void 0, destroy && key.destroy());
        }

        return this;
      },
      createCombo: function createCombo(keys, config) {
        return new KeyCombo(this, keys, config);
      },
      checkDown: function checkDown(key, t) {
        if (void 0 === t && (t = 0), this.enabled && key.isDown) {
          t = SnapFloor(this.time - key.timeDown, t);
          if (t > key._tick) return key._tick = t, !0;
        }

        return !1;
      },
      update: function update() {
        var queue = this.manager.queue,
            len = queue.length;
        if (this.isActive() && 0 !== len) for (var keys = this.keys, i = 0; i < len; i++) {
          var event = queue[i],
              code = event.keyCode,
              key = keys[code],
              repeat = !1;
          void 0 === event.cancelled && (event.cancelled = 0, event.stopImmediatePropagation = function () {
            event.cancelled = 1;
          }, event.stopPropagation = function () {
            event.cancelled = -1;
          }), -1 !== event.cancelled && (code === this.prevCode && event.timeStamp === this.prevTime && event.type === this.prevType || (this.prevCode = code, this.prevTime = event.timeStamp, this.prevType = event.type, "keydown" === event.type ? (key && (repeat = key.isDown, key.onDown(event)), event.cancelled || key && repeat || (KeyMap[code] && this.emit(Events.KEY_DOWN + KeyMap[code], event), event.cancelled || this.emit(Events.ANY_KEY_DOWN, event))) : (key && key.onUp(event), event.cancelled || (KeyMap[code] && this.emit(Events.KEY_UP + KeyMap[code], event), event.cancelled || this.emit(Events.ANY_KEY_UP, event))), 1 === event.cancelled && (event.cancelled = 0)));
        }
      },
      resetKeys: function resetKeys() {
        for (var keys = this.keys, i = 0; i < keys.length; i++) {
          keys[i] && keys[i].reset();
        }

        return this;
      },
      shutdown: function shutdown() {
        this.removeAllKeys(!0), this.removeAllListeners(), this.sceneInputPlugin.manager.events.off(InputEvents.MANAGER_PROCESS, this.update, this), this.game.events.off(GameEvents.BLUR, this.resetKeys), this.scene.sys.events.off(SceneEvents.PAUSE, this.resetKeys, this), this.scene.sys.events.off(SceneEvents.SLEEP, this.resetKeys, this), this.queue = [];
      },
      destroy: function destroy() {
        this.shutdown();

        for (var keys = this.keys, i = 0; i < keys.length; i++) {
          keys[i] && keys[i].destroy();
        }

        this.keys = [], this.combos = [], this.queue = [], this.scene = null, this.settings = null, this.sceneInputPlugin = null, this.manager = null;
      },
      time: {
        get: function get() {
          return this.sceneInputPlugin.manager.time;
        }
      }
    });

    InputPluginCache.register("KeyboardPlugin", KeyboardPlugin, "keyboard", "keyboard", "inputKeyboard"), module.exports = KeyboardPlugin;
  }, function (module, exports, __webpack_require__) {
    var key,
        KeyCodes = __webpack_require__(143),
        KeyMap = {};

    for (key in KeyCodes) {
      KeyMap[KeyCodes[key]] = key;
    }

    module.exports = KeyMap;
  }, function (module, exports) {
    module.exports = function (key) {
      return !!key._justDown && !(key._justDown = !1);
    };
  }, function (module, exports) {
    module.exports = function (key) {
      return !!key._justUp && !(key._justUp = !1);
    };
  }, function (module, exports) {
    module.exports = function (key, duration) {
      void 0 === duration && (duration = 50);
      var current = key.plugin.game.loop.time - key.timeDown;
      return key.isDown && current < duration;
    };
  }, function (module, exports) {
    module.exports = function (key, duration) {
      void 0 === duration && (duration = 50);
      var current = key.plugin.game.loop.time - key.timeUp;
      return key.isUp && current < duration;
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      MouseManager: __webpack_require__(411)
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      TouchManager: __webpack_require__(413)
    };
  }, function (module, exports, Loader) {
    var CONST = Loader(21),
        Loader = Loader(17)(!1, Loader = {
      Events: Loader(95),
      FileTypes: Loader(1339),
      File: Loader(23),
      FileTypesManager: Loader(8),
      GetURL: Loader(155),
      LoaderPlugin: Loader(1365),
      MergeXHRSettings: Loader(240),
      MultiFile: Loader(49),
      XHRLoader: Loader(517),
      XHRSettings: Loader(156)
    }, CONST);
    module.exports = Loader;
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      AnimationJSONFile: __webpack_require__(1340),
      AsepriteFile: __webpack_require__(1341),
      AtlasJSONFile: __webpack_require__(1342),
      AtlasXMLFile: __webpack_require__(1343),
      AudioFile: __webpack_require__(518),
      AudioSpriteFile: __webpack_require__(1344),
      BinaryFile: __webpack_require__(1345),
      BitmapFontFile: __webpack_require__(1346),
      CSSFile: __webpack_require__(1347),
      GLSLFile: __webpack_require__(1348),
      HTML5AudioFile: __webpack_require__(519),
      HTMLFile: __webpack_require__(1349),
      HTMLTextureFile: __webpack_require__(1350),
      ImageFile: __webpack_require__(71),
      JSONFile: __webpack_require__(61),
      MultiAtlasFile: __webpack_require__(1351),
      MultiScriptFile: __webpack_require__(1352),
      OBJFile: __webpack_require__(1353),
      PackFile: __webpack_require__(1354),
      PluginFile: __webpack_require__(1355),
      SceneFile: __webpack_require__(1356),
      ScenePluginFile: __webpack_require__(1357),
      ScriptFile: __webpack_require__(520),
      SpriteSheetFile: __webpack_require__(1358),
      SVGFile: __webpack_require__(1359),
      TextFile: __webpack_require__(242),
      TilemapCSVFile: __webpack_require__(1360),
      TilemapImpactFile: __webpack_require__(1361),
      TilemapJSONFile: __webpack_require__(1362),
      UnityAtlasFile: __webpack_require__(1363),
      VideoFile: __webpack_require__(1364),
      XMLFile: __webpack_require__(241)
    };
  }, function (module, exports, __webpack_require__) {
    var Class = __webpack_require__(0),
        FileTypesManager = __webpack_require__(8),
        JSONFile = __webpack_require__(61),
        LoaderEvents = __webpack_require__(95),
        AnimationJSONFile = new Class({
      Extends: JSONFile,
      initialize: function initialize(loader, key, url, xhrSettings, dataKey) {
        JSONFile.call(this, loader, key, url, xhrSettings, dataKey), this.type = "animationJSON";
      },
      onProcess: function onProcess() {
        this.loader.once(LoaderEvents.POST_PROCESS, this.onLoadComplete, this), JSONFile.prototype.onProcess.call(this);
      },
      onLoadComplete: function onLoadComplete() {
        this.loader.systems.anims.fromJSON(this.data);
      }
    });

    FileTypesManager.register("animation", function (key, url, dataKey, xhrSettings) {
      if (Array.isArray(key)) for (var i = 0; i < key.length; i++) {
        this.addFile(new AnimationJSONFile(this, key[i]));
      } else this.addFile(new AnimationJSONFile(this, key, url, xhrSettings, dataKey));
      return this;
    }), module.exports = AnimationJSONFile;
  }, function (module, exports, __webpack_require__) {
    var Class = __webpack_require__(0),
        FileTypesManager = __webpack_require__(8),
        GetFastValue = __webpack_require__(2),
        ImageFile = __webpack_require__(71),
        IsPlainObject = __webpack_require__(7),
        JSONFile = __webpack_require__(61),
        MultiFile = __webpack_require__(49),
        AsepriteFile = new Class({
      Extends: MultiFile,
      initialize: function initialize(loader, key, textureURL, atlasURL, textureXhrSettings, data) {
        var image,
            config,
            data = IsPlainObject(key) ? (key = GetFastValue(config = key, "key"), image = new ImageFile(loader, {
          key: key,
          url: GetFastValue(config, "textureURL"),
          extension: GetFastValue(config, "textureExtension", "png"),
          normalMap: GetFastValue(config, "normalMap"),
          xhrSettings: GetFastValue(config, "textureXhrSettings")
        }), new JSONFile(loader, {
          key: key,
          url: GetFastValue(config, "atlasURL"),
          extension: GetFastValue(config, "atlasExtension", "json"),
          xhrSettings: GetFastValue(config, "atlasXhrSettings")
        })) : (image = new ImageFile(loader, key, textureURL, textureXhrSettings), new JSONFile(loader, key, atlasURL, data));
        image.linkFile ? MultiFile.call(this, loader, "atlasjson", key, [image, data, image.linkFile]) : MultiFile.call(this, loader, "atlasjson", key, [image, data]);
      },
      addToCache: function addToCache() {
        var image, json, normalMap;
        this.isReadyToProcess() && (image = this.files[0], json = this.files[1], normalMap = this.files[2] ? this.files[2].data : null, this.loader.textureManager.addAtlas(image.key, image.data, json.data, normalMap), json.addToCache(), this.complete = !0);
      }
    });

    FileTypesManager.register("aseprite", function (key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings) {
      var multifile;
      if (Array.isArray(key)) for (var i = 0; i < key.length; i++) {
        multifile = new AsepriteFile(this, key[i]), this.addFile(multifile.files);
      } else multifile = new AsepriteFile(this, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings), this.addFile(multifile.files);
      return this;
    }), module.exports = AsepriteFile;
  }, function (module, exports, __webpack_require__) {
    var Class = __webpack_require__(0),
        FileTypesManager = __webpack_require__(8),
        GetFastValue = __webpack_require__(2),
        ImageFile = __webpack_require__(71),
        IsPlainObject = __webpack_require__(7),
        JSONFile = __webpack_require__(61),
        MultiFile = __webpack_require__(49),
        AtlasJSONFile = new Class({
      Extends: MultiFile,
      initialize: function initialize(loader, key, textureURL, atlasURL, textureXhrSettings, data) {
        var image,
            config,
            data = IsPlainObject(key) ? (key = GetFastValue(config = key, "key"), image = new ImageFile(loader, {
          key: key,
          url: GetFastValue(config, "textureURL"),
          extension: GetFastValue(config, "textureExtension", "png"),
          normalMap: GetFastValue(config, "normalMap"),
          xhrSettings: GetFastValue(config, "textureXhrSettings")
        }), new JSONFile(loader, {
          key: key,
          url: GetFastValue(config, "atlasURL"),
          extension: GetFastValue(config, "atlasExtension", "json"),
          xhrSettings: GetFastValue(config, "atlasXhrSettings")
        })) : (image = new ImageFile(loader, key, textureURL, textureXhrSettings), new JSONFile(loader, key, atlasURL, data));
        image.linkFile ? MultiFile.call(this, loader, "atlasjson", key, [image, data, image.linkFile]) : MultiFile.call(this, loader, "atlasjson", key, [image, data]);
      },
      addToCache: function addToCache() {
        var image, json, normalMap;
        this.isReadyToProcess() && (image = this.files[0], json = this.files[1], normalMap = this.files[2] ? this.files[2].data : null, this.loader.textureManager.addAtlas(image.key, image.data, json.data, normalMap), json.pendingDestroy(), this.complete = !0);
      }
    });

    FileTypesManager.register("atlas", function (key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings) {
      var multifile;
      if (Array.isArray(key)) for (var i = 0; i < key.length; i++) {
        multifile = new AtlasJSONFile(this, key[i]), this.addFile(multifile.files);
      } else multifile = new AtlasJSONFile(this, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings), this.addFile(multifile.files);
      return this;
    }), module.exports = AtlasJSONFile;
  }, function (module, exports, __webpack_require__) {
    var Class = __webpack_require__(0),
        FileTypesManager = __webpack_require__(8),
        GetFastValue = __webpack_require__(2),
        ImageFile = __webpack_require__(71),
        IsPlainObject = __webpack_require__(7),
        MultiFile = __webpack_require__(49),
        XMLFile = __webpack_require__(241),
        AtlasXMLFile = new Class({
      Extends: MultiFile,
      initialize: function initialize(loader, key, textureURL, atlasURL, textureXhrSettings, data) {
        var image,
            config,
            data = IsPlainObject(key) ? (key = GetFastValue(config = key, "key"), image = new ImageFile(loader, {
          key: key,
          url: GetFastValue(config, "textureURL"),
          extension: GetFastValue(config, "textureExtension", "png"),
          normalMap: GetFastValue(config, "normalMap"),
          xhrSettings: GetFastValue(config, "textureXhrSettings")
        }), new XMLFile(loader, {
          key: key,
          url: GetFastValue(config, "atlasURL"),
          extension: GetFastValue(config, "atlasExtension", "xml"),
          xhrSettings: GetFastValue(config, "atlasXhrSettings")
        })) : (image = new ImageFile(loader, key, textureURL, textureXhrSettings), new XMLFile(loader, key, atlasURL, data));
        image.linkFile ? MultiFile.call(this, loader, "atlasxml", key, [image, data, image.linkFile]) : MultiFile.call(this, loader, "atlasxml", key, [image, data]);
      },
      addToCache: function addToCache() {
        var image, xml, normalMap;
        this.isReadyToProcess() && (image = this.files[0], xml = this.files[1], normalMap = this.files[2] ? this.files[2].data : null, this.loader.textureManager.addAtlasXML(image.key, image.data, xml.data, normalMap), xml.pendingDestroy(), this.complete = !0);
      }
    });

    FileTypesManager.register("atlasXML", function (key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings) {
      var multifile;
      if (Array.isArray(key)) for (var i = 0; i < key.length; i++) {
        multifile = new AtlasXMLFile(this, key[i]), this.addFile(multifile.files);
      } else multifile = new AtlasXMLFile(this, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings), this.addFile(multifile.files);
      return this;
    }), module.exports = AtlasXMLFile;
  }, function (module, exports, __webpack_require__) {
    var AudioFile = __webpack_require__(518),
        Class = __webpack_require__(0),
        FileTypesManager = __webpack_require__(8),
        GetFastValue = __webpack_require__(2),
        IsPlainObject = __webpack_require__(7),
        JSONFile = __webpack_require__(61),
        MultiFile = __webpack_require__(49),
        AudioSpriteFile = new Class({
      Extends: MultiFile,
      initialize: function initialize(loader, key, jsonURL, audio, audioConfig, audioXhrSettings, jsonXhrSettings) {
        var config, data;
        IsPlainObject(key) && (key = GetFastValue(config = key, "key"), jsonURL = GetFastValue(config, "jsonURL"), audio = GetFastValue(config, "audioURL"), audioConfig = GetFastValue(config, "audioConfig"), audioXhrSettings = GetFastValue(config, "audioXhrSettings"), jsonXhrSettings = GetFastValue(config, "jsonXhrSettings")), audio ? (audio = AudioFile.create(loader, key, audio, audioConfig, audioXhrSettings)) && (data = new JSONFile(loader, key, jsonURL, jsonXhrSettings), MultiFile.call(this, loader, "audiosprite", key, [audio, data]), this.config.resourceLoad = !1) : (data = new JSONFile(loader, key, jsonURL, jsonXhrSettings), MultiFile.call(this, loader, "audiosprite", key, [data]), this.config.resourceLoad = !0, this.config.audioConfig = audioConfig, this.config.audioXhrSettings = audioXhrSettings);
      },
      onFileComplete: function onFileComplete(file) {
        var urls, audioConfig, audio;
        -1 !== this.files.indexOf(file) && (this.pending--, this.config.resourceLoad && "json" === file.type && file.data.hasOwnProperty("resources") && (urls = file.data.resources, audioConfig = GetFastValue(this.config, "audioConfig"), audio = GetFastValue(this.config, "audioXhrSettings"), (audio = AudioFile.create(this.loader, file.key, urls, audioConfig, audio)) && (this.addToMultiFile(audio), this.loader.addFile(audio))));
      },
      addToCache: function addToCache() {
        var fileA, fileB;
        this.isReadyToProcess() && (fileA = this.files[0], fileB = this.files[1], fileA.addToCache(), fileB.addToCache(), this.complete = !0);
      }
    });

    FileTypesManager.register("audioSprite", function (key, jsonURL, audioURL, audioConfig, audioXhrSettings, jsonXhrSettings) {
      var multifile,
          deviceAudio = this.systems.game,
          gameAudioConfig = deviceAudio.config.audio,
          deviceAudio = deviceAudio.device.audio;
      if (gameAudioConfig && gameAudioConfig.noAudio || !deviceAudio.webAudio && !deviceAudio.audioData) return this;
      if (Array.isArray(key)) for (var i = 0; i < key.length; i++) {
        (multifile = new AudioSpriteFile(this, key[i])).files && this.addFile(multifile.files);
      } else (multifile = new AudioSpriteFile(this, key, jsonURL, audioURL, audioConfig, audioXhrSettings, jsonXhrSettings)).files && this.addFile(multifile.files);
      return this;
    });
  }, function (module, exports, __webpack_require__) {
    var Class = __webpack_require__(0),
        CONST = __webpack_require__(21),
        File = __webpack_require__(23),
        FileTypesManager = __webpack_require__(8),
        GetFastValue = __webpack_require__(2),
        IsPlainObject = __webpack_require__(7),
        BinaryFile = new Class({
      Extends: File,
      initialize: function initialize(loader, key, url, xhrSettings, fileConfig) {
        var config,
            extension = "bin";
        IsPlainObject(key) && (key = GetFastValue(config = key, "key"), url = GetFastValue(config, "url"), xhrSettings = GetFastValue(config, "xhrSettings"), extension = GetFastValue(config, "extension", extension), fileConfig = GetFastValue(config, "dataType", fileConfig));
        fileConfig = {
          type: "binary",
          cache: loader.cacheManager.binary,
          extension: extension,
          responseType: "arraybuffer",
          key: key,
          url: url,
          xhrSettings: xhrSettings,
          config: {
            dataType: fileConfig
          }
        };
        File.call(this, loader, fileConfig);
      },
      onProcess: function onProcess() {
        this.state = CONST.FILE_PROCESSING;
        var ctor = this.config.dataType;
        this.data = ctor ? new ctor(this.xhrLoader.response) : this.xhrLoader.response, this.onProcessComplete();
      }
    });

    FileTypesManager.register("binary", function (key, url, dataType, xhrSettings) {
      if (Array.isArray(key)) for (var i = 0; i < key.length; i++) {
        this.addFile(new BinaryFile(this, key[i]));
      } else this.addFile(new BinaryFile(this, key, url, xhrSettings, dataType));
      return this;
    }), module.exports = BinaryFile;
  }, function (module, exports, __webpack_require__) {
    var Class = __webpack_require__(0),
        FileTypesManager = __webpack_require__(8),
        GetFastValue = __webpack_require__(2),
        ImageFile = __webpack_require__(71),
        IsPlainObject = __webpack_require__(7),
        MultiFile = __webpack_require__(49),
        ParseXMLBitmapFont = __webpack_require__(212),
        XMLFile = __webpack_require__(241),
        BitmapFontFile = new Class({
      Extends: MultiFile,
      initialize: function initialize(loader, key, textureURL, fontDataURL, textureXhrSettings, data) {
        var image,
            config,
            data = IsPlainObject(key) ? (key = GetFastValue(config = key, "key"), image = new ImageFile(loader, {
          key: key,
          url: GetFastValue(config, "textureURL"),
          extension: GetFastValue(config, "textureExtension", "png"),
          normalMap: GetFastValue(config, "normalMap"),
          xhrSettings: GetFastValue(config, "textureXhrSettings")
        }), new XMLFile(loader, {
          key: key,
          url: GetFastValue(config, "fontDataURL"),
          extension: GetFastValue(config, "fontDataExtension", "xml"),
          xhrSettings: GetFastValue(config, "fontDataXhrSettings")
        })) : (image = new ImageFile(loader, key, textureURL, textureXhrSettings), new XMLFile(loader, key, fontDataURL, data));
        image.linkFile ? MultiFile.call(this, loader, "bitmapfont", key, [image, data, image.linkFile]) : MultiFile.call(this, loader, "bitmapfont", key, [image, data]);
      },
      addToCache: function addToCache() {
        var image, xml, data;
        this.isReadyToProcess() && (image = this.files[0], xml = this.files[1], image.addToCache(), xml.pendingDestroy(), data = image.cache.get(image.key), data = ParseXMLBitmapFont(xml.data, image.cache.getFrame(image.key), 0, 0, data), this.loader.cacheManager.bitmapFont.add(image.key, {
          data: data,
          texture: image.key,
          frame: null
        }), this.complete = !0);
      }
    });

    FileTypesManager.register("bitmapFont", function (key, textureURL, fontDataURL, textureXhrSettings, fontDataXhrSettings) {
      var multifile;
      if (Array.isArray(key)) for (var i = 0; i < key.length; i++) {
        multifile = new BitmapFontFile(this, key[i]), this.addFile(multifile.files);
      } else multifile = new BitmapFontFile(this, key, textureURL, fontDataURL, textureXhrSettings, fontDataXhrSettings), this.addFile(multifile.files);
      return this;
    }), module.exports = BitmapFontFile;
  }, function (module, exports, __webpack_require__) {
    var Class = __webpack_require__(0),
        CONST = __webpack_require__(21),
        File = __webpack_require__(23),
        FileTypesManager = __webpack_require__(8),
        GetFastValue = __webpack_require__(2),
        IsPlainObject = __webpack_require__(7),
        CSSFile = new Class({
      Extends: File,
      initialize: function initialize(loader, key, url, xhrSettings) {
        var config,
            extension = "css";
        IsPlainObject(key) && (key = GetFastValue(config = key, "key"), url = GetFastValue(config, "url"), xhrSettings = GetFastValue(config, "xhrSettings"), extension = GetFastValue(config, "extension", extension)), File.call(this, loader, {
          type: "script",
          cache: !1,
          extension: extension,
          responseType: "text",
          key: key,
          url: url,
          xhrSettings: xhrSettings
        });
      },
      onProcess: function onProcess() {
        this.state = CONST.FILE_PROCESSING, this.data = document.createElement("style"), this.data.defer = !1, this.data.innerHTML = this.xhrLoader.responseText, document.head.appendChild(this.data), this.onProcessComplete();
      }
    });

    FileTypesManager.register("css", function (key, url, xhrSettings) {
      if (Array.isArray(key)) for (var i = 0; i < key.length; i++) {
        this.addFile(new CSSFile(this, key[i]));
      } else this.addFile(new CSSFile(this, key, url, xhrSettings));
      return this;
    }), module.exports = CSSFile;
  }, function (module, exports, __webpack_require__) {
    var Class = __webpack_require__(0),
        CONST = __webpack_require__(21),
        File = __webpack_require__(23),
        FileTypesManager = __webpack_require__(8),
        GetFastValue = __webpack_require__(2),
        IsPlainObject = __webpack_require__(7),
        Shader = __webpack_require__(396),
        GLSLFile = new Class({
      Extends: File,
      initialize: function initialize(loader, key, url, shaderType, fileConfig) {
        var config,
            extension = "glsl";
        IsPlainObject(key) ? (key = GetFastValue(config = key, "key"), url = GetFastValue(config, "url"), shaderType = GetFastValue(config, "shaderType", "fragment"), fileConfig = GetFastValue(config, "xhrSettings"), extension = GetFastValue(config, "extension", extension)) : void 0 === shaderType && (shaderType = "fragment");
        fileConfig = {
          type: "glsl",
          cache: loader.cacheManager.shader,
          extension: extension,
          responseType: "text",
          key: key,
          url: url,
          config: {
            shaderType: shaderType
          },
          xhrSettings: fileConfig
        };
        File.call(this, loader, fileConfig);
      },
      onProcess: function onProcess() {
        this.state = CONST.FILE_PROCESSING, this.data = this.xhrLoader.responseText, this.onProcessComplete();
      },
      addToCache: function addToCache() {
        var data = this.data.split("\n"),
            block = this.extractBlock(data, 0);
        if (block) for (; block;) {
          var shader,
              key = this.getShaderName(block.header),
              shaderType = this.getShaderType(block.header),
              uniforms = this.getShaderUniforms(block.header),
              shaderSrc = block.shader;
          this.cache.has(key) ? (shader = this.cache.get(key), "fragment" === shaderType ? shader.fragmentSrc = shaderSrc : shader.vertexSrc = shaderSrc, shader.uniforms || (shader.uniforms = uniforms)) : "fragment" === shaderType ? this.cache.add(key, new Shader(key, shaderSrc, "", uniforms)) : this.cache.add(key, new Shader(key, "", shaderSrc, uniforms)), block = this.extractBlock(data, block.offset);
        } else "fragment" === this.config.shaderType ? this.cache.add(this.key, new Shader(this.key, this.data)) : this.cache.add(this.key, new Shader(this.key, "", this.data));
        this.pendingDestroy();
      },
      getShaderName: function getShaderName(headerSource) {
        for (var i = 0; i < headerSource.length; i++) {
          var line = headerSource[i].trim();
          if ("name:" === line.substring(0, 5)) return line.substring(5).trim();
        }

        return this.key;
      },
      getShaderType: function getShaderType(headerSource) {
        for (var i = 0; i < headerSource.length; i++) {
          var line = headerSource[i].trim();
          if ("type:" === line.substring(0, 5)) return line.substring(5).trim();
        }

        return this.config.shaderType;
      },
      getShaderUniforms: function getShaderUniforms(headerSource) {
        for (var uniforms = {}, i = 0; i < headerSource.length; i++) {
          var line = headerSource[i].trim();

          if ("uniform." === line.substring(0, 8)) {
            var pos = line.indexOf(":");

            if (pos) {
              var key = line.substring(8, pos);

              try {
                uniforms[key] = JSON.parse(line.substring(pos + 1));
              } catch (e) {
                console.warn("Invalid uniform JSON: " + key);
              }
            }
          }
        }

        return uniforms;
      },
      extractBlock: function extractBlock(data, offset) {
        for (var headerStart = -1, headerEnd = -1, blockEnd = -1, headerOpen = !1, captureSource = !1, headerSource = [], shaderSource = [], i = offset; i < data.length; i++) {
          var line = data[i].trim();
          if ("---" === line) {
            if (-1 === headerStart) headerStart = i, headerOpen = !0;else {
              if (!headerOpen) {
                captureSource = !1;
                break;
              }

              headerEnd = i, captureSource = !(headerOpen = !1);
            }
          } else headerOpen ? headerSource.push(line) : captureSource && (shaderSource.push(line), blockEnd = i);
        }

        return headerOpen || -1 === headerEnd ? null : {
          header: headerSource,
          shader: shaderSource.join("\n"),
          offset: blockEnd
        };
      }
    });

    FileTypesManager.register("glsl", function (key, url, shaderType, xhrSettings) {
      if (Array.isArray(key)) for (var i = 0; i < key.length; i++) {
        this.addFile(new GLSLFile(this, key[i]));
      } else this.addFile(new GLSLFile(this, key, url, shaderType, xhrSettings));
      return this;
    }), module.exports = GLSLFile;
  }, function (module, exports, __webpack_require__) {
    var Class = __webpack_require__(0),
        CONST = __webpack_require__(21),
        File = __webpack_require__(23),
        FileTypesManager = __webpack_require__(8),
        GetFastValue = __webpack_require__(2),
        IsPlainObject = __webpack_require__(7),
        HTMLFile = new Class({
      Extends: File,
      initialize: function initialize(loader, key, url, fileConfig) {
        var config,
            extension = "html";
        IsPlainObject(key) && (key = GetFastValue(config = key, "key"), url = GetFastValue(config, "url"), fileConfig = GetFastValue(config, "xhrSettings"), extension = GetFastValue(config, "extension", extension));
        fileConfig = {
          type: "text",
          cache: loader.cacheManager.html,
          extension: extension,
          responseType: "text",
          key: key,
          url: url,
          xhrSettings: fileConfig
        };
        File.call(this, loader, fileConfig);
      },
      onProcess: function onProcess() {
        this.state = CONST.FILE_PROCESSING, this.data = this.xhrLoader.responseText, this.onProcessComplete();
      }
    });

    FileTypesManager.register("html", function (key, url, xhrSettings) {
      if (Array.isArray(key)) for (var i = 0; i < key.length; i++) {
        this.addFile(new HTMLFile(this, key[i]));
      } else this.addFile(new HTMLFile(this, key, url, xhrSettings));
      return this;
    }), module.exports = HTMLFile;
  }, function (module, exports, __webpack_require__) {
    var Class = __webpack_require__(0),
        CONST = __webpack_require__(21),
        File = __webpack_require__(23),
        FileTypesManager = __webpack_require__(8),
        GetFastValue = __webpack_require__(2),
        IsPlainObject = __webpack_require__(7),
        HTMLTextureFile = new Class({
      Extends: File,
      initialize: function initialize(loader, key, url, width, fileConfig, xhrSettings) {
        void 0 === width && (width = 512), void 0 === fileConfig && (fileConfig = 512);
        var config,
            extension = "html";
        IsPlainObject(key) && (key = GetFastValue(config = key, "key"), url = GetFastValue(config, "url"), xhrSettings = GetFastValue(config, "xhrSettings"), extension = GetFastValue(config, "extension", extension), width = GetFastValue(config, "width", width), fileConfig = GetFastValue(config, "height", fileConfig));
        fileConfig = {
          type: "html",
          cache: loader.textureManager,
          extension: extension,
          responseType: "text",
          key: key,
          url: url,
          xhrSettings: xhrSettings,
          config: {
            width: width,
            height: fileConfig
          }
        };
        File.call(this, loader, fileConfig);
      },
      onProcess: function onProcess() {
        this.state = CONST.FILE_PROCESSING;
        var w = this.config.width,
            h = this.config.height,
            svg = [];
        svg.push('<svg width="' + w + 'px" height="' + h + 'px" viewBox="0 0 ' + w + " " + h + '" xmlns="http://www.w3.org/2000/svg">'), svg.push('<foreignObject width="100%" height="100%">'), svg.push('<body xmlns="http://www.w3.org/1999/xhtml">'), svg.push(this.xhrLoader.responseText), svg.push("</body>"), svg.push("</foreignObject>"), svg.push("</svg>");

        var svg = [svg.join("\n")],
            _this = this;

        try {
          var blob = new window.Blob(svg, {
            type: "image/svg+xml;charset=utf-8"
          });
        } catch (e) {
          return _this.state = CONST.FILE_ERRORED, void _this.onProcessComplete();
        }

        this.data = new Image(), this.data.crossOrigin = this.crossOrigin, this.data.onload = function () {
          File.revokeObjectURL(_this.data), _this.onProcessComplete();
        }, this.data.onerror = function () {
          File.revokeObjectURL(_this.data), _this.onProcessError();
        }, File.createObjectURL(this.data, blob, "image/svg+xml");
      },
      addToCache: function addToCache() {
        var texture = this.cache.addImage(this.key, this.data);
        this.pendingDestroy(texture);
      }
    });

    FileTypesManager.register("htmlTexture", function (key, url, width, height, xhrSettings) {
      if (Array.isArray(key)) for (var i = 0; i < key.length; i++) {
        this.addFile(new HTMLTextureFile(this, key[i]));
      } else this.addFile(new HTMLTextureFile(this, key, url, width, height, xhrSettings));
      return this;
    }), module.exports = HTMLTextureFile;
  }, function (module, exports, __webpack_require__) {
    var Class = __webpack_require__(0),
        FileTypesManager = __webpack_require__(8),
        GetFastValue = __webpack_require__(2),
        ImageFile = __webpack_require__(71),
        IsPlainObject = __webpack_require__(7),
        JSONFile = __webpack_require__(61),
        MultiFile = __webpack_require__(49),
        MultiAtlasFile = new Class({
      Extends: MultiFile,
      initialize: function initialize(loader, key, atlasURL, path, baseURL, data, textureXhrSettings) {
        var config;
        IsPlainObject(key) && (key = GetFastValue(config = key, "key"), atlasURL = GetFastValue(config, "url", !1) ? GetFastValue(config, "url") : GetFastValue(config, "atlasURL"), data = GetFastValue(config, "xhrSettings"), path = GetFastValue(config, "path"), baseURL = GetFastValue(config, "baseURL"), textureXhrSettings = GetFastValue(config, "textureXhrSettings"));
        data = new JSONFile(loader, key, atlasURL, data);
        MultiFile.call(this, loader, "multiatlas", key, [data]), this.config.path = path, this.config.baseURL = baseURL, this.config.textureXhrSettings = textureXhrSettings;
      },
      onFileComplete: function onFileComplete(prefix) {
        var path = this.files.indexOf(prefix);

        if (-1 !== path && (this.pending--, "json" === prefix.type && prefix.data.hasOwnProperty("textures"))) {
          var textures = prefix.data.textures,
              config = this.config,
              loader = this.loader,
              currentBaseURL = loader.baseURL,
              currentPath = loader.path,
              currentPrefix = loader.prefix,
              baseURL = GetFastValue(config, "baseURL", this.baseURL),
              path = GetFastValue(config, "path", this.path),
              prefix = GetFastValue(config, "prefix", this.prefix),
              textureXhrSettings = GetFastValue(config, "textureXhrSettings");
          loader.setBaseURL(baseURL), loader.setPath(path), loader.setPrefix(prefix);

          for (var i = 0; i < textures.length; i++) {
            var image = textures[i].image,
                normalMap = "MA" + this.multiKeyIndex + "_" + image,
                image = new ImageFile(loader, normalMap, image, textureXhrSettings);
            this.addToMultiFile(image), loader.addFile(image), textures[i].normalMap && ((normalMap = new ImageFile(loader, normalMap, textures[i].normalMap, textureXhrSettings)).type = "normalMap", image.setLink(normalMap), this.addToMultiFile(normalMap), loader.addFile(normalMap));
          }

          loader.setBaseURL(currentBaseURL), loader.setPath(currentPath), loader.setPrefix(currentPrefix);
        }
      },
      addToCache: function addToCache() {
        if (this.isReadyToProcess()) {
          for (var fileJSON = this.files[0], data = [], images = [], normalMaps = [], i = 1; i < this.files.length; i++) {
            var file = this.files[i];
            if ("normalMap" !== file.type) for (var pos = file.key.indexOf("_"), key = file.key.substr(pos + 1), image = file.data, t = 0; t < fileJSON.data.textures.length; t++) {
              var item = fileJSON.data.textures[t];

              if (item.image === key) {
                images.push(image), data.push(item), file.linkFile && normalMaps.push(file.linkFile.data);
                break;
              }
            }
          }

          for (0 === normalMaps.length && (normalMaps = void 0), this.loader.textureManager.addAtlasJSONArray(this.key, images, data, normalMaps), this.complete = !0, i = 0; i < this.files.length; i++) {
            this.files[i].pendingDestroy();
          }
        }
      }
    });

    FileTypesManager.register("multiatlas", function (key, atlasURL, path, baseURL, atlasXhrSettings) {
      var multifile;
      if (Array.isArray(key)) for (var i = 0; i < key.length; i++) {
        multifile = new MultiAtlasFile(this, key[i]), this.addFile(multifile.files);
      } else multifile = new MultiAtlasFile(this, key, atlasURL, path, baseURL, atlasXhrSettings), this.addFile(multifile.files);
      return this;
    }), module.exports = MultiAtlasFile;
  }, function (module, exports, __webpack_require__) {
    var Class = __webpack_require__(0),
        FileTypesManager = __webpack_require__(8),
        GetFastValue = __webpack_require__(2),
        IsPlainObject = __webpack_require__(7),
        MultiFile = __webpack_require__(49),
        ScriptFile = __webpack_require__(520),
        MultiScriptFile = new Class({
      Extends: MultiFile,
      initialize: function initialize(loader, key, url, xhrSettings) {
        var config,
            extension = "js",
            files = [];
        IsPlainObject(key) && (key = GetFastValue(config = key, "key"), url = GetFastValue(config, "url"), xhrSettings = GetFastValue(config, "xhrSettings"), extension = GetFastValue(config, "extension", extension)), Array.isArray(url) || (url = [url]);

        for (var i = 0; i < url.length; i++) {
          var scriptFile = new ScriptFile(loader, {
            key: key + "_" + i.toString(),
            url: url[i],
            extension: extension,
            xhrSettings: xhrSettings
          });
          scriptFile.onProcess = function () {
            this.onProcessComplete();
          }, files.push(scriptFile);
        }

        MultiFile.call(this, loader, "scripts", key, files);
      },
      addToCache: function addToCache() {
        if (this.isReadyToProcess()) {
          for (var i = 0; i < this.files.length; i++) {
            var file = this.files[i];
            file.data = document.createElement("script"), file.data.language = "javascript", file.data.type = "text/javascript", file.data.defer = !1, file.data.text = file.xhrLoader.responseText, document.head.appendChild(file.data);
          }

          this.complete = !0;
        }
      }
    });

    FileTypesManager.register("scripts", function (key, url, xhrSettings) {
      var multifile;
      if (Array.isArray(key)) for (var i = 0; i < key.length; i++) {
        multifile = new MultiScriptFile(this, key[i]), this.addFile(multifile.files);
      } else multifile = new MultiScriptFile(this, key, url, xhrSettings), this.addFile(multifile.files);
      return this;
    }), module.exports = MultiScriptFile;
  }, function (module, exports, __webpack_require__) {
    var Class = __webpack_require__(0),
        FileTypesManager = __webpack_require__(8),
        GetFastValue = __webpack_require__(2),
        IsPlainObject = __webpack_require__(7),
        MultiFile = __webpack_require__(49),
        ParseObj = __webpack_require__(498),
        ParseObjMaterial = __webpack_require__(499),
        TextFile = __webpack_require__(242),
        OBJFile = new Class({
      Extends: MultiFile,
      initialize: function initialize(loader, key, objURL, matURL, flipUV, xhrSettings) {
        var obj,
            mat,
            config,
            cache = loader.cacheManager.obj;
        IsPlainObject(key) ? (key = GetFastValue(config = key, "key"), obj = new TextFile(loader, {
          key: key,
          type: "obj",
          cache: cache,
          url: GetFastValue(config, "url"),
          extension: GetFastValue(config, "extension", "obj"),
          xhrSettings: GetFastValue(config, "xhrSettings"),
          config: {
            flipUV: GetFastValue(config, "flipUV", flipUV)
          }
        }), (matURL = GetFastValue(config, "matURL")) && (mat = new TextFile(loader, {
          key: key,
          type: "mat",
          cache: cache,
          url: matURL,
          extension: GetFastValue(config, "matExtension", "mat"),
          xhrSettings: GetFastValue(config, "xhrSettings")
        }))) : (obj = new TextFile(loader, {
          key: key,
          url: objURL,
          type: "obj",
          cache: cache,
          extension: "obj",
          xhrSettings: xhrSettings,
          config: {
            flipUV: flipUV
          }
        }), matURL && (mat = new TextFile(loader, {
          key: key,
          url: matURL,
          type: "mat",
          cache: cache,
          extension: "mat",
          xhrSettings: xhrSettings
        }))), MultiFile.call(this, loader, "obj", key, [obj, mat]);
      },
      addToCache: function addToCache() {
        var obj, mat, objData;
        this.isReadyToProcess() && (obj = this.files[0], mat = this.files[1], objData = ParseObj(obj.data, obj.config.flipUV), mat && (objData.materials = ParseObjMaterial(mat.data)), obj.cache.add(obj.key, objData), this.complete = !0);
      }
    });

    FileTypesManager.register("obj", function (key, objURL, matURL, flipUVs, xhrSettings) {
      var multifile;
      if (Array.isArray(key)) for (var i = 0; i < key.length; i++) {
        multifile = new OBJFile(this, key[i]), this.addFile(multifile.files);
      } else multifile = new OBJFile(this, key, objURL, matURL, flipUVs, xhrSettings), this.addFile(multifile.files);
      return this;
    }), module.exports = OBJFile;
  }, function (module, exports, __webpack_require__) {
    var Class = __webpack_require__(0),
        CONST = __webpack_require__(21),
        FileTypesManager = __webpack_require__(8),
        JSONFile = __webpack_require__(61),
        PackFile = new Class({
      Extends: JSONFile,
      initialize: function initialize(loader, key, url, xhrSettings, dataKey) {
        JSONFile.call(this, loader, key, url, xhrSettings, dataKey), this.type = "packfile";
      },
      onProcess: function onProcess() {
        this.state !== CONST.FILE_POPULATED && (this.state = CONST.FILE_PROCESSING, this.data = JSON.parse(this.xhrLoader.responseText)), this.loader.addPack(this.data, this.config), this.onProcessComplete();
      }
    });

    FileTypesManager.register("pack", function (key, url, packKey, xhrSettings) {
      if (Array.isArray(key)) for (var i = 0; i < key.length; i++) {
        this.addFile(new PackFile(this, key[i]));
      } else this.addFile(new PackFile(this, key, url, xhrSettings, packKey));
      return this;
    }), module.exports = PackFile;
  }, function (module, exports, __webpack_require__) {
    var Class = __webpack_require__(0),
        CONST = __webpack_require__(21),
        File = __webpack_require__(23),
        FileTypesManager = __webpack_require__(8),
        GetFastValue = __webpack_require__(2),
        IsPlainObject = __webpack_require__(7),
        PluginFile = new Class({
      Extends: File,
      initialize: function initialize(loader, key, url, start, mapping, xhrSettings) {
        var config,
            extension = "js";
        IsPlainObject(key) && (key = GetFastValue(config = key, "key"), url = GetFastValue(config, "url"), xhrSettings = GetFastValue(config, "xhrSettings"), extension = GetFastValue(config, "extension", extension), start = GetFastValue(config, "start"), mapping = GetFastValue(config, "mapping")), File.call(this, loader, {
          type: "plugin",
          cache: !1,
          extension: extension,
          responseType: "text",
          key: key,
          url: url,
          xhrSettings: xhrSettings,
          config: {
            start: start,
            mapping: mapping
          }
        }), "function" == typeof url && (this.data = url, this.state = CONST.FILE_POPULATED);
      },
      onProcess: function onProcess() {
        var plugin = this.loader.systems.plugins,
            mapping = this.config,
            start = GetFastValue(mapping, "start", !1),
            mapping = GetFastValue(mapping, "mapping", null);
        this.state === CONST.FILE_POPULATED ? plugin.install(this.key, this.data, start, mapping) : (this.state = CONST.FILE_PROCESSING, this.data = document.createElement("script"), this.data.language = "javascript", this.data.type = "text/javascript", this.data.defer = !1, this.data.text = this.xhrLoader.responseText, document.head.appendChild(this.data), plugin = plugin.install(this.key, window[this.key], start, mapping), (start || mapping) && (this.loader.systems[mapping] = plugin, this.loader.scene[mapping] = plugin)), this.onProcessComplete();
      }
    });

    FileTypesManager.register("plugin", function (key, url, start, mapping, xhrSettings) {
      if (Array.isArray(key)) for (var i = 0; i < key.length; i++) {
        this.addFile(new PluginFile(this, key[i]));
      } else this.addFile(new PluginFile(this, key, url, start, mapping, xhrSettings));
      return this;
    }), module.exports = PluginFile;
  }, function (module, exports, __webpack_require__) {
    var Class = __webpack_require__(0),
        CONST = __webpack_require__(21),
        File = __webpack_require__(23),
        FileTypesManager = __webpack_require__(8),
        GetFastValue = __webpack_require__(2),
        IsPlainObject = __webpack_require__(7),
        SceneFile = new Class({
      Extends: File,
      initialize: function initialize(loader, key, url, xhrSettings) {
        var config,
            extension = "js";
        IsPlainObject(key) && (key = GetFastValue(config = key, "key"), url = GetFastValue(config, "url"), xhrSettings = GetFastValue(config, "xhrSettings"), extension = GetFastValue(config, "extension", extension)), File.call(this, loader, {
          type: "text",
          extension: extension,
          responseType: "text",
          key: key,
          url: url,
          xhrSettings: xhrSettings
        });
      },
      onProcess: function onProcess() {
        this.state = CONST.FILE_PROCESSING, this.data = this.xhrLoader.responseText, this.onProcessComplete();
      },
      addToCache: function addToCache() {
        var code = this.data.concat("(function(){\nreturn new " + this.key + "();\n}).call(this);"),
            eval2 = eval;
        this.loader.sceneManager.add(this.key, eval2(code)), this.complete = !0;
      }
    });

    FileTypesManager.register("sceneFile", function (key, url, xhrSettings) {
      if (Array.isArray(key)) for (var i = 0; i < key.length; i++) {
        this.addFile(new SceneFile(this, key[i]));
      } else this.addFile(new SceneFile(this, key, url, xhrSettings));
      return this;
    }), module.exports = SceneFile;
  }, function (module, exports, __webpack_require__) {
    var Class = __webpack_require__(0),
        CONST = __webpack_require__(21),
        File = __webpack_require__(23),
        FileTypesManager = __webpack_require__(8),
        GetFastValue = __webpack_require__(2),
        IsPlainObject = __webpack_require__(7),
        ScenePluginFile = new Class({
      Extends: File,
      initialize: function initialize(loader, key, url, systemKey, sceneKey, xhrSettings) {
        var config,
            extension = "js";
        IsPlainObject(key) && (key = GetFastValue(config = key, "key"), url = GetFastValue(config, "url"), xhrSettings = GetFastValue(config, "xhrSettings"), extension = GetFastValue(config, "extension", extension), systemKey = GetFastValue(config, "systemKey"), sceneKey = GetFastValue(config, "sceneKey")), File.call(this, loader, {
          type: "scenePlugin",
          cache: !1,
          extension: extension,
          responseType: "text",
          key: key,
          url: url,
          xhrSettings: xhrSettings,
          config: {
            systemKey: systemKey,
            sceneKey: sceneKey
          }
        }), "function" == typeof url && (this.data = url, this.state = CONST.FILE_POPULATED);
      },
      onProcess: function onProcess() {
        var pluginManager = this.loader.systems.plugins,
            config = this.config,
            sceneKey = this.key,
            systemKey = GetFastValue(config, "systemKey", sceneKey),
            sceneKey = GetFastValue(config, "sceneKey", sceneKey);
        this.state === CONST.FILE_POPULATED ? pluginManager.installScenePlugin(systemKey, this.data, sceneKey, this.loader.scene, !0) : (this.state = CONST.FILE_PROCESSING, this.data = document.createElement("script"), this.data.language = "javascript", this.data.type = "text/javascript", this.data.defer = !1, this.data.text = this.xhrLoader.responseText, document.head.appendChild(this.data), pluginManager.installScenePlugin(systemKey, window[this.key], sceneKey, this.loader.scene, !0)), this.onProcessComplete();
      }
    });

    FileTypesManager.register("scenePlugin", function (key, url, systemKey, sceneKey, xhrSettings) {
      if (Array.isArray(key)) for (var i = 0; i < key.length; i++) {
        this.addFile(new ScenePluginFile(this, key[i]));
      } else this.addFile(new ScenePluginFile(this, key, url, systemKey, sceneKey, xhrSettings));
      return this;
    }), module.exports = ScenePluginFile;
  }, function (module, exports, __webpack_require__) {
    var Class = __webpack_require__(0),
        FileTypesManager = __webpack_require__(8),
        ImageFile = __webpack_require__(71),
        SpriteSheetFile = new Class({
      Extends: ImageFile,
      initialize: function initialize(loader, key, url, frameConfig, xhrSettings) {
        ImageFile.call(this, loader, key, url, xhrSettings, frameConfig), this.type = "spritesheet";
      },
      addToCache: function addToCache() {
        var texture = this.cache.addSpriteSheet(this.key, this.data, this.config);
        this.pendingDestroy(texture);
      }
    });

    FileTypesManager.register("spritesheet", function (key, url, frameConfig, xhrSettings) {
      if (Array.isArray(key)) for (var i = 0; i < key.length; i++) {
        this.addFile(new SpriteSheetFile(this, key[i]));
      } else this.addFile(new SpriteSheetFile(this, key, url, frameConfig, xhrSettings));
      return this;
    }), module.exports = SpriteSheetFile;
  }, function (module, exports, __webpack_require__) {
    var Class = __webpack_require__(0),
        CONST = __webpack_require__(21),
        File = __webpack_require__(23),
        FileTypesManager = __webpack_require__(8),
        GetFastValue = __webpack_require__(2),
        IsPlainObject = __webpack_require__(7),
        SVGFile = new Class({
      Extends: File,
      initialize: function initialize(loader, key, url, fileConfig, xhrSettings) {
        var config,
            extension = "svg";
        IsPlainObject(key) && (key = GetFastValue(config = key, "key"), url = GetFastValue(config, "url"), fileConfig = GetFastValue(config, "svgConfig", {}), xhrSettings = GetFastValue(config, "xhrSettings"), extension = GetFastValue(config, "extension", extension));
        fileConfig = {
          type: "svg",
          cache: loader.textureManager,
          extension: extension,
          responseType: "text",
          key: key,
          url: url,
          xhrSettings: xhrSettings,
          config: {
            width: GetFastValue(fileConfig, "width"),
            height: GetFastValue(fileConfig, "height"),
            scale: GetFastValue(fileConfig, "scale")
          }
        };
        File.call(this, loader, fileConfig);
      },
      onProcess: function onProcess() {
        this.state = CONST.FILE_PROCESSING;
        var text = this.xhrLoader.responseText,
            svg = [text],
            width = this.config.width,
            height = this.config.height,
            scale = this.config.scale;

        resize: if (width && height || scale) {
          var svgXML = new DOMParser().parseFromString(text, "text/xml").getElementsByTagName("svg")[0],
              viewBox = svgXML.hasAttribute("viewBox"),
              svgWidth = parseFloat(svgXML.getAttribute("width")),
              svgHeight = parseFloat(svgXML.getAttribute("height"));

          if (!viewBox && svgWidth && svgHeight ? svgXML.setAttribute("viewBox", "0  0 " + svgWidth + " " + svgHeight) : !viewBox || svgWidth || svgHeight || (svgWidth = (viewBox = svgXML.getAttribute("viewBox").split(/\s+|,/))[2], svgHeight = viewBox[3]), scale) {
            if (!svgWidth || !svgHeight) break resize;
            width = svgWidth * scale, height = svgHeight * scale;
          }

          svgXML.setAttribute("width", width.toString() + "px"), svgXML.setAttribute("height", height.toString() + "px"), svg = [new XMLSerializer().serializeToString(svgXML)];
        }

        try {
          var blob = new window.Blob(svg, {
            type: "image/svg+xml;charset=utf-8"
          });
        } catch (e) {
          return void this.onProcessError();
        }

        this.data = new Image(), this.data.crossOrigin = this.crossOrigin;

        var _this = this,
            retry = !1;

        this.data.onload = function () {
          retry || File.revokeObjectURL(_this.data), _this.onProcessComplete();
        }, this.data.onerror = function () {
          retry ? _this.onProcessError() : (retry = !0, File.revokeObjectURL(_this.data), _this.data.src = "data:image/svg+xml," + encodeURIComponent(svg.join("")));
        }, File.createObjectURL(this.data, blob, "image/svg+xml");
      },
      addToCache: function addToCache() {
        var texture = this.cache.addImage(this.key, this.data);
        this.pendingDestroy(texture);
      }
    });

    FileTypesManager.register("svg", function (key, url, svgConfig, xhrSettings) {
      if (Array.isArray(key)) for (var i = 0; i < key.length; i++) {
        this.addFile(new SVGFile(this, key[i]));
      } else this.addFile(new SVGFile(this, key, url, svgConfig, xhrSettings));
      return this;
    }), module.exports = SVGFile;
  }, function (module, exports, __webpack_require__) {
    var Class = __webpack_require__(0),
        CONST = __webpack_require__(21),
        File = __webpack_require__(23),
        FileTypesManager = __webpack_require__(8),
        GetFastValue = __webpack_require__(2),
        IsPlainObject = __webpack_require__(7),
        TILEMAP_FORMATS = __webpack_require__(40),
        TilemapCSVFile = new Class({
      Extends: File,
      initialize: function initialize(loader, key, url, fileConfig) {
        var config,
            extension = "csv";
        IsPlainObject(key) && (key = GetFastValue(config = key, "key"), url = GetFastValue(config, "url"), fileConfig = GetFastValue(config, "xhrSettings"), extension = GetFastValue(config, "extension", extension));
        fileConfig = {
          type: "tilemapCSV",
          cache: loader.cacheManager.tilemap,
          extension: extension,
          responseType: "text",
          key: key,
          url: url,
          xhrSettings: fileConfig
        };
        File.call(this, loader, fileConfig), this.tilemapFormat = TILEMAP_FORMATS.CSV;
      },
      onProcess: function onProcess() {
        this.state = CONST.FILE_PROCESSING, this.data = this.xhrLoader.responseText, this.onProcessComplete();
      },
      addToCache: function addToCache() {
        var tiledata = {
          format: this.tilemapFormat,
          data: this.data
        };
        this.cache.add(this.key, tiledata), this.pendingDestroy(tiledata);
      }
    });

    FileTypesManager.register("tilemapCSV", function (key, url, xhrSettings) {
      if (Array.isArray(key)) for (var i = 0; i < key.length; i++) {
        this.addFile(new TilemapCSVFile(this, key[i]));
      } else this.addFile(new TilemapCSVFile(this, key, url, xhrSettings));
      return this;
    }), module.exports = TilemapCSVFile;
  }, function (module, exports, __webpack_require__) {
    var Class = __webpack_require__(0),
        FileTypesManager = __webpack_require__(8),
        JSONFile = __webpack_require__(61),
        TILEMAP_FORMATS = __webpack_require__(40),
        TilemapImpactFile = new Class({
      Extends: JSONFile,
      initialize: function initialize(loader, key, url, xhrSettings) {
        JSONFile.call(this, loader, key, url, xhrSettings), this.type = "tilemapJSON", this.cache = loader.cacheManager.tilemap;
      },
      addToCache: function addToCache() {
        var tiledata = {
          format: TILEMAP_FORMATS.WELTMEISTER,
          data: this.data
        };
        this.cache.add(this.key, tiledata), this.pendingDestroy(tiledata);
      }
    });

    FileTypesManager.register("tilemapImpact", function (key, url, xhrSettings) {
      if (Array.isArray(key)) for (var i = 0; i < key.length; i++) {
        this.addFile(new TilemapImpactFile(this, key[i]));
      } else this.addFile(new TilemapImpactFile(this, key, url, xhrSettings));
      return this;
    }), module.exports = TilemapImpactFile;
  }, function (module, exports, __webpack_require__) {
    var Class = __webpack_require__(0),
        FileTypesManager = __webpack_require__(8),
        JSONFile = __webpack_require__(61),
        TILEMAP_FORMATS = __webpack_require__(40),
        TilemapJSONFile = new Class({
      Extends: JSONFile,
      initialize: function initialize(loader, key, url, xhrSettings) {
        JSONFile.call(this, loader, key, url, xhrSettings), this.type = "tilemapJSON", this.cache = loader.cacheManager.tilemap;
      },
      addToCache: function addToCache() {
        var tiledata = {
          format: TILEMAP_FORMATS.TILED_JSON,
          data: this.data
        };
        this.cache.add(this.key, tiledata), this.pendingDestroy(tiledata);
      }
    });

    FileTypesManager.register("tilemapTiledJSON", function (key, url, xhrSettings) {
      if (Array.isArray(key)) for (var i = 0; i < key.length; i++) {
        this.addFile(new TilemapJSONFile(this, key[i]));
      } else this.addFile(new TilemapJSONFile(this, key, url, xhrSettings));
      return this;
    }), module.exports = TilemapJSONFile;
  }, function (module, exports, __webpack_require__) {
    var Class = __webpack_require__(0),
        FileTypesManager = __webpack_require__(8),
        GetFastValue = __webpack_require__(2),
        ImageFile = __webpack_require__(71),
        IsPlainObject = __webpack_require__(7),
        MultiFile = __webpack_require__(49),
        TextFile = __webpack_require__(242),
        UnityAtlasFile = new Class({
      Extends: MultiFile,
      initialize: function initialize(loader, key, textureURL, atlasURL, textureXhrSettings, data) {
        var image,
            config,
            data = IsPlainObject(key) ? (key = GetFastValue(config = key, "key"), image = new ImageFile(loader, {
          key: key,
          url: GetFastValue(config, "textureURL"),
          extension: GetFastValue(config, "textureExtension", "png"),
          normalMap: GetFastValue(config, "normalMap"),
          xhrSettings: GetFastValue(config, "textureXhrSettings")
        }), new TextFile(loader, {
          key: key,
          url: GetFastValue(config, "atlasURL"),
          extension: GetFastValue(config, "atlasExtension", "txt"),
          xhrSettings: GetFastValue(config, "atlasXhrSettings")
        })) : (image = new ImageFile(loader, key, textureURL, textureXhrSettings), new TextFile(loader, key, atlasURL, data));
        image.linkFile ? MultiFile.call(this, loader, "unityatlas", key, [image, data, image.linkFile]) : MultiFile.call(this, loader, "unityatlas", key, [image, data]);
      },
      addToCache: function addToCache() {
        var image, text, normalMap;
        this.isReadyToProcess() && (image = this.files[0], text = this.files[1], normalMap = this.files[2] ? this.files[2].data : null, this.loader.textureManager.addUnityAtlas(image.key, image.data, text.data, normalMap), text.pendingDestroy(), this.complete = !0);
      }
    });

    FileTypesManager.register("unityAtlas", function (key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings) {
      var multifile;
      if (Array.isArray(key)) for (var i = 0; i < key.length; i++) {
        multifile = new UnityAtlasFile(this, key[i]), this.addFile(multifile.files);
      } else multifile = new UnityAtlasFile(this, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings), this.addFile(multifile.files);
      return this;
    }), module.exports = UnityAtlasFile;
  }, function (module, exports, __webpack_require__) {
    var Class = __webpack_require__(0),
        CONST = __webpack_require__(21),
        File = __webpack_require__(23),
        FileTypesManager = __webpack_require__(8),
        GetURL = __webpack_require__(155),
        GetFastValue = __webpack_require__(2),
        IsPlainObject = __webpack_require__(7),
        VideoFile = new Class({
      Extends: File,
      initialize: function initialize(loader, key, urlConfig, loadEvent, asBlob, fileConfig, xhrSettings) {
        fileConfig = {
          type: "video",
          cache: loader.cacheManager.video,
          extension: urlConfig.type,
          responseType: "blob",
          key: key,
          url: urlConfig.url,
          xhrSettings: xhrSettings,
          config: {
            loadEvent: loadEvent = "loadeddata" !== (loadEvent = void 0 === loadEvent ? "loadeddata" : loadEvent) && "canplay" !== loadEvent && "canplaythrough" !== loadEvent ? "loadeddata" : loadEvent,
            asBlob: asBlob = void 0 === asBlob ? !1 : asBlob,
            noAudio: fileConfig = void 0 === fileConfig ? !1 : fileConfig
          }
        };
        this.onLoadCallback = this.onVideoLoadHandler.bind(this), this.onErrorCallback = this.onVideoErrorHandler.bind(this), File.call(this, loader, fileConfig);
      },
      onProcess: function onProcess() {
        var video, _this;

        this.state = CONST.FILE_PROCESSING, this.config.asBlob ? (video = this.createVideoElement(), this.data = video, (_this = this).data.onloadeddata = function () {
          _this.onProcessComplete();
        }, this.data.onerror = function () {
          File.revokeObjectURL(_this.data), _this.onProcessError();
        }, File.createObjectURL(video, this.xhrLoader.response, ""), video.load()) : this.onProcessComplete();
      },
      createVideoElement: function createVideoElement() {
        var video = document.createElement("video");
        return video.controls = !1, video.crossOrigin = this.loader.crossOrigin, this.config.noAudio && (video.muted = !0, video.defaultMuted = !0, video.setAttribute("autoplay", "autoplay")), video.setAttribute("playsinline", "playsinline"), video.setAttribute("preload", "auto"), video;
      },
      onVideoLoadHandler: function onVideoLoadHandler(video) {
        video = video.target;
        video.removeEventListener(this.config.loadEvent, this.onLoadCallback, !0), video.removeEventListener("error", this.onErrorCallback, !0), this.data = video, this.resetXHR(), this.loader.nextFile(this, !0);
      },
      onVideoErrorHandler: function onVideoErrorHandler(video) {
        video = video.target;
        video && (video.removeEventListener(this.config.loadEvent, this.onLoadCallback, !0), video.removeEventListener("error", this.onErrorCallback, !0)), this.resetXHR(), this.loader.nextFile(this, !1);
      },
      load: function load() {
        var video,
            loadEvent = this.config.loadEvent;
        this.config.asBlob ? File.prototype.load.call(this) : (this.percentComplete = 0, (video = this.createVideoElement()).addEventListener(loadEvent, this.onLoadCallback, !0), video.addEventListener("error", this.onErrorCallback, !0), video.src = GetURL(this, this.loader.baseURL), video.load());
      }
    });

    VideoFile.create = function (loader, key, urlConfig, loadEvent, asBlob, noAudio, xhrSettings) {
      var game = loader.systems.game;
      IsPlainObject(key) && (urlConfig = GetFastValue(key, "url", []), loadEvent = GetFastValue(key, "loadEvent", "loadeddata"), asBlob = GetFastValue(key, "asBlob", !1), noAudio = GetFastValue(key, "noAudio", !1), xhrSettings = GetFastValue(key, "xhrSettings"), key = GetFastValue(key, "key"));
      urlConfig = VideoFile.getVideoURL(game, urlConfig);
      if (urlConfig) return new VideoFile(loader, key, urlConfig, loadEvent, asBlob, noAudio, xhrSettings);
    }, VideoFile.getVideoURL = function (game, urls) {
      Array.isArray(urls) || (urls = [urls]);

      for (var i = 0; i < urls.length; i++) {
        var videoType,
            url = GetFastValue(urls[i], "url", urls[i]);
        if (0 === url.indexOf("blob:")) return {
          url: url,
          type: ""
        };
        if (videoType = 0 === url.indexOf("data:") ? url.split(",")[0].match(/\/(.*?);/) : url.match(/\.([a-zA-Z0-9]+)($|\?)/), videoType = GetFastValue(urls[i], "type", videoType ? videoType[1] : "").toLowerCase(), game.device.video[videoType]) return {
          url: url,
          type: videoType
        };
      }

      return null;
    }, FileTypesManager.register("video", function (key, urls, loadEvent, asBlob, noAudio, xhrSettings) {
      var videoFile;
      if (Array.isArray(key)) for (var i = 0; i < key.length; i++) {
        (videoFile = VideoFile.create(this, key[i])) && this.addFile(videoFile);
      } else (videoFile = VideoFile.create(this, key, urls, loadEvent, asBlob, noAudio, xhrSettings)) && this.addFile(videoFile);
      return this;
    }), module.exports = VideoFile;
  }, function (module, exports, __webpack_require__) {
    var LoaderPlugin = __webpack_require__(0),
        CONST = __webpack_require__(21),
        CustomSet = __webpack_require__(149),
        EventEmitter = __webpack_require__(9),
        Events = __webpack_require__(95),
        FileTypesManager = __webpack_require__(8),
        GetFastValue = __webpack_require__(2),
        PluginCache = __webpack_require__(24),
        SceneEvents = __webpack_require__(20),
        XHRSettings = __webpack_require__(156),
        LoaderPlugin = new LoaderPlugin({
      Extends: EventEmitter,
      initialize: function initialize(scene) {
        EventEmitter.call(this);
        var gameConfig = scene.sys.game.config,
            sceneConfig = scene.sys.settings.loader;
        this.scene = scene, this.systems = scene.sys, this.cacheManager = scene.sys.cache, this.textureManager = scene.sys.textures, this.sceneManager = scene.sys.game.scene, FileTypesManager.install(this), this.prefix = "", this.path = "", this.baseURL = "", this.setBaseURL(GetFastValue(sceneConfig, "baseURL", gameConfig.loaderBaseURL)), this.setPath(GetFastValue(sceneConfig, "path", gameConfig.loaderPath)), this.setPrefix(GetFastValue(sceneConfig, "prefix", gameConfig.loaderPrefix)), this.maxParallelDownloads = GetFastValue(sceneConfig, "maxParallelDownloads", gameConfig.loaderMaxParallelDownloads), this.xhr = XHRSettings(GetFastValue(sceneConfig, "responseType", gameConfig.loaderResponseType), GetFastValue(sceneConfig, "async", gameConfig.loaderAsync), GetFastValue(sceneConfig, "user", gameConfig.loaderUser), GetFastValue(sceneConfig, "password", gameConfig.loaderPassword), GetFastValue(sceneConfig, "timeout", gameConfig.loaderTimeout), GetFastValue(sceneConfig, "withCredentials", gameConfig.loaderWithCredentials)), this.crossOrigin = GetFastValue(sceneConfig, "crossOrigin", gameConfig.loaderCrossOrigin), this.totalToLoad = 0, this.progress = 0, this.list = new CustomSet(), this.inflight = new CustomSet(), this.queue = new CustomSet(), this._deleteQueue = new CustomSet(), this.totalFailed = 0, this.totalComplete = 0, this.state = CONST.LOADER_IDLE, this.multiKeyIndex = 0, scene.sys.events.once(SceneEvents.BOOT, this.boot, this), scene.sys.events.on(SceneEvents.START, this.pluginStart, this);
      },
      boot: function boot() {
        this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);
      },
      pluginStart: function pluginStart() {
        this.systems.events.once(SceneEvents.SHUTDOWN, this.shutdown, this);
      },
      setBaseURL: function setBaseURL(url) {
        return "" !== (url = void 0 === url ? "" : url) && "/" !== url.substr(-1) && (url = url.concat("/")), this.baseURL = url, this;
      },
      setPath: function setPath(path) {
        return "" !== (path = void 0 === path ? "" : path) && "/" !== path.substr(-1) && (path = path.concat("/")), this.path = path, this;
      },
      setPrefix: function setPrefix(prefix) {
        return this.prefix = prefix = void 0 === prefix ? "" : prefix, this;
      },
      setCORS: function setCORS(crossOrigin) {
        return this.crossOrigin = crossOrigin, this;
      },
      addFile: function addFile(file) {
        Array.isArray(file) || (file = [file]);

        for (var i = 0; i < file.length; i++) {
          var item = file[i];
          this.keyExists(item) || (this.list.set(item), this.emit(Events.ADD, item.key, item.type, this, item), this.isLoading() && (this.totalToLoad++, this.updateProgress()));
        }
      },
      keyExists: function keyExists(file) {
        var keyConflict = file.hasCacheConflict();
        return keyConflict || this.list.iterate(function (item) {
          if (item.type === file.type && item.key === file.key) return !(keyConflict = !0);
        }), !keyConflict && this.isLoading() && (this.inflight.iterate(function (item) {
          if (item.type === file.type && item.key === file.key) return !(keyConflict = !0);
        }), this.queue.iterate(function (item) {
          if (item.type === file.type && item.key === file.key) return !(keyConflict = !0);
        })), keyConflict;
      },
      addPack: function addPack(pack, packKey) {
        packKey && pack.hasOwnProperty(packKey) && (pack = {
          packKey: pack[packKey]
        });
        var key,
            total = 0,
            currentBaseURL = this.baseURL,
            currentPath = this.path,
            currentPrefix = this.prefix;

        for (key in pack) {
          if (Object.prototype.hasOwnProperty.call(pack, key)) {
            var config = pack[key],
                baseURL = GetFastValue(config, "baseURL", currentBaseURL),
                path = GetFastValue(config, "path", currentPath),
                prefix = GetFastValue(config, "prefix", currentPrefix),
                files = GetFastValue(config, "files", null),
                defaultType = GetFastValue(config, "defaultType", "void");

            if (Array.isArray(files)) {
              this.setBaseURL(baseURL), this.setPath(path), this.setPrefix(prefix);

              for (var i = 0; i < files.length; i++) {
                var file = files[i],
                    type = file.hasOwnProperty("type") ? file.type : defaultType;
                this[type] && (this[type](file), total++);
              }
            }
          }
        }

        return this.setBaseURL(currentBaseURL), this.setPath(currentPath), this.setPrefix(currentPrefix), 0 < total;
      },
      isLoading: function isLoading() {
        return this.state === CONST.LOADER_LOADING || this.state === CONST.LOADER_PROCESSING;
      },
      isReady: function isReady() {
        return this.state === CONST.LOADER_IDLE || this.state === CONST.LOADER_COMPLETE;
      },
      start: function start() {
        this.isReady() && (this.progress = 0, this.totalFailed = 0, this.totalComplete = 0, this.totalToLoad = this.list.size, this.emit(Events.START, this), 0 === this.list.size ? this.loadComplete() : (this.state = CONST.LOADER_LOADING, this.inflight.clear(), this.queue.clear(), this.updateProgress(), this.checkLoadQueue(), this.systems.events.on(SceneEvents.UPDATE, this.update, this)));
      },
      updateProgress: function updateProgress() {
        this.progress = 1 - (this.list.size + this.inflight.size) / this.totalToLoad, this.emit(Events.PROGRESS, this.progress);
      },
      update: function update() {
        this.state === CONST.LOADER_LOADING && 0 < this.list.size && this.inflight.size < this.maxParallelDownloads && this.checkLoadQueue();
      },
      checkLoadQueue: function checkLoadQueue() {
        this.list.each(function (file) {
          if ((file.state === CONST.FILE_POPULATED || file.state === CONST.FILE_PENDING && this.inflight.size < this.maxParallelDownloads) && (this.inflight.set(file), this.list.delete(file), file.crossOrigin || (file.crossOrigin = this.crossOrigin), file.load()), this.inflight.size === this.maxParallelDownloads) return !1;
        }, this);
      },
      nextFile: function nextFile(file, success) {
        this.inflight && (this.inflight.delete(file), this.updateProgress(), success ? (this.totalComplete++, this.queue.set(file), this.emit(Events.FILE_LOAD, file), file.onProcess()) : (this.totalFailed++, this._deleteQueue.set(file), this.emit(Events.FILE_LOAD_ERROR, file), this.fileProcessComplete(file)));
      },
      fileProcessComplete: function fileProcessComplete(file) {
        this.scene && this.systems && this.systems.game && !this.systems.game.pendingDestroy && (file.state === CONST.FILE_ERRORED ? file.multiFile && file.multiFile.onFileFailed(file) : file.state === CONST.FILE_COMPLETE && (file.multiFile ? file.multiFile.isReadyToProcess() && file.multiFile.addToCache() : file.addToCache()), this.queue.delete(file), 0 === this.list.size && 0 === this.inflight.size && 0 === this.queue.size && this.loadComplete());
      },
      loadComplete: function loadComplete() {
        this.emit(Events.POST_PROCESS, this), this.list.clear(), this.inflight.clear(), this.queue.clear(), this.progress = 1, this.state = CONST.LOADER_COMPLETE, this.systems.events.off(SceneEvents.UPDATE, this.update, this), this._deleteQueue.iterateLocal("destroy"), this._deleteQueue.clear(), this.emit(Events.COMPLETE, this, this.totalComplete, this.totalFailed);
      },
      flagForRemoval: function flagForRemoval(file) {
        this._deleteQueue.set(file);
      },
      saveJSON: function saveJSON(data, filename) {
        return this.save(JSON.stringify(data), filename);
      },
      save: function save(a, filename, url) {
        void 0 === filename && (filename = "file.json"), void 0 === url && (url = "application/json");
        a = new Blob([a], {
          type: url
        }), url = URL.createObjectURL(a), a = document.createElement("a");
        return a.download = filename, a.textContent = "Download " + filename, a.href = url, a.click(), this;
      },
      reset: function reset() {
        this.list.clear(), this.inflight.clear(), this.queue.clear();
        var gameConfig = this.systems.game.config,
            sceneConfig = this.systems.settings.loader;
        this.setBaseURL(GetFastValue(sceneConfig, "baseURL", gameConfig.loaderBaseURL)), this.setPath(GetFastValue(sceneConfig, "path", gameConfig.loaderPath)), this.setPrefix(GetFastValue(sceneConfig, "prefix", gameConfig.loaderPrefix)), this.state = CONST.LOADER_IDLE;
      },
      shutdown: function shutdown() {
        this.reset(), this.state = CONST.LOADER_SHUTDOWN, this.systems.events.off(SceneEvents.UPDATE, this.update, this), this.systems.events.off(SceneEvents.SHUTDOWN, this.shutdown, this);
      },
      destroy: function destroy() {
        this.shutdown(), this.state = CONST.LOADER_DESTROYED, this.systems.events.off(SceneEvents.UPDATE, this.update, this), this.systems.events.off(SceneEvents.START, this.pluginStart, this), this.list = null, this.inflight = null, this.queue = null, this.scene = null, this.systems = null, this.textureManager = null, this.cacheManager = null, this.sceneManager = null;
      }
    });

    PluginCache.register("Loader", LoaderPlugin, "load"), module.exports = LoaderPlugin;
  }, function (module, exports, Arcade) {
    var CONST = Arcade(62),
        Arcade = Arcade(17)(!1, Arcade = {
      ArcadePhysics: Arcade(1367),
      Body: Arcade(527),
      Collider: Arcade(528),
      Components: Arcade(243),
      Events: Arcade(245),
      Factory: Arcade(521),
      GetOverlapX: Arcade(246),
      GetOverlapY: Arcade(247),
      SeparateX: Arcade(537),
      SeparateY: Arcade(538),
      Group: Arcade(524),
      Image: Arcade(522),
      Sprite: Arcade(157),
      StaticBody: Arcade(539),
      StaticGroup: Arcade(525),
      Tilemap: Arcade(1391),
      World: Arcade(526)
    }, CONST);
    module.exports = Arcade;
  }, function (module, exports, __webpack_require__) {
    var ArcadePhysics = __webpack_require__(0),
        DegToRad = __webpack_require__(36),
        DistanceBetween = __webpack_require__(50),
        DistanceSquared = __webpack_require__(353),
        Factory = __webpack_require__(521),
        GetFastValue = __webpack_require__(2),
        Merge = __webpack_require__(127),
        OverlapCirc = __webpack_require__(523),
        OverlapRect = __webpack_require__(244),
        PluginCache = __webpack_require__(24),
        SceneEvents = __webpack_require__(20),
        Vector2 = __webpack_require__(3),
        World = __webpack_require__(526),
        ArcadePhysics = new ArcadePhysics({
      initialize: function initialize(scene) {
        this.scene = scene, this.systems = scene.sys, this.config = this.getConfig(), this.world, this.add, scene.sys.events.once(SceneEvents.BOOT, this.boot, this), scene.sys.events.on(SceneEvents.START, this.start, this);
      },
      boot: function boot() {
        this.world = new World(this.scene, this.config), this.add = new Factory(this.world), this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);
      },
      start: function start() {
        this.world || (this.world = new World(this.scene, this.config), this.add = new Factory(this.world));
        var eventEmitter = this.systems.events;
        GetFastValue(this.config, "customUpdate", !1) || eventEmitter.on(SceneEvents.UPDATE, this.world.update, this.world), eventEmitter.on(SceneEvents.POST_UPDATE, this.world.postUpdate, this.world), eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);
      },
      enableUpdate: function enableUpdate() {
        this.systems.events.on(SceneEvents.UPDATE, this.world.update, this.world);
      },
      disableUpdate: function disableUpdate() {
        this.systems.events.off(SceneEvents.UPDATE, this.world.update, this.world);
      },
      getConfig: function getConfig() {
        var gameConfig = this.systems.game.config.physics,
            sceneConfig = this.systems.settings.physics;
        return Merge(GetFastValue(sceneConfig, "arcade", {}), GetFastValue(gameConfig, "arcade", {}));
      },
      overlap: function overlap(object1, object2, overlapCallback, processCallback, callbackContext) {
        return void 0 === overlapCallback && (overlapCallback = null), void 0 === callbackContext && (callbackContext = overlapCallback), this.world.collideObjects(object1, object2, overlapCallback, processCallback = void 0 === processCallback ? null : processCallback, callbackContext, !0);
      },
      collide: function collide(object1, object2, collideCallback, processCallback, callbackContext) {
        return void 0 === collideCallback && (collideCallback = null), void 0 === callbackContext && (callbackContext = collideCallback), this.world.collideObjects(object1, object2, collideCallback, processCallback = void 0 === processCallback ? null : processCallback, callbackContext, !1);
      },
      collideTiles: function collideTiles(sprite, tiles, collideCallback, processCallback, callbackContext) {
        return this.world.collideTiles(sprite, tiles, collideCallback, processCallback, callbackContext);
      },
      overlapTiles: function overlapTiles(sprite, tiles, collideCallback, processCallback, callbackContext) {
        return this.world.overlapTiles(sprite, tiles, collideCallback, processCallback, callbackContext);
      },
      pause: function pause() {
        return this.world.pause();
      },
      resume: function resume() {
        return this.world.resume();
      },
      accelerateTo: function accelerateTo(gameObject, angle, y, speed, xSpeedMax, ySpeedMax) {
        void 0 === speed && (speed = 60);
        angle = Math.atan2(y - gameObject.y, angle - gameObject.x);
        return gameObject.body.acceleration.setToPolar(angle, speed), void 0 !== xSpeedMax && void 0 !== ySpeedMax && gameObject.body.maxVelocity.set(xSpeedMax, ySpeedMax), angle;
      },
      accelerateToObject: function accelerateToObject(gameObject, destination, speed, xSpeedMax, ySpeedMax) {
        return this.accelerateTo(gameObject, destination.x, destination.y, speed, xSpeedMax, ySpeedMax);
      },
      closest: function closest(source, targets) {
        targets = targets || this.world.bodies.entries;

        for (var min = Number.MAX_VALUE, closest = null, x = source.x, y = source.y, len = targets.length, i = 0; i < len; i++) {
          var target = targets[i],
              distance = target.body || target;
          source !== target && source !== distance && source !== distance.gameObject && source !== distance.center && (distance = DistanceSquared(x, y, distance.center.x, distance.center.y)) < min && (closest = target, min = distance);
        }

        return closest;
      },
      furthest: function furthest(source, targets) {
        targets = targets || this.world.bodies.entries;

        for (var max = -1, farthest = null, x = source.x, y = source.y, len = targets.length, i = 0; i < len; i++) {
          var target = targets[i],
              distance = target.body || target;
          source !== target && source !== distance && source !== distance.gameObject && source !== distance.center && max < (distance = DistanceSquared(x, y, distance.center.x, distance.center.y)) && (farthest = target, max = distance);
        }

        return farthest;
      },
      moveTo: function moveTo(gameObject, x, y, speed, maxTime) {
        void 0 === speed && (speed = 60), void 0 === maxTime && (maxTime = 0);
        var angle = Math.atan2(y - gameObject.y, x - gameObject.x);
        return 0 < maxTime && (speed = DistanceBetween(gameObject.x, gameObject.y, x, y) / (maxTime / 1e3)), gameObject.body.velocity.setToPolar(angle, speed), angle;
      },
      moveToObject: function moveToObject(gameObject, destination, speed, maxTime) {
        return this.moveTo(gameObject, destination.x, destination.y, speed, maxTime);
      },
      velocityFromAngle: function velocityFromAngle(angle, speed, vec2) {
        return void 0 === speed && (speed = 60), (vec2 = void 0 === vec2 ? new Vector2() : vec2).setToPolar(DegToRad(angle), speed);
      },
      velocityFromRotation: function velocityFromRotation(rotation, speed, vec2) {
        return void 0 === speed && (speed = 60), (vec2 = void 0 === vec2 ? new Vector2() : vec2).setToPolar(rotation, speed);
      },
      overlapRect: function overlapRect(x, y, width, height, includeDynamic, includeStatic) {
        return OverlapRect(this.world, x, y, width, height, includeDynamic, includeStatic);
      },
      overlapCirc: function overlapCirc(x, y, radius, includeDynamic, includeStatic) {
        return OverlapCirc(this.world, x, y, radius, includeDynamic, includeStatic);
      },
      shutdown: function shutdown() {
        var eventEmitter;
        this.world && ((eventEmitter = this.systems.events).off(SceneEvents.UPDATE, this.world.update, this.world), eventEmitter.off(SceneEvents.POST_UPDATE, this.world.postUpdate, this.world), eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this), this.add.destroy(), this.world.destroy(), this.add = null, this.world = null);
      },
      destroy: function destroy() {
        this.shutdown(), this.scene.sys.events.off(SceneEvents.START, this.start, this), this.scene = null, this.systems = null;
      }
    });

    PluginCache.register("ArcadePhysics", ArcadePhysics, "arcadePhysics"), module.exports = ArcadePhysics;
  }, function (module, exports) {
    module.exports = {
      setAcceleration: function setAcceleration(x, y) {
        return this.body.acceleration.set(x, y), this;
      },
      setAccelerationX: function setAccelerationX(value) {
        return this.body.acceleration.x = value, this;
      },
      setAccelerationY: function setAccelerationY(value) {
        return this.body.acceleration.y = value, this;
      }
    };
  }, function (module, exports) {
    module.exports = {
      setAngularVelocity: function setAngularVelocity(value) {
        return this.body.angularVelocity = value, this;
      },
      setAngularAcceleration: function setAngularAcceleration(value) {
        return this.body.angularAcceleration = value, this;
      },
      setAngularDrag: function setAngularDrag(value) {
        return this.body.angularDrag = value, this;
      }
    };
  }, function (module, exports) {
    module.exports = {
      setBounce: function setBounce(x, y) {
        return this.body.bounce.set(x, y), this;
      },
      setBounceX: function setBounceX(value) {
        return this.body.bounce.x = value, this;
      },
      setBounceY: function setBounceY(value) {
        return this.body.bounce.y = value, this;
      },
      setCollideWorldBounds: function setCollideWorldBounds(value, bounceX, bounceY) {
        return this.body.setCollideWorldBounds(value, bounceX, bounceY), this;
      }
    };
  }, function (module, exports) {
    module.exports = {
      setDebug: function setDebug(showBody, showVelocity, bodyColor) {
        return this.debugShowBody = showBody, this.debugShowVelocity = showVelocity, this.debugBodyColor = bodyColor, this;
      },
      setDebugBodyColor: function setDebugBodyColor(value) {
        return this.body.debugBodyColor = value, this;
      },
      debugShowBody: {
        get: function get() {
          return this.body.debugShowBody;
        },
        set: function set(value) {
          this.body.debugShowBody = value;
        }
      },
      debugShowVelocity: {
        get: function get() {
          return this.body.debugShowVelocity;
        },
        set: function set(value) {
          this.body.debugShowVelocity = value;
        }
      },
      debugBodyColor: {
        get: function get() {
          return this.body.debugBodyColor;
        },
        set: function set(value) {
          this.body.debugBodyColor = value;
        }
      }
    };
  }, function (module, exports) {
    module.exports = {
      setDrag: function setDrag(x, y) {
        return this.body.drag.set(x, y), this;
      },
      setDragX: function setDragX(value) {
        return this.body.drag.x = value, this;
      },
      setDragY: function setDragY(value) {
        return this.body.drag.y = value, this;
      },
      setDamping: function setDamping(value) {
        return this.body.useDamping = value, this;
      }
    };
  }, function (module, exports) {
    module.exports = {
      enableBody: function enableBody(reset, x, y, enableGameObject, showGameObject) {
        return reset && this.body.reset(x, y), enableGameObject && (this.body.gameObject.active = !0), showGameObject && (this.body.gameObject.visible = !0), this.body.enable = !0, this;
      },
      disableBody: function disableBody(disableGameObject, hideGameObject) {
        return void 0 === disableGameObject && (disableGameObject = !1), void 0 === hideGameObject && (hideGameObject = !1), this.body.stop(), this.body.enable = !1, disableGameObject && (this.body.gameObject.active = !1), hideGameObject && (this.body.gameObject.visible = !1), this;
      },
      refreshBody: function refreshBody() {
        return this.body.updateFromGameObject(), this;
      }
    };
  }, function (module, exports) {
    module.exports = {
      setFriction: function setFriction(x, y) {
        return this.body.friction.set(x, y), this;
      },
      setFrictionX: function setFrictionX(x) {
        return this.body.friction.x = x, this;
      },
      setFrictionY: function setFrictionY(y) {
        return this.body.friction.y = y, this;
      }
    };
  }, function (module, exports) {
    module.exports = {
      setGravity: function setGravity(x, y) {
        return this.body.gravity.set(x, y), this;
      },
      setGravityX: function setGravityX(x) {
        return this.body.gravity.x = x, this;
      },
      setGravityY: function setGravityY(y) {
        return this.body.gravity.y = y, this;
      }
    };
  }, function (module, exports) {
    module.exports = {
      setImmovable: function setImmovable(value) {
        return this.body.immovable = value = void 0 === value ? !0 : value, this;
      }
    };
  }, function (module, exports) {
    module.exports = {
      setMass: function setMass(value) {
        return this.body.mass = value, this;
      }
    };
  }, function (module, exports) {
    module.exports = {
      setPushable: function setPushable(value) {
        return this.body.pushable = value = void 0 === value ? !0 : value, this;
      }
    };
  }, function (module, exports) {
    module.exports = {
      setOffset: function setOffset(x, y) {
        return this.body.setOffset(x, y), this;
      },
      setSize: function setSize(width, height, center) {
        return this.body.setSize(width, height, center), this;
      },
      setBodySize: function setBodySize(width, height, center) {
        return this.body.setSize(width, height, center), this;
      },
      setCircle: function setCircle(radius, offsetX, offsetY) {
        return this.body.setCircle(radius, offsetX, offsetY), this;
      }
    };
  }, function (module, exports) {
    module.exports = {
      setVelocity: function setVelocity(x, y) {
        return this.body.setVelocity(x, y), this;
      },
      setVelocityX: function setVelocityX(x) {
        return this.body.setVelocityX(x), this;
      },
      setVelocityY: function setVelocityY(y) {
        return this.body.setVelocityY(y), this;
      },
      setMaxVelocity: function setMaxVelocity(x, y) {
        return this.body.maxVelocity.set(x, y), this;
      }
    };
  }, function (module, exports) {
    module.exports = "collide";
  }, function (module, exports) {
    module.exports = "overlap";
  }, function (module, exports) {
    module.exports = "pause";
  }, function (module, exports) {
    module.exports = "resume";
  }, function (module, exports) {
    module.exports = "tilecollide";
  }, function (module, exports) {
    module.exports = "tileoverlap";
  }, function (module, exports) {
    module.exports = "worldbounds";
  }, function (module, exports) {
    module.exports = "worldstep";
  }, function (module, exports) {
    function BlockCheck() {
      return body1MovingRight && body1OnLeft && body2.blocked.right ? (body1.processX(-overlap, body1FullImpact, !1, !0), 1) : body1MovingLeft && body2OnLeft && body2.blocked.left ? (body1.processX(overlap, body1FullImpact, !0), 1) : body2MovingRight && body2OnLeft && body1.blocked.right ? (body2.processX(-overlap, body2FullImpact, !1, !0), 2) : body2MovingLeft && body1OnLeft && body1.blocked.left ? (body2.processX(overlap, body2FullImpact, !0), 2) : 0;
    }

    function Run(side) {
      var halfOverlap;
      return body1Pushable && body2Pushable ? (overlap *= .5, 0 === side || 3 === side ? (body1.processX(overlap, body1MassImpact), body2.processX(-overlap, body2MassImpact)) : (body1.processX(-overlap, body1MassImpact), body2.processX(overlap, body2MassImpact))) : body1Pushable && !body2Pushable ? 0 === side || 3 === side ? body1.processX(overlap, body1FullImpact, !0) : body1.processX(-overlap, body1FullImpact, !1, !0) : !body1Pushable && body2Pushable ? 0 === side || 3 === side ? body2.processX(-overlap, body2FullImpact, !1, !0) : body2.processX(overlap, body2FullImpact, !0) : (halfOverlap = .5 * overlap, 0 === side ? body2Stationary ? (body1.processX(overlap, 0, !0), body2.processX(0, null, !1, !0)) : body2MovingRight ? (body1.processX(halfOverlap, 0, !0), body2.processX(-halfOverlap, 0, !1, !0)) : (body1.processX(halfOverlap, body2.velocity.x, !0), body2.processX(-halfOverlap, null, !1, !0)) : 1 === side ? body1Stationary ? (body1.processX(0, null, !1, !0), body2.processX(overlap, 0, !0)) : body1MovingRight ? (body1.processX(-halfOverlap, 0, !1, !0), body2.processX(halfOverlap, 0, !0)) : (body1.processX(-halfOverlap, null, !1, !0), body2.processX(halfOverlap, body1.velocity.x, !0)) : 2 === side ? body2Stationary ? (body1.processX(-overlap, 0, !1, !0), body2.processX(0, null, !0)) : body2MovingLeft ? (body1.processX(-halfOverlap, 0, !1, !0), body2.processX(halfOverlap, 0, !0)) : (body1.processX(-halfOverlap, body2.velocity.x, !1, !0), body2.processX(halfOverlap, null, !0)) : 3 === side && (body1Stationary ? (body1.processX(0, null, !0), body2.processX(-overlap, 0, !1, !0)) : body1MovingLeft ? (body1.processX(halfOverlap, 0, !0), body2.processX(-halfOverlap, 0, !1, !0)) : (body1.processX(halfOverlap, body2.velocity.y, !0), body2.processX(-halfOverlap, null, !1, !0)))), !0;
    }

    var body1, body2, body1Pushable, body2Pushable, body1MassImpact, body2MassImpact, body1FullImpact, body2FullImpact, body1MovingLeft, body1MovingRight, body1Stationary, body2MovingLeft, body2MovingRight, body2Stationary, body1OnLeft, body2OnLeft, overlap;
    module.exports = {
      BlockCheck: BlockCheck,
      Check: function Check() {
        var avg = body1.velocity.x,
            nv2 = body2.velocity.x,
            nv1 = Math.sqrt(nv2 * nv2 * body2.mass / body1.mass) * (0 < nv2 ? 1 : -1),
            nv2 = Math.sqrt(avg * avg * body1.mass / body2.mass) * (0 < avg ? 1 : -1),
            avg = .5 * (nv1 + nv2);
        return body1MassImpact = avg + (nv1 -= avg) * body1.bounce.x, body2MassImpact = avg + (nv2 -= avg) * body2.bounce.x, body1MovingLeft && body2OnLeft ? Run(0) : body2MovingLeft && body1OnLeft ? Run(1) : body1MovingRight && body1OnLeft ? Run(2) : !(!body2MovingRight || !body2OnLeft) && Run(3);
      },
      Set: function Set(v2, v1, ov) {
        body2 = v1;
        v1 = (body1 = v2).velocity.x, v2 = body2.velocity.x;
        return body1Pushable = body1.pushable, body1MovingLeft = body1._dx < 0, body1MovingRight = 0 < body1._dx, body1Stationary = 0 === body1._dx, body1OnLeft = Math.abs(body1.right - body2.x) <= Math.abs(body2.right - body1.x), body1FullImpact = v2 - v1 * body1.bounce.x, body2Pushable = body2.pushable, body2MovingLeft = body2._dx < 0, body2MovingRight = 0 < body2._dx, body2Stationary = 0 === body2._dx, body2OnLeft = !body1OnLeft, body2FullImpact = v1 - v2 * body2.bounce.x, overlap = Math.abs(ov), BlockCheck();
      },
      Run: Run,
      RunImmovableBody1: function RunImmovableBody1(blockedState) {
        1 === blockedState ? body2.velocity.x = 0 : body1OnLeft ? body2.processX(overlap, body2FullImpact, !0) : body2.processX(-overlap, body2FullImpact, !1, !0), body1.moves && (body2.y += (body1.y - body1.prev.y) * body1.friction.y, body2._dy = body2.y - body2.prev.y);
      },
      RunImmovableBody2: function RunImmovableBody2(blockedState) {
        2 === blockedState ? body1.velocity.x = 0 : body2OnLeft ? body1.processX(overlap, body1FullImpact, !0) : body1.processX(-overlap, body1FullImpact, !1, !0), body2.moves && (body1.y += (body2.y - body2.prev.y) * body2.friction.y, body1._dy = body1.y - body1.prev.y);
      }
    };
  }, function (module, exports) {
    function BlockCheck() {
      return body1MovingDown && body1OnTop && body2.blocked.down ? (body1.processY(-overlap, body1FullImpact, !1, !0), 1) : body1MovingUp && body2OnTop && body2.blocked.up ? (body1.processY(overlap, body1FullImpact, !0), 1) : body2MovingDown && body2OnTop && body1.blocked.down ? (body2.processY(-overlap, body2FullImpact, !1, !0), 2) : body2MovingUp && body1OnTop && body1.blocked.up ? (body2.processY(overlap, body2FullImpact, !0), 2) : 0;
    }

    function Run(side) {
      var halfOverlap;
      return body1Pushable && body2Pushable ? (overlap *= .5, 0 === side || 3 === side ? (body1.processY(overlap, body1MassImpact), body2.processY(-overlap, body2MassImpact)) : (body1.processY(-overlap, body1MassImpact), body2.processY(overlap, body2MassImpact))) : body1Pushable && !body2Pushable ? 0 === side || 3 === side ? body1.processY(overlap, body1FullImpact, !0) : body1.processY(-overlap, body1FullImpact, !1, !0) : !body1Pushable && body2Pushable ? 0 === side || 3 === side ? body2.processY(-overlap, body2FullImpact, !1, !0) : body2.processY(overlap, body2FullImpact, !0) : (halfOverlap = .5 * overlap, 0 === side ? body2Stationary ? (body1.processY(overlap, 0, !0), body2.processY(0, null, !1, !0)) : body2MovingDown ? (body1.processY(halfOverlap, 0, !0), body2.processY(-halfOverlap, 0, !1, !0)) : (body1.processY(halfOverlap, body2.velocity.y, !0), body2.processY(-halfOverlap, null, !1, !0)) : 1 === side ? body1Stationary ? (body1.processY(0, null, !1, !0), body2.processY(overlap, 0, !0)) : body1MovingDown ? (body1.processY(-halfOverlap, 0, !1, !0), body2.processY(halfOverlap, 0, !0)) : (body1.processY(-halfOverlap, null, !1, !0), body2.processY(halfOverlap, body1.velocity.y, !0)) : 2 === side ? body2Stationary ? (body1.processY(-overlap, 0, !1, !0), body2.processY(0, null, !0)) : body2MovingUp ? (body1.processY(-halfOverlap, 0, !1, !0), body2.processY(halfOverlap, 0, !0)) : (body1.processY(-halfOverlap, body2.velocity.y, !1, !0), body2.processY(halfOverlap, null, !0)) : 3 === side && (body1Stationary ? (body1.processY(0, null, !0), body2.processY(-overlap, 0, !1, !0)) : body1MovingUp ? (body1.processY(halfOverlap, 0, !0), body2.processY(-halfOverlap, 0, !1, !0)) : (body1.processY(halfOverlap, body2.velocity.y, !0), body2.processY(-halfOverlap, null, !1, !0)))), !0;
    }

    var body1, body2, body1Pushable, body2Pushable, body1MassImpact, body2MassImpact, body1FullImpact, body2FullImpact, body1MovingUp, body1MovingDown, body1Stationary, body2MovingUp, body2MovingDown, body2Stationary, body1OnTop, body2OnTop, overlap;
    module.exports = {
      BlockCheck: BlockCheck,
      Check: function Check() {
        var avg = body1.velocity.y,
            nv2 = body2.velocity.y,
            nv1 = Math.sqrt(nv2 * nv2 * body2.mass / body1.mass) * (0 < nv2 ? 1 : -1),
            nv2 = Math.sqrt(avg * avg * body1.mass / body2.mass) * (0 < avg ? 1 : -1),
            avg = .5 * (nv1 + nv2);
        return body1MassImpact = avg + (nv1 -= avg) * body1.bounce.y, body2MassImpact = avg + (nv2 -= avg) * body2.bounce.y, body1MovingUp && body2OnTop ? Run(0) : body2MovingUp && body1OnTop ? Run(1) : body1MovingDown && body1OnTop ? Run(2) : !(!body2MovingDown || !body2OnTop) && Run(3);
      },
      Set: function Set(v2, v1, ov) {
        body2 = v1;
        v1 = (body1 = v2).velocity.y, v2 = body2.velocity.y;
        return body1Pushable = body1.pushable, body1MovingUp = body1._dy < 0, body1MovingDown = 0 < body1._dy, body1Stationary = 0 === body1._dy, body1OnTop = Math.abs(body1.bottom - body2.y) <= Math.abs(body2.bottom - body1.y), body1FullImpact = v2 - v1 * body1.bounce.y, body2Pushable = body2.pushable, body2MovingUp = body2._dy < 0, body2MovingDown = 0 < body2._dy, body2Stationary = 0 === body2._dy, body2OnTop = !body1OnTop, body2FullImpact = v1 - v2 * body2.bounce.y, overlap = Math.abs(ov), BlockCheck();
      },
      Run: Run,
      RunImmovableBody1: function RunImmovableBody1(blockedState) {
        1 === blockedState ? body2.velocity.y = 0 : body1OnTop ? body2.processY(overlap, body2FullImpact, !0) : body2.processY(-overlap, body2FullImpact, !1, !0), body1.moves && (body2.x += (body1.x - body1.prev.x) * body1.friction.x, body2._dx = body2.x - body2.prev.x);
      },
      RunImmovableBody2: function RunImmovableBody2(blockedState) {
        2 === blockedState ? body1.velocity.y = 0 : body2OnTop ? body1.processY(overlap, body1FullImpact, !0) : body1.processY(-overlap, body1FullImpact, !1, !0), body2.moves && (body1.x += (body2.x - body2.prev.x) * body2.friction.x, body1._dx = body1.x - body1.prev.x);
      }
    };
  }, function (module, exports, Tilemap) {
    Tilemap = {
      ProcessTileCallbacks: Tilemap(530),
      ProcessTileSeparationX: Tilemap(534),
      ProcessTileSeparationY: Tilemap(536),
      SeparateTile: Tilemap(532),
      TileCheckX: Tilemap(533),
      TileCheckY: Tilemap(535),
      TileIntersectsBody: Tilemap(248)
    };
    module.exports = Tilemap;
  }, function (module, exports, __webpack_require__) {
    var BodyBounds = __webpack_require__(0),
        Vector2 = __webpack_require__(3),
        BodyBounds = new BodyBounds({
      initialize: function initialize() {
        this.boundsCenter = new Vector2(), this.centerDiff = new Vector2();
      },
      parseBody: function parseBody(bodyCenterY) {
        if (!(bodyCenterY = bodyCenterY.hasOwnProperty("body") ? bodyCenterY.body : bodyCenterY).hasOwnProperty("bounds") || !bodyCenterY.hasOwnProperty("centerOfMass")) return !1;
        var boundsCenter = this.boundsCenter,
            centerDiff = this.centerDiff,
            boundsWidth = bodyCenterY.bounds.max.x - bodyCenterY.bounds.min.x,
            boundsHeight = bodyCenterY.bounds.max.y - bodyCenterY.bounds.min.y,
            bodyCenterX = boundsWidth * bodyCenterY.centerOfMass.x,
            bodyCenterY = boundsHeight * bodyCenterY.centerOfMass.y;
        return boundsCenter.set(boundsWidth / 2, boundsHeight / 2), centerDiff.set(bodyCenterX - boundsCenter.x, bodyCenterY - boundsCenter.y), !0;
      },
      getTopLeft: function getTopLeft(diff, x, y) {
        if (void 0 === x && (x = 0), void 0 === y && (y = 0), this.parseBody(diff)) {
          var center = this.boundsCenter,
              diff = this.centerDiff;
          return new Vector2(x + center.x + diff.x, y + center.y + diff.y);
        }

        return !1;
      },
      getTopCenter: function getTopCenter(diff, x, y) {
        if (void 0 === x && (x = 0), void 0 === y && (y = 0), this.parseBody(diff)) {
          var center = this.boundsCenter,
              diff = this.centerDiff;
          return new Vector2(x + diff.x, y + center.y + diff.y);
        }

        return !1;
      },
      getTopRight: function getTopRight(diff, x, y) {
        if (void 0 === x && (x = 0), void 0 === y && (y = 0), this.parseBody(diff)) {
          var center = this.boundsCenter,
              diff = this.centerDiff;
          return new Vector2(x - (center.x - diff.x), y + center.y + diff.y);
        }

        return !1;
      },
      getLeftCenter: function getLeftCenter(diff, x, y) {
        if (void 0 === x && (x = 0), void 0 === y && (y = 0), this.parseBody(diff)) {
          var center = this.boundsCenter,
              diff = this.centerDiff;
          return new Vector2(x + center.x + diff.x, y + diff.y);
        }

        return !1;
      },
      getCenter: function getCenter(diff, x, y) {
        if (void 0 === x && (x = 0), void 0 === y && (y = 0), this.parseBody(diff)) {
          diff = this.centerDiff;
          return new Vector2(x + diff.x, y + diff.y);
        }

        return !1;
      },
      getRightCenter: function getRightCenter(diff, x, y) {
        if (void 0 === x && (x = 0), void 0 === y && (y = 0), this.parseBody(diff)) {
          var center = this.boundsCenter,
              diff = this.centerDiff;
          return new Vector2(x - (center.x - diff.x), y + diff.y);
        }

        return !1;
      },
      getBottomLeft: function getBottomLeft(diff, x, y) {
        if (void 0 === x && (x = 0), void 0 === y && (y = 0), this.parseBody(diff)) {
          var center = this.boundsCenter,
              diff = this.centerDiff;
          return new Vector2(x + center.x + diff.x, y - (center.y - diff.y));
        }

        return !1;
      },
      getBottomCenter: function getBottomCenter(diff, x, y) {
        if (void 0 === x && (x = 0), void 0 === y && (y = 0), this.parseBody(diff)) {
          var center = this.boundsCenter,
              diff = this.centerDiff;
          return new Vector2(x + diff.x, y - (center.y - diff.y));
        }

        return !1;
      },
      getBottomRight: function getBottomRight(diff, x, y) {
        if (void 0 === x && (x = 0), void 0 === y && (y = 0), this.parseBody(diff)) {
          var center = this.boundsCenter,
              diff = this.centerDiff;
          return new Vector2(x - (center.x - diff.x), y - (center.y - diff.y));
        }

        return !1;
      }
    });

    module.exports = BodyBounds;
  }, function (module, exports) {
    function lineSegmentsIntersect(p1, db, q1, s) {
      var dx = db[0] - p1[0],
          t = db[1] - p1[1],
          da = s[0] - q1[0],
          db = s[1] - q1[1];

      if (da * t - db * dx != 0) {
        s = (dx * (q1[1] - p1[1]) + t * (p1[0] - q1[0])) / (da * t - db * dx), t = (da * (p1[1] - q1[1]) + db * (q1[0] - p1[0])) / (db * dx - da * t);
        return 0 <= s && s <= 1 && 0 <= t && t <= 1;
      }
    }

    function triangleArea(a, b, c) {
      return (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]);
    }

    function isLeft(a, b, c) {
      return 0 < triangleArea(a, b, c);
    }

    function isLeftOn(a, b, c) {
      return 0 <= triangleArea(a, b, c);
    }

    function isRight(a, b, c) {
      return triangleArea(a, b, c) < 0;
    }

    function isRightOn(a, b, c) {
      return triangleArea(a, b, c) <= 0;
    }

    module.exports = {
      decomp: function decomp(polygon) {
        var edges = function polygonGetCutEdges(polygon) {
          var min = [],
              tmp1 = [],
              tmp2 = [],
              tmpPoly = [];
          var nDiags = Number.MAX_VALUE;

          for (var i = 0; i < polygon.length; ++i) {
            if (polygonIsReflex(polygon, i)) for (var j = 0; j < polygon.length; ++j) {
              if (polygonCanSee(polygon, i, j)) {
                tmp1 = polygonGetCutEdges(polygonCopy(polygon, i, j, tmpPoly)), tmp2 = polygonGetCutEdges(polygonCopy(polygon, j, i, tmpPoly));

                for (var k = 0; k < tmp2.length; k++) {
                  tmp1.push(tmp2[k]);
                }

                tmp1.length < nDiags && (nDiags = (min = tmp1).length, min.push([polygonAt(polygon, i), polygonAt(polygon, j)]));
              }
            }
          }

          return min;
        }(polygon);

        return 0 < edges.length ? function polygonSlice(polygon, cutEdges) {
          if (0 === cutEdges.length) return [polygon];
          {
            if (cutEdges instanceof Array && cutEdges.length && cutEdges[0] instanceof Array && 2 === cutEdges[0].length && cutEdges[0][0] instanceof Array) {
              for (var polys = [polygon], i = 0; i < cutEdges.length; i++) {
                for (var cutEdge = cutEdges[i], j = 0; j < polys.length; j++) {
                  var result = polys[j],
                      result = polygonSlice(result, cutEdge);

                  if (result) {
                    polys.splice(j, 1), polys.push(result[0], result[1]);
                    break;
                  }
                }
              }

              return polys;
            }

            cutEdge = cutEdges, i = polygon.indexOf(cutEdge[0]), j = polygon.indexOf(cutEdge[1]);
            return -1 !== i && -1 !== j && [polygonCopy(polygon, i, j), polygonCopy(polygon, j, i)];
          }
        }(polygon, edges) : [polygon];
      },
      quickDecomp: function polygonQuickDecomp(polygon, result, reflexVertices, steinerPoints, delta, maxlevel, level) {
        maxlevel = maxlevel || 100;
        level = level || 0;
        delta = delta || 25;
        result = void 0 !== result ? result : [];
        reflexVertices = reflexVertices || [];
        steinerPoints = steinerPoints || [];
        var upperInt = [0, 0],
            lowerInt = [0, 0],
            p = [0, 0];
        var upperDist = 0,
            lowerDist = 0,
            d = 0,
            closestDist = 0;
        var upperIndex = 0,
            lowerIndex = 0,
            closestIndex = 0;
        var lowerPoly = [],
            upperPoly = [];
        var poly = polygon,
            v = polygon;
        if (v.length < 3) return result;
        level++;
        if (maxlevel < level) return console.warn("quickDecomp: max level (" + maxlevel + ") reached."), result;

        for (var i = 0; i < polygon.length; ++i) {
          if (polygonIsReflex(poly, i)) {
            reflexVertices.push(poly[i]), upperDist = lowerDist = Number.MAX_VALUE;

            for (var j = 0; j < polygon.length; ++j) {
              isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j - 1)) && (p = getIntersectionPoint(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j - 1)), isRight(polygonAt(poly, i + 1), polygonAt(poly, i), p) && (d = sqdist(poly[i], p)) < lowerDist && (lowerDist = d, lowerInt = p, lowerIndex = j)), isLeft(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j + 1)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j)) && (p = getIntersectionPoint(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j + 1)), isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), p) && (d = sqdist(poly[i], p)) < upperDist && (upperDist = d, upperInt = p, upperIndex = j));
            }

            if (lowerIndex === (upperIndex + 1) % polygon.length) p[0] = (lowerInt[0] + upperInt[0]) / 2, p[1] = (lowerInt[1] + upperInt[1]) / 2, steinerPoints.push(p), i < upperIndex ? (polygonAppend(lowerPoly, poly, i, upperIndex + 1), lowerPoly.push(p), upperPoly.push(p), 0 !== lowerIndex && polygonAppend(upperPoly, poly, lowerIndex, poly.length), polygonAppend(upperPoly, poly, 0, i + 1)) : (0 !== i && polygonAppend(lowerPoly, poly, i, poly.length), polygonAppend(lowerPoly, poly, 0, upperIndex + 1), lowerPoly.push(p), upperPoly.push(p), polygonAppend(upperPoly, poly, lowerIndex, i + 1));else {
              if (upperIndex < lowerIndex && (upperIndex += polygon.length), closestDist = Number.MAX_VALUE, upperIndex < lowerIndex) return result;

              for (j = lowerIndex; j <= upperIndex; ++j) {
                isLeftOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j)) && (d = sqdist(polygonAt(poly, i), polygonAt(poly, j))) < closestDist && polygonCanSee2(poly, i, j) && (closestDist = d, closestIndex = j % polygon.length);
              }

              i < closestIndex ? (polygonAppend(lowerPoly, poly, i, closestIndex + 1), 0 !== closestIndex && polygonAppend(upperPoly, poly, closestIndex, v.length), polygonAppend(upperPoly, poly, 0, i + 1)) : (0 !== i && polygonAppend(lowerPoly, poly, i, v.length), polygonAppend(lowerPoly, poly, 0, closestIndex + 1), polygonAppend(upperPoly, poly, closestIndex, i + 1));
            }
            return lowerPoly.length < upperPoly.length ? (polygonQuickDecomp(lowerPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level), polygonQuickDecomp(upperPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level)) : (polygonQuickDecomp(upperPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level), polygonQuickDecomp(lowerPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level)), result;
          }
        }

        result.push(polygon);
        return result;
      },
      isSimple: function isSimple(polygon) {
        var i,
            path = polygon;

        for (i = 0; i < path.length - 1; i++) {
          for (var j = 0; j < i - 1; j++) {
            if (lineSegmentsIntersect(path[i], path[i + 1], path[j], path[j + 1])) return !1;
          }
        }

        for (i = 1; i < path.length - 2; i++) {
          if (lineSegmentsIntersect(path[0], path[path.length - 1], path[i], path[i + 1])) return !1;
        }

        return !0;
      },
      removeCollinearPoints: function removeCollinearPoints(polygon, precision) {
        for (var num = 0, i = polygon.length - 1; 3 < polygon.length && 0 <= i; --i) {
          !function (a, b, c, thresholdAngle) {
            {
              if (thresholdAngle) {
                var magA = tmpPoint1,
                    magB = tmpPoint2;
                magA[0] = b[0] - a[0], magA[1] = b[1] - a[1], magB[0] = c[0] - b[0], magB[1] = c[1] - b[1];
                var dot = magA[0] * magB[0] + magA[1] * magB[1],
                    magA = Math.sqrt(magA[0] * magA[0] + magA[1] * magA[1]),
                    magB = Math.sqrt(magB[0] * magB[0] + magB[1] * magB[1]);
                return Math.acos(dot / (magA * magB)) < thresholdAngle;
              }

              return 0 === triangleArea(a, b, c);
            }
          }(polygonAt(polygon, i - 1), polygonAt(polygon, i), polygonAt(polygon, i + 1), precision) || (polygon.splice(i % polygon.length, 1), num++);
        }

        return num;
      },
      removeDuplicatePoints: function removeDuplicatePoints(polygon, precision) {
        for (var i = polygon.length - 1; 1 <= i; --i) {
          for (var pi = polygon[i], j = i - 1; 0 <= j; --j) {
            !function (a, b, precision) {
              return scalar_eq(a[0], b[0], precision) && scalar_eq(a[1], b[1], precision);
            }(pi, polygon[j], precision) || polygon.splice(i, 1);
          }
        }
      },
      makeCCW: function makeCCW(polygon) {
        for (var br = 0, v = polygon, i = 1; i < polygon.length; ++i) {
          (v[i][1] < v[br][1] || v[i][1] === v[br][1] && v[i][0] > v[br][0]) && (br = i);
        }

        return !isLeft(polygonAt(polygon, br - 1), polygonAt(polygon, br), polygonAt(polygon, br + 1)) && (function (polygon) {
          for (var tmp = [], N = polygon.length, i = 0; i !== N; i++) {
            tmp.push(polygon.pop());
          }

          for (i = 0; i !== N; i++) {
            polygon[i] = tmp[i];
          }
        }(polygon), !0);
      }
    };
    var tmpPoint1 = [],
        tmpPoint2 = [];

    function sqdist(dy, b) {
      var dx = b[0] - dy[0],
          dy = b[1] - dy[1];
      return dx * dx + dy * dy;
    }

    function polygonAt(polygon, i) {
      var s = polygon.length;
      return polygon[i < 0 ? i % s + s : i % s];
    }

    function polygonAppend(polygon, poly, from, to) {
      for (var i = from; i < to; i++) {
        polygon.push(poly[i]);
      }
    }

    function polygonIsReflex(polygon, i) {
      return isRight(polygonAt(polygon, i - 1), polygonAt(polygon, i), polygonAt(polygon, i + 1));
    }

    var tmpLine1 = [],
        tmpLine2 = [];

    function polygonCanSee(polygon, a, b) {
      var p,
          l1 = tmpLine1,
          l2 = tmpLine2;
      if (isLeftOn(polygonAt(polygon, a + 1), polygonAt(polygon, a), polygonAt(polygon, b)) && isRightOn(polygonAt(polygon, a - 1), polygonAt(polygon, a), polygonAt(polygon, b))) return !1;

      for (var dist = sqdist(polygonAt(polygon, a), polygonAt(polygon, b)), i = 0; i !== polygon.length; ++i) {
        if ((i + 1) % polygon.length !== a && i !== a && isLeftOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i + 1)) && isRightOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i)) && (l1[0] = polygonAt(polygon, a), l1[1] = polygonAt(polygon, b), l2[0] = polygonAt(polygon, i), l2[1] = polygonAt(polygon, i + 1), p = function (c2, det, precision) {
          var i = [0, 0],
              a1 = c2[1][1] - c2[0][1],
              b1 = c2[0][0] - c2[1][0],
              c1 = a1 * c2[0][0] + b1 * c2[0][1],
              a2 = det[1][1] - det[0][1],
              b2 = det[0][0] - det[1][0],
              c2 = a2 * det[0][0] + b2 * det[0][1];
          return scalar_eq(det = a1 * b2 - a2 * b1, 0, precision = precision || 0) || (i[0] = (b2 * c1 - b1 * c2) / det, i[1] = (a1 * c2 - a2 * c1) / det), i;
        }(l1, l2), sqdist(polygonAt(polygon, a), p) < dist)) return !1;
      }

      return !0;
    }

    function polygonCanSee2(polygon, a, b) {
      for (var i = 0; i !== polygon.length; ++i) {
        if (i !== a && i !== b && (i + 1) % polygon.length !== a && (i + 1) % polygon.length !== b && lineSegmentsIntersect(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i), polygonAt(polygon, i + 1))) return !1;
      }

      return !0;
    }

    function polygonCopy(polygon, i, j, targetPoly) {
      var p = targetPoly || [];
      if (p.length = 0, i < j) for (var k = i; k <= j; k++) {
        p.push(polygon[k]);
      } else {
        for (k = 0; k <= j; k++) {
          p.push(polygon[k]);
        }

        for (k = i; k < polygon.length; k++) {
          p.push(polygon[k]);
        }
      }
      return p;
    }

    function getIntersectionPoint(b2, a2, det, c2, delta) {
      var a1 = a2[1] - b2[1],
          b1 = b2[0] - a2[0],
          c1 = a1 * b2[0] + b1 * b2[1],
          a2 = c2[1] - det[1],
          b2 = det[0] - c2[0],
          c2 = a2 * det[0] + b2 * det[1],
          det = a1 * b2 - a2 * b1;
      return scalar_eq(det, 0, delta = delta || 0) ? [0, 0] : [(b2 * c1 - b1 * c2) / det, (a1 * c2 - a2 * c1) / det];
    }

    function scalar_eq(a, b, precision) {
      return precision = precision || 0, Math.abs(a - b) <= precision;
    }
  }, function (module, exports, __webpack_require__) {
    var Bodies = __webpack_require__(86),
        Factory = __webpack_require__(0),
        Composites = __webpack_require__(591),
        Constraint = __webpack_require__(128),
        Svg = __webpack_require__(592),
        MatterGameObject = __webpack_require__(1395),
        MatterImage = __webpack_require__(1396),
        MatterSprite = __webpack_require__(1397),
        MatterTileBody = __webpack_require__(593),
        PhysicsEditorParser = __webpack_require__(589),
        PhysicsJSONParser = __webpack_require__(590),
        PointerConstraint = __webpack_require__(1398),
        Vertices = __webpack_require__(64),
        Factory = new Factory({
      initialize: function initialize(world) {
        this.world = world, this.scene = world.scene, this.sys = world.scene.sys;
      },
      rectangle: function rectangle(x, y, width, height, body) {
        body = Bodies.rectangle(x, y, width, height, body);
        return this.world.add(body), body;
      },
      trapezoid: function trapezoid(x, y, width, height, slope, body) {
        body = Bodies.trapezoid(x, y, width, height, slope, body);
        return this.world.add(body), body;
      },
      circle: function circle(x, y, radius, options, body) {
        body = Bodies.circle(x, y, radius, options, body);
        return this.world.add(body), body;
      },
      polygon: function polygon(x, y, sides, radius, body) {
        body = Bodies.polygon(x, y, sides, radius, body);
        return this.world.add(body), body;
      },
      fromVertices: function fromVertices(x, y, vertexSets, options, flagInternal, removeCollinear, body) {
        "string" == typeof vertexSets && (vertexSets = Vertices.fromPath(vertexSets));
        body = Bodies.fromVertices(x, y, vertexSets, options, flagInternal, removeCollinear, body);
        return this.world.add(body), body;
      },
      fromPhysicsEditor: function fromPhysicsEditor(x, y, config, body, addToWorld) {
        void 0 === addToWorld && (addToWorld = !0);
        body = PhysicsEditorParser.parseBody(x, y, config, body);
        return addToWorld && !this.world.has(body) && this.world.add(body), body;
      },
      fromSVG: function fromSVG(x, y, xml, scale, body, addToWorld) {
        void 0 === scale && (scale = 1), void 0 === body && (body = {}), void 0 === addToWorld && (addToWorld = !0);

        for (var path = xml.getElementsByTagName("path"), vertexSets = [], i = 0; i < path.length; i++) {
          var points = Svg.pathToVertices(path[i], 30);
          1 !== scale && Vertices.scale(points, scale, scale), vertexSets.push(points);
        }

        body = Bodies.fromVertices(x, y, vertexSets, body);
        return addToWorld && this.world.add(body), body;
      },
      fromJSON: function fromJSON(x, y, config, body, addToWorld) {
        void 0 === addToWorld && (addToWorld = !0);
        body = PhysicsJSONParser.parseBody(x, y, config, body = void 0 === body ? {} : body);
        return body && addToWorld && this.world.add(body), body;
      },
      imageStack: function imageStack(key, frame, x, y, columns, rows, columnGap, stack, options) {
        void 0 === columnGap && (columnGap = 0), void 0 === stack && (stack = 0), void 0 === options && (options = {});
        var world = this.world,
            displayList = this.sys.displayList;
        options.addToWorld = !1;
        stack = Composites.stack(x, y, columns, rows, columnGap, stack, function (x, image) {
          image = new MatterImage(world, x, image, key, frame, options);
          return displayList.add(image), image.body;
        });
        return world.add(stack), stack;
      },
      stack: function stack(x, y, columns, rows, columnGap, rowGap, _stack) {
        _stack = Composites.stack(x, y, columns, rows, columnGap, rowGap, _stack);
        return this.world.add(_stack), _stack;
      },
      pyramid: function pyramid(x, y, columns, rows, columnGap, rowGap, stack) {
        stack = Composites.pyramid(x, y, columns, rows, columnGap, rowGap, stack);
        return this.world.add(stack), stack;
      },
      chain: function chain(composite, xOffsetA, yOffsetA, xOffsetB, yOffsetB, options) {
        return Composites.chain(composite, xOffsetA, yOffsetA, xOffsetB, yOffsetB, options);
      },
      mesh: function mesh(composite, columns, rows, crossBrace, options) {
        return Composites.mesh(composite, columns, rows, crossBrace, options);
      },
      newtonsCradle: function newtonsCradle(x, y, number, size, composite) {
        composite = Composites.newtonsCradle(x, y, number, size, composite);
        return this.world.add(composite), composite;
      },
      car: function car(x, y, width, height, composite) {
        composite = Composites.car(x, y, width, height, composite);
        return this.world.add(composite), composite;
      },
      softBody: function softBody(x, y, columns, rows, columnGap, rowGap, crossBrace, particleRadius, particleOptions, composite) {
        composite = Composites.softBody(x, y, columns, rows, columnGap, rowGap, crossBrace, particleRadius, particleOptions, composite);
        return this.world.add(composite), composite;
      },
      joint: function joint(bodyA, bodyB, length, stiffness, options) {
        return this.constraint(bodyA, bodyB, length, stiffness, options);
      },
      spring: function spring(bodyA, bodyB, length, stiffness, options) {
        return this.constraint(bodyA, bodyB, length, stiffness, options);
      },
      constraint: function constraint(bodyA, bodyB, length, stiffness, _constraint) {
        void 0 === stiffness && (stiffness = 1), (_constraint = void 0 === _constraint ? {} : _constraint).bodyA = "body" === bodyA.type ? bodyA : bodyA.body, _constraint.bodyB = "body" === bodyB.type ? bodyB : bodyB.body, isNaN(length) || (_constraint.length = length), _constraint.stiffness = stiffness;
        _constraint = Constraint.create(_constraint);
        return this.world.add(_constraint), _constraint;
      },
      worldConstraint: function worldConstraint(body, length, stiffness, constraint) {
        void 0 === stiffness && (stiffness = 1), (constraint = void 0 === constraint ? {} : constraint).bodyB = "body" === body.type ? body : body.body, isNaN(length) || (constraint.length = length), constraint.stiffness = stiffness;
        constraint = Constraint.create(constraint);
        return this.world.add(constraint), constraint;
      },
      mouseSpring: function mouseSpring(options) {
        return this.pointerConstraint(options);
      },
      pointerConstraint: function pointerConstraint(_pointerConstraint) {
        (_pointerConstraint = void 0 === _pointerConstraint ? {} : _pointerConstraint).hasOwnProperty("render") || (_pointerConstraint.render = {
          visible: !1
        });
        _pointerConstraint = new PointerConstraint(this.scene, this.world, _pointerConstraint);
        return this.world.add(_pointerConstraint.constraint), _pointerConstraint;
      },
      image: function image(x, y, key, frame, _image2) {
        _image2 = new MatterImage(this.world, x, y, key, frame, _image2);
        return this.sys.displayList.add(_image2), _image2;
      },
      tileBody: function tileBody(tile, options) {
        return new MatterTileBody(this.world, tile, options);
      },
      sprite: function sprite(x, y, key, frame, _sprite2) {
        _sprite2 = new MatterSprite(this.world, x, y, key, frame, _sprite2);
        return this.sys.displayList.add(_sprite2), this.sys.updateList.add(_sprite2), _sprite2;
      },
      gameObject: function gameObject(_gameObject, options, addToWorld) {
        return MatterGameObject(this.world, _gameObject, options, addToWorld);
      },
      destroy: function destroy() {
        this.world = null, this.scene = null, this.sys = null;
      }
    });

    module.exports = Factory;
  }, function (module, exports, __webpack_require__) {
    var Components = __webpack_require__(249),
        GetFastValue = __webpack_require__(2),
        Vector2 = __webpack_require__(3);

    module.exports = function (world, gameObject, options, addToWorld) {
      void 0 === options && (options = {}), void 0 === addToWorld && (addToWorld = !0);
      var x = gameObject.x,
          shape = gameObject.y;
      return gameObject.body = {
        temp: !0,
        position: {
          x: x,
          y: shape
        }
      }, [Components.Bounce, Components.Collision, Components.Force, Components.Friction, Components.Gravity, Components.Mass, Components.Sensor, Components.SetBody, Components.Sleep, Components.Static, Components.Transform, Components.Velocity].forEach(function (mixin) {
        for (var key in mixin) {
          (def = mixin[key]).get && "function" == typeof def.get || def.set && "function" == typeof def.set ? Object.defineProperty(gameObject, key, {
            get: mixin[key].get,
            set: mixin[key].set
          }) : Object.defineProperty(gameObject, key, {
            value: mixin[key]
          });
        }

        var def;
      }), gameObject.world = world, gameObject._tempVec2 = new Vector2(x, shape), options.hasOwnProperty("type") && "body" === options.type ? gameObject.setExistingBody(options, addToWorld) : (shape = GetFastValue(options, "shape", null) || "rectangle", options.addToWorld = addToWorld, gameObject.setBody(shape, options)), gameObject;
    };
  }, function (module, exports, __webpack_require__) {
    var Class = __webpack_require__(0),
        Components = __webpack_require__(249),
        GameObject = __webpack_require__(15),
        GetFastValue = __webpack_require__(2),
        Image = __webpack_require__(125),
        MatterImage = __webpack_require__(167),
        Vector2 = __webpack_require__(3),
        MatterImage = new Class({
      Extends: Image,
      Mixins: [Components.Bounce, Components.Collision, Components.Force, Components.Friction, Components.Gravity, Components.Mass, Components.Sensor, Components.SetBody, Components.Sleep, Components.Static, Components.Transform, Components.Velocity, MatterImage],
      initialize: function initialize(shape, x, y, texture, frame, options) {
        GameObject.call(this, shape.scene, "Image"), this._crop = this.resetCropObject(), this.setTexture(texture, frame), this.setSizeToFrame(), this.setOrigin(), this.world = shape, this._tempVec2 = new Vector2(x, y);
        shape = GetFastValue(options, "shape", null);
        shape ? this.setBody(shape, options) : this.setRectangle(this.width, this.height, options), this.setPosition(x, y), this.initPipeline();
      }
    });

    module.exports = MatterImage;
  }, function (module, exports, __webpack_require__) {
    var AnimationState = __webpack_require__(164),
        Class = __webpack_require__(0),
        Components = __webpack_require__(249),
        GameObject = __webpack_require__(15),
        GetFastValue = __webpack_require__(2),
        MatterSprite = __webpack_require__(167),
        Sprite = __webpack_require__(73),
        Vector2 = __webpack_require__(3),
        MatterSprite = new Class({
      Extends: Sprite,
      Mixins: [Components.Bounce, Components.Collision, Components.Force, Components.Friction, Components.Gravity, Components.Mass, Components.Sensor, Components.SetBody, Components.Sleep, Components.Static, Components.Transform, Components.Velocity, MatterSprite],
      initialize: function initialize(shape, x, y, texture, frame, options) {
        GameObject.call(this, shape.scene, "Sprite"), this._crop = this.resetCropObject(), this.anims = new AnimationState(this), this.setTexture(texture, frame), this.setSizeToFrame(), this.setOrigin(), this.world = shape, this._tempVec2 = new Vector2(x, y);
        shape = GetFastValue(options, "shape", null);
        shape ? this.setBody(shape, options) : this.setRectangle(this.width, this.height, options), this.setPosition(x, y), this.initPipeline();
      }
    });

    module.exports = MatterSprite;
  }, function (module, exports, __webpack_require__) {
    var Bounds = __webpack_require__(84),
        PointerConstraint = __webpack_require__(0),
        Composite = __webpack_require__(118),
        Constraint = __webpack_require__(128),
        Detector = __webpack_require__(273),
        Events = __webpack_require__(272),
        InputEvents = __webpack_require__(51),
        Merge = __webpack_require__(127),
        Sleeping = __webpack_require__(165),
        Vector2 = __webpack_require__(3),
        Vertices = __webpack_require__(64),
        PointerConstraint = new PointerConstraint({
      initialize: function initialize(scene, world, options) {
        void 0 === options && (options = {});
        this.scene = scene, this.world = world, this.camera = null, this.pointer = null, this.active = !0, this.position = new Vector2(), this.body = null, this.part = null, this.constraint = Constraint.create(Merge(options, {
          label: "Pointer Constraint",
          pointA: {
            x: 0,
            y: 0
          },
          pointB: {
            x: 0,
            y: 0
          },
          length: .01,
          stiffness: .1,
          angularStiffness: 1,
          collisionFilter: {
            category: 1,
            mask: 4294967295,
            group: 0
          }
        })), this.world.on(Events.BEFORE_UPDATE, this.update, this), scene.sys.input.on(InputEvents.POINTER_DOWN, this.onDown, this), scene.sys.input.on(InputEvents.POINTER_UP, this.onUp, this);
      },
      onDown: function onDown(pointer) {
        this.pointer || (this.pointer = pointer, this.camera = pointer.camera);
      },
      onUp: function onUp(pointer) {
        pointer === this.pointer && (this.pointer = null);
      },
      getBody: function getBody(pointer) {
        var pos = this.position,
            constraint = this.constraint;
        this.camera.getWorldPoint(pointer.x, pointer.y, pos);

        for (var bodies = Composite.allBodies(this.world.localWorld), i = 0; i < bodies.length; i++) {
          var body = bodies[i];
          if (!body.ignorePointer && Bounds.contains(body.bounds, pos) && Detector.canCollide(body.collisionFilter, constraint.collisionFilter) && this.hitTestBody(body, pos)) return this.world.emit(Events.DRAG_START, body, this.part, this), !0;
        }

        return !1;
      },
      hitTestBody: function hitTestBody(body, position) {
        for (var constraint = this.constraint, partsLength = body.parts.length, i = 1 < partsLength ? 1 : 0; i < partsLength; i++) {
          var part = body.parts[i];
          if (Vertices.contains(part.vertices, position)) return constraint.pointA = position, constraint.pointB = {
            x: position.x - body.position.x,
            y: position.y - body.position.y
          }, constraint.bodyB = body, constraint.angleB = body.angle, Sleeping.set(body, !1), this.part = part, this.body = body, !0;
        }

        return !1;
      },
      update: function update() {
        var pos,
            constraint,
            pointer = this.pointer,
            body = this.body;
        this.active && pointer ? !pointer.isDown && body ? this.stopDrag() : pointer.isDown && (body || this.getBody(pointer)) && (body = this.body, pos = this.position, constraint = this.constraint, this.camera.getWorldPoint(pointer.x, pointer.y, pos), constraint.pointA.x = pos.x, constraint.pointA.y = pos.y, Sleeping.set(body, !1), this.world.emit(Events.DRAG, body, this)) : body && this.stopDrag();
      },
      stopDrag: function stopDrag() {
        var body = this.body,
            constraint = this.constraint;
        constraint.bodyB = null, constraint.pointB = null, this.pointer = null, this.body = null, this.part = null, body && this.world.emit(Events.DRAG_END, body, this);
      },
      destroy: function destroy() {
        this.world.removeConstraint(this.constraint), this.pointer = null, this.constraint = null, this.body = null, this.part = null, this.world.off(Events.BEFORE_UPDATE, this.update), this.scene.sys.input.off(InputEvents.POINTER_DOWN, this.onDown, this), this.scene.sys.input.off(InputEvents.POINTER_UP, this.onUp, this);
      }
    });

    module.exports = PointerConstraint;
  }, function (module, exports, __webpack_require__) {
    var Matter = {};
    module.exports = Matter;

    var Plugin = __webpack_require__(595),
        Common = __webpack_require__(32);

    Matter.name = "matter-js", Matter.version = "0.14.2", Matter.uses = [], Matter.used = [], Matter.use = function () {
      Plugin.use(Matter, Array.prototype.slice.call(arguments));
    }, Matter.before = function (path, func) {
      return path = path.replace(/^Matter./, ""), Common.chainPathBefore(Matter, path, func);
    }, Matter.after = function (path, func) {
      return path = path.replace(/^Matter./, ""), Common.chainPathAfter(Matter, path, func);
    };
  }, function (module, exports, __webpack_require__) {
    var Query = {};
    module.exports = Query;

    var Vector = __webpack_require__(83),
        SAT = __webpack_require__(274),
        Bounds = __webpack_require__(84),
        Bodies = __webpack_require__(86),
        Vertices = __webpack_require__(64);

    Query.collides = function (body, bodies) {
      for (var collisions = [], i = 0; i < bodies.length; i++) {
        var bodyA = bodies[i];
        if (body !== bodyA && Bounds.overlaps(bodyA.bounds, body.bounds)) for (var j = 1 === bodyA.parts.length ? 0 : 1; j < bodyA.parts.length; j++) {
          var collision = bodyA.parts[j];

          if (Bounds.overlaps(collision.bounds, body.bounds)) {
            collision = SAT.collides(collision, body);

            if (collision.collided) {
              collisions.push(collision);
              break;
            }
          }
        }
      }

      return collisions;
    }, Query.ray = function (bodies, rayY, endPoint, rayWidth) {
      rayWidth = rayWidth || 1e-100;

      for (var ray = Vector.angle(rayY, endPoint), rayLength = Vector.magnitude(Vector.sub(rayY, endPoint)), rayX = .5 * (endPoint.x + rayY.x), rayY = .5 * (endPoint.y + rayY.y), ray = Bodies.rectangle(rayX, rayY, rayLength, rayWidth, {
        angle: ray
      }), collisions = Query.collides(ray, bodies), i = 0; i < collisions.length; i += 1) {
        var collision = collisions[i];
        collision.body = collision.bodyB = collision.bodyA;
      }

      return collisions;
    }, Query.region = function (bodies, bounds, outside) {
      for (var result = [], i = 0; i < bodies.length; i++) {
        var body = bodies[i],
            overlaps = Bounds.overlaps(body.bounds, bounds);
        (overlaps && !outside || !overlaps && outside) && result.push(body);
      }

      return result;
    }, Query.point = function (bodies, point) {
      for (var result = [], i = 0; i < bodies.length; i++) {
        var body = bodies[i];
        if (Bounds.contains(body.bounds, point)) for (var j = 1 === body.parts.length ? 0 : 1; j < body.parts.length; j++) {
          var part = body.parts[j];

          if (Bounds.contains(part.bounds, point) && Vertices.contains(part.vertices, point)) {
            result.push(body);
            break;
          }
        }
      }

      return result;
    };
  }, function (module, exports, __webpack_require__) {
    var Engine = {};
    module.exports = Engine;

    var World = __webpack_require__(596),
        Sleeping = __webpack_require__(165),
        Resolver = __webpack_require__(599),
        Pairs = __webpack_require__(598),
        Metrics = __webpack_require__(1523),
        Grid = __webpack_require__(597),
        Events = __webpack_require__(166),
        Composite = __webpack_require__(118),
        Constraint = __webpack_require__(128),
        Common = __webpack_require__(32),
        Body = __webpack_require__(41);

    Engine.create = function (engine, options) {
      options = (options = Common.isElement(engine) ? options : engine) || {}, ((engine = Common.isElement(engine) ? engine : null) || options.render) && Common.warn("Engine.create: engine.render is deprecated (see docs)");
      engine = Common.extend({
        positionIterations: 6,
        velocityIterations: 4,
        constraintIterations: 2,
        enableSleeping: !1,
        events: [],
        plugin: {},
        timing: {
          timestamp: 0,
          timeScale: 1
        },
        broadphase: {
          controller: Grid
        }
      }, options);
      return engine.world = options.world || World.create(engine.world), engine.pairs = Pairs.create(), engine.broadphase = engine.broadphase.controller.create(engine.broadphase), engine.metrics = engine.metrics || {
        extended: !1
      }, engine.metrics = Metrics.create(engine.metrics), engine;
    }, Engine.update = function (engine, delta, correction) {
      correction = correction || 1;
      var i,
          world = engine.world,
          timing = engine.timing,
          collisions = engine.broadphase,
          timestamp = [];
      timing.timestamp += (delta = delta || 1e3 / 60) * timing.timeScale;
      var event = {
        timestamp: timing.timestamp
      };
      Events.trigger(engine, "beforeUpdate", event);
      var allBodies = Composite.allBodies(world),
          allConstraints = Composite.allConstraints(world);

      for (Metrics.reset(engine.metrics), engine.enableSleeping && Sleeping.update(allBodies, timing.timeScale), Engine._bodiesApplyGravity(allBodies, world.gravity), Engine._bodiesUpdate(allBodies, delta, timing.timeScale, correction, world.bounds), Constraint.preSolveAll(allBodies), i = 0; i < engine.constraintIterations; i++) {
        Constraint.solveAll(allConstraints, timing.timeScale);
      }

      Constraint.postSolveAll(allBodies), timestamp = collisions.controller ? (world.isModified && collisions.controller.clear(collisions), collisions.controller.update(collisions, allBodies, engine, world.isModified), collisions.pairsList) : allBodies, world.isModified && Composite.setModified(world, !1, !1, !0);
      var collisions = collisions.detector(timestamp, engine),
          pairs = engine.pairs,
          timestamp = timing.timestamp;

      for (Pairs.update(pairs, collisions, timestamp), Pairs.removeOld(pairs, timestamp), engine.enableSleeping && Sleeping.afterCollisions(pairs.list, timing.timeScale), 0 < pairs.collisionStart.length && Events.trigger(engine, "collisionStart", {
        pairs: pairs.collisionStart
      }), Resolver.preSolvePosition(pairs.list), i = 0; i < engine.positionIterations; i++) {
        Resolver.solvePosition(pairs.list, allBodies, timing.timeScale);
      }

      for (Resolver.postSolvePosition(allBodies), Constraint.preSolveAll(allBodies), i = 0; i < engine.constraintIterations; i++) {
        Constraint.solveAll(allConstraints, timing.timeScale);
      }

      for (Constraint.postSolveAll(allBodies), Resolver.preSolveVelocity(pairs.list), i = 0; i < engine.velocityIterations; i++) {
        Resolver.solveVelocity(pairs.list, timing.timeScale);
      }

      return 0 < pairs.collisionActive.length && Events.trigger(engine, "collisionActive", {
        pairs: pairs.collisionActive
      }), 0 < pairs.collisionEnd.length && Events.trigger(engine, "collisionEnd", {
        pairs: pairs.collisionEnd
      }), Metrics.update(engine.metrics, engine), Engine._bodiesClearForces(allBodies), Events.trigger(engine, "afterUpdate", event), engine;
    }, Engine.merge = function (engineA, engineB) {
      if (Common.extend(engineA, engineB), engineB.world) {
        engineA.world = engineB.world, Engine.clear(engineA);

        for (var bodies = Composite.allBodies(engineA.world), i = 0; i < bodies.length; i++) {
          var body = bodies[i];
          Sleeping.set(body, !1), body.id = Common.nextId();
        }
      }
    }, Engine.clear = function (engine) {
      var bodies = engine.world;
      Pairs.clear(engine.pairs);
      var broadphase = engine.broadphase;
      broadphase.controller && (bodies = Composite.allBodies(bodies), broadphase.controller.clear(broadphase), broadphase.controller.update(broadphase, bodies, engine, !0));
    }, Engine._bodiesClearForces = function (bodies) {
      for (var i = 0; i < bodies.length; i++) {
        var body = bodies[i];
        body.force.x = 0, body.force.y = 0, body.torque = 0;
      }
    }, Engine._bodiesApplyGravity = function (bodies, gravity) {
      var gravityScale = void 0 !== gravity.scale ? gravity.scale : .001;
      if ((0 !== gravity.x || 0 !== gravity.y) && 0 !== gravityScale) for (var i = 0; i < bodies.length; i++) {
        var body = bodies[i];
        body.ignoreGravity || body.isStatic || body.isSleeping || (body.force.x += body.mass * gravity.x * gravityScale * body.gravityScale.x, body.force.y += body.mass * gravity.y * gravityScale * body.gravityScale.y);
      }
    }, Engine._bodiesUpdate = function (bodies, deltaTime, timeScale, correction, worldBounds) {
      for (var i = 0; i < bodies.length; i++) {
        var body = bodies[i];
        body.isStatic || body.isSleeping || Body.update(body, deltaTime, timeScale, correction);
      }
    };
  }, function (module, exports, __webpack_require__) {
    var Bodies = __webpack_require__(86),
        Body = __webpack_require__(41),
        World = __webpack_require__(0),
        Common = __webpack_require__(32),
        Composite = __webpack_require__(118),
        Engine = __webpack_require__(1401),
        EventEmitter = __webpack_require__(9),
        Events = __webpack_require__(272),
        GetFastValue = __webpack_require__(2),
        GetValue = __webpack_require__(6),
        MatterBody = __webpack_require__(41),
        MatterEvents = __webpack_require__(166),
        MatterTileBody = __webpack_require__(593),
        MatterWorld = __webpack_require__(596),
        Vector = __webpack_require__(83),
        World = new World({
      Extends: EventEmitter,
      initialize: function initialize(top, right) {
        EventEmitter.call(this), this.scene = top, this.engine = Engine.create(right), this.localWorld = this.engine.world;
        var left = GetValue(right, "gravity", null);
        left ? this.setGravity(left.x, left.y, left.scale) : !1 === left && this.setGravity(0, 0, 0), this.walls = {
          left: null,
          right: null,
          top: null,
          bottom: null
        }, this.enabled = GetValue(right, "enabled", !0), this.correction = GetValue(right, "correction", 1), this.getDelta = GetValue(right, "getDelta", this.update60Hz);
        var y = GetFastValue(right, "runner", {}),
            bottom = GetFastValue(y, "fps", !1),
            x = GetFastValue(y, "fps", 60),
            width = GetFastValue(y, "delta", 1e3 / x),
            height = GetFastValue(y, "deltaMin", 1e3 / x),
            thickness = GetFastValue(y, "deltaMax", 1e3 / (.5 * x));
        this.runner = {
          fps: x = !bottom ? 1e3 / width : x,
          correction: GetFastValue(y, "correction", 1),
          deltaSampleSize: GetFastValue(y, "deltaSampleSize", 60),
          counterTimestamp: 0,
          frameCounter: 0,
          deltaHistory: [],
          timePrev: null,
          timeScalePrev: 1,
          frameRequestId: null,
          isFixed: GetFastValue(y, "isFixed", !1),
          delta: width,
          deltaMin: height,
          deltaMax: thickness
        }, this.autoUpdate = GetValue(right, "autoUpdate", !0);
        var left = GetValue(right, "debug", !1);
        this.drawDebug = "object" == _typeof(left) || left, this.debugGraphic, this.debugConfig = {
          showAxes: GetFastValue(left, "showAxes", !1),
          showAngleIndicator: GetFastValue(left, "showAngleIndicator", !1),
          angleColor: GetFastValue(left, "angleColor", 15208787),
          showBroadphase: GetFastValue(left, "showBroadphase", !1),
          broadphaseColor: GetFastValue(left, "broadphaseColor", 16757760),
          showBounds: GetFastValue(left, "showBounds", !1),
          boundsColor: GetFastValue(left, "boundsColor", 16777215),
          showVelocity: GetFastValue(left, "showVelocity", !1),
          velocityColor: GetFastValue(left, "velocityColor", 44783),
          showCollisions: GetFastValue(left, "showCollisions", !1),
          collisionColor: GetFastValue(left, "collisionColor", 16094476),
          showSeparations: GetFastValue(left, "showSeparations", !1),
          separationColor: GetFastValue(left, "separationColor", 16753920),
          showBody: GetFastValue(left, "showBody", !0),
          showStaticBody: GetFastValue(left, "showStaticBody", !0),
          showInternalEdges: GetFastValue(left, "showInternalEdges", !1),
          renderFill: GetFastValue(left, "renderFill", !1),
          renderLine: GetFastValue(left, "renderLine", !0),
          fillColor: GetFastValue(left, "fillColor", 1075465),
          fillOpacity: GetFastValue(left, "fillOpacity", 1),
          lineColor: GetFastValue(left, "lineColor", 2678297),
          lineOpacity: GetFastValue(left, "lineOpacity", 1),
          lineThickness: GetFastValue(left, "lineThickness", 1),
          staticFillColor: GetFastValue(left, "staticFillColor", 857979),
          staticLineColor: GetFastValue(left, "staticLineColor", 1255396),
          showSleeping: GetFastValue(left, "showSleeping", !1),
          staticBodySleepOpacity: GetFastValue(left, "staticBodySleepOpacity", .7),
          sleepFillColor: GetFastValue(left, "sleepFillColor", 4605510),
          sleepLineColor: GetFastValue(left, "sleepLineColor", 10066585),
          showSensors: GetFastValue(left, "showSensors", !0),
          sensorFillColor: GetFastValue(left, "sensorFillColor", 857979),
          sensorLineColor: GetFastValue(left, "sensorLineColor", 1255396),
          showPositions: GetFastValue(left, "showPositions", !0),
          positionSize: GetFastValue(left, "positionSize", 4),
          positionColor: GetFastValue(left, "positionColor", 14697178),
          showJoint: GetFastValue(left, "showJoint", !0),
          jointColor: GetFastValue(left, "jointColor", 14737474),
          jointLineOpacity: GetFastValue(left, "jointLineOpacity", 1),
          jointLineThickness: GetFastValue(left, "jointLineThickness", 2),
          pinSize: GetFastValue(left, "pinSize", 4),
          pinColor: GetFastValue(left, "pinColor", 4382944),
          springColor: GetFastValue(left, "springColor", 14697184),
          anchorColor: GetFastValue(left, "anchorColor", 15724527),
          anchorSize: GetFastValue(left, "anchorSize", 4),
          showConvexHulls: GetFastValue(left, "showConvexHulls", !1),
          hullColor: GetFastValue(left, "hullColor", 14091216)
        }, this.drawDebug && this.createDebugGraphic(), this.setEventsProxy(), GetFastValue(right, "setBounds", !1) && ("boolean" == typeof (bottom = right.setBounds) ? this.setBounds() : (x = GetFastValue(bottom, "x", 0), y = GetFastValue(bottom, "y", 0), width = GetFastValue(bottom, "width", top.sys.scale.width), height = GetFastValue(bottom, "height", top.sys.scale.height), thickness = GetFastValue(bottom, "thickness", 64), left = GetFastValue(bottom, "left", !0), right = GetFastValue(bottom, "right", !0), top = GetFastValue(bottom, "top", !0), bottom = GetFastValue(bottom, "bottom", !0), this.setBounds(x, y, width, height, thickness, left, right, top, bottom)));
      },
      setCompositeRenderStyle: function setCompositeRenderStyle(composite) {
        for (var obj, render, bodies = composite.bodies, constraints = composite.constraints, composites = composite.composites, i = 0; i < bodies.length; i++) {
          render = (obj = bodies[i]).render, this.setBodyRenderStyle(obj, render.lineColor, render.lineOpacity, render.lineThickness, render.fillColor, render.fillOpacity);
        }

        for (i = 0; i < constraints.length; i++) {
          render = (obj = constraints[i]).render, this.setConstraintRenderStyle(obj, render.lineColor, render.lineOpacity, render.lineThickness, render.pinSize, render.anchorColor, render.anchorSize);
        }

        for (i = 0; i < composites.length; i++) {
          obj = composites[i], this.setCompositeRenderStyle(obj);
        }

        return this;
      },
      setBodyRenderStyle: function setBodyRenderStyle(body, lineColor, lineOpacity, lineThickness, fillColor, fillOpacity) {
        var render = body.render,
            config = this.debugConfig;
        return render && (null == lineColor && (lineColor = body.isStatic ? config.staticLineColor : config.lineColor), null == lineOpacity && (lineOpacity = config.lineOpacity), null == lineThickness && (lineThickness = config.lineThickness), null == fillColor && (fillColor = body.isStatic ? config.staticFillColor : config.fillColor), null == fillOpacity && (fillOpacity = config.fillOpacity), !1 !== lineColor && (render.lineColor = lineColor), !1 !== lineOpacity && (render.lineOpacity = lineOpacity), !1 !== lineThickness && (render.lineThickness = lineThickness), !1 !== fillColor && (render.fillColor = fillColor), !1 !== fillOpacity && (render.fillOpacity = fillOpacity)), this;
      },
      setConstraintRenderStyle: function setConstraintRenderStyle(type, lineColor, lineOpacity, lineThickness, pinSize, anchorColor, anchorSize) {
        var render = type.render,
            config = this.debugConfig;
        return render && (null == lineColor && ("line" === (type = render.type) ? lineColor = config.jointColor : "pin" === type ? lineColor = config.pinColor : "spring" === type && (lineColor = config.springColor)), null == lineOpacity && (lineOpacity = config.jointLineOpacity), null == lineThickness && (lineThickness = config.jointLineThickness), null == pinSize && (pinSize = config.pinSize), null == anchorColor && (anchorColor = config.anchorColor), null == anchorSize && (anchorSize = config.anchorSize), !1 !== lineColor && (render.lineColor = lineColor), !1 !== lineOpacity && (render.lineOpacity = lineOpacity), !1 !== lineThickness && (render.lineThickness = lineThickness), !1 !== pinSize && (render.pinSize = pinSize), !1 !== anchorColor && (render.anchorColor = anchorColor), !1 !== anchorSize && (render.anchorSize = anchorSize)), this;
      },
      setEventsProxy: function setEventsProxy() {
        var _this = this,
            engine = this.engine,
            world = this.localWorld;

        this.drawDebug && (MatterEvents.on(world, "compositeModified", function (composite) {
          _this.setCompositeRenderStyle(composite);
        }), MatterEvents.on(world, "beforeAdd", function (event) {
          for (var objects = [].concat(event.object), i = 0; i < objects.length; i++) {
            var obj = objects[i],
                render = obj.render;
            "body" === obj.type ? _this.setBodyRenderStyle(obj, render.lineColor, render.lineOpacity, render.lineThickness, render.fillColor, render.fillOpacity) : "composite" === obj.type ? _this.setCompositeRenderStyle(obj) : "constraint" === obj.type && _this.setConstraintRenderStyle(obj, render.lineColor, render.lineOpacity, render.lineThickness, render.pinSize, render.anchorColor, render.anchorSize);
          }
        })), MatterEvents.on(world, "beforeAdd", function (event) {
          _this.emit(Events.BEFORE_ADD, event);
        }), MatterEvents.on(world, "afterAdd", function (event) {
          _this.emit(Events.AFTER_ADD, event);
        }), MatterEvents.on(world, "beforeRemove", function (event) {
          _this.emit(Events.BEFORE_REMOVE, event);
        }), MatterEvents.on(world, "afterRemove", function (event) {
          _this.emit(Events.AFTER_REMOVE, event);
        }), MatterEvents.on(engine, "beforeUpdate", function (event) {
          _this.emit(Events.BEFORE_UPDATE, event);
        }), MatterEvents.on(engine, "afterUpdate", function (event) {
          _this.emit(Events.AFTER_UPDATE, event);
        }), MatterEvents.on(engine, "collisionStart", function (event) {
          var bodyA,
              bodyB,
              pairs = event.pairs;
          0 < pairs.length && (bodyA = pairs[0].bodyA, bodyB = pairs[0].bodyB), _this.emit(Events.COLLISION_START, event, bodyA, bodyB);
        }), MatterEvents.on(engine, "collisionActive", function (event) {
          var bodyA,
              bodyB,
              pairs = event.pairs;
          0 < pairs.length && (bodyA = pairs[0].bodyA, bodyB = pairs[0].bodyB), _this.emit(Events.COLLISION_ACTIVE, event, bodyA, bodyB);
        }), MatterEvents.on(engine, "collisionEnd", function (event) {
          var bodyA,
              bodyB,
              pairs = event.pairs;
          0 < pairs.length && (bodyA = pairs[0].bodyA, bodyB = pairs[0].bodyB), _this.emit(Events.COLLISION_END, event, bodyA, bodyB);
        });
      },
      setBounds: function setBounds(x, y, width, height, thickness, left, right, top, bottom) {
        return void 0 === width && (width = this.scene.sys.scale.width), void 0 === height && (height = this.scene.sys.scale.height), void 0 === right && (right = !0), void 0 === top && (top = !0), void 0 === bottom && (bottom = !0), this.updateWall(left = void 0 === left ? !0 : left, "left", (x = void 0 === x ? 0 : x) - (thickness = void 0 === thickness ? 64 : thickness), (y = void 0 === y ? 0 : y) - thickness, thickness, height + 2 * thickness), this.updateWall(right, "right", x + width, y - thickness, thickness, height + 2 * thickness), this.updateWall(top, "top", x, y - thickness, width, thickness), this.updateWall(bottom, "bottom", x, y + height, width, thickness), this;
      },
      updateWall: function updateWall(add, position, x, y, width, height) {
        var wall = this.walls[position];
        add ? (wall && MatterWorld.remove(this.localWorld, wall), this.walls[position] = this.create(x += width / 2, y += height / 2, width, height, {
          isStatic: !0,
          friction: 0,
          frictionStatic: 0
        })) : (wall && MatterWorld.remove(this.localWorld, wall), this.walls[position] = null);
      },
      createDebugGraphic: function createDebugGraphic() {
        var graphic = this.scene.sys.add.graphics({
          x: 0,
          y: 0
        });
        return graphic.setDepth(Number.MAX_VALUE), this.debugGraphic = graphic, this.drawDebug = !0, graphic;
      },
      disableGravity: function disableGravity() {
        return this.localWorld.gravity.x = 0, this.localWorld.gravity.y = 0, this.localWorld.gravity.scale = 0, this;
      },
      setGravity: function setGravity(x, y, scale) {
        return void 0 === y && (y = 1), this.localWorld.gravity.x = x = void 0 === x ? 0 : x, this.localWorld.gravity.y = y, void 0 !== scale && (this.localWorld.gravity.scale = scale), this;
      },
      create: function create(x, y, width, height, body) {
        body = Bodies.rectangle(x, y, width, height, body);
        return MatterWorld.add(this.localWorld, body), body;
      },
      add: function add(object) {
        return MatterWorld.add(this.localWorld, object), this;
      },
      remove: function remove(object, deep) {
        Array.isArray(object) || (object = [object]);

        for (var i = 0; i < object.length; i++) {
          var body = object[i],
              body = body.body || body;
          Composite.remove(this.localWorld, body, deep);
        }

        return this;
      },
      removeConstraint: function removeConstraint(constraint, deep) {
        return Composite.remove(this.localWorld, constraint, deep), this;
      },
      convertTilemapLayer: function convertTilemapLayer(tilemapLayer, options) {
        var tiles = tilemapLayer.layer,
            tiles = tilemapLayer.getTilesWithin(0, 0, tiles.width, tiles.height, {
          isColliding: !0
        });
        return this.convertTiles(tiles, options), this;
      },
      convertTiles: function convertTiles(tiles, options) {
        if (0 === tiles.length) return this;

        for (var i = 0; i < tiles.length; i++) {
          new MatterTileBody(this, tiles[i], options);
        }

        return this;
      },
      nextGroup: function nextGroup(isNonColliding) {
        return MatterBody.nextGroup(isNonColliding);
      },
      nextCategory: function nextCategory() {
        return MatterBody.nextCategory();
      },
      pause: function pause() {
        return this.enabled = !1, this.emit(Events.PAUSE), this;
      },
      resume: function resume() {
        return this.enabled = !0, this.emit(Events.RESUME), this;
      },
      update: function update(time, delta) {
        var engine, runner, timing, correction;
        this.enabled && this.autoUpdate && (engine = this.engine, runner = this.runner, timing = engine.timing, correction = this.correction, runner.isFixed ? delta = this.getDelta(time, delta) : (delta = time - runner.timePrev || runner.delta, runner.timePrev = time, runner.deltaHistory.push(delta), runner.deltaHistory = runner.deltaHistory.slice(-runner.deltaSampleSize), correction = (delta = (delta = (delta = Math.min.apply(null, runner.deltaHistory)) < runner.deltaMin ? runner.deltaMin : delta) > runner.deltaMax ? runner.deltaMax : delta) / runner.delta, runner.delta = delta), 0 !== runner.timeScalePrev && (correction *= timing.timeScale / runner.timeScalePrev), 0 === timing.timeScale && (correction = 0), runner.timeScalePrev = timing.timeScale, runner.correction = correction, runner.frameCounter += 1, 1e3 <= time - runner.counterTimestamp && (runner.fps = runner.frameCounter * ((time - runner.counterTimestamp) / 1e3), runner.counterTimestamp = time, runner.frameCounter = 0), Engine.update(engine, delta, correction));
      },
      step: function step(delta, correction) {
        Engine.update(this.engine, delta, correction);
      },
      update60Hz: function update60Hz() {
        return 1e3 / 60;
      },
      update30Hz: function update30Hz() {
        return 1e3 / 30;
      },
      has: function has(src) {
        src = src.hasOwnProperty("body") ? src.body : src;
        return null !== Composite.get(this.localWorld, src.id, src.type);
      },
      getAllBodies: function getAllBodies() {
        return Composite.allBodies(this.localWorld);
      },
      getAllConstraints: function getAllConstraints() {
        return Composite.allConstraints(this.localWorld);
      },
      getAllComposites: function getAllComposites() {
        return Composite.allComposites(this.localWorld);
      },
      postUpdate: function postUpdate() {
        var config, engine, graphics, bodies;
        this.drawDebug && (config = this.debugConfig, engine = this.engine, graphics = this.debugGraphic, bodies = Composite.allBodies(this.localWorld), this.debugGraphic.clear(), config.showBroadphase && engine.broadphase.controller && this.renderGrid(engine.broadphase, graphics, config.broadphaseColor, .5), config.showBounds && this.renderBodyBounds(bodies, graphics, config.boundsColor, .5), (config.showBody || config.showStaticBody) && this.renderBodies(bodies), config.showJoint && this.renderJoints(), (config.showAxes || config.showAngleIndicator) && this.renderBodyAxes(bodies, graphics, config.showAxes, config.angleColor, .5), config.showVelocity && this.renderBodyVelocity(bodies, graphics, config.velocityColor, 1, 2), config.showSeparations && this.renderSeparations(engine.pairs.list, graphics, config.separationColor), config.showCollisions && this.renderCollisions(engine.pairs.list, graphics, config.collisionColor));
      },
      renderGrid: function renderGrid(grid, graphics, lineColor, lineOpacity) {
        graphics.lineStyle(1, lineColor, lineOpacity);

        for (var bucketKeys = Common.keys(grid.buckets), i = 0; i < bucketKeys.length; i++) {
          var region = bucketKeys[i];
          grid.buckets[region].length < 2 || (region = region.split(/C|R/), graphics.strokeRect(parseInt(region[1], 10) * grid.bucketWidth, parseInt(region[2], 10) * grid.bucketHeight, grid.bucketWidth, grid.bucketHeight));
        }

        return this;
      },
      renderSeparations: function renderSeparations(pairs, graphics, lineColor) {
        graphics.lineStyle(1, lineColor, 1);

        for (var i = 0; i < pairs.length; i++) {
          var bodyA,
              bodyB,
              posA,
              posB,
              k,
              penetration = pairs[i];
          penetration.isActive && (bodyA = (k = penetration.collision).bodyA, bodyB = k.bodyB, posA = bodyA.position, posB = bodyB.position, penetration = k.penetration, k = bodyA.isStatic || bodyB.isStatic ? 1 : 4, bodyB.isStatic && (k = 0), graphics.lineBetween(posB.x, posB.y, posB.x - penetration.x * k, posB.y - penetration.y * k), k = bodyA.isStatic || bodyB.isStatic ? 1 : 4, bodyA.isStatic && (k = 0), graphics.lineBetween(posA.x, posA.y, posA.x - penetration.x * k, posA.y - penetration.y * k));
        }

        return this;
      },
      renderCollisions: function renderCollisions(pairs, graphics, lineColor) {
        var i, collision, contacts, normalPosX, normalPosY, pair;

        for (graphics.lineStyle(1, lineColor, .5), graphics.fillStyle(lineColor, 1), i = 0; i < pairs.length; i++) {
          if ((pair = pairs[i]).isActive) for (var j = 0; j < pair.activeContacts.length; j++) {
            var vertex = pair.activeContacts[j].vertex;
            graphics.fillRect(vertex.x - 2, vertex.y - 2, 5, 5);
          }
        }

        for (i = 0; i < pairs.length; i++) {
          (pair = pairs[i]).isActive && (collision = pair.collision, 0 < (contacts = pair.activeContacts).length && (normalPosX = contacts[0].vertex.x, normalPosY = contacts[0].vertex.y, 2 === contacts.length && (normalPosX = (contacts[0].vertex.x + contacts[1].vertex.x) / 2, normalPosY = (contacts[0].vertex.y + contacts[1].vertex.y) / 2), collision.bodyB === collision.supports[0].body || collision.bodyA.isStatic ? graphics.lineBetween(normalPosX - 8 * collision.normal.x, normalPosY - 8 * collision.normal.y, normalPosX, normalPosY) : graphics.lineBetween(normalPosX + 8 * collision.normal.x, normalPosY + 8 * collision.normal.y, normalPosX, normalPosY)));
        }

        return this;
      },
      renderBodyBounds: function renderBodyBounds(bodies, graphics, lineColor, lineOpacity) {
        graphics.lineStyle(1, lineColor, lineOpacity);

        for (var i = 0; i < bodies.length; i++) {
          var body = bodies[i];

          if (body.render.visible) {
            var bounds = body.bounds;
            if (bounds) graphics.strokeRect(bounds.min.x, bounds.min.y, bounds.max.x - bounds.min.x, bounds.max.y - bounds.min.y);else for (var parts = body.parts, j = 1 < parts.length ? 1 : 0; j < parts.length; j++) {
              var part = parts[j];
              graphics.strokeRect(part.bounds.min.x, part.bounds.min.y, part.bounds.max.x - part.bounds.min.x, part.bounds.max.y - part.bounds.min.y);
            }
          }
        }

        return this;
      },
      renderBodyAxes: function renderBodyAxes(bodies, graphics, showAxes, lineColor, lineOpacity) {
        graphics.lineStyle(1, lineColor, lineOpacity);

        for (var i = 0; i < bodies.length; i++) {
          var part,
              j,
              k,
              body = bodies[i],
              parts = body.parts;
          if (body.render.visible) if (showAxes) for (j = 1 < parts.length ? 1 : 0; j < parts.length; j++) {
            for (part = parts[j], k = 0; k < part.axes.length; k++) {
              var axis = part.axes[k];
              graphics.lineBetween(part.position.x, part.position.y, part.position.x + 20 * axis.x, part.position.y + 20 * axis.y);
            }
          } else for (j = 1 < parts.length ? 1 : 0; j < parts.length; j++) {
            for (part = parts[j], k = 0; k < part.axes.length; k++) {
              graphics.lineBetween(part.position.x, part.position.y, (part.vertices[0].x + part.vertices[part.vertices.length - 1].x) / 2, (part.vertices[0].y + part.vertices[part.vertices.length - 1].y) / 2);
            }
          }
        }

        return this;
      },
      renderBodyVelocity: function renderBodyVelocity(bodies, graphics, lineColor, lineOpacity, lineThickness) {
        graphics.lineStyle(lineThickness, lineColor, lineOpacity);

        for (var i = 0; i < bodies.length; i++) {
          var body = bodies[i];
          body.render.visible && graphics.lineBetween(body.position.x, body.position.y, body.position.x + 2 * (body.position.x - body.positionPrev.x), body.position.y + 2 * (body.position.y - body.positionPrev.y));
        }

        return this;
      },
      renderBodies: function renderBodies(bodies) {
        for (var graphics = this.debugGraphic, config = this.debugConfig, showBody = config.showBody, showStaticBody = config.showStaticBody, showSleeping = config.showSleeping, showInternalEdges = config.showInternalEdges, showConvexHulls = config.showConvexHulls, renderFill = config.renderFill, renderLine = config.renderLine, staticBodySleepOpacity = config.staticBodySleepOpacity, sleepFillColor = config.sleepFillColor, sleepLineColor = config.sleepLineColor, hullColor = config.hullColor, i = 0; i < bodies.length; i++) {
          var lineColor,
              lineOpacity,
              lineThickness,
              fillColor,
              partsLength,
              body = bodies[i];
          body.render.visible && (!showStaticBody && body.isStatic || !showBody && !body.isStatic || (lineColor = body.render.lineColor, lineOpacity = body.render.lineOpacity, lineThickness = body.render.lineThickness, fillColor = body.render.fillColor, partsLength = body.render.fillOpacity, showSleeping && body.isSleeping && (body.isStatic ? (lineOpacity *= staticBodySleepOpacity, partsLength *= staticBodySleepOpacity) : (lineColor = sleepLineColor, fillColor = sleepFillColor)), this.renderBody(body, graphics, showInternalEdges, lineColor = !renderLine ? null : lineColor, lineOpacity, lineThickness, fillColor = !renderFill ? null : fillColor, partsLength), partsLength = body.parts.length, showConvexHulls && 1 < partsLength && this.renderConvexHull(body, graphics, hullColor, lineThickness)));
        }
      },
      renderBody: function renderBody(hs, graphics, showInternalEdges, lineColor, lineOpacity, lineThickness, fillColor, fillOpacity) {
        void 0 === lineColor && (lineColor = null), void 0 === lineOpacity && (lineOpacity = null), void 0 === lineThickness && (lineThickness = 1), void 0 === fillColor && (fillColor = null), void 0 === fillOpacity && (fillOpacity = null);

        for (var px, py, config = this.debugConfig, sensorFillColor = config.sensorFillColor, sensorLineColor = config.sensorLineColor, parts = hs.parts, partsLength = parts.length, k = 1 < partsLength ? 1 : 0; k < partsLength; k++) {
          var part = parts[k],
              circleRadius = part.render,
              opacity = circleRadius.opacity;

          if (circleRadius.visible && 0 !== opacity && (!part.isSensor || config.showSensors)) {
            circleRadius = part.circleRadius;
            if (graphics.beginPath(), part.isSensor ? (null !== fillColor && graphics.fillStyle(sensorFillColor, fillOpacity * opacity), null !== lineColor && graphics.lineStyle(lineThickness, sensorLineColor, lineOpacity * opacity)) : (null !== fillColor && graphics.fillStyle(fillColor, fillOpacity * opacity), null !== lineColor && graphics.lineStyle(lineThickness, lineColor, lineOpacity * opacity)), circleRadius) graphics.arc(part.position.x, part.position.y, circleRadius, 0, 2 * Math.PI);else {
              var vertices = part.vertices,
                  vertLength = vertices.length;
              graphics.moveTo(vertices[0].x, vertices[0].y);

              for (var j = 1; j < vertLength; j++) {
                var nextIndex = vertices[j];
                !vertices[j - 1].isInternal || showInternalEdges ? graphics.lineTo(nextIndex.x, nextIndex.y) : graphics.moveTo(nextIndex.x, nextIndex.y), j < vertLength && nextIndex.isInternal && !showInternalEdges && graphics.moveTo(vertices[nextIndex = (j + 1) % vertLength].x, vertices[nextIndex].y);
              }

              graphics.closePath();
            }
            null !== fillColor && graphics.fillPath(), null !== lineColor && graphics.strokePath();
          }
        }

        return config.showPositions && !hs.isStatic && (px = hs.position.x, py = hs.position.y, hs = Math.ceil(config.positionSize / 2), graphics.fillStyle(config.positionColor, 1), graphics.fillRect(px - hs, py - hs, config.positionSize, config.positionSize)), this;
      },
      renderConvexHull: function renderConvexHull(body, graphics, hullColor, lineThickness) {
        if (void 0 === lineThickness && (lineThickness = 1), 1 < body.parts.length) {
          var verts = body.vertices;
          graphics.lineStyle(lineThickness, hullColor), graphics.beginPath(), graphics.moveTo(verts[0].x, verts[0].y);

          for (var v = 1; v < verts.length; v++) {
            graphics.lineTo(verts[v].x, verts[v].y);
          }

          graphics.lineTo(verts[0].x, verts[0].y), graphics.strokePath();
        }

        return this;
      },
      renderJoints: function renderJoints() {
        for (var graphics = this.debugGraphic, constraints = Composite.allConstraints(this.localWorld), i = 0; i < constraints.length; i++) {
          var anchorSize = constraints[i].render,
              lineColor = anchorSize.lineColor,
              lineOpacity = anchorSize.lineOpacity,
              lineThickness = anchorSize.lineThickness,
              pinSize = anchorSize.pinSize,
              anchorColor = anchorSize.anchorColor,
              anchorSize = anchorSize.anchorSize;
          this.renderConstraint(constraints[i], graphics, lineColor, lineOpacity, lineThickness, pinSize, anchorColor, anchorSize);
        }
      },
      renderConstraint: function renderConstraint(constraint, graphics, bodyA, bodyB, lineThickness, pinSize, anchorColor, anchorSize) {
        var render = constraint.render;
        if (!render.visible || !constraint.pointA || !constraint.pointB) return this;
        graphics.lineStyle(lineThickness, bodyA, bodyB);
        var end,
            bodyA = constraint.bodyA,
            bodyB = constraint.bodyB,
            start = bodyA ? Vector.add(bodyA.position, constraint.pointA) : constraint.pointA;
        if ("pin" === render.type) graphics.strokeCircle(start.x, start.y, pinSize);else {
          if (end = bodyB ? Vector.add(bodyB.position, constraint.pointB) : constraint.pointB, graphics.beginPath(), graphics.moveTo(start.x, start.y), "spring" === render.type) for (var offset, delta = Vector.sub(end, start), normal = Vector.perp(Vector.normalise(delta)), coils = Math.ceil(Common.clamp(constraint.length / 5, 12, 20)), j = 1; j < coils; j += 1) {
            graphics.lineTo(start.x + delta.x * (j / coils) + normal.x * (offset = j % 2 == 0 ? 1 : -1) * 4, start.y + delta.y * (j / coils) + normal.y * offset * 4);
          }
          graphics.lineTo(end.x, end.y);
        }
        return graphics.strokePath(), render.anchors && 0 < anchorSize && (graphics.fillStyle(anchorColor), graphics.fillCircle(start.x, start.y, anchorSize), graphics.fillCircle(end.x, end.y, anchorSize)), this;
      },
      resetCollisionIDs: function resetCollisionIDs() {
        return Body._nextCollidingGroupId = 1, Body._nextNonCollidingGroupId = -1, Body._nextCategory = 1, this;
      },
      shutdown: function shutdown() {
        MatterEvents.off(this.engine), this.removeAllListeners(), MatterWorld.clear(this.localWorld, !1), Engine.clear(this.engine), this.drawDebug && this.debugGraphic.destroy();
      },
      destroy: function destroy() {
        this.shutdown();
      }
    });

    module.exports = World;
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      BasePlugin: __webpack_require__(540),
      DefaultPlugins: __webpack_require__(197),
      PluginCache: __webpack_require__(24),
      PluginManager: __webpack_require__(414),
      ScenePlugin: __webpack_require__(1404)
    };
  }, function (module, exports, __webpack_require__) {
    var BasePlugin = __webpack_require__(540),
        ScenePlugin = __webpack_require__(0),
        SceneEvents = __webpack_require__(20),
        ScenePlugin = new ScenePlugin({
      Extends: BasePlugin,
      initialize: function initialize(scene, pluginManager, pluginKey) {
        BasePlugin.call(this, pluginManager), this.scene = scene, this.systems = scene.sys, this.pluginKey = pluginKey, scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
      },
      boot: function boot() {},
      destroy: function destroy() {
        this.pluginManager = null, this.game = null, this.scene = null, this.systems = null;
      }
    });

    module.exports = ScenePlugin;
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      Canvas: __webpack_require__(1406),
      Events: __webpack_require__(91),
      Snapshot: __webpack_require__(1407),
      WebGL: __webpack_require__(1408)
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      CanvasRenderer: __webpack_require__(368),
      GetBlendModes: __webpack_require__(370),
      SetTransform: __webpack_require__(30)
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      Canvas: __webpack_require__(369),
      WebGL: __webpack_require__(383)
    };
  }, function (module, exports, WebGL) {
    var WEBGL_CONST = WebGL(107),
        WebGL = WebGL(17)(!1, WebGL = {
      PipelineManager: WebGL(372),
      Pipelines: WebGL(1409),
      RenderTarget: WebGL(141),
      Utils: WebGL(12),
      WebGLPipeline: WebGL(58),
      WebGLRenderer: WebGL(371),
      WebGLShader: WebGL(375)
    }, WEBGL_CONST);
    module.exports = WebGL;
  }, function (module, exports, Pipelines) {
    var CONST = Pipelines(92),
        Pipelines = Pipelines(17)(!1, Pipelines = {
      BitmapMaskPipeline: Pipelines(373),
      Events: Pipelines(374),
      GraphicsPipeline: Pipelines(376),
      LightPipeline: Pipelines(377),
      MultiPipeline: Pipelines(108),
      PointLightPipeline: Pipelines(378),
      PostFXPipeline: Pipelines(1410),
      RopePipeline: Pipelines(379),
      SinglePipeline: Pipelines(380),
      UtilityPipeline: Pipelines(381)
    }, CONST);
    module.exports = Pipelines;
  }, function (module, exports, __webpack_require__) {
    var PostFXPipeline = __webpack_require__(0),
        ColorMatrix = __webpack_require__(198),
        GetFastValue = __webpack_require__(2),
        ShaderSourceFS = __webpack_require__(1411),
        ShaderSourceVS = __webpack_require__(382),
        WebGLPipeline = __webpack_require__(58),
        PostFXPipeline = new PostFXPipeline({
      Extends: WebGLPipeline,
      initialize: function initialize(config) {
        config.renderTarget = GetFastValue(config, "renderTarget", 1), config.fragShader = GetFastValue(config, "fragShader", ShaderSourceFS), config.vertShader = GetFastValue(config, "vertShader", ShaderSourceVS), config.attributes = GetFastValue(config, "attributes", [{
          name: "inPosition",
          size: 2
        }, {
          name: "inTexCoord",
          size: 2
        }]), config.batchSize = 1, config.vertices = [-1, -1, 0, 0, -1, 1, 0, 1, 1, 1, 1, 1, -1, -1, 0, 0, 1, 1, 1, 1, 1, -1, 1, 0], WebGLPipeline.call(this, config), this.isPostFX = !0, this.gameObject, this.colorMatrix = new ColorMatrix(), this.fullFrame1, this.fullFrame2, this.halfFrame1, this.halfFrame2, this.renderer.isBooted && (this.manager = this.renderer.pipelines, this.boot());
      },
      boot: function boot() {
        WebGLPipeline.prototype.boot.call(this);
        var utility = this.manager.UTILITY_PIPELINE;
        this.fullFrame1 = utility.fullFrame1, this.fullFrame2 = utility.fullFrame2, this.halfFrame1 = utility.halfFrame1, this.halfFrame2 = utility.halfFrame2, this.set1i("uMainSampler", 0);
      },
      onDraw: function onDraw(renderTarget) {
        this.bindAndDraw(renderTarget);
      },
      copyFrame: function copyFrame(source, target, brightness, clear, clearAlpha) {
        this.manager.copyFrame(source, target, brightness, clear, clearAlpha);
      },
      copyToGame: function copyToGame(source) {
        this.manager.copyToGame(source);
      },
      drawFrame: function drawFrame(source, target, clearAlpha) {
        this.manager.drawFrame(source, target, clearAlpha, this.colorMatrix);
      },
      blendFrames: function blendFrames(source1, source2, target, strength, clearAlpha) {
        this.manager.blendFrames(source1, source2, target, strength, clearAlpha);
      },
      blendFramesAdditive: function blendFramesAdditive(source1, source2, target, strength, clearAlpha) {
        this.manager.blendFramesAdditive(source1, source2, target, strength, clearAlpha);
      },
      clearFrame: function clearFrame(target, clearAlpha) {
        this.manager.clearFrame(target, clearAlpha);
      },
      blitFrame: function blitFrame(source, target, brightness, clear, clearAlpha, eraseMode) {
        this.manager.blitFrame(source, target, brightness, clear, clearAlpha, eraseMode);
      },
      copyFrameRect: function copyFrameRect(source, target, x, y, width, height, clear, clearAlpha) {
        this.manager.copyFrameRect(source, target, x, y, width, height, clear, clearAlpha);
      },
      bindAndDraw: function bindAndDraw(source, target, clear, clearAlpha, currentShader) {
        void 0 === clear && (clear = !0), void 0 === clearAlpha && (clearAlpha = !0);
        var gl = this.gl,
            renderer = this.renderer;
        this.bind(currentShader), this.set1i("uMainSampler", 0), target ? (gl.viewport(0, 0, target.width, target.height), gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer), gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target.texture, 0), clear && (clearAlpha ? gl.clearColor(0, 0, 0, 0) : gl.clearColor(0, 0, 0, 1), gl.clear(gl.COLOR_BUFFER_BIT))) : (renderer.popFramebuffer(!1, !1, !1), renderer.currentFramebuffer || gl.viewport(0, 0, renderer.width, renderer.height)), gl.activeTexture(gl.TEXTURE0), gl.bindTexture(gl.TEXTURE_2D, source.texture), gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.STATIC_DRAW), gl.drawArrays(gl.TRIANGLES, 0, 6), target ? (gl.bindTexture(gl.TEXTURE_2D, null), gl.bindFramebuffer(gl.FRAMEBUFFER, null)) : renderer.resetTextures();
      }
    });

    module.exports = PostFXPipeline;
  }, function (module, exports) {
    module.exports = ["#define SHADER_NAME PHASER_POSTFX_FS", "", "precision mediump float;", "", "uniform sampler2D uMainSampler;", "", "varying vec2 outTexCoord;", "", "void main ()", "{", "    gl_FragColor = texture2D(uMainSampler, outTexCoord);", "}", ""].join("\n");
  }, function (module, exports, Scale) {
    var Extend = Scale(17),
        CONST = Scale(201),
        Scale = Extend(!1, Scale = {
      Center: Scale(403),
      Events: Scale(104),
      Orientation: Scale(404),
      ScaleManager: Scale(415),
      ScaleModes: Scale(405),
      Zoom: Scale(406)
    }, CONST.CENTER);
    Scale = Extend(!1, Scale, CONST.ORIENTATION), Scale = Extend(!1, Scale, CONST.SCALE_MODE), Scale = Extend(!1, Scale, CONST.ZOOM), module.exports = Scale;
  }, function (module, exports, Scene) {
    var CONST = Scene(144),
        Scene = Scene(17)(!1, Scene = {
      Events: Scene(20),
      GetPhysicsPlugins: Scene(419),
      GetScenePlugins: Scene(420),
      SceneManager: Scene(417),
      ScenePlugin: Scene(1414),
      Settings: Scene(421),
      Systems: Scene(204)
    }, CONST);
    module.exports = Scene;
  }, function (module, exports, PluginCache) {
    var Clamp = PluginCache(18),
        ScenePlugin = PluginCache(0),
        Events = PluginCache(20),
        GetFastValue = PluginCache(2),
        PluginCache = PluginCache(24),
        ScenePlugin = new ScenePlugin({
      initialize: function initialize(scene) {
        this.scene = scene, this.systems = scene.sys, this.settings = scene.sys.settings, this.key = scene.sys.settings.key, this.manager = scene.sys.game.scene, this.transitionProgress = 0, this._elapsed = 0, this._target = null, this._duration = 0, this._onUpdate, this._onUpdateScope, this._willSleep = !1, this._willRemove = !1, scene.sys.events.once(Events.BOOT, this.boot, this), scene.sys.events.on(Events.START, this.pluginStart, this);
      },
      boot: function boot() {
        this.systems.events.once(Events.DESTROY, this.destroy, this);
      },
      pluginStart: function pluginStart() {
        this._target = null, this.systems.events.once(Events.SHUTDOWN, this.shutdown, this);
      },
      start: function start(key, data) {
        return void 0 === key && (key = this.key), this.manager.queueOp("stop", this.key), this.manager.queueOp("start", key, data), this;
      },
      restart: function restart(data) {
        var key = this.key;
        return this.manager.queueOp("stop", key), this.manager.queueOp("start", key, data), this;
      },
      transition: function transition(config) {
        var key = GetFastValue(config = void 0 === config ? {} : config, "target", !1),
            target = this.manager.getScene(key);
        if (!key || !this.checkValidTransition(target)) return !1;
        var duration = GetFastValue(config, "duration", 1e3);
        this._elapsed = 0, this._target = target, this._duration = duration, this._willSleep = GetFastValue(config, "sleep", !1), this._willRemove = GetFastValue(config, "remove", !1);
        var targetSettings = GetFastValue(config, "onUpdate", null);
        targetSettings && (this._onUpdate = targetSettings, this._onUpdateScope = GetFastValue(config, "onUpdateScope", this.scene));
        var allowInput = GetFastValue(config, "allowInput", !1);
        this.settings.transitionAllowInput = allowInput;
        targetSettings = target.sys.settings;
        return targetSettings.isTransition = !0, targetSettings.transitionFrom = this.scene, targetSettings.transitionDuration = duration, targetSettings.transitionAllowInput = allowInput, GetFastValue(config, "moveAbove", !1) ? this.manager.moveAbove(this.key, key) : GetFastValue(config, "moveBelow", !1) && this.manager.moveBelow(this.key, key), target.sys.isSleeping() ? target.sys.wake(GetFastValue(config, "data")) : this.manager.start(key, GetFastValue(config, "data")), this.systems.events.emit(Events.TRANSITION_OUT, target, duration), this.systems.events.on(Events.UPDATE, this.step, this), !0;
      },
      checkValidTransition: function checkValidTransition(target) {
        return !(!target || target.sys.isActive() || target.sys.isTransitioning() || target === this.scene || this.systems.isTransitioning());
      },
      step: function step(time, delta) {
        this._elapsed += delta, this.transitionProgress = Clamp(this._elapsed / this._duration, 0, 1), this._onUpdate && this._onUpdate.call(this._onUpdateScope, this.transitionProgress), this._elapsed >= this._duration && this.transitionComplete();
      },
      transitionComplete: function transitionComplete() {
        var targetSys = this._target.sys,
            targetSettings = this._target.sys.settings;
        this.systems.events.off(Events.UPDATE, this.step, this), targetSys.events.emit(Events.TRANSITION_COMPLETE, this.scene), targetSettings.isTransition = !1, targetSettings.transitionFrom = null, this._duration = 0, this._target = null, this._onUpdate = null, this._onUpdateScope = null, this._willRemove ? this.manager.remove(this.key) : this._willSleep ? this.systems.sleep() : this.manager.stop(this.key);
      },
      add: function add(key, sceneConfig, autoStart, data) {
        return this.manager.add(key, sceneConfig, autoStart, data);
      },
      launch: function launch(key, data) {
        return key && key !== this.key && this.manager.queueOp("start", key, data), this;
      },
      run: function run(key, data) {
        return key && key !== this.key && this.manager.queueOp("run", key, data), this;
      },
      pause: function pause(key, data) {
        return void 0 === key && (key = this.key), this.manager.queueOp("pause", key, data), this;
      },
      resume: function resume(key, data) {
        return void 0 === key && (key = this.key), this.manager.queueOp("resume", key, data), this;
      },
      sleep: function sleep(key, data) {
        return void 0 === key && (key = this.key), this.manager.queueOp("sleep", key, data), this;
      },
      wake: function wake(key, data) {
        return void 0 === key && (key = this.key), this.manager.queueOp("wake", key, data), this;
      },
      switch: function _switch(key) {
        return key !== this.key && this.manager.queueOp("switch", this.key, key), this;
      },
      stop: function stop(key, data) {
        return void 0 === key && (key = this.key), this.manager.queueOp("stop", key, data), this;
      },
      setActive: function setActive(value, scene, data) {
        void 0 === scene && (scene = this.key);
        scene = this.manager.getScene(scene);
        return scene && scene.sys.setActive(value, data), this;
      },
      setVisible: function setVisible(value, scene) {
        void 0 === scene && (scene = this.key);
        scene = this.manager.getScene(scene);
        return scene && scene.sys.setVisible(value), this;
      },
      isSleeping: function isSleeping(key) {
        return void 0 === key && (key = this.key), this.manager.isSleeping(key);
      },
      isActive: function isActive(key) {
        return void 0 === key && (key = this.key), this.manager.isActive(key);
      },
      isPaused: function isPaused(key) {
        return void 0 === key && (key = this.key), this.manager.isPaused(key);
      },
      isVisible: function isVisible(key) {
        return void 0 === key && (key = this.key), this.manager.isVisible(key);
      },
      swapPosition: function swapPosition(keyA, keyB) {
        return keyA !== (keyB = void 0 === keyB ? this.key : keyB) && this.manager.swapPosition(keyA, keyB), this;
      },
      moveAbove: function moveAbove(keyA, keyB) {
        return keyA !== (keyB = void 0 === keyB ? this.key : keyB) && this.manager.moveAbove(keyA, keyB), this;
      },
      moveBelow: function moveBelow(keyA, keyB) {
        return keyA !== (keyB = void 0 === keyB ? this.key : keyB) && this.manager.moveBelow(keyA, keyB), this;
      },
      remove: function remove(key) {
        return void 0 === key && (key = this.key), this.manager.remove(key), this;
      },
      moveUp: function moveUp(key) {
        return void 0 === key && (key = this.key), this.manager.moveUp(key), this;
      },
      moveDown: function moveDown(key) {
        return void 0 === key && (key = this.key), this.manager.moveDown(key), this;
      },
      bringToTop: function bringToTop(key) {
        return void 0 === key && (key = this.key), this.manager.bringToTop(key), this;
      },
      sendToBack: function sendToBack(key) {
        return void 0 === key && (key = this.key), this.manager.sendToBack(key), this;
      },
      get: function get(key) {
        return this.manager.getScene(key);
      },
      getIndex: function getIndex(key) {
        return void 0 === key && (key = this.key), this.manager.getIndex(key);
      },
      shutdown: function shutdown() {
        var eventEmitter = this.systems.events;
        eventEmitter.off(Events.SHUTDOWN, this.shutdown, this), eventEmitter.off(Events.POST_UPDATE, this.step, this), eventEmitter.off(Events.TRANSITION_OUT);
      },
      destroy: function destroy() {
        this.shutdown(), this.scene.sys.events.off(Events.START, this.start, this), this.scene = null, this.systems = null, this.settings = null, this.manager = null;
      }
    });
    PluginCache.register("ScenePlugin", ScenePlugin, "scenePlugin"), module.exports = ScenePlugin;
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      Events: __webpack_require__(438),
      List: __webpack_require__(110),
      Map: __webpack_require__(102),
      ProcessQueue: __webpack_require__(211),
      RTree: __webpack_require__(531),
      Set: __webpack_require__(149),
      Size: __webpack_require__(416)
    };
  }, function (module, exports, Textures) {
    var Extend = Textures(17),
        FilterMode = Textures(1417),
        Textures = Extend(!1, Textures = {
      CanvasTexture: Textures(423),
      Events: Textures(106),
      FilterMode: FilterMode,
      Frame: Textures(109),
      Parsers: Textures(425),
      Texture: Textures(206),
      TextureManager: Textures(422),
      TextureSource: Textures(424)
    }, FilterMode);
    module.exports = Textures;
  }, function (module, exports) {
    module.exports = {
      LINEAR: 0,
      NEAREST: 1
    };
  }, function (module, exports, Tilemaps) {
    var Extend = Tilemaps(17),
        CONST = Tilemaps(1419),
        Tilemaps = Extend(!1, Tilemaps = {
      Components: Tilemaps(251),
      Parsers: Tilemaps(1452),
      Formats: Tilemaps(40),
      ImageCollection: Tilemaps(576),
      ParseToTilemap: Tilemaps(262),
      Tile: Tilemaps(85),
      Tilemap: Tilemaps(580),
      TilemapCreator: Tilemaps(1459),
      TilemapFactory: Tilemaps(1460),
      Tileset: Tilemaps(122),
      TilemapLayer: Tilemaps(581),
      Orientation: Tilemaps(29),
      LayerData: Tilemaps(120),
      MapData: Tilemaps(121),
      ObjectLayer: Tilemaps(572)
    }, CONST.ORIENTATION);
    module.exports = Tilemaps;
  }, function (module, exports, CONST) {
    CONST = {
      ORIENTATION: CONST(29)
    };
    module.exports = CONST;
  }, function (module, exports, __webpack_require__) {
    var GetTilesWithin = __webpack_require__(26),
        CalculateFacesWithin = __webpack_require__(63);

    module.exports = function (srcTileX, srcTileY, width, height, destTileX, destTileY, recalculateFaces, layer) {
      void 0 === recalculateFaces && (recalculateFaces = !0);

      for (var srcTiles = GetTilesWithin(srcTileX = srcTileX < 0 ? 0 : srcTileX, srcTileY = srcTileY < 0 ? 0 : srcTileY, width, height, null, layer), offsetX = destTileX - srcTileX, offsetY = destTileY - srcTileY, i = 0; i < srcTiles.length; i++) {
        var tileX = srcTiles[i].x + offsetX,
            tileY = srcTiles[i].y + offsetY;
        0 <= tileX && tileX < layer.width && 0 <= tileY && tileY < layer.height && layer.data[tileY][tileX] && layer.data[tileY][tileX].copy(srcTiles[i]);
      }

      recalculateFaces && CalculateFacesWithin(destTileX - 1, destTileY - 1, width + 2, height + 2, layer);
    };
  }, function (module, exports, __webpack_require__) {
    var GetTilesWithin = __webpack_require__(26),
        ReplaceByIndex = __webpack_require__(542);

    module.exports = function (indexes, replacements, spriteConfig, scene, camera, layer) {
      spriteConfig = spriteConfig || {}, Array.isArray(indexes) || (indexes = [indexes]);
      var tilemapLayer = layer.tilemapLayer;
      scene = scene || tilemapLayer.scene, camera = camera || scene.cameras.main;

      for (var tiles = GetTilesWithin(0, 0, layer.width, layer.height, null, layer), sprites = [], i = 0; i < tiles.length; i++) {
        var point = tiles[i];
        -1 !== indexes.indexOf(point.index) && (point = tilemapLayer.tileToWorldXY(point.x, point.y, void 0, camera, layer), spriteConfig.x = point.x, spriteConfig.y = point.y, sprites.push(scene.make.sprite(spriteConfig)));
      }

      if ("number" == typeof replacements) for (i = 0; i < indexes.length; i++) {
        ReplaceByIndex(indexes[i], replacements, 0, 0, layer.width, layer.height, layer);
      } else if (Array.isArray(replacements)) for (i = 0; i < indexes.length; i++) {
        ReplaceByIndex(indexes[i], replacements[i], 0, 0, layer.width, layer.height, layer);
      }
      return sprites;
    };
  }, function (module, exports, __webpack_require__) {
    var GetTilesWithin = __webpack_require__(26),
        CalculateFacesWithin = __webpack_require__(63),
        SetTileCollision = __webpack_require__(72);

    module.exports = function (index, tileX, tileY, width, height, recalculateFaces, layer) {
      for (var doesIndexCollide = -1 !== layer.collideIndexes.indexOf(index), tiles = GetTilesWithin(tileX, tileY, width, height, null, layer), i = 0; i < tiles.length; i++) {
        tiles[i].index = index, SetTileCollision(tiles[i], doesIndexCollide);
      }

      recalculateFaces && CalculateFacesWithin(tileX - 1, tileY - 1, width + 2, height + 2, layer);
    };
  }, function (module, exports, __webpack_require__) {
    var GetTilesWithin = __webpack_require__(26);

    module.exports = function (callback, context, tileX, tileY, width, height, filteringOptions, layer) {
      return GetTilesWithin(tileX, tileY, width, height, filteringOptions, layer).filter(callback, context);
    };
  }, function (module, exports) {
    module.exports = function (findIndex, skip, reverse, layer) {
      void 0 === skip && (skip = 0);
      var tx,
          ty,
          tile,
          count = 0;

      if (reverse = void 0 === reverse ? !1 : reverse) {
        for (ty = layer.height - 1; 0 <= ty; ty--) {
          for (tx = layer.width - 1; 0 <= tx; tx--) {
            if ((tile = layer.data[ty][tx]) && tile.index === findIndex) {
              if (count === skip) return tile;
              count += 1;
            }
          }
        }
      } else for (ty = 0; ty < layer.height; ty++) {
        for (tx = 0; tx < layer.width; tx++) {
          if ((tile = layer.data[ty][tx]) && tile.index === findIndex) {
            if (count === skip) return tile;
            count += 1;
          }
        }
      }

      return null;
    };
  }, function (module, exports, __webpack_require__) {
    var GetTilesWithin = __webpack_require__(26);

    module.exports = function (callback, context, tileX, tileY, width, height, filteringOptions, layer) {
      return GetTilesWithin(tileX, tileY, width, height, filteringOptions, layer).find(callback, context) || null;
    };
  }, function (module, exports, __webpack_require__) {
    var GetTilesWithin = __webpack_require__(26);

    module.exports = function (callback, context, tileX, tileY, width, height, filteringOptions, layer) {
      GetTilesWithin(tileX, tileY, width, height, filteringOptions, layer).forEach(callback, context);
    };
  }, function (module, exports, __webpack_require__) {
    var CONST = __webpack_require__(29),
        CullTiles = __webpack_require__(544),
        HexagonalCullTiles = __webpack_require__(545),
        IsometricCullTiles = __webpack_require__(547),
        NOOP = __webpack_require__(1),
        StaggeredCullTiles = __webpack_require__(548);

    module.exports = function (orientation) {
      return orientation === CONST.ORTHOGONAL ? CullTiles : orientation === CONST.HEXAGONAL ? HexagonalCullTiles : orientation === CONST.STAGGERED ? StaggeredCullTiles : orientation === CONST.ISOMETRIC ? IsometricCullTiles : NOOP;
    };
  }, function (module, exports, __webpack_require__) {
    var GetTileAt = __webpack_require__(158),
        point = new (__webpack_require__(3))();

    module.exports = function (worldX, worldY, nonNull, camera, layer) {
      return layer.tilemapLayer.worldToTileXY(worldX, worldY, !0, point, camera), GetTileAt(point.x, point.y, nonNull, layer);
    };
  }, function (module, exports, Vector2) {
    function TriangleToRectangle(triangle, rect) {
      return Intersects.RectangleToTriangle(rect, triangle);
    }

    var Geom = Vector2(483),
        GetTilesWithin = Vector2(26),
        Intersects = Vector2(484),
        NOOP = Vector2(1),
        Vector2 = Vector2(3),
        point = new Vector2(),
        pointStart = new Vector2(),
        pointEnd = new Vector2();

    module.exports = function (shape, tileHeight, camera, layer) {
      if (void 0 === shape) return [];
      var intersectTest = NOOP;
      shape instanceof Geom.Circle ? intersectTest = Intersects.CircleToRectangle : shape instanceof Geom.Rectangle ? intersectTest = Intersects.RectangleToRectangle : shape instanceof Geom.Triangle ? intersectTest = TriangleToRectangle : shape instanceof Geom.Line && (intersectTest = Intersects.LineToRectangle), layer.tilemapLayer.worldToTileXY(shape.left, shape.top, !0, pointStart, camera);
      var xStart = pointStart.x,
          yStart = pointStart.y;
      layer.tilemapLayer.worldToTileXY(shape.right, shape.bottom, !0, pointEnd, camera);
      var width = Math.ceil(pointEnd.x),
          tileWidth = Math.ceil(pointEnd.y),
          width = Math.max(width - xStart, 1),
          tileWidth = Math.max(tileWidth - yStart, 1),
          tiles = GetTilesWithin(xStart, yStart, width, tileWidth, tileHeight, layer),
          tileWidth = layer.tileWidth,
          tileHeight = layer.tileHeight;
      layer.tilemapLayer && (tileWidth *= layer.tilemapLayer.scaleX, tileHeight *= layer.tilemapLayer.scaleY);

      for (var results = [], tileRect = new Geom.Rectangle(0, 0, tileWidth, tileHeight), i = 0; i < tiles.length; i++) {
        var tile = tiles[i];
        layer.tilemapLayer.tileToWorldXY(tile.x, tile.y, point, camera), tileRect.x = point.x, tileRect.y = point.y, intersectTest(shape, tileRect) && results.push(tile);
      }

      return results;
    };
  }, function (module, exports, __webpack_require__) {
    var CONST = __webpack_require__(29),
        NOOP = __webpack_require__(1),
        TileToWorldX = __webpack_require__(253);

    module.exports = function (orientation) {
      return orientation === CONST.ORTHOGONAL ? TileToWorldX : NOOP;
    };
  }, function (module, exports, __webpack_require__) {
    var CONST = __webpack_require__(29),
        HexagonalTileToWorldXY = __webpack_require__(550),
        IsometricTileToWorldXY = __webpack_require__(551),
        NOOP = __webpack_require__(1),
        StaggeredTileToWorldXY = __webpack_require__(552),
        TileToWorldXY = __webpack_require__(553);

    module.exports = function (orientation) {
      return orientation === CONST.ORTHOGONAL ? TileToWorldXY : orientation === CONST.ISOMETRIC ? IsometricTileToWorldXY : orientation === CONST.HEXAGONAL ? HexagonalTileToWorldXY : orientation === CONST.STAGGERED ? StaggeredTileToWorldXY : NOOP;
    };
  }, function (module, exports, __webpack_require__) {
    var CONST = __webpack_require__(29),
        HexagonalTileToWorldY = __webpack_require__(554),
        NOOP = __webpack_require__(1),
        StaggeredTileToWorldY = __webpack_require__(555),
        TileToWorldY = __webpack_require__(254);

    module.exports = function (orientation) {
      return orientation === CONST.ORTHOGONAL ? TileToWorldY : orientation === CONST.HEXAGONAL ? HexagonalTileToWorldY : orientation === CONST.STAGGERED ? StaggeredTileToWorldY : NOOP;
    };
  }, function (module, exports, __webpack_require__) {
    var CONST = __webpack_require__(29),
        NOOP = __webpack_require__(1),
        WorldToTileX = __webpack_require__(255);

    module.exports = function (orientation) {
      return orientation === CONST.ORTHOGONAL ? WorldToTileX : NOOP;
    };
  }, function (module, exports, __webpack_require__) {
    var CONST = __webpack_require__(29),
        HexagonalWorldToTileXY = __webpack_require__(556),
        IsometricWorldToTileXY = __webpack_require__(557),
        NOOP = __webpack_require__(1),
        StaggeredWorldToTileXY = __webpack_require__(558),
        WorldToTileXY = __webpack_require__(559);

    module.exports = function (orientation) {
      return orientation === CONST.ORTHOGONAL ? WorldToTileXY : orientation === CONST.ISOMETRIC ? IsometricWorldToTileXY : orientation === CONST.HEXAGONAL ? HexagonalWorldToTileXY : orientation === CONST.STAGGERED ? StaggeredWorldToTileXY : NOOP;
    };
  }, function (module, exports, __webpack_require__) {
    var CONST = __webpack_require__(29),
        HexagonalWorldToTileY = __webpack_require__(560),
        NOOP = __webpack_require__(1),
        StaggeredWorldToTileY = __webpack_require__(561),
        WorldToTileY = __webpack_require__(256);

    module.exports = function (orientation) {
      return orientation === CONST.ORTHOGONAL ? WorldToTileY : orientation === CONST.HEXAGONAL ? HexagonalWorldToTileY : orientation === CONST.STAGGERED ? StaggeredWorldToTileY : NOOP;
    };
  }, function (module, exports, __webpack_require__) {
    var HasTileAt = __webpack_require__(562),
        point = new (__webpack_require__(3))();

    module.exports = function (worldX, tileX, tileY, layer) {
      layer.tilemapLayer.worldToTileXY(worldX, tileX, !0, point, tileY);
      tileX = point.x, tileY = point.y;
      return HasTileAt(tileX, tileY, layer);
    };
  }, function (module, exports, __webpack_require__) {
    var PutTileAt = __webpack_require__(257),
        point = new (__webpack_require__(3))();

    module.exports = function (tile, worldX, worldY, recalculateFaces, camera, layer) {
      return layer.tilemapLayer.worldToTileXY(worldX, worldY, !0, point, camera, layer), PutTileAt(tile, point.x, point.y, recalculateFaces, layer);
    };
  }, function (module, exports, __webpack_require__) {
    var CalculateFacesWithin = __webpack_require__(63),
        PutTileAt = __webpack_require__(257);

    module.exports = function (tilesArray, tileX, tileY, recalculateFaces, layer) {
      if (void 0 === recalculateFaces && (recalculateFaces = !0), !Array.isArray(tilesArray)) return null;

      for (var height = (tilesArray = !Array.isArray(tilesArray[0]) ? [tilesArray] : tilesArray).length, width = tilesArray[0].length, ty = 0; ty < height; ty++) {
        for (var tx = 0; tx < width; tx++) {
          var tile = tilesArray[ty][tx];
          PutTileAt(tile, tileX + tx, tileY + ty, !1, layer);
        }
      }

      recalculateFaces && CalculateFacesWithin(tileX - 1, tileY - 1, width + 2, height + 2, layer);
    };
  }, function (module, exports, __webpack_require__) {
    var GetTilesWithin = __webpack_require__(26),
        GetRandom = __webpack_require__(210);

    module.exports = function (tileX, tileY, width, height, indexes, layer) {
      var i,
          tiles = GetTilesWithin(tileX, tileY, width, height, {}, layer);
      if (!indexes) for (indexes = [], i = 0; i < tiles.length; i++) {
        -1 === indexes.indexOf(tiles[i].index) && indexes.push(tiles[i].index);
      }

      for (i = 0; i < tiles.length; i++) {
        tiles[i].index = GetRandom(indexes);
      }
    };
  }, function (module, exports, __webpack_require__) {
    var RemoveTileAt = __webpack_require__(563),
        point = new (__webpack_require__(3))();

    module.exports = function (worldX, worldY, replaceWithNull, recalculateFaces, camera, layer) {
      return layer.tilemapLayer.worldToTileXY(worldX, worldY, !0, point, camera, layer), RemoveTileAt(point.x, point.y, replaceWithNull, recalculateFaces, layer);
    };
  }, function (module, exports, Color) {
    var GetTilesWithin = Color(26),
        Color = Color(397),
        defaultTileColor = new Color(105, 210, 231, 150),
        defaultCollidingTileColor = new Color(243, 134, 48, 200),
        defaultFaceColor = new Color(40, 39, 37, 150);

    module.exports = function (graphics, styleConfig, layer) {
      var tileColor = void 0 !== (styleConfig = void 0 === styleConfig ? {} : styleConfig).tileColor ? styleConfig.tileColor : defaultTileColor,
          collidingTileColor = void 0 !== styleConfig.collidingTileColor ? styleConfig.collidingTileColor : defaultCollidingTileColor,
          faceColor = void 0 !== styleConfig.faceColor ? styleConfig.faceColor : defaultFaceColor,
          tiles = GetTilesWithin(0, 0, layer.width, layer.height, null, layer);
      graphics.translateCanvas(layer.tilemapLayer.x, layer.tilemapLayer.y), graphics.scaleCanvas(layer.tilemapLayer.scaleX, layer.tilemapLayer.scaleY);

      for (var i = 0; i < tiles.length; i++) {
        var tile = tiles[i],
            tw = tile.width,
            th = tile.height,
            x = tile.pixelX,
            y = tile.pixelY,
            color = tile.collides ? collidingTileColor : tileColor;
        null !== color && (graphics.fillStyle(color.color, color.alpha / 255), graphics.fillRect(x, y, tw, th)), x += 1, y += 1, tw -= 2, th -= 2, null !== faceColor && (graphics.lineStyle(1, faceColor.color, faceColor.alpha / 255), tile.faceTop && graphics.lineBetween(x, y, x + tw, y), tile.faceRight && graphics.lineBetween(x + tw, y, x + tw, y + th), tile.faceBottom && graphics.lineBetween(x, y + th, x + tw, y + th), tile.faceLeft && graphics.lineBetween(x, y, x, y + th));
      }
    };
  }, function (module, exports, __webpack_require__) {
    var SetTileCollision = __webpack_require__(72),
        CalculateFacesWithin = __webpack_require__(63),
        SetLayerCollisionIndex = __webpack_require__(160);

    module.exports = function (indexes, collides, recalculateFaces, layer, updateLayer) {
      void 0 === collides && (collides = !0), void 0 === recalculateFaces && (recalculateFaces = !0), void 0 === updateLayer && (updateLayer = !0), Array.isArray(indexes) || (indexes = [indexes]);

      for (var i = 0; i < indexes.length; i++) {
        SetLayerCollisionIndex(indexes[i], collides, layer);
      }

      if (updateLayer) for (var ty = 0; ty < layer.height; ty++) {
        for (var tx = 0; tx < layer.width; tx++) {
          var tile = layer.data[ty][tx];
          tile && -1 !== indexes.indexOf(tile.index) && SetTileCollision(tile, collides);
        }
      }
      recalculateFaces && CalculateFacesWithin(0, 0, layer.width, layer.height, layer);
    };
  }, function (module, exports, __webpack_require__) {
    var SetTileCollision = __webpack_require__(72),
        CalculateFacesWithin = __webpack_require__(63),
        SetLayerCollisionIndex = __webpack_require__(160);

    module.exports = function (start, stop, collides, recalculateFaces, layer, updateLayer) {
      if (void 0 === collides && (collides = !0), void 0 === recalculateFaces && (recalculateFaces = !0), void 0 === updateLayer && (updateLayer = !0), !(stop < start)) {
        for (var index = start; index <= stop; index++) {
          SetLayerCollisionIndex(index, collides, layer);
        }

        if (updateLayer) for (var ty = 0; ty < layer.height; ty++) {
          for (var tx = 0; tx < layer.width; tx++) {
            var tile = layer.data[ty][tx];
            tile && tile.index >= start && tile.index <= stop && SetTileCollision(tile, collides);
          }
        }
        recalculateFaces && CalculateFacesWithin(0, 0, layer.width, layer.height, layer);
      }
    };
  }, function (module, exports, __webpack_require__) {
    var SetTileCollision = __webpack_require__(72),
        CalculateFacesWithin = __webpack_require__(63),
        SetLayerCollisionIndex = __webpack_require__(160);

    module.exports = function (indexes, collides, recalculateFaces, layer) {
      void 0 === collides && (collides = !0), void 0 === recalculateFaces && (recalculateFaces = !0), Array.isArray(indexes) || (indexes = [indexes]);

      for (var ty = 0; ty < layer.height; ty++) {
        for (var tx = 0; tx < layer.width; tx++) {
          var tile = layer.data[ty][tx];
          tile && -1 === indexes.indexOf(tile.index) && (SetTileCollision(tile, collides), SetLayerCollisionIndex(tile.index, collides, layer));
        }
      }

      recalculateFaces && CalculateFacesWithin(0, 0, layer.width, layer.height, layer);
    };
  }, function (module, exports, __webpack_require__) {
    var SetTileCollision = __webpack_require__(72),
        CalculateFacesWithin = __webpack_require__(63),
        HasValue = __webpack_require__(126);

    module.exports = function (properties, collides, recalculateFaces, layer) {
      void 0 === collides && (collides = !0), void 0 === recalculateFaces && (recalculateFaces = !0);

      for (var ty = 0; ty < layer.height; ty++) {
        for (var tx = 0; tx < layer.width; tx++) {
          var tile = layer.data[ty][tx];
          if (tile) for (var property in properties) {
            if (HasValue(tile.properties, property)) {
              var values = properties[property];
              Array.isArray(values) || (values = [values]);

              for (var i = 0; i < values.length; i++) {
                tile.properties[property] === values[i] && SetTileCollision(tile, collides);
              }
            }
          }
        }
      }

      recalculateFaces && CalculateFacesWithin(0, 0, layer.width, layer.height, layer);
    };
  }, function (module, exports, __webpack_require__) {
    var SetTileCollision = __webpack_require__(72),
        CalculateFacesWithin = __webpack_require__(63);

    module.exports = function (collides, recalculateFaces, layer) {
      void 0 === collides && (collides = !0), void 0 === recalculateFaces && (recalculateFaces = !0);

      for (var ty = 0; ty < layer.height; ty++) {
        for (var tx = 0; tx < layer.width; tx++) {
          var collisionGroup,
              tile = layer.data[ty][tx];
          tile && (collisionGroup = tile.getCollisionGroup()) && collisionGroup.objects && 0 < collisionGroup.objects.length && SetTileCollision(tile, collides);
        }
      }

      recalculateFaces && CalculateFacesWithin(0, 0, layer.width, layer.height, layer);
    };
  }, function (module, exports) {
    module.exports = function (indexes, callback, callbackContext, layer) {
      if ("number" == typeof indexes) layer.callbacks[indexes] = null !== callback ? {
        callback: callback,
        callbackContext: callbackContext
      } : void 0;else for (var i = 0, len = indexes.length; i < len; i++) {
        layer.callbacks[indexes[i]] = null !== callback ? {
          callback: callback,
          callbackContext: callbackContext
        } : void 0;
      }
    };
  }, function (module, exports, __webpack_require__) {
    var GetTilesWithin = __webpack_require__(26);

    module.exports = function (tileX, tileY, width, height, callback, callbackContext, layer) {
      for (var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer), i = 0; i < tiles.length; i++) {
        tiles[i].setCollisionCallback(callback, callbackContext);
      }
    };
  }, function (module, exports, __webpack_require__) {
    var GetTilesWithin = __webpack_require__(26),
        ShuffleArray = __webpack_require__(131);

    module.exports = function (tileX, tileY, width, height, layer) {
      var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer),
          indexes = tiles.map(function (tile) {
        return tile.index;
      });
      ShuffleArray(indexes);

      for (var i = 0; i < tiles.length; i++) {
        tiles[i].index = indexes[i];
      }
    };
  }, function (module, exports, __webpack_require__) {
    var GetTilesWithin = __webpack_require__(26);

    module.exports = function (indexA, indexB, tileX, tileY, width, height, layer) {
      for (var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer), i = 0; i < tiles.length; i++) {
        tiles[i] && (tiles[i].index === indexA ? tiles[i].index = indexB : tiles[i].index === indexB && (tiles[i].index = indexA));
      }
    };
  }, function (module, exports, __webpack_require__) {
    var GetTilesWithin = __webpack_require__(26);

    module.exports = function (tileX, tileY, width, height, weightedIndexes, layer) {
      if (weightedIndexes) {
        for (var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer), weightTotal = 0, i = 0; i < weightedIndexes.length; i++) {
          weightTotal += weightedIndexes[i].weight;
        }

        if (!(weightTotal <= 0)) for (i = 0; i < tiles.length; i++) {
          for (var rand = Math.random() * weightTotal, sum = 0, randomIndex = -1, j = 0; j < weightedIndexes.length; j++) {
            if (rand <= (sum += weightedIndexes[j].weight)) {
              var chosen = weightedIndexes[j].index,
                  randomIndex = Array.isArray(chosen) ? chosen[Math.floor(Math.random() * chosen.length)] : chosen;
              break;
            }
          }

          tiles[i].index = randomIndex;
        }
      }
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      FromOrientationString: __webpack_require__(258),
      Parse: __webpack_require__(564),
      Parse2DArray: __webpack_require__(259),
      ParseCSV: __webpack_require__(565),
      Impact: __webpack_require__(1454),
      Tiled: __webpack_require__(1455)
    };
  }, function (module, exports) {
    module.exports = function (wangsets, datas) {
      for (var w = 0; w < wangsets.length; w++) {
        var wangset = wangsets[w],
            identifier = w;

        if (wangset.name && "" !== wangset.name && (identifier = wangset.name), Array.isArray(wangset.wangtiles) && 0 < wangset.wangtiles.length) {
          var c,
              colorIndex,
              edgeColors = {},
              cornerColors = {};
          if (Array.isArray(wangset.edgecolors)) for (c = 0; c < wangset.edgecolors.length; c++) {
            colorIndex = 1 + c, "" !== (color = wangset.edgecolors[c]).name && (edgeColors[colorIndex] = color.name);
          }
          if (Array.isArray(wangset.cornercolors)) for (c = 0; c < wangset.cornercolors.length; c++) {
            colorIndex = 1 + c, "" !== (color = wangset.cornercolors[c]).name && (cornerColors[colorIndex] = color.name);
          }
          if (Array.isArray(wangset.colors)) for (c = 0; c < wangset.colors.length; c++) {
            colorIndex = 1 + c, "" !== (color = wangset.colors[c]).name && (edgeColors[colorIndex] = cornerColors[colorIndex] = color.name);
          }

          for (var idLayout = [edgeColors, cornerColors, edgeColors, cornerColors, edgeColors, cornerColors, edgeColors, cornerColors], t = 0; t < wangset.wangtiles.length; t++) {
            for (var renamed, color, wangtile = wangset.wangtiles[t], obj = (obj = datas[wangtile.tileid] || (datas[wangtile.tileid] = {})).wangid || (obj.wangid = {}), wangid = [], i = 0; i < Math.min(idLayout.length, wangtile.wangid.length); i++) {
              0 !== (color = wangtile.wangid[i]) ? void 0 === (renamed = idLayout[i][color]) ? wangid.push(color) : wangid.push(renamed) : wangid.push(void 0);
            }

            obj[identifier] = wangid;
          }
        }
      }
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      ParseTileLayers: __webpack_require__(578),
      ParseTilesets: __webpack_require__(579),
      ParseWeltmeister: __webpack_require__(577)
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      AssignTileProperties: __webpack_require__(567),
      Base64Decode: __webpack_require__(574),
      BuildTilesetIndex: __webpack_require__(568),
      CreateGroupLayer: __webpack_require__(161),
      ParseGID: __webpack_require__(261),
      ParseImageLayers: __webpack_require__(569),
      ParseJSONTiled: __webpack_require__(566),
      ParseObject: __webpack_require__(260),
      ParseObjectLayers: __webpack_require__(570),
      ParseTileLayers: __webpack_require__(573),
      ParseTilesets: __webpack_require__(575)
    };
  }, function (module, exports, __webpack_require__) {
    var renderWebGL = __webpack_require__(1),
        renderCanvas = __webpack_require__(1),
        renderWebGL = __webpack_require__(1457),
        renderCanvas = __webpack_require__(1458);

    module.exports = {
      renderWebGL: renderWebGL,
      renderCanvas: renderCanvas
    };
  }, function (module, exports, __webpack_require__) {
    var Utils = __webpack_require__(12);

    module.exports = function (renderer, src, camera) {
      var renderTiles = src.cull(camera),
          tileCount = renderTiles.length,
          alpha = camera.alpha * src.alpha;

      if (!(0 === tileCount || alpha <= 0)) {
        var gidMap = src.gidMap,
            pipeline = renderer.pipelines.set(src.pipeline, src),
            getTint = Utils.getTintAppendFloatAlpha,
            scrollFactorX = src.scrollFactorX,
            scrollFactorY = src.scrollFactorY,
            x = src.x,
            y = src.y,
            sx = src.scaleX,
            sy = src.scaleY;
        renderer.pipelines.preBatch(src);

        for (var i = 0; i < tileCount; i++) {
          var texture,
              textureUnit,
              frameWidth,
              frameHeight,
              frameX,
              frameY,
              tw,
              th,
              tile = renderTiles[i],
              tint = gidMap[tile.index];
          tint && null !== (th = tint.getTileTextureCoordinates(tile.index)) && (texture = tint.glTexture, textureUnit = pipeline.setTexture2D(texture, src), frameWidth = tint.tileWidth, frameHeight = tint.tileHeight, frameX = th.x, frameY = th.y, tw = .5 * tint.tileWidth, th = .5 * tint.tileHeight, tint = getTint(tile.tint, alpha * tile.alpha), pipeline.batchTexture(src, texture, texture.width, texture.height, x + (tw + tile.pixelX) * sx, y + (th + tile.pixelY) * sy, tile.width, tile.height, sx, sy, tile.rotation, tile.flipX, tile.flipY, scrollFactorX, scrollFactorY, tw, th, frameX, frameY, frameWidth, frameHeight, tint, tint, tint, tint, !1, 0, 0, camera, null, !0, textureUnit));
        }

        renderer.pipelines.postBatch(src);
      }
    };
  }, function (module, exports, TransformMatrix) {
    var TransformMatrix = TransformMatrix(25),
        tempMatrix1 = new TransformMatrix(),
        tempMatrix2 = new TransformMatrix(),
        tempMatrix3 = new TransformMatrix();

    module.exports = function (renderer, src, camera, parentMatrix) {
      var renderTiles = src.cull(camera),
          tileCount = renderTiles.length,
          alpha = camera.alpha * src.alpha;

      if (!(0 === tileCount || alpha <= 0)) {
        var camMatrix = tempMatrix1,
            layerMatrix = tempMatrix2,
            calcMatrix = tempMatrix3;
        layerMatrix.applyITRS(src.x, src.y, src.rotation, src.scaleX, src.scaleY), camMatrix.copyFrom(camera.matrix);
        var ctx = renderer.currentContext,
            gidMap = src.gidMap;
        ctx.save(), parentMatrix ? (camMatrix.multiplyWithOffset(parentMatrix, -camera.scrollX * src.scrollFactorX, -camera.scrollY * src.scrollFactorY), layerMatrix.e = src.x, layerMatrix.f = src.y, camMatrix.multiply(layerMatrix, calcMatrix), calcMatrix.copyToContext(ctx)) : (layerMatrix.e -= camera.scrollX * src.scrollFactorX, layerMatrix.f -= camera.scrollY * src.scrollFactorY, layerMatrix.copyToContext(ctx)), (!renderer.antialias || 1 < src.scaleX || 1 < src.scaleY) && (ctx.imageSmoothingEnabled = !1);

        for (var i = 0; i < tileCount; i++) {
          var image,
              tileTexCoords,
              tileWidth,
              tileHeight,
              halfWidth,
              tile = renderTiles[i],
              halfHeight = gidMap[tile.index];
          halfHeight && (image = halfHeight.image.getSourceImage(), null !== (tileTexCoords = halfHeight.getTileTextureCoordinates(tile.index)) && (halfWidth = .5 * (tileWidth = halfHeight.tileWidth), halfHeight = .5 * (tileHeight = halfHeight.tileHeight), ctx.save(), ctx.translate(tile.pixelX + halfWidth, tile.pixelY + halfHeight), 0 !== tile.rotation && ctx.rotate(tile.rotation), (tile.flipX || tile.flipY) && ctx.scale(tile.flipX ? -1 : 1, tile.flipY ? -1 : 1), ctx.globalAlpha = alpha * tile.alpha, ctx.drawImage(image, tileTexCoords.x, tileTexCoords.y, tileWidth, tileHeight, -halfWidth, -halfHeight, tileWidth, tileHeight), ctx.restore()));
        }

        ctx.restore();
      }
    };
  }, function (module, exports, __webpack_require__) {
    var GameObjectCreator = __webpack_require__(16),
        ParseToTilemap = __webpack_require__(262);

    GameObjectCreator.register("tilemap", function (c) {
      c = void 0 !== c ? c : {};
      return ParseToTilemap(this.scene, c.key, c.tileWidth, c.tileHeight, c.width, c.height, c.data, c.insertNull);
    });
  }, function (module, exports, __webpack_require__) {
    var GameObjectFactory = __webpack_require__(5),
        ParseToTilemap = __webpack_require__(262);

    GameObjectFactory.register("tilemap", function (key, tileWidth, tileHeight, width, height, data, insertNull) {
      return ParseToTilemap(this.scene, key = null === key ? void 0 : key, tileWidth = null === tileWidth ? void 0 : tileWidth, tileHeight = null === tileHeight ? void 0 : tileHeight, width = null === width ? void 0 : width, height = null === height ? void 0 : height, data, insertNull);
    });
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      Clock: __webpack_require__(1462),
      TimerEvent: __webpack_require__(582)
    };
  }, function (module, exports, __webpack_require__) {
    var Clock = __webpack_require__(0),
        PluginCache = __webpack_require__(24),
        SceneEvents = __webpack_require__(20),
        TimerEvent = __webpack_require__(582),
        Remove = __webpack_require__(93),
        Clock = new Clock({
      initialize: function initialize(scene) {
        this.scene = scene, this.systems = scene.sys, this.now = 0, this.timeScale = 1, this.paused = !1, this._active = [], this._pendingInsertion = [], this._pendingRemoval = [], scene.sys.events.once(SceneEvents.BOOT, this.boot, this), scene.sys.events.on(SceneEvents.START, this.start, this);
      },
      boot: function boot() {
        this.now = this.systems.game.loop.time, this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);
      },
      start: function start() {
        var eventEmitter = this.systems.events;
        eventEmitter.on(SceneEvents.PRE_UPDATE, this.preUpdate, this), eventEmitter.on(SceneEvents.UPDATE, this.update, this), eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);
      },
      addEvent: function addEvent(config) {
        var event;
        return config instanceof TimerEvent ? (this.removeEvent(event = config), event.elapsed = event.startAt, event.hasDispatched = !1, event.repeatCount = -1 === event.repeat || event.loop ? 999999999999 : event.repeat) : event = new TimerEvent(config), this._pendingInsertion.push(event), event;
      },
      delayedCall: function delayedCall(delay, callback, args, callbackScope) {
        return this.addEvent({
          delay: delay,
          callback: callback,
          args: args,
          callbackScope: callbackScope
        });
      },
      clearPendingEvents: function clearPendingEvents() {
        return this._pendingInsertion = [], this;
      },
      removeEvent: function removeEvent(events) {
        Array.isArray(events) || (events = [events]);

        for (var i = 0; i < events.length; i++) {
          var event = events[i];
          Remove(this._pendingRemoval, event), Remove(this._pendingInsertion, event), Remove(this._active, event);
        }

        return this;
      },
      removeAllEvents: function removeAllEvents() {
        return this._pendingRemoval = this._pendingRemoval.concat(this._active), this;
      },
      preUpdate: function preUpdate() {
        var toRemove = this._pendingRemoval.length,
            toInsert = this._pendingInsertion.length;

        if (0 !== toRemove || 0 !== toInsert) {
          for (var i = 0; i < toRemove; i++) {
            var event = this._pendingRemoval[i],
                index = this._active.indexOf(event);

            -1 < index && this._active.splice(index, 1), event.destroy();
          }

          for (i = 0; i < toInsert; i++) {
            event = this._pendingInsertion[i], this._active.push(event);
          }

          this._pendingRemoval.length = 0, this._pendingInsertion.length = 0;
        }
      },
      update: function update(time, delta) {
        if (this.now = time, !this.paused) {
          delta *= this.timeScale;

          for (var i = 0; i < this._active.length; i++) {
            var remainder,
                event = this._active[i];
            event.paused || (event.elapsed += delta * event.timeScale, event.elapsed >= event.delay && (remainder = event.elapsed - event.delay, event.elapsed = event.delay, !event.hasDispatched && event.callback && (event.hasDispatched = !0, event.callback.apply(event.callbackScope, event.args)), 0 < event.repeatCount ? (event.repeatCount--, event.elapsed = remainder, event.hasDispatched = !1) : this._pendingRemoval.push(event)));
          }
        }
      },
      shutdown: function shutdown() {
        for (var i = 0; i < this._pendingInsertion.length; i++) {
          this._pendingInsertion[i].destroy();
        }

        for (i = 0; i < this._active.length; i++) {
          this._active[i].destroy();
        }

        for (i = 0; i < this._pendingRemoval.length; i++) {
          this._pendingRemoval[i].destroy();
        }

        this._active.length = 0, this._pendingRemoval.length = 0, this._pendingInsertion.length = 0;
        var eventEmitter = this.systems.events;
        eventEmitter.off(SceneEvents.PRE_UPDATE, this.preUpdate, this), eventEmitter.off(SceneEvents.UPDATE, this.update, this), eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);
      },
      destroy: function destroy() {
        this.shutdown(), this.scene.sys.events.off(SceneEvents.START, this.start, this), this.scene = null, this.systems = null;
      }
    });

    PluginCache.register("Clock", Clock, "time"), module.exports = Clock;
  }, function (module, exports, Tweens) {
    var CONST = Tweens(100),
        Tweens = Tweens(17)(!1, Tweens = {
      Builders: Tweens(1464),
      Events: Tweens(267),
      TweenManager: Tweens(1480),
      Tween: Tweens(266),
      TweenData: Tweens(268),
      Timeline: Tweens(588)
    }, CONST);
    module.exports = Tweens;
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      GetBoolean: __webpack_require__(99),
      GetEaseFunction: __webpack_require__(80),
      GetNewValue: __webpack_require__(162),
      GetProps: __webpack_require__(583),
      GetTargets: __webpack_require__(263),
      GetTweens: __webpack_require__(584),
      GetValueOp: __webpack_require__(264),
      NumberTweenBuilder: __webpack_require__(585),
      StaggerBuilder: __webpack_require__(586),
      TimelineBuilder: __webpack_require__(587),
      TweenBuilder: __webpack_require__(163)
    };
  }, function (module, exports) {
    module.exports = ["callbackScope", "completeDelay", "delay", "duration", "ease", "easeParams", "flipX", "flipY", "hold", "loop", "loopDelay", "offset", "onActive", "onActiveParams", "onActiveScope", "onComplete", "onCompleteParams", "onCompleteScope", "onLoop", "onLoopParams", "onLoopScope", "onRepeat", "onRepeatParams", "onRepeatScope", "onStart", "onStartParams", "onStartScope", "onStop", "onStopParams", "onStopScope", "onUpdate", "onUpdateParams", "onUpdateScope", "onYoyo", "onYoyoParams", "onYoyoScope", "paused", "props", "repeat", "repeatDelay", "targets", "useFrames", "yoyo"];
  }, function (module, exports) {
    module.exports = "complete";
  }, function (module, exports) {
    module.exports = "loop";
  }, function (module, exports) {
    module.exports = "pause";
  }, function (module, exports) {
    module.exports = "resume";
  }, function (module, exports) {
    module.exports = "start";
  }, function (module, exports) {
    module.exports = "update";
  }, function (module, exports) {
    module.exports = "active";
  }, function (module, exports) {
    module.exports = "complete";
  }, function (module, exports) {
    module.exports = "loop";
  }, function (module, exports) {
    module.exports = "repeat";
  }, function (module, exports) {
    module.exports = "start";
  }, function (module, exports) {
    module.exports = "stop";
  }, function (module, exports) {
    module.exports = "update";
  }, function (module, exports) {
    module.exports = "yoyo";
  }, function (module, exports, __webpack_require__) {
    var ArrayRemove = __webpack_require__(93),
        TweenManager = __webpack_require__(0),
        NumberTweenBuilder = __webpack_require__(585),
        PluginCache = __webpack_require__(24),
        SceneEvents = __webpack_require__(20),
        StaggerBuilder = __webpack_require__(586),
        TimelineBuilder = __webpack_require__(587),
        TWEEN_CONST = __webpack_require__(100),
        TweenBuilder = __webpack_require__(163),
        TweenManager = new TweenManager({
      initialize: function initialize(scene) {
        this.scene = scene, this.systems = scene.sys, this.timeScale = 1, this._add = [], this._pending = [], this._active = [], this._destroy = [], this._toProcess = 0, scene.sys.events.once(SceneEvents.BOOT, this.boot, this), scene.sys.events.on(SceneEvents.START, this.start, this);
      },
      boot: function boot() {
        this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);
      },
      start: function start() {
        var eventEmitter = this.systems.events;
        eventEmitter.on(SceneEvents.PRE_UPDATE, this.preUpdate, this), eventEmitter.on(SceneEvents.UPDATE, this.update, this), eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this), this.timeScale = 1;
      },
      createTimeline: function createTimeline(config) {
        return TimelineBuilder(this, config);
      },
      timeline: function timeline(_timeline) {
        _timeline = TimelineBuilder(this, _timeline);
        return _timeline.paused || (this._add.push(_timeline), this._toProcess++), _timeline;
      },
      create: function create(config) {
        return TweenBuilder(this, config);
      },
      add: function add(tween) {
        tween = TweenBuilder(this, tween);
        return this._add.push(tween), this._toProcess++, tween;
      },
      existing: function existing(tween) {
        return this._add.push(tween), this._toProcess++, this;
      },
      addCounter: function addCounter(tween) {
        tween = NumberTweenBuilder(this, tween);
        return this._add.push(tween), this._toProcess++, tween;
      },
      stagger: function stagger(value, options) {
        return StaggerBuilder(value, options);
      },
      preUpdate: function preUpdate() {
        if (0 !== this._toProcess) {
          for (var list = this._destroy, active = this._active, pending = this._pending, i = 0; i < list.length; i++) {
            var tween = list[i],
                idx = active.indexOf(tween);
            -1 === idx ? -1 < (idx = pending.indexOf(tween)) && (tween.state = TWEEN_CONST.REMOVED, pending.splice(idx, 1)) : (tween.state = TWEEN_CONST.REMOVED, active.splice(idx, 1));
          }

          for (list.length = 0, list = this._add, i = 0; i < list.length; i++) {
            (tween = list[i]).state === TWEEN_CONST.PENDING_ADD && (tween.init() ? (tween.play(), this._active.push(tween)) : this._pending.push(tween));
          }

          list.length = 0, this._toProcess = 0;
        }
      },
      update: function update(timestamp, delta) {
        var tween,
            list = this._active;
        delta *= this.timeScale;

        for (var i = 0; i < list.length; i++) {
          (tween = list[i]).update(timestamp, delta) && (this._destroy.push(tween), this._toProcess++);
        }
      },
      remove: function remove(tween) {
        return ArrayRemove(this._add, tween), ArrayRemove(this._pending, tween), ArrayRemove(this._active, tween), ArrayRemove(this._destroy, tween), tween.state = TWEEN_CONST.REMOVED, this;
      },
      makeActive: function makeActive(tween) {
        if (-1 !== this._add.indexOf(tween) || -1 !== this._active.indexOf(tween)) return this;

        var idx = this._pending.indexOf(tween);

        return -1 !== idx && this._pending.splice(idx, 1), this._add.push(tween), tween.state = TWEEN_CONST.PENDING_ADD, this._toProcess++, this;
      },
      each: function each(callback, scope) {
        for (var texture, args = [null], i = 1; i < arguments.length; i++) {
          args.push(arguments[i]);
        }

        for (texture in this.list) {
          args[0] = this.list[texture], callback.apply(scope, args);
        }
      },
      getAllTweens: function getAllTweens() {
        for (var list = this._active, output = [], i = 0; i < list.length; i++) {
          output.push(list[i]);
        }

        return output;
      },
      getGlobalTimeScale: function getGlobalTimeScale() {
        return this.timeScale;
      },
      getTweensOf: function getTweensOf(target, includePending) {
        void 0 === includePending && (includePending = !1);
        var tween,
            i,
            t,
            list = this._active,
            output = [];

        for (Array.isArray(target) || (target = [target]), i = 0; i < list.length; i++) {
          for (tween = list[i], t = 0; t < target.length; t++) {
            tween.hasTarget(target[t]) && output.push(tween);
          }
        }

        if (includePending) for (list = this._pending, i = 0; i < list.length; i++) {
          for (tween = list[i], t = 0; t < target.length; t++) {
            tween.hasTarget(target[t]) && output.push(tween);
          }
        }
        return output;
      },
      isTweening: function isTweening(target) {
        for (var tween, list = this._active, i = 0; i < list.length; i++) {
          if ((tween = list[i]).hasTarget(target) && tween.isPlaying()) return !0;
        }

        return !1;
      },
      killAll: function killAll() {
        for (var tweens = this.getAllTweens(), i = 0; i < tweens.length; i++) {
          tweens[i].stop();
        }

        return this;
      },
      killTweensOf: function killTweensOf(target) {
        for (var tweens = this.getTweensOf(target), i = 0; i < tweens.length; i++) {
          tweens[i].stop();
        }

        return this;
      },
      pauseAll: function pauseAll() {
        for (var list = this._active, i = 0; i < list.length; i++) {
          list[i].pause();
        }

        return this;
      },
      resumeAll: function resumeAll() {
        for (var list = this._active, i = 0; i < list.length; i++) {
          list[i].resume();
        }

        return this;
      },
      setGlobalTimeScale: function setGlobalTimeScale(value) {
        return this.timeScale = value, this;
      },
      shutdown: function shutdown() {
        this.killAll(), this._add = [], this._pending = [], this._active = [], this._destroy = [], this._toProcess = 0;
        var eventEmitter = this.systems.events;
        eventEmitter.off(SceneEvents.PRE_UPDATE, this.preUpdate, this), eventEmitter.off(SceneEvents.UPDATE, this.update, this), eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);
      },
      destroy: function destroy() {
        this.shutdown(), this.scene.sys.events.off(SceneEvents.START, this.start, this), this.scene = null, this.systems = null;
      }
    });

    PluginCache.register("TweenManager", TweenManager, "tweens"), module.exports = TweenManager;
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      Array: __webpack_require__(208),
      Base64: __webpack_require__(1482),
      Objects: __webpack_require__(1484),
      String: __webpack_require__(1488),
      NOOP: __webpack_require__(1)
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      ArrayBufferToBase64: __webpack_require__(1483),
      Base64ToArrayBuffer: __webpack_require__(433)
    };
  }, function (module, exports) {
    var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

    module.exports = function (arrayBuffer, mediaType) {
      for (var bytes = new Uint8Array(arrayBuffer), len = bytes.length, base64 = mediaType ? "data:" + mediaType + ";base64," : "", i = 0; i < len; i += 3) {
        base64 += chars[bytes[i] >> 2], base64 += chars[(3 & bytes[i]) << 4 | bytes[i + 1] >> 4], base64 += chars[(15 & bytes[i + 1]) << 2 | bytes[i + 2] >> 6], base64 += chars[63 & bytes[i + 2]];
      }

      return len % 3 == 2 ? base64 = base64.substring(0, base64.length - 1) + "=" : len % 3 == 1 && (base64 = base64.substring(0, base64.length - 2) + "=="), base64;
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      Clone: __webpack_require__(77),
      DeepCopy: __webpack_require__(175),
      Extend: __webpack_require__(17),
      GetAdvancedValue: __webpack_require__(13),
      GetFastValue: __webpack_require__(2),
      GetMinMaxValue: __webpack_require__(1485),
      GetValue: __webpack_require__(6),
      HasAll: __webpack_require__(1486),
      HasAny: __webpack_require__(455),
      HasValue: __webpack_require__(126),
      IsPlainObject: __webpack_require__(7),
      Merge: __webpack_require__(127),
      MergeRight: __webpack_require__(1487),
      Pick: __webpack_require__(571),
      SetValue: __webpack_require__(478)
    };
  }, function (module, exports, __webpack_require__) {
    var GetValue = __webpack_require__(6),
        Clamp = __webpack_require__(18);

    module.exports = function (source, key, min, max, value) {
      value = GetValue(source, key, value = void 0 === value ? min : value);
      return Clamp(value, min, max);
    };
  }, function (module, exports) {
    module.exports = function (source, keys) {
      for (var i = 0; i < keys.length; i++) {
        if (!source.hasOwnProperty(keys[i])) return !1;
      }

      return !0;
    };
  }, function (module, exports, __webpack_require__) {
    var Clone = __webpack_require__(77);

    module.exports = function (obj1, obj2) {
      var key,
          clone = Clone(obj1);

      for (key in obj2) {
        clone.hasOwnProperty(key) && (clone[key] = obj2[key]);
      }

      return clone;
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      Format: __webpack_require__(1489),
      Pad: __webpack_require__(186),
      RemoveAt: __webpack_require__(1490),
      Reverse: __webpack_require__(1491),
      UppercaseFirst: __webpack_require__(205),
      UUID: __webpack_require__(222)
    };
  }, function (module, exports) {
    module.exports = function (string, values) {
      return string.replace(/%([0-9]+)/g, function (s, n) {
        return values[Number(n) - 1];
      });
    };
  }, function (module, exports) {
    module.exports = function (string, index) {
      return 0 === index ? string.slice(1) : string.slice(0, index - 1) + string.slice(index);
    };
  }, function (module, exports) {
    module.exports = function (string) {
      return string.split("").reverse().join("");
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      SoundManagerCreator: __webpack_require__(426),
      Events: __webpack_require__(70),
      BaseSound: __webpack_require__(146),
      BaseSoundManager: __webpack_require__(145),
      WebAudioSound: __webpack_require__(434),
      WebAudioSoundManager: __webpack_require__(432),
      HTML5AudioSound: __webpack_require__(429),
      HTML5AudioSoundManager: __webpack_require__(427),
      NoAudioSound: __webpack_require__(431),
      NoAudioSoundManager: __webpack_require__(430)
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      Arcade: __webpack_require__(1366),
      Matter: __webpack_require__(1494)
    };
  }, function (module, exports, __webpack_require__) {
    module.exports = {
      BodyBounds: __webpack_require__(1392),
      Components: __webpack_require__(249),
      Events: __webpack_require__(272),
      Factory: __webpack_require__(1394),
      MatterGameObject: __webpack_require__(1395),
      Image: __webpack_require__(1396),
      Matter: __webpack_require__(594),
      MatterPhysics: __webpack_require__(1524),
      PolyDecomp: __webpack_require__(1393),
      Sprite: __webpack_require__(1397),
      TileBody: __webpack_require__(593),
      PhysicsEditorParser: __webpack_require__(589),
      PhysicsJSONParser: __webpack_require__(590),
      PointerConstraint: __webpack_require__(1398),
      World: __webpack_require__(1402)
    };
  }, function (module, exports) {
    module.exports = {
      setBounce: function setBounce(value) {
        return this.body.restitution = value, this;
      }
    };
  }, function (module, exports) {
    module.exports = {
      setCollisionCategory: function setCollisionCategory(value) {
        return this.body.collisionFilter.category = value, this;
      },
      setCollisionGroup: function setCollisionGroup(value) {
        return this.body.collisionFilter.group = value, this;
      },
      setCollidesWith: function setCollidesWith(categories) {
        var flags = 0;
        if (Array.isArray(categories)) for (var i = 0; i < categories.length; i++) {
          flags |= categories[i];
        } else flags = categories;
        return this.body.collisionFilter.mask = flags, this;
      },
      setOnCollide: function setOnCollide(callback) {
        return this.body.onCollideCallback = callback, this;
      },
      setOnCollideEnd: function setOnCollideEnd(callback) {
        return this.body.onCollideEndCallback = callback, this;
      },
      setOnCollideActive: function setOnCollideActive(callback) {
        return this.body.onCollideActiveCallback = callback, this;
      },
      setOnCollideWith: function setOnCollideWith(body, callback) {
        Array.isArray(body) || (body = [body]);

        for (var i = 0; i < body.length; i++) {
          var src = body[i].hasOwnProperty("body") ? body[i].body : body[i];
          this.body.setOnCollideWith(src, callback);
        }

        return this;
      }
    };
  }, function (module, exports, __webpack_require__) {
    var Body = __webpack_require__(41);

    module.exports = {
      applyForce: function applyForce(force) {
        return this._tempVec2.set(this.body.position.x, this.body.position.y), Body.applyForce(this.body, this._tempVec2, force), this;
      },
      applyForceFrom: function applyForceFrom(position, force) {
        return Body.applyForce(this.body, position, force), this;
      },
      thrust: function thrust(speed) {
        var angle = this.body.angle;
        return this._tempVec2.set(speed * Math.cos(angle), speed * Math.sin(angle)), Body.applyForce(this.body, {
          x: this.body.position.x,
          y: this.body.position.y
        }, this._tempVec2), this;
      },
      thrustLeft: function thrustLeft(speed) {
        var angle = this.body.angle - Math.PI / 2;
        return this._tempVec2.set(speed * Math.cos(angle), speed * Math.sin(angle)), Body.applyForce(this.body, {
          x: this.body.position.x,
          y: this.body.position.y
        }, this._tempVec2), this;
      },
      thrustRight: function thrustRight(speed) {
        var angle = this.body.angle + Math.PI / 2;
        return this._tempVec2.set(speed * Math.cos(angle), speed * Math.sin(angle)), Body.applyForce(this.body, {
          x: this.body.position.x,
          y: this.body.position.y
        }, this._tempVec2), this;
      },
      thrustBack: function thrustBack(speed) {
        var angle = this.body.angle - Math.PI;
        return this._tempVec2.set(speed * Math.cos(angle), speed * Math.sin(angle)), Body.applyForce(this.body, {
          x: this.body.position.x,
          y: this.body.position.y
        }, this._tempVec2), this;
      }
    };
  }, function (module, exports) {
    module.exports = {
      setFriction: function setFriction(value, air, fstatic) {
        return this.body.friction = value, void 0 !== air && (this.body.frictionAir = air), void 0 !== fstatic && (this.body.frictionStatic = fstatic), this;
      },
      setFrictionAir: function setFrictionAir(value) {
        return this.body.frictionAir = value, this;
      },
      setFrictionStatic: function setFrictionStatic(value) {
        return this.body.frictionStatic = value, this;
      }
    };
  }, function (module, exports) {
    module.exports = {
      setIgnoreGravity: function setIgnoreGravity(value) {
        return this.body.ignoreGravity = value, this;
      }
    };
  }, function (module, exports, __webpack_require__) {
    var Body = __webpack_require__(41),
        Vector2 = __webpack_require__(3);

    module.exports = {
      setMass: function setMass(value) {
        return Body.setMass(this.body, value), this;
      },
      setDensity: function setDensity(value) {
        return Body.setDensity(this.body, value), this;
      },
      centerOfMass: {
        get: function get() {
          return new Vector2(this.body.centerOfMass.x, this.body.centerOfMass.y);
        }
      }
    };
  }, function (module, exports) {
    module.exports = {
      setSensor: function setSensor(value) {
        return this.body.isSensor = value, this;
      },
      isSensor: function isSensor() {
        return this.body.isSensor;
      }
    };
  }, function (module, exports, __webpack_require__) {
    var Bodies = __webpack_require__(86),
        Body = __webpack_require__(41),
        FuzzyEquals = __webpack_require__(124),
        GetFastValue = __webpack_require__(2),
        PhysicsEditorParser = __webpack_require__(589),
        PhysicsJSONParser = __webpack_require__(590),
        Vertices = __webpack_require__(64);

    module.exports = {
      setRectangle: function setRectangle(width, height, options) {
        return this.setBody({
          type: "rectangle",
          width: width,
          height: height
        }, options);
      },
      setCircle: function setCircle(radius, options) {
        return this.setBody({
          type: "circle",
          radius: radius
        }, options);
      },
      setPolygon: function setPolygon(radius, sides, options) {
        return this.setBody({
          type: "polygon",
          sides: sides,
          radius: radius
        }, options);
      },
      setTrapezoid: function setTrapezoid(width, height, slope, options) {
        return this.setBody({
          type: "trapezoid",
          width: width,
          height: height,
          slope: slope
        }, options);
      },
      setExistingBody: function setExistingBody(body, cy) {
        void 0 === cy && (cy = !0), this.body && this.world.remove(this.body, !0), this.body = body;

        for (var i = 0; i < body.parts.length; i++) {
          body.parts[i].gameObject = this;
        }

        var rx,
            ry,
            cx,
            _this = this;

        return body.destroy = function () {
          _this.world.remove(_this.body, !0), _this.body.gameObject = null;
        }, cy && (this.world.has(body) && this.world.remove(body, !0), this.world.add(body)), this._originComponent && (rx = body.render.sprite.xOffset, ry = body.render.sprite.yOffset, cx = body.centerOfMass.x, cy = body.centerOfMass.y, FuzzyEquals(cx, .5) && FuzzyEquals(cy, .5) ? this.setOrigin(rx + .5, ry + .5) : (cx = body.centerOffset.x, cy = body.centerOffset.y, this.setOrigin(rx + cx / this.displayWidth, ry + cy / this.displayHeight))), this;
      },
      setBody: function setBody(config, options) {
        if (!config) return this;
        var shapeType = GetFastValue(config = "string" == typeof config ? {
          type: config
        } : config, "type", "rectangle"),
            bodyX = GetFastValue(config, "x", this._tempVec2.x),
            bodyY = GetFastValue(config, "y", this._tempVec2.y),
            bodyWidth = GetFastValue(config, "width", this.width),
            bodyHeight = GetFastValue(config, "height", this.height);

        switch (shapeType) {
          case "rectangle":
            body = Bodies.rectangle(bodyX, bodyY, bodyWidth, bodyHeight, options);
            break;

          case "circle":
            var radius = GetFastValue(config, "radius", Math.max(bodyWidth, bodyHeight) / 2),
                verts = GetFastValue(config, "maxSides", 25),
                body = Bodies.circle(bodyX, bodyY, radius, options, verts);
            break;

          case "trapezoid":
            var flagInternal = GetFastValue(config, "slope", .5);
            body = Bodies.trapezoid(bodyX, bodyY, bodyWidth, bodyHeight, flagInternal, options);
            break;

          case "polygon":
            var removeCollinear = GetFastValue(config, "sides", 5),
                minimumArea = GetFastValue(config, "radius", Math.max(bodyWidth, bodyHeight) / 2);
            body = Bodies.polygon(bodyX, bodyY, removeCollinear, minimumArea, options);
            break;

          case "fromVertices":
          case "fromVerts":
            verts = GetFastValue(config, "verts", null);
            verts && ("string" == typeof verts && (verts = Vertices.fromPath(verts)), body = this.body && !this.body.hasOwnProperty("temp") ? (Body.setVertices(this.body, verts), this.body) : (flagInternal = GetFastValue(config, "flagInternal", !1), removeCollinear = GetFastValue(config, "removeCollinear", .01), minimumArea = GetFastValue(config, "minimumArea", 10), Bodies.fromVertices(bodyX, bodyY, verts, options, flagInternal, removeCollinear, minimumArea)));
            break;

          case "fromPhysicsEditor":
            body = PhysicsEditorParser.parseBody(bodyX, bodyY, config, options);
            break;

          case "fromPhysicsTracer":
            body = PhysicsJSONParser.parseBody(bodyX, bodyY, config, options);
        }

        return body && this.setExistingBody(body, config.addToWorld), this;
      }
    };
  }, function (module, exports, __webpack_require__) {
    var Events = __webpack_require__(272),
        Sleeping = __webpack_require__(165),
        MatterEvents = __webpack_require__(166);

    module.exports = {
      setToSleep: function setToSleep() {
        return Sleeping.set(this.body, !0), this;
      },
      setAwake: function setAwake() {
        return Sleeping.set(this.body, !1), this;
      },
      setSleepThreshold: function setSleepThreshold(value) {
        return this.body.sleepThreshold = value = void 0 === value ? 60 : value, this;
      },
      setSleepEvents: function setSleepEvents(start, end) {
        return this.setSleepStartEvent(start), this.setSleepEndEvent(end), this;
      },
      setSleepStartEvent: function setSleepStartEvent(value) {
        var world;
        return value ? (world = this.world, MatterEvents.on(this.body, "sleepStart", function (event) {
          world.emit(Events.SLEEP_START, event, this);
        })) : MatterEvents.off(this.body, "sleepStart"), this;
      },
      setSleepEndEvent: function setSleepEndEvent(value) {
        var world;
        return value ? (world = this.world, MatterEvents.on(this.body, "sleepEnd", function (event) {
          world.emit(Events.SLEEP_END, event, this);
        })) : MatterEvents.off(this.body, "sleepEnd"), this;
      }
    };
  }, function (module, exports) {
    module.exports = "afteradd";
  }, function (module, exports) {
    module.exports = "afterremove";
  }, function (module, exports) {
    module.exports = "afterupdate";
  }, function (module, exports) {
    module.exports = "beforeadd";
  }, function (module, exports) {
    module.exports = "beforeremove";
  }, function (module, exports) {
    module.exports = "beforeupdate";
  }, function (module, exports) {
    module.exports = "collisionactive";
  }, function (module, exports) {
    module.exports = "collisionend";
  }, function (module, exports) {
    module.exports = "collisionstart";
  }, function (module, exports) {
    module.exports = "dragend";
  }, function (module, exports) {
    module.exports = "drag";
  }, function (module, exports) {
    module.exports = "dragstart";
  }, function (module, exports) {
    module.exports = "pause";
  }, function (module, exports) {
    module.exports = "resume";
  }, function (module, exports) {
    module.exports = "sleepend";
  }, function (module, exports) {
    module.exports = "sleepstart";
  }, function (module, exports, __webpack_require__) {
    var Body = __webpack_require__(41);

    module.exports = {
      setStatic: function setStatic(value) {
        return Body.setStatic(this.body, value), this;
      },
      isStatic: function isStatic() {
        return this.body.isStatic;
      }
    };
  }, function (module, exports, __webpack_require__) {
    var Body = __webpack_require__(41),
        MATH_CONST = __webpack_require__(14),
        WrapAngle = __webpack_require__(269),
        WrapAngleDegrees = __webpack_require__(270);

    module.exports = {
      x: {
        get: function get() {
          return this.body.position.x;
        },
        set: function set(value) {
          this._tempVec2.set(value, this.y), Body.setPosition(this.body, this._tempVec2);
        }
      },
      y: {
        get: function get() {
          return this.body.position.y;
        },
        set: function set(value) {
          this._tempVec2.set(this.x, value), Body.setPosition(this.body, this._tempVec2);
        }
      },
      scaleX: {
        get: function get() {
          return this._scaleX;
        },
        set: function set(value) {
          var factorX = 1 / this._scaleX,
              factorY = 1 / this._scaleY;
          this._scaleX = value, 0 === this._scaleX ? this.renderFlags &= -5 : this.renderFlags |= 4, Body.scale(this.body, factorX, factorY), Body.scale(this.body, value, this._scaleY);
        }
      },
      scaleY: {
        get: function get() {
          return this._scaleY;
        },
        set: function set(value) {
          var factorX = 1 / this._scaleX,
              factorY = 1 / this._scaleY;
          this._scaleY = value, 0 === this._scaleY ? this.renderFlags &= -5 : this.renderFlags |= 4, Body.scale(this.body, factorX, factorY), Body.scale(this.body, this._scaleX, value);
        }
      },
      angle: {
        get: function get() {
          return WrapAngleDegrees(this.body.angle * MATH_CONST.RAD_TO_DEG);
        },
        set: function set(value) {
          this.rotation = WrapAngleDegrees(value) * MATH_CONST.DEG_TO_RAD;
        }
      },
      rotation: {
        get: function get() {
          return this.body.angle;
        },
        set: function set(value) {
          this._rotation = WrapAngle(value), Body.setAngle(this.body, this._rotation);
        }
      },
      setPosition: function setPosition(x, y) {
        return void 0 === x && (x = 0), void 0 === y && (y = x), this._tempVec2.set(x, y), Body.setPosition(this.body, this._tempVec2), this;
      },
      setRotation: function setRotation(radians) {
        return this._rotation = WrapAngle(radians = void 0 === radians ? 0 : radians), Body.setAngle(this.body, radians), this;
      },
      setFixedRotation: function setFixedRotation() {
        return Body.setInertia(this.body, 1 / 0), this;
      },
      setAngle: function setAngle(degrees) {
        return this.angle = degrees = void 0 === degrees ? 0 : degrees, Body.setAngle(this.body, this.rotation), this;
      },
      setScale: function setScale(x, y, point) {
        void 0 === x && (x = 1), void 0 === y && (y = x);
        var factorX = 1 / this._scaleX,
            factorY = 1 / this._scaleY;
        return this._scaleX = x, this._scaleY = y, Body.scale(this.body, factorX, factorY, point), Body.scale(this.body, x, y, point), this;
      }
    };
  }, function (module, exports, __webpack_require__) {
    var Body = __webpack_require__(41);

    module.exports = {
      setAngularVelocity: function setAngularVelocity(value) {
        return Body.setAngularVelocity(this.body, value), this;
      },
      setVelocityX: function setVelocityX(x) {
        return this._tempVec2.set(x, this.body.velocity.y), Body.setVelocity(this.body, this._tempVec2), this;
      },
      setVelocityY: function setVelocityY(y) {
        return this._tempVec2.set(this.body.velocity.x, y), Body.setVelocity(this.body, this._tempVec2), this;
      },
      setVelocity: function setVelocity(x, y) {
        return this._tempVec2.set(x, y), Body.setVelocity(this.body, this._tempVec2), this;
      }
    };
  }, function (module, exports, __webpack_require__) {
    var Metrics = {};
    module.exports = Metrics;

    var Composite = __webpack_require__(118),
        Common = __webpack_require__(32);

    Metrics.create = function (options) {
      return Common.extend({
        extended: !1,
        narrowDetections: 0,
        narrowphaseTests: 0,
        narrowReuse: 0,
        narrowReuseCount: 0,
        midphaseTests: 0,
        broadphaseTests: 0,
        narrowEff: 1e-4,
        midEff: 1e-4,
        broadEff: 1e-4,
        collisions: 0,
        buckets: 0,
        bodies: 0,
        pairs: 0
      }, !1, options);
    }, Metrics.reset = function (metrics) {
      metrics.extended && (metrics.narrowDetections = 0, metrics.narrowphaseTests = 0, metrics.narrowReuse = 0, metrics.narrowReuseCount = 0, metrics.midphaseTests = 0, metrics.broadphaseTests = 0, metrics.narrowEff = 0, metrics.midEff = 0, metrics.broadEff = 0, metrics.collisions = 0, metrics.buckets = 0, metrics.pairs = 0, metrics.bodies = 0);
    }, Metrics.update = function (metrics, engine) {
      var bodies;
      metrics.extended && (bodies = engine.world, bodies = Composite.allBodies(bodies), metrics.collisions = metrics.narrowDetections, metrics.pairs = engine.pairs.list.length, metrics.bodies = bodies.length, metrics.midEff = (metrics.narrowDetections / (metrics.midphaseTests || 1)).toFixed(2), metrics.narrowEff = (metrics.narrowDetections / (metrics.narrowphaseTests || 1)).toFixed(2), metrics.broadEff = (1 - metrics.broadphaseTests / (bodies.length || 1)).toFixed(2), metrics.narrowReuse = (metrics.narrowReuseCount / (metrics.narrowphaseTests || 1)).toFixed(2));
    };
  }, function (module, exports, __webpack_require__) {
    var ALIGN_CONST = __webpack_require__(123),
        Axes = __webpack_require__(271),
        Bodies = __webpack_require__(86),
        Body = __webpack_require__(41),
        BodyBounds = __webpack_require__(1392),
        Bounds = __webpack_require__(84),
        MatterPhysics = __webpack_require__(0),
        Composite = __webpack_require__(118),
        Composites = __webpack_require__(591),
        Constraint = __webpack_require__(128),
        Detector = __webpack_require__(273),
        DistanceBetween = __webpack_require__(50),
        Factory = __webpack_require__(1394),
        GetFastValue = __webpack_require__(2),
        GetValue = __webpack_require__(6),
        Grid = __webpack_require__(597),
        MatterAttractors = __webpack_require__(1525),
        MatterCollisionEvents = __webpack_require__(1526),
        MatterLib = __webpack_require__(1399),
        MatterWrap = __webpack_require__(1527),
        Merge = __webpack_require__(127),
        Pair = __webpack_require__(250),
        Pairs = __webpack_require__(598),
        Plugin = __webpack_require__(595),
        PluginCache = __webpack_require__(24),
        Query = __webpack_require__(1400),
        Resolver = __webpack_require__(599),
        SAT = __webpack_require__(274),
        SceneEvents = __webpack_require__(20),
        Svg = __webpack_require__(592),
        Vector = __webpack_require__(83),
        Vertices = __webpack_require__(64),
        World = __webpack_require__(1402),
        MatterPhysics = new MatterPhysics({
      initialize: function initialize(scene) {
        this.scene = scene, this.systems = scene.sys, this.config = this.getConfig(), this.world, this.add, this.bodyBounds, this.body = Body, this.composite = Composite, this.detector = Detector, this.grid = Grid, this.pair = Pair, this.pairs = Pairs, this.query = Query, this.resolver = Resolver, this.sat = SAT, this.constraint = Constraint, this.bodies = Bodies, this.composites = Composites, this.axes = Axes, this.bounds = Bounds, this.svg = Svg, this.vector = Vector, this.vertices = Vertices, this.verts = Vertices, this._tempVec2 = Vector.create(), GetValue(this.config, "plugins.collisionevents", !0) && this.enableCollisionEventsPlugin(), GetValue(this.config, "plugins.attractors", !1) && this.enableAttractorPlugin(), GetValue(this.config, "plugins.wrap", !1) && this.enableWrapPlugin(), Resolver._restingThresh = GetValue(this.config, "restingThresh", 4), Resolver._restingThreshTangent = GetValue(this.config, "restingThreshTangent", 6), Resolver._positionDampen = GetValue(this.config, "positionDampen", .9), Resolver._positionWarming = GetValue(this.config, "positionWarming", .8), Resolver._frictionNormalMultiplier = GetValue(this.config, "frictionNormalMultiplier", 5), scene.sys.events.once(SceneEvents.BOOT, this.boot, this), scene.sys.events.on(SceneEvents.START, this.start, this);
      },
      boot: function boot() {
        this.world = new World(this.scene, this.config), this.add = new Factory(this.world), this.bodyBounds = new BodyBounds(), this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);
      },
      start: function start() {
        this.world || (this.world = new World(this.scene, this.config), this.add = new Factory(this.world));
        var eventEmitter = this.systems.events;
        eventEmitter.on(SceneEvents.UPDATE, this.world.update, this.world), eventEmitter.on(SceneEvents.POST_UPDATE, this.world.postUpdate, this.world), eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);
      },
      getConfig: function getConfig() {
        var gameConfig = this.systems.game.config.physics,
            sceneConfig = this.systems.settings.physics;
        return Merge(GetFastValue(sceneConfig, "matter", {}), GetFastValue(gameConfig, "matter", {}));
      },
      enableAttractorPlugin: function enableAttractorPlugin() {
        return Plugin.register(MatterAttractors), Plugin.use(MatterLib, MatterAttractors), this;
      },
      enableWrapPlugin: function enableWrapPlugin() {
        return Plugin.register(MatterWrap), Plugin.use(MatterLib, MatterWrap), this;
      },
      enableCollisionEventsPlugin: function enableCollisionEventsPlugin() {
        return Plugin.register(MatterCollisionEvents), Plugin.use(MatterLib, MatterCollisionEvents), this;
      },
      pause: function pause() {
        return this.world.pause();
      },
      resume: function resume() {
        return this.world.resume();
      },
      set60Hz: function set60Hz() {
        return this.world.getDelta = this.world.update60Hz, this.world.autoUpdate = !0, this;
      },
      set30Hz: function set30Hz() {
        return this.world.getDelta = this.world.update30Hz, this.world.autoUpdate = !0, this;
      },
      step: function step(delta, correction) {
        this.world.step(delta, correction);
      },
      containsPoint: function containsPoint(body, x, position) {
        body = this.getMatterBodies(body);
        position = Vector.create(x, position);
        return 0 < Query.point(body, position).length;
      },
      intersectPoint: function intersectPoint(x, position, bodies) {
        bodies = this.getMatterBodies(bodies);
        var position = Vector.create(x, position),
            output = [];
        return Query.point(bodies, position).forEach(function (body) {
          -1 === output.indexOf(body) && output.push(body);
        }), output;
      },
      intersectRect: function intersectRect(x, y, width, height, outside, bodies) {
        void 0 === outside && (outside = !1), bodies = this.getMatterBodies(bodies);
        var output = [];
        return Query.region(bodies, {
          min: {
            x: x,
            y: y
          },
          max: {
            x: x + width,
            y: y + height
          }
        }, outside).forEach(function (body) {
          -1 === output.indexOf(body) && output.push(body);
        }), output;
      },
      intersectRay: function intersectRay(x1, y1, x2, y2, rayWidth, bodies) {
        void 0 === rayWidth && (rayWidth = 1), bodies = this.getMatterBodies(bodies);

        for (var result = [], collisions = Query.ray(bodies, Vector.create(x1, y1), Vector.create(x2, y2), rayWidth), i = 0; i < collisions.length; i++) {
          result.push(collisions[i].body);
        }

        return result;
      },
      intersectBody: function intersectBody(body, bodies) {
        bodies = this.getMatterBodies(bodies);

        for (var result = [], collisions = Query.collides(body, bodies), i = 0; i < collisions.length; i++) {
          var pair = collisions[i];
          pair.bodyA === body ? result.push(pair.bodyB) : result.push(pair.bodyA);
        }

        return result;
      },
      overlap: function overlap(target, bodies, overlapCallback, processCallback, callbackContext) {
        void 0 === overlapCallback && (overlapCallback = null), void 0 === processCallback && (processCallback = null), void 0 === callbackContext && (callbackContext = overlapCallback), Array.isArray(target) || (target = [target]), target = this.getMatterBodies(target), bodies = this.getMatterBodies(bodies);

        for (var match = !1, i = 0; i < target.length; i++) {
          for (var entry = target[i], collisions = Query.collides(entry, bodies), c = 0; c < collisions.length; c++) {
            var info = collisions[c],
                bodyB = info.bodyA.id === entry.id ? info.bodyB : info.bodyA;
            if (!processCallback || processCallback.call(callbackContext, entry, bodyB, info)) if (match = !0, overlapCallback) overlapCallback.call(callbackContext, entry, bodyB, info);else if (!processCallback) return !0;
          }
        }

        return match;
      },
      setCollisionCategory: function setCollisionCategory(bodies, value) {
        return (bodies = this.getMatterBodies(bodies)).forEach(function (body) {
          body.collisionFilter.category = value;
        }), this;
      },
      setCollisionGroup: function setCollisionGroup(bodies, value) {
        return (bodies = this.getMatterBodies(bodies)).forEach(function (body) {
          body.collisionFilter.group = value;
        }), this;
      },
      setCollidesWith: function setCollidesWith(bodies, categories) {
        bodies = this.getMatterBodies(bodies);
        var flags = 0;
        if (Array.isArray(categories)) for (var i = 0; i < categories.length; i++) {
          flags |= categories[i];
        } else flags = categories;
        return bodies.forEach(function (body) {
          body.collisionFilter.mask = flags;
        }), this;
      },
      getMatterBodies: function getMatterBodies(bodies) {
        if (!bodies) return this.world.getAllBodies();
        Array.isArray(bodies) || (bodies = [bodies]);

        for (var output = [], i = 0; i < bodies.length; i++) {
          var body = bodies[i].hasOwnProperty("body") ? bodies[i].body : bodies[i];
          output.push(body);
        }

        return output;
      },
      setVelocity: function setVelocity(bodies, x, y) {
        bodies = this.getMatterBodies(bodies);
        var vec2 = this._tempVec2;
        return vec2.x = x, vec2.y = y, bodies.forEach(function (body) {
          Body.setVelocity(body, vec2);
        }), this;
      },
      setVelocityX: function setVelocityX(bodies, x) {
        bodies = this.getMatterBodies(bodies);
        var vec2 = this._tempVec2;
        return vec2.x = x, bodies.forEach(function (body) {
          vec2.y = body.velocity.y, Body.setVelocity(body, vec2);
        }), this;
      },
      setVelocityY: function setVelocityY(bodies, y) {
        bodies = this.getMatterBodies(bodies);
        var vec2 = this._tempVec2;
        return vec2.y = y, bodies.forEach(function (body) {
          vec2.x = body.velocity.x, Body.setVelocity(body, vec2);
        }), this;
      },
      setAngularVelocity: function setAngularVelocity(bodies, value) {
        return (bodies = this.getMatterBodies(bodies)).forEach(function (body) {
          Body.setAngularVelocity(body, value);
        }), this;
      },
      applyForce: function applyForce(bodies, force) {
        bodies = this.getMatterBodies(bodies);
        var vec2 = this._tempVec2;
        return bodies.forEach(function (body) {
          vec2.x = body.position.x, vec2.y = body.position.y, Body.applyForce(body, vec2, force);
        }), this;
      },
      applyForceFromPosition: function applyForceFromPosition(bodies, position, speed, angle) {
        bodies = this.getMatterBodies(bodies);
        var vec2 = this._tempVec2;
        return bodies.forEach(function (body) {
          void 0 === angle && (angle = body.angle), vec2.x = speed * Math.cos(angle), vec2.y = speed * Math.sin(angle), Body.applyForce(body, position, vec2);
        }), this;
      },
      applyForceFromAngle: function applyForceFromAngle(bodies, speed, angle) {
        bodies = this.getMatterBodies(bodies);
        var vec2 = this._tempVec2;
        return bodies.forEach(function (body) {
          void 0 === angle && (angle = body.angle), vec2.x = speed * Math.cos(angle), vec2.y = speed * Math.sin(angle), Body.applyForce(body, {
            x: body.position.x,
            y: body.position.y
          }, vec2);
        }), this;
      },
      getConstraintLength: function getConstraintLength(constraint) {
        var aX = constraint.pointA.x,
            aY = constraint.pointA.y,
            bX = constraint.pointB.x,
            bY = constraint.pointB.y;
        return constraint.bodyA && (aX += constraint.bodyA.position.x, aY += constraint.bodyA.position.y), constraint.bodyB && (bX += constraint.bodyB.position.x, bY += constraint.bodyB.position.y), DistanceBetween(aX, aY, bX, bY);
      },
      alignBody: function alignBody(body, x, y, align) {
        var pos;

        switch (body = body.hasOwnProperty("body") ? body.body : body, align) {
          case ALIGN_CONST.TOP_LEFT:
          case ALIGN_CONST.LEFT_TOP:
            pos = this.bodyBounds.getTopLeft(body, x, y);
            break;

          case ALIGN_CONST.TOP_CENTER:
            pos = this.bodyBounds.getTopCenter(body, x, y);
            break;

          case ALIGN_CONST.TOP_RIGHT:
          case ALIGN_CONST.RIGHT_TOP:
            pos = this.bodyBounds.getTopRight(body, x, y);
            break;

          case ALIGN_CONST.LEFT_CENTER:
            pos = this.bodyBounds.getLeftCenter(body, x, y);
            break;

          case ALIGN_CONST.CENTER:
            pos = this.bodyBounds.getCenter(body, x, y);
            break;

          case ALIGN_CONST.RIGHT_CENTER:
            pos = this.bodyBounds.getRightCenter(body, x, y);
            break;

          case ALIGN_CONST.LEFT_BOTTOM:
          case ALIGN_CONST.BOTTOM_LEFT:
            pos = this.bodyBounds.getBottomLeft(body, x, y);
            break;

          case ALIGN_CONST.BOTTOM_CENTER:
            pos = this.bodyBounds.getBottomCenter(body, x, y);
            break;

          case ALIGN_CONST.BOTTOM_RIGHT:
          case ALIGN_CONST.RIGHT_BOTTOM:
            pos = this.bodyBounds.getBottomRight(body, x, y);
        }

        return pos && Body.setPosition(body, pos), this;
      },
      shutdown: function shutdown() {
        var eventEmitter = this.systems.events;
        this.world && (eventEmitter.off(SceneEvents.UPDATE, this.world.update, this.world), eventEmitter.off(SceneEvents.POST_UPDATE, this.world.postUpdate, this.world)), eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this), this.add && this.add.destroy(), this.world && this.world.destroy(), this.add = null, this.world = null;
      },
      destroy: function destroy() {
        this.shutdown(), this.scene.sys.events.off(SceneEvents.START, this.start, this), this.scene = null, this.systems = null;
      }
    });

    PluginCache.register("MatterPhysics", MatterPhysics, "matterPhysics"), module.exports = MatterPhysics;
  }, function (module, exports, __webpack_require__) {
    var Matter = __webpack_require__(594),
        MatterAttractors = {
      name: "matter-attractors",
      version: "0.1.7",
      for: "matter-js@^0.14.2",
      silent: !0,
      install: function install(base) {
        base.after("Body.create", function () {
          MatterAttractors.Body.init(this);
        }), base.before("Engine.update", function (engine) {
          MatterAttractors.Engine.update(engine);
        });
      },
      Body: {
        init: function init(body) {
          body.plugin.attractors = body.plugin.attractors || [];
        }
      },
      Engine: {
        update: function update(engine) {
          for (var bodies = Matter.Composite.allBodies(engine.world), i = 0; i < bodies.length; i++) {
            var bodyA = bodies[i],
                attractors = bodyA.plugin.attractors;
            if (attractors && 0 < attractors.length) for (var j = 0; j < bodies.length; j++) {
              var bodyB = bodies[j];
              if (i !== j) for (var k = 0; k < attractors.length; k++) {
                var attractor = attractors[k],
                    forceVector = attractor;
                (forceVector = Matter.Common.isFunction(attractor) ? attractor(bodyA, bodyB) : forceVector) && Matter.Body.applyForce(bodyB, bodyB.position, forceVector);
              }
            }
          }
        }
      },
      Attractors: {
        gravityConstant: .001,
        gravity: function gravity(bodyA, bodyB) {
          var normal = Matter.Vector.sub(bodyB.position, bodyA.position),
              force = Matter.Vector.magnitudeSquared(normal) || 1e-4,
              normal = Matter.Vector.normalise(normal),
              force = -MatterAttractors.Attractors.gravityConstant * (bodyA.mass * bodyB.mass / force),
              force = Matter.Vector.mult(normal, force);
          Matter.Body.applyForce(bodyA, bodyA.position, Matter.Vector.neg(force)), Matter.Body.applyForce(bodyB, bodyB.position, force);
        }
      }
    };

    module.exports = MatterAttractors;
  }, function (module, exports) {
    module.exports = {
      name: "matter-collision-events",
      version: "0.1.6",
      for: "matter-js@^0.14.2",
      silent: !0,
      install: function install(matter) {
        matter.after("Engine.create", function () {
          matter.Events.on(this, "collisionStart", function (event) {
            event.pairs.map(function (pair) {
              var bodyA = pair.bodyA,
                  bodyB = pair.bodyB;
              bodyA.gameObject && bodyA.gameObject.emit("collide", bodyA, bodyB, pair), bodyB.gameObject && bodyB.gameObject.emit("collide", bodyB, bodyA, pair), matter.Events.trigger(bodyA, "onCollide", {
                pair: pair
              }), matter.Events.trigger(bodyB, "onCollide", {
                pair: pair
              }), bodyA.onCollideCallback && bodyA.onCollideCallback(pair), bodyB.onCollideCallback && bodyB.onCollideCallback(pair), bodyA.onCollideWith[bodyB.id] && bodyA.onCollideWith[bodyB.id](bodyB, pair), bodyB.onCollideWith[bodyA.id] && bodyB.onCollideWith[bodyA.id](bodyA, pair);
            });
          }), matter.Events.on(this, "collisionActive", function (event) {
            event.pairs.map(function (pair) {
              var bodyA = pair.bodyA,
                  bodyB = pair.bodyB;
              bodyA.gameObject && bodyA.gameObject.emit("collideActive", bodyA, bodyB, pair), bodyB.gameObject && bodyB.gameObject.emit("collideActive", bodyB, bodyA, pair), matter.Events.trigger(bodyA, "onCollideActive", {
                pair: pair
              }), matter.Events.trigger(bodyB, "onCollideActive", {
                pair: pair
              }), bodyA.onCollideActiveCallback && bodyA.onCollideActiveCallback(pair), bodyB.onCollideActiveCallback && bodyB.onCollideActiveCallback(pair);
            });
          }), matter.Events.on(this, "collisionEnd", function (event) {
            event.pairs.map(function (pair) {
              var bodyA = pair.bodyA,
                  bodyB = pair.bodyB;
              bodyA.gameObject && bodyA.gameObject.emit("collideEnd", bodyA, bodyB, pair), bodyB.gameObject && bodyB.gameObject.emit("collideEnd", bodyB, bodyA, pair), matter.Events.trigger(bodyA, "onCollideEnd", {
                pair: pair
              }), matter.Events.trigger(bodyB, "onCollideEnd", {
                pair: pair
              }), bodyA.onCollideEndCallback && bodyA.onCollideEndCallback(pair), bodyB.onCollideEndCallback && bodyB.onCollideEndCallback(pair);
            });
          });
        });
      }
    };
  }, function (module, exports, __webpack_require__) {
    var Matter = __webpack_require__(594),
        MatterWrap = {
      name: "matter-wrap",
      version: "0.1.4",
      for: "matter-js@^0.14.2",
      silent: !0,
      install: function install(base) {
        base.after("Engine.update", function () {
          MatterWrap.Engine.update(this);
        });
      },
      Engine: {
        update: function update(world) {
          for (var world = world.world, bodies = Matter.Composite.allBodies(world), composites = Matter.Composite.allComposites(world), i = 0; i < bodies.length; i += 1) {
            var body = bodies[i];
            body.plugin.wrap && MatterWrap.Body.wrap(body, body.plugin.wrap);
          }

          for (i = 0; i < composites.length; i += 1) {
            var composite = composites[i];
            composite.plugin.wrap && MatterWrap.Composite.wrap(composite, composite.plugin.wrap);
          }
        }
      },
      Bounds: {
        wrap: function wrap(objectBounds, bounds) {
          var x = null,
              y = null;
          if (void 0 !== bounds.min.x && void 0 !== bounds.max.x && (objectBounds.min.x > bounds.max.x ? x = bounds.min.x - objectBounds.max.x : objectBounds.max.x < bounds.min.x && (x = bounds.max.x - objectBounds.min.x)), void 0 !== bounds.min.y && void 0 !== bounds.max.y && (objectBounds.min.y > bounds.max.y ? y = bounds.min.y - objectBounds.max.y : objectBounds.max.y < bounds.min.y && (y = bounds.max.y - objectBounds.min.y)), null !== x || null !== y) return {
            x: x || 0,
            y: y || 0
          };
        }
      },
      Body: {
        wrap: function wrap(body, translation) {
          translation = MatterWrap.Bounds.wrap(body.bounds, translation);
          return translation && Matter.Body.translate(body, translation), translation;
        }
      },
      Composite: {
        bounds: function bounds(composite) {
          for (var bodies = Matter.Composite.allBodies(composite), vertices = [], i = 0; i < bodies.length; i += 1) {
            var body = bodies[i];
            vertices.push(body.bounds.min, body.bounds.max);
          }

          return Matter.Bounds.create(vertices);
        },
        wrap: function wrap(composite, translation) {
          translation = MatterWrap.Bounds.wrap(MatterWrap.Composite.bounds(composite), translation);
          return translation && Matter.Composite.translate(composite, translation), translation;
        }
      }
    };

    module.exports = MatterWrap;
  }, function (module, exports, __webpack_require__) {
    !function (global) {
      var CONST = __webpack_require__(33),
          Extend = __webpack_require__(17),
          Phaser = {
        Actions: __webpack_require__(275),
        Animations: __webpack_require__(723),
        BlendModes: __webpack_require__(35),
        Cache: __webpack_require__(735),
        Cameras: __webpack_require__(738),
        Core: __webpack_require__(806),
        Class: __webpack_require__(0),
        Create: __webpack_require__(888),
        Curves: __webpack_require__(894),
        Data: __webpack_require__(896),
        Display: __webpack_require__(898),
        DOM: __webpack_require__(917),
        Events: __webpack_require__(918),
        Game: __webpack_require__(920),
        GameObjects: __webpack_require__(1011),
        Geom: __webpack_require__(483),
        Input: __webpack_require__(1308),
        Loader: __webpack_require__(1338),
        Math: __webpack_require__(193),
        Physics: __webpack_require__(1493),
        Plugins: __webpack_require__(1403),
        Renderer: __webpack_require__(1405),
        Scale: __webpack_require__(1412),
        ScaleModes: __webpack_require__(168),
        Scene: __webpack_require__(418),
        Scenes: __webpack_require__(1413),
        Structs: __webpack_require__(1415),
        Textures: __webpack_require__(1416),
        Tilemaps: __webpack_require__(1418),
        Time: __webpack_require__(1461),
        Tweens: __webpack_require__(1463),
        Utils: __webpack_require__(1481)
      };

      Phaser.Sound = __webpack_require__(1492), Phaser = Extend(!1, Phaser, CONST), module.exports = Phaser, global.Phaser = Phaser;
    }.call(this, __webpack_require__(600));
  }], __webpack_require__.c = installedModules, __webpack_require__.d = function (exports, name, getter) {
    __webpack_require__.o(exports, name) || Object.defineProperty(exports, name, {
      enumerable: !0,
      get: getter
    });
  }, __webpack_require__.r = function (exports) {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(exports, Symbol.toStringTag, {
      value: "Module"
    }), Object.defineProperty(exports, "__esModule", {
      value: !0
    });
  }, __webpack_require__.t = function (value, mode) {
    if (1 & mode && (value = __webpack_require__(value)), 8 & mode) return value;
    if (4 & mode && "object" == _typeof(value) && value && value.__esModule) return value;
    var ns = Object.create(null);
    if (__webpack_require__.r(ns), Object.defineProperty(ns, "default", {
      enumerable: !0,
      value: value
    }), 2 & mode && "string" != typeof value) for (var key in value) {
      __webpack_require__.d(ns, key, function (key) {
        return value[key];
      }.bind(null, key));
    }
    return ns;
  }, __webpack_require__.n = function (module) {
    var getter = module && module.__esModule ? function () {
      return module.default;
    } : function () {
      return module;
    };
    return __webpack_require__.d(getter, "a", getter), getter;
  }, __webpack_require__.o = function (object, property) {
    return Object.prototype.hasOwnProperty.call(object, property);
  }, __webpack_require__.p = "", __webpack_require__(__webpack_require__.s = 1528);

  function __webpack_require__(moduleId) {
    if (installedModules[moduleId]) return installedModules[moduleId].exports;
    var module = installedModules[moduleId] = {
      i: moduleId,
      l: !1,
      exports: {}
    };
    return modules[moduleId].call(module.exports, module, module.exports, __webpack_require__), module.l = !0, module.exports;
  }

  var modules, installedModules;
});
},{"process":"C:/Users/maryj/AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/process/browser.js"}],"C:/Users/maryj/AppData/Roaming/npm/node_modules/parcel-bundler/src/builtins/hmr-runtime.js":[function(require,module,exports) {
var global = arguments[3];
var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;

function Module(moduleName) {
  OldModule.call(this, moduleName);
  this.hot = {
    data: module.bundle.hotData,
    _acceptCallbacks: [],
    _disposeCallbacks: [],
    accept: function (fn) {
      this._acceptCallbacks.push(fn || function () {});
    },
    dispose: function (fn) {
      this._disposeCallbacks.push(fn);
    }
  };
  module.bundle.hotData = null;
}

module.bundle.Module = Module;
var checkedAssets, assetsToAccept;
var parent = module.bundle.parent;

if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
  var hostname = "" || location.hostname;
  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';
  var ws = new WebSocket(protocol + '://' + hostname + ':' + "62496" + '/');

  ws.onmessage = function (event) {
    checkedAssets = {};
    assetsToAccept = [];
    var data = JSON.parse(event.data);

    if (data.type === 'update') {
      var handled = false;
      data.assets.forEach(function (asset) {
        if (!asset.isNew) {
          var didAccept = hmrAcceptCheck(global.parcelRequire, asset.id);

          if (didAccept) {
            handled = true;
          }
        }
      }); // Enable HMR for CSS by default.

      handled = handled || data.assets.every(function (asset) {
        return asset.type === 'css' && asset.generated.js;
      });

      if (handled) {
        console.clear();
        data.assets.forEach(function (asset) {
          hmrApply(global.parcelRequire, asset);
        });
        assetsToAccept.forEach(function (v) {
          hmrAcceptRun(v[0], v[1]);
        });
      } else if (location.reload) {
        // `location` global exists in a web worker context but lacks `.reload()` function.
        location.reload();
      }
    }

    if (data.type === 'reload') {
      ws.close();

      ws.onclose = function () {
        location.reload();
      };
    }

    if (data.type === 'error-resolved') {
      console.log('[parcel] ✨ Error resolved');
      removeErrorOverlay();
    }

    if (data.type === 'error') {
      console.error('[parcel] 🚨  ' + data.error.message + '\n' + data.error.stack);
      removeErrorOverlay();
      var overlay = createErrorOverlay(data);
      document.body.appendChild(overlay);
    }
  };
}

function removeErrorOverlay() {
  var overlay = document.getElementById(OVERLAY_ID);

  if (overlay) {
    overlay.remove();
  }
}

function createErrorOverlay(data) {
  var overlay = document.createElement('div');
  overlay.id = OVERLAY_ID; // html encode message and stack trace

  var message = document.createElement('div');
  var stackTrace = document.createElement('pre');
  message.innerText = data.error.message;
  stackTrace.innerText = data.error.stack;
  overlay.innerHTML = '<div style="background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;">' + '<span style="background: red; padding: 2px 4px; border-radius: 2px;">ERROR</span>' + '<span style="top: 2px; margin-left: 5px; position: relative;">🚨</span>' + '<div style="font-size: 18px; font-weight: bold; margin-top: 20px;">' + message.innerHTML + '</div>' + '<pre>' + stackTrace.innerHTML + '</pre>' + '</div>';
  return overlay;
}

function getParents(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return [];
  }

  var parents = [];
  var k, d, dep;

  for (k in modules) {
    for (d in modules[k][1]) {
      dep = modules[k][1][d];

      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {
        parents.push(k);
      }
    }
  }

  if (bundle.parent) {
    parents = parents.concat(getParents(bundle.parent, id));
  }

  return parents;
}

function hmrApply(bundle, asset) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (modules[asset.id] || !bundle.parent) {
    var fn = new Function('require', 'module', 'exports', asset.generated.js);
    asset.isNew = !modules[asset.id];
    modules[asset.id] = [fn, asset.deps];
  } else if (bundle.parent) {
    hmrApply(bundle.parent, asset);
  }
}

function hmrAcceptCheck(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (!modules[id] && bundle.parent) {
    return hmrAcceptCheck(bundle.parent, id);
  }

  if (checkedAssets[id]) {
    return;
  }

  checkedAssets[id] = true;
  var cached = bundle.cache[id];
  assetsToAccept.push([bundle, id]);

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    return true;
  }

  return getParents(global.parcelRequire, id).some(function (id) {
    return hmrAcceptCheck(global.parcelRequire, id);
  });
}

function hmrAcceptRun(bundle, id) {
  var cached = bundle.cache[id];
  bundle.hotData = {};

  if (cached) {
    cached.hot.data = bundle.hotData;
  }

  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {
    cached.hot._disposeCallbacks.forEach(function (cb) {
      cb(bundle.hotData);
    });
  }

  delete bundle.cache[id];
  bundle(id);
  cached = bundle.cache[id];

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    cached.hot._acceptCallbacks.forEach(function (cb) {
      cb();
    });

    return true;
  }
}
},{}]},{},["C:/Users/maryj/AppData/Roaming/npm/node_modules/parcel-bundler/src/builtins/hmr-runtime.js","src/site/phaserLightFix.min.js"], null)
//# sourceMappingURL=/phaserLightFix.min.20056427.js.map